Java_QA / 12. Cucumber. BDD

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Подходы в разработке ПО](#1-подходы-в-разработке-по)
    * [1.1. Разработка через тестирование (Test Driven Development (TDD))](#11-разработка-через-тестирование-test-driven-development-tdd)
        * [1.1.1. Описание](#111-описание)
        * [1.1.2. Плюсы](#112-плюсы)
        * [1.1.3. Минусы](#113-минусы)
    * [1.2. Разработка через поведение (Behaviour Driven Development (BDD))](#12-разработка-через-поведение-behaviour-driven-development-bdd)
        * [1.2.1. Описание](#121-описание)
        * [1.2.2. Плюсы](#122-плюсы)
        * [1.2.3. Минусы](#123-минусы)
    * [1.3. TDD VS BDD](#13-tdd-vs-bdd)
    * [1.4. Прочие X Driven Development](#14-прочие-x-driven-development)
* [2. Подходы в разработке тестов](#2-подходы-в-разработке-тестов)
    * [2.1. Тестирование, управляемое данными (Data Driven Testing (DDT))](#21-тестирование-управляемое-данными-data-driven-testing-ddt)
        * [2.1.1. Описание](#211-описание)
        * [2.1.2. Плюсы](#212-плюсы)
        * [2.1.3. Минусы](#213-минусы)
    * [2.2. Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))](#22-тестирование-управляемое-ключевыми-словами-keyword-driven-testing-kdt)
        * [2.2.1. Описание](#221-описание)
        * [2.2.2. Плюсы](#222-плюсы)
        * [2.2.3. Минусы](#223-минусы)
* [3. Фреймворки BDD тестирования](#3-фреймворки-bdd-тестирования)
    * [3.1. Python](#31-python)
        * [3.1.1. Основные](#311-основные)
        * [3.1.2. Альтернативы](#312-альтернативы)
    * [3.2. Ruby](#32-ruby)
        * [3.2.1. Основные](#321-основные)
        * [3.2.2. Альтернативы](#322-альтернативы)
    * [3.2. Ruby](#32-ruby)
        * [3.2.1. Основные](#321-основные)
        * [3.2.2. Альтернативы](#322-альтернативы)
    * [3.3. JavaScript](#33-javascript)
        * [3.3.1. Основные](#331-основные)
        * [3.3.2. Альтернативы](#332-альтернативы)
    * [3.4. C# и .NET](#34-c-и-net)
        * [3.4.1. Основные](#341-основные)
        * [3.4.2. Альтернативы](#342-альтернативы)
    * [3.5. Java И JVM](#35-java-и-jvm)
        * [3.5.1. Основные](#351-основные)
        * [3.5.2. Альтернативы](#352-альтернативы)
    * [3.6. Какой фреймворк лучше?](#36-какой-фреймворк-лучше)
* [4. Cucumber](#4-cucumber)
* [5. Плюсы и минусы](#5-плюсы-и-минусы)
* [6. Старт проекта с Cucumber](#6-старт-проекта-с-cucumber)
  * [6.1. Настройка способа написания реализации шагов Gherkin](#61-настройка-способа-написания-реализации-шагов-gherkin)
    * [6.1.1. Настройка проекта для работы через аннотации Java](#611-настройка-проекта-для-работы-через-аннотации-java)
      * [6.1.1.1. Зависимости](#6111-зависимости)
      * [6.1.1.2. Реализация шагов через аннотации Java](#6112-реализация-шагов-через-аннотации-java)
    * [6.1.2. Настройка проекта для работы через лямбда выражения Java](#612-настройка-проекта-для-работы-через-лямбда-выражения-java)
      * [6.1.2.1. Зависимости](#6121-зависимости)
      * [6.1.2.2. Реализация шагов через лямбда выражения Java](#6122-реализация-шагов-через-лямбда-выражения-java)
  * [6.2. Настройка связки с тестовым фрймворком](#62-настройка-связки-с-тестовым-фрймворком)
    * [6.2.1. Настройка проекта под JUnit 4](#621-настройка-проекта-под-junit-4)
      * [6.2.1.1. Зависимости](#6211-зависимости)
      * [6.2.1.2. Плагины](#6212-плагины)
      * [6.2.1.3. Раннер](#6213-раннер)
    * [6.2.2. Настройка проекта под JUnit 5](#622-настройка-проекта-под-junit-5)
      * [6.2.2.1. Зависимости](#6221-зависимости)
      * [6.2.2.2. Плагины](#6222-плагины)
      * [6.2.2.3. Раннер](#6223-раннер)
    * [6.2.3. Настройка проекта под TestNG](#623-настройка-проекта-под-testng)
      * [6.2.3.1. Зависимости](#6231-зависимости)
      * [6.2.3.2. Плагины](#6232-плагины)
      * [6.2.3.3. Раннер](#6233-раннер)
* [7. Структура проекта Cucumber](#7-структура-проекта-cucumber)
    * [7.1. Описание сценариев (Features)](#71-описание-сценариев-features)
    * [7.2. Реализация шагов сценариев (Step Defs)](#72-реализация-шагов-сценариев-step-defs)
    * [7.3. Хуки (Hooks)](#73-хуки-hooks)
    * [7.4. Теги (Tags)](#74-теги-tags)
    * [7.5. Раннер (Runner)](#75-раннер-runner)
    * [7.6. Прочие файлы](#76-прочие-файлы)
* [8. Схема работы](#8-схема-работы)
* [9. Запуск (Run)](#9-запуск-run)
    * [9.1. Запуск с помощью встроенных возможностей IDE Jetbrains](#91-запуск-с-помощью-встроенных-возможностей-ide-jetbrains)
        * [9.1.1. Простой запуск](#911-простой-запуск)
        * [9.1.2. Запуск с помощью новой конфигурации](#912-запуск-с-помощью-новой-конфигурации)
    * [9.2. Запуск с помощью JUnit раннера](#92-запуск-с-помощью-junit-раннера)
    * [9.3. Запуск с помощью Maven в JUnit 5](#93-запуск-с-помощью-maven-в-junit-5)

***

# 1. Подходы в разработке ПО

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Любой современный софт, включая веб-ориентированные приложения, тестируется на наличие ошибок.
Скорость идентификации этих ошибок зависит не только от инструментов,
количества тестировщиков и их опыта, но и от выбранного подхода.

Существуют следующие подходы в разработке ПО:

1. *Разработка через тестирование* (**Test Driven Development (TDD)**)
2. *Разработка через поведение* (**Behaviour Driven Development (BDD)**)

## 1.1. Разработка через тестирование (Test Driven Development (TDD))

***Разработка через тестирование (Test Driven Development (TDD))*** - подход в разработке ПО, 
предполагающий сначала написание тестов основанных на требованиях к ПО, с помощью которых ПО многократно проверяется, 
а потом уже программный код, достаточный для выполнения этих тестов.

**Разработка через тестирование (Test Driven Development (TDD))** — по сути, практика написания точных спецификаций, 
которые могут быть автоматически проверены до написания кода.

**Тесты** — это лучшие спецификации, потому что они не лгут. 
Они не скажут вам после двух недель мучения с кодом «я имел в виду совершенно не это». 
Тесты, если они правильно написаны, либо успешно выполняются, либо терпят неудачу.
Тесты недвусмысленно указывают, что именно должно происходить при определенных обстоятельствах.

[Кент Бек](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D0%BA,_%D0%9A%D0%B5%D0%BD%D1%82) -
[Кент Бек - Экстремальное программирование. Разработка через тестирование](https://www.litres.ru/kent-bek/ekstremalnoe-programmirovanie-razrabotka-cherez-testirovanie/)

### 1.1.1. Описание

**Разработка через тестирование (Test Driven Development (TDD))** основывается на повторении коротких циклов разработки.

Каждый цикл состоит из этапов:

1. *Написание кода теста*

На этом этапе занимаются написанием кода теста, покрывающий желаемое поведение системы и 
проверяющий корректность работы ещё ненаписанного кода.

Добавление каждой новой функциональности (**feature**) в программу начинается с написания теста.
Тест содержит проверки условий, которые могут либо выполняться, либо нет.
Прохождение теста подтверждает поведение, предполагаемое программистом.

На практике тесты покрывают критические и нетривиальные участки кода. Это может быть:

* код, подверженный частым изменениям
* код, от работы которого зависит работоспособность большого количества другого кода
* код с большим количеством зависимостей

2. *Запуск тестов - новые тесты не проходят (Red)* - 

На этом этапе проверяют, что новые написанные тесты не проходят.

Новый тест не будет проходить, поскольку соответствующий код ещё не написан.

3. *Написание кода ПО*

На этом этапе пишется новый код, который реализует желаемое поведение системы и позволит пройти написанный тест. 

Этот код не обязательно должен быть идеален. 
Допустимо, чтобы он проходил тест каким-то неэлегантным способом. 
Это приемлемо, поскольку последующие этапы улучшат и отполируют его.
Важно писать код, предназначенный именно для прохождения теста. 
Не следует добавлять лишней и, соответственно, не тестируемой функциональности.

4. *Запуск теста - новые тесты проходит (Green)*

На этом этапе проверяют, что новые написанные тесты проходят.

Если все тесты проходят, программист может быть уверен, что код удовлетворяет всем тестируемым требованиям (старым и новым).

Если все тесты не проходят, то написание кода продолжается (этап 2).

5. *Рефакторинг (Refactoring)*

Требуемая функциональность уже достигнута. На этом этапе может быть проведен рефакторинг кода.

***Рефакторинг*** — процесс изменения внутренней структуры программы, 
не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы, 
устранить дублирование кода, облегчить внесение изменений в ближайшем будущем.

Основные проблемы требующие рефакторинга:

* дублирование кода 
* длинный метод 
* большой класс 
* длинный список параметров 
* «жадные» функции (метод, который чрезмерно обращается к данным другого объекта) 
* избыточные временные переменные 
* классы данных 
* несгруппированные данные 
* и т.д

Рефакторинг написанного кода проводится с постоянной проверкой прохождения тестов.

6. *Повторение цикла*

Описанный цикл повторяется снова и снова, реализуя всё новую и новую функциональность.
Шаги следует делать небольшими, от 1 до 10 изменений между запусками тестов. 
Если новый код не удовлетворяет новым тестам или старые тесты перестают проходить, 
программист должен вернуться к отладке.

![TDD](_Files/1.%20TDD,%20BDD,%20ETC/01.png "TDD")

Названия цветов относятся к пользовательскому интерфейсу популярного автоматического запуска теста **JUnit**, 
где красная полоса указывает на то, что тест не пройден, а зеленая полоса указывает на то, что тест прошел успешно.

### 1.1.2. Плюсы 

1. *Раннее обнаружение багов*

Потенциальные критические баги могут быть найдены еще на начальном этапе разработки ПО.

2. *Хорошее покрытие функционала ПО тестами*

Разработка через тестирование сосредотачивается на тестировании отдельно взятых модулей.
Всё, что программа должна делать, проверяется тестами.

3. *Упрощение программной реализации*
   
Можно быть абсолютно уверенным, в том, что не пишется никакого ненужного кода, 
поскольку нужно будет писать код только для прохождения тестов.

4. *Сокращение времени на разработку и отладку ПО*

В то время как общее количество строк кода увеличивается (из-за тестов), 
частое тестирование исключает ошибки в процессе и выявляет существующие намного раньше, 
предотвращая возникновение проблем в дальнейшем.

5. *Повышение стабильности работы ПО*

Все основные функциональные возможности программы покрыты тестами и их работоспособность постоянно проверяется.

6. *Улучшение сопровождаемости ПО*

Разработчики могут не бояться вносить изменения в код, 
если что-то пойдёт не так, то об этом сообщат результаты автоматического тестирования.

7. *Использование тестов в качестве документации к коду ПО*

Хороший код расскажет о том, как он работает, лучше любой документации. 
Документация и комментарии в коде могут устаревать. 
Это может сбивать с толку разработчиков, изучающих код. 
А так как документация, в отличие от тестов, не может сказать, что она устарела, 
такие ситуации, когда документация не соответствует действительности — не редкость.

### 1.1.3. Минусы

1. *Наличие задач, которые невозможно (по крайней мере, на текущий момент) решить только при помощи тестов*

В частности, TDD не позволяет механически продемонстрировать адекватность разработанного кода 
в области безопасности данных и взаимодействия между процессами.

2. *Сложность применения в тех случаях, когда для тестирования необходимо прохождение функциональных тестов*

Примерами может быть: разработка интерфейсов пользователя, программ, работающих с базами данных, 
а также того, что зависит от специфической конфигурации сети.

3. *Увеличение времени на разработку и поддержку тестов*

Хотя время, затрачиваемое на предварительную генерацию тестов, экономится позднее в жизненном цикле разработки. 
Тем не менее, для подготовки и написания тестов требуется значительное время. 
Его многие разработчики предпочитают потратить на написание нового кода или рефакторинг существующего.

4. *Возможное падение контроля качества*

Большое количество используемых тестов может создать ложное ощущение надежности, 
приводящее к меньшему количеству действий по контролю качества.
В то же время тесты написанные с ошибками неизбежно приведут к ошибкам в разрабатываемом ПО.

## 1.2. Разработка через поведение (Behaviour Driven Development (BDD))

***Разработка через поведение (Behaviour Driven Development (BDD))*** - подход в разработке ПО, 
предполагающий написание тестовых сценариев (обычно выражающих поведение программного продукта и 
ожидаемые результаты в терминах, понятных неспециалисту) на понятном предметно-ориентированном языке, 
основу которого представляют конструкции из естественного языка.

Благодаря чему достигается совмещение в процессе разработки чисто технических интересов и интересов бизнеса, 
позволяя тем самым управляющему персоналу и программистам говорить на одном языке.
Это даёт возможность ускорить процесс получения обратной связи, убрав традиционные барьеры.
То есть описание пользовательских сценариев происходит на естественном языке — грубо говоря, на языке бизнеса.

[Три амиго](https://habr.com/ru/company/tinkoff/blog/449424/)

Три точки зрения (называемые триадой), необходимые, для четкого определения поведения решения:

1. *Клиентоориентированные заинтересованные лица* 

Понимают потребности клиентов и бизнеса, их пожелания и насколько они осуществимы.

2. *Заинтересованные лица, ориентированные на разработку* 

Понимают возможности решения и технологическую осуществимость.

3. *Заинтересованные лица, ориентированные на тестирование*

Видят исключения, граничные случаи и ограничительные условия для нового поведения системы.

![Три амиго](_Files/1.%20TDD,%20BDD,%20ETC/02.png "Три амиго")

Вместе эта группа достигает согласованности в том, что именно нужно создавать, чтобы уменьшить количество ошибок и переделок и ускорить поток ценностей.

**Разработка через поведение (Behaviour Driven Development (BDD))** по сути является разновидностью (расширением) **TDD**
в том смысле, что перед тем как написать какой-либо тест, необходимо сначала описать желаемый результат от 
добавляемой функциональности на предметно-ориентированном языке и только после того как это будет проделано, 
конструкции этого языка переводятся специалистами или специальным программным обеспечением в описание теста.

[Ден Норт](https://dannorth.net/)
[Ден Норт - Introducing BDD](https://dannorth.net/introducing-bdd/)
[Ден Норт - Введение в программирование через поведение (BDD)](https://habr.com/ru/post/216923/)

### 1.2.1. Описание

**Разработка через поведение (Behaviour Driven Development (BDD))** ориентирована на поведение сущности,
которую тестируют, в то время как в **TDD** основной фокус идёт непосредственно на сам код.

Тесты для некоторой единицы программного обеспечения должны быть описаны с точки зрения желаемого поведения. 
Под желаемым поведением здесь понимается такое, которое имеет ценность для бизнеса. 
Описание желаемого поведения даётся с помощью спецификации поведения (Behavioral Specification).

Спецификация поведения строится в полуформальной форме. 
В настоящее время в практике **BDD** устоялась следующая структура:

1. *Заголовок (Title)* - в сослагательной форме должно быть дано описание бизнес-цели
2. *Описание (Narrative)* - в краткой и свободной форме должны быть раскрыты следующие вопросы:

* кто является заинтересованным лицом данной истории?
* что входит в состав данной истории?
* какую ценность данная история предоставляет для бизнеса?

3. *Сценарии (Scenarios)* в одной спецификации может быть один и более сценариев, каждый из которых раскрывает 
одну из ситуаций поведения пользователя, тем самым конкретизируя описание спецификации

Каждый сценарий обычно строится по одной и той же схеме:

* начальные условия (**Givens**)
* событие, инициирующее начало сценария (**Whens**)
* ожидаемый результат(ы) (**Thens**)

![BDD](_Files/1.%20TDD,%20BDD,%20ETC/03.png "BDD")

**BDD** не предоставляет каких-либо формальных правил, но настаивает на том, чтобы использовался 
ограниченный стандартный набор фраз, который включал бы все элементы спецификации поведения. 
В 2007 году **Дэном Нортом** был предложен шаблон для спецификации, 
который получил популярность и впоследствии стал известен как язык **Gherkin**.

Полуформальный формат спецификации поведения требует использования ограниченного набора предложений, 
о которых управляющий персонал и разработчики должны предварительно договориться. 
Исходя из этого, фреймворки для поддержки **BDD** строятся по следующим принципам:

1. Парсер может разбить спецификацию по её формальным частям, например по ключевым словам языка Gherkin. 
На выходе мы получаем набор предложений, каждое из которых начинается с ключевого слова.
2. Каждое предложение может выражать один шаг теста.
3. Некоторые части предложения могут являться входными параметрами, которые можно захватить, 
а остальные части могут никак не использоваться и служить только для понимания действия человеком. 
Обычно для такого захвата используется процессор регулярных выражений. 
Захваченные параметры могут быть конвертированы и отправлены на вход конкретной исполняющей функции.
На этом принципе строятся такие фреймворки как **JBehave** и **RBehave**, которые основаны на языке **Gherkin**. 
Некоторые фреймворки строятся по аналогии, например **CBehave** и **Cucumber**.

Этапы:

1. *Определение функциональности с точки зрения бизнеса*

Задание на понятном нам языке, что хочет бизнес увидеть от функциональности разрабатываемого ПО.

*Пример*

```gherkin
#language: ru
Функция: Показать имя авторизованного пользователя
  Войдя в систему как пользователь "Username"
  Я хочу видеть в заголовке страницы текст "Здравствуйте, Username!"
```

2. *Написание сценария по шагам*

Сценарий с использованием специальной нотации (**Gherkin**). 

*Пример*

```gherkin
#language: ru
Сценарий: Показать приветствие авторизованному пользователю
  Дано Я вошел в систему как пользователь "Username"
  Когда Я посетил страницу
  Тогда В заголовке страницы отображается текст "Здравствуйте, Username!"
```

3. *Реализация определения шагов*

Написание кода по взаимодействию с системой, на который мапятся шаги сценария.
Таким образом BDD фреймворк (**Cucumber**) сможет интерпретировать каждый шаг, 
вычленить с помощью регулярных выражений параметры и запустить соответствующие тесты.

*Пример*

```java
@Дано("Я вошел в систему как пользователь \"{string}\"")
public void ...
```

4. *Запуск тестов - новые тесты не проходят*

5. *Написание кода ПО*

6. *Запуск тестов - новые тесты проходят*

7. *Рефакторинг (Refactoring)*

8. *Повторение цикла*

![BDD](_Files/1.%20TDD,%20BDD,%20ETC/04.png "BDD")

### 1.2.2. Плюсы

1. *Вовлечение всех заинтересованных лиц в написание сценариев*

Использование понятного языка для написания сценариев способствует тому, 
что сценарии могут читать и писать Product Owner, аналитики или другие заинтересованные лица.
Так в написании сценариев участвуют все (представители бизнеса, аналитики, разработчики и тестировщики), 
то формируется общее понимание ожидаемого поведения разрабатываемой системы.

2. *Независимость тестовых сценариев от реализации*

Так как сами сценарии пишутся на естественном языке и не зависят от реализации шагов сценария, 
то миграция на другой язык программирования сильно упрощается - нужно просто переписать шаги. 
Также упрощается поддержка тестовых сценариев в случае изменения реализации системы - нужно просто отредактировать шаги.
Сценарии могут измениться только в случае изменения требований.

3. *Поощрение автоматизации тестирования*

**BDD** подход изначально был направлен на внедрение автоматизации - пишем сценарии и сразу автотесты к ним.

4. *Снижение количества потенциальных дефектов*

Фокусировка на поведении системы с точки зрения пользователей позволяет проводить приемочное автотматизированное тестирование, 
В случае, если система не будет удовлетворять спецификациям, то автотесты не пройдут.

7. *Всегда актуальная структурированная документация*

**BDD** подход совместно с инженерными практиками позволит отказаться от legacy-документации, 
содержащей неактуальную информацию, и получать новую документацию налету, 
хранить ее вместе с проектом, что приблизило бы аналитиков и тестировщиков к коду.

### 1.2.3. Минусы

1. *Долго и дорого по сравнению с другими методами*

**BDD** неудобен хотя бы тем, что требует привлечения специалистов тестирования уже на этапе проработки требований, 
а это удлиняет цикл разработки. Выходом из этой ситуации может оказаться выбор подходящего 
**BDD** фреймворка и правильно выстроенных процессов разработки.

Поддержка сценариев и тестов также требует времени и усилий, которые в некоторых проектах могут считаться накладными.

2. *Бесполезность в случае неучастия всех заинтересованных сторон*

В случае, если в написании сценариев BDD участвует только тестировщик, 
то это только дополнительные затраты времени на разработку и поддержку сценариев.

3. *Необходимость внедрения с самого старта проекта*

**BDD** не имеет пользы, если внедрение началось в середине процесса разработки. 
Это только заставит выполнить дополнительную работы для уже готовых частей проекта. 
Модернизация сценариев и тестов для устаревшего кода практически невозможна и не имеет смысла.

## 1.3. TDD VS BDD

Подходы **BDD** и **TDD** имеют много различий.

| **Критерий**      | **TDD**                    | **BDD**                       |
|-------------------|----------------------------|-------------------------------|
| *Фокус*           | Код, Реализация            | Поведение системы, Требования |
| *Стартовая точка* | Тест кейс                  | Пользовательская история      |
| *Участники*       | Разработчики, тестировщики | Все + бизнес                  |
| *Документация*    | Раздельная                 | Спеки=Тест кейсы=Автотесты    |
| *Язык*            | Язык программирования      | Общеупотребительный язык      |
| *Тестирование*    | Модульное                  | Интеграционное Е2Е Системное  |
| *Автотесты*       | Отдельным этапом           | На всех этапах                |

Но оба подхода отлично дополняют друг друга.

![BDD](_Files/1.%20TDD,%20BDD,%20ETC/05.png "BDD")

## 1.4. Прочие X Driven Development

1. *Разработка на основе типов (Type Driven Development (TDD))* - 
типы данных и сигнатуры типов являются спецификацией программы

2. *Предметно-ориентированное проектирование (Domain Driven Design (DDD))* -
создание программных абстракций, которые называются моделями предметных областей

3. *Разработка на основе функциональности (Features Driven Development (FDD))* -
функциональность (свойства) разрабатываемого программного обеспечения

4. *Разработка на основе моделей (Model Driven Development (MDD))* -
основная бизнес-логика содержится в диаграммах и 
не сковывает рамками выбора языка программирования и инструментов разработки

***

# 2. Подходы в разработке тестов

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 2.1. Тестирование, управляемое данными (Data Driven Testing (DDT))

***Тестирование, управляемое данными (Data Driven Testing (DDT))*** - подход, при котором тестовые данные хранятся 
отдельно от тест-кейсов, (в файле либо в базе данных). Такое разделение логически упрощает тесты.

Часто покрываемая система, или метод являются очень сложными, и тогда невозможно ввести явно эталонные значения, 
здесь можно говорить об эталонных выходных состояниях. Бывает, нужно применить смекалку, чтобы понять, 
что же будет входным описанием, а что будет выходным. 

Чтобы проверка приложения была успешна, потребуются разные комбинации данных.

### 2.1.1. Описание

При использовании подхода **Тестирование, управляемое данными (Data Driven Testing (DDT))** 
тест умеет принимать набор входных параметров, и эталонный результат или эталонное состояние, 
с которым он должен сравнить результат, полученный в ходе прогонки входных параметров.

Для реализации подхода **Тестирование, управляемое данными (Data Driven Testing (DDT))** 
необходимо наличие хранилища данных - файлы **.xls**, **.csv**, **.xml**, **.json** либо база данных. 

Этапы:

1. *Извлечение части тестовых данных из хранилища*

Чтение файлов, запрос к БД.

2. *Использование данных тестовым сценарием*

Ввод данных в форму на UI, подстановка данных в методы или передача данных в запросы API.

3. *Проверка и сохранение результатов для последующего анализа*

Получение результатов на UI, от API или методов.
Проверка и сравнение с эталонными значениями.

4. *Продолжение тестирования со следующим набором входных данных*

![DDT](_Files/1.%20TDD,%20BDD,%20ETC/06.jpg "DDT")

### 2.1.2. Плюсы

1. *Раздельное хранение кода тестов и тестовых данных*

Возможность ввода входных значений и эталонного результата в виде, удобном для всех ролей на проекте – 
начиная от мануального тестировщика и заканчивая менеджером (тест менеджером) проекта.
Это может быть Excel файл либо CSV файл.

Подготовка эталонных тестовых данных любым членом команды.

2. *Прогон тестов в нескольких средах с большими наборами данных*

### 2.1.3. Минусы

1. *Качество теста зависит от навыков автоматизации команды разработчиков*

Если в приложении сложная логика, которая проверяется на наборе комбинаций входных параметров, 
то от тех кто подготавливает тестовые наборы, требуется высокая квалификация в области применения техник тест дизайна.

2. *Затраты на подготовку данных*

Подготовка данных может занять некоторое время.

3. *Затраты на проверку*

Проверка данных - трудоемкая задача при тестировании большого количества данных.

3. *Больше документации*

В основном связано с управлением скриптами, инфраструктурой тестирования и результатами тестирования.

## 2.2. Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))

***Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))*** - подход, 
согласно которому используются некоторые ключевые слова, детально описывающие набор выполняемых действий, 
нужных для прохождения определенного шага тестового сценария.

### 2.2.1. Описание

При использовании подхода **Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))** 
в первую очередь определяется набор ключевых слов, а только после этого ассоциируется функция либо действие, 
связанное с данным ключевым словом.

Идея подхода **Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))** 
заключается в том, что количество операций в любом приложении конечно. 
Это значит, что если все операции в приложении реализовать в виде ключевых слов, 
можно на эти кейворды делать бесконечное количество новых тестовых сценариев, 
комбинируя их в правильном порядке. 
Так можно обеспечить рабочий инструмент людям, которые хотят вовлекаться.

Например, каждые шаги теста, такие как щелчок мышью, нажатие клавиши,
открытие либо закрытие браузера описываются определёнными ключевыми словами 
(**открыть** - openbrowser, **нажать** - click и т. п.).

Этапы:

1. *Определение набора ключевых слов*

Формируется набор ключевых слов, за которыми будет закреплено выполнение определенных действий с системой.

2. *Реализация ключевых слов как исполняемых файлов / функций*

Реализация ассоциаций (определенных действий или функций), связанных с данным ключевым словом.
Например, написание кода по взаимодействию с системой.
То есть каждый такой шаг теста, например, открытие и закрытие иконки браузера, клик мышки по объекту, 
описывается специальным ключевым словом – **открыть** или **нажать** (open browser или click).

3. *Написание тестовых сценариев с использованием набора ключевых слов*

Тестовый сценарий представляет собой последовательность из ключевых слов.
Во время выполнения тестирования на основе ключевых слов существует возможность 
создавать простые функциональные тесты на любой стадии разработки программного продукта, 
проверяя приложение по разным составным частям.

4. *Запуск тестов*

Во время выполнения тест-кейсов все ключевые слова интерпретируются согласно использованной тестовой библиотеке.

![KDT](_Files/1.%20TDD,%20BDD,%20ETC/07.png "KDT")

### 2.2.2. Плюсы

1. *Абстрагирование от системы*

Функциональные тестировщики могут планировать автоматизацию тестирования до того, как приложение будет готово.

2. *Повышение производительности на проекте*

Тесты можно разработать без знаний программирования. 
Поэтому каждый участник может участвовать в разработке тестовых сценариев, которые потом будут автоматизированы.

3. *Подход не зависит от выбранного языка программирования*

Сценарии могут быть реализованы на любом языке программирования. 
В случае с миграцией на новую платформу нужно будет лишь реализовать функции по взаимодействию с системой.
Тогда как сами сценарии останутся неименными.

4. *Ускорение написания новых сценариев*

Так как большинство сценариев могут включать уже существующие шаги, 
то переиспользование уже готовых шагов позволит существенно сократить время на разработку новых сценариев. 

### 2.2.3. Минусы

1. *Накладные расходы*

Если на проекте тесты пишут только тестировщики, и, возможно, только автоматизаторы, 
то для них это в данном случае является оверхедом – использованием подхода там, где нет проблематики.

2. *Планирование и управление может быть сложными*
   
Планирование и управление имеют решающее значение
Если структура, основанная на ключевых словах, не планируется заранее, 
это может привести к созданию ключевых слов, которые бесполезны в долгосрочной перспективе или 
могут потребовать слишком большого количества изменений каждый раз, когда ключевое слово добавляется.
Таким образом, обдумывание того, какие ключевые слова использовать и как реализовать, 
становится решающим шагом для повышения продуктивности и эффективности фреймворка.

***

# 3. Фреймворки BDD тестирования

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В любом из основных языков программирования существуют **BDD** фреймворки автоматизации. В некоторых даже не один.

Больше половины BDD фреймворков – это своего рода унифицированные версии **Cucumber**, 
исходящие от базового фреймворка JBehave, описанные в стиле его автора **Дена Норта (Dan North)**, или non-Gherkin спек-раннеры.
Некоторые организуют поведенческие сценарии в отдельные файлы, 
в то время как другие размещают их непосредственно в исходном коде.

## 3.1. Python

### 3.1.1. Основные

У языка **Python** насчитывается большое количество тестовых фреймворков, 
многие из которых по своей сущности являются **BDD**. 
Наиболее популярными и известными считаются – **lettuce** и **behave**.

***Behave*** - фреймворк полностью совместимый с **Gherkin**. 

[Behave - github.com](https://github.com/behave/behave)

[Behave - readthedocs.io](https://behave.readthedocs.io/en/stable/)

***lettuce*** - фреймворк совместимый с **Gherkin**, но лишенный некоторых лингвистических элементов.

[Lettuce - github.com](https://github.com/gabrielfalcao/lettuce)

Оба имеют плагины для основных **IDE**, и записывают сценарии в отдельные **feature** файлы. 
Все они внедряют определение шагов в виде функций вместо классов, 
что не только упрощает описание шагов и делает их использование более независимым, 
но и помогает избежать ненужных объектных конструкций.

### 3.1.2. Альтернативы

***Radish*** - фреймворк, который расширяет язык **Gherkin** с целью возможности использования 
сценарных циклов, сценарных предусловий и переменных.
Так же как и **behave** **lettuce**, записывают сценарии в отдельные feature файлы,
и внедряет определение шагов в виде функций вместо классов.

[Radish - radish-bdd.io](http://radish-bdd.io/)

[Radish - github.com](https://github.com/radish-bdd/radish)

***Pyspecs*** - фреймворк, который spec-ориентированный фреймворк.

[Pyspecs - github.com](https://github.com/mdwhatcott/pyspecs)

***Pytest-BDD*** - фреймворк, который добавляет некоторые **Gherkin** фичи в популярную библиотеку **pytest**.

**pytest** является популярным фреймворком для тестирования в сообществе **Python**.

[Pytest-BDD - github.com](https://github.com/pytest-dev/pytest-bdd)

## 3.2. Ruby

### 3.2.1. Основные

***Cucumber*** - основной BDD фреймворк, являющийся золотым стандартом BDD фреймворков, 
впервые был выпущен на языке **Ruby**. **Cucumber** поддерживает официальный стандарт языка **Gherkin** 
и все версии **Cucumber** написаны на основе оригинальной на **Ruby**.

Поскольку многие **Ruby**-разработчики уже знакомы с **Cucumber**, большинство проектов **Ruby**, 
как правило, придерживаются фреймворка, чтобы разработчикам не приходилось изучать новый инструмент.

[Cucumber - cucumber.io](https://cucumber.io/)

[Cucumber - github.com](https://github.com/cucumber/cucumber-ruby)

### 3.2.2. Альтернативы

***Spinach*** - фреймворк, который позиционирует себя как самый упрощенный **Cucumber**
с максимально доработанным функционалом инкапсуляции пользовательских шагов. 

[Spinach - github.com](https://github.com/codegram/spinach)

***RSpec***  - фреймворк, который spec-ориентированный фреймворк, не взаимодействующий с **Gherkin**.

[RSpec - rspec.info](https://rspec.info/)

[RSpec - github.com](https://github.com/rspec/rspec)

## 3.3. JavaScript

### 3.3.1. Основные

Почти все **JavaScript** **BDD** фреймворки работают на **Node.js**. 

Наиболее популярные - это **Jasime** and **Mocha**.

***Mocha*** - многоцелевой тестовый фреймворк, который преобразовывает фразы на английском языке в код спецификаций. 

[Mocha - mochajs.org](https://mochajs.org/)

[Mocha - github.com](https://github.com/mochajs/mocha)

***Jasmine*** - похожий на **Mocha** фреймворк, но по нему гораздо меньше обучающего материала.

[Jasmine](https://jasmine.github.io/)

[Jasmine](https://github.com/jasmine/jasmine)

### 3.3.2. Альтернативы

***Cucumber.js*** - решение **Cucumber** на **JS** для полной совместимости с **Gherkin**.
В блоге **Cucumber** ведутся споры на тему того, что **Cucumber.js** лучший, благодаря тому, 
что его фокус направлен на достижение лучшей коммуникации посредством описания шагов человеко-читаемым текстом, 
в то время как в других **JavaScript** **BDD** фреймворках больше кода, чем лингвистических средств.

[Cucumber - cucumber.io](https://cucumber.io/)

[Cucumber.js - github.com](https://github.com/cucumber/cucumber-js)

***Yadda*** - фреймворк, который чем-то напоминает **Gherkin**, но с более гибким синтаксисом. 

[Yadda - github.com](https://github.com/acuminous/yadda)

***Vows*** - фреймворк, который предоставляет другой тип **BDD** подхода с использованием 
более формализованных делений фразовых конструкций для обеспечения уникальности при их переиспользовании.

[Vows - vowsjs.org](https://www.vowsjs.org/)

[Vows - github.com](https://github.com/vowsjs/vows)

## 3.4. C# и .NET

### 3.4.1. Основные

***SpecFlow*** - наиболее популярный BDD фреймворк для языков программирования Microsoft .NET.

Его слоган звучит как **Cucumber для .NET** – поэтому он полностью совместим с **Gherkin**. 
Основной пакет фреймворка бесплатный и опенсорсный, но лицензии на расширения **SpecFlow+** являются платными.

Бесплатная версия требует установки юнит-тест раннера такого как, например, **MsTest**, 
**NUnit** или **xUnit.net** для запуска сценариев. Это делает использование **SpecFlow** удобным, 
но в то же время оставляет ощущение некоторой топорности фреймворка. 

В лицензионной версии предоставляется легкий раннер под названием **SpecFlow+ Runner**
(который совместим с BDD) и инструмент для интеграции с **Microsoft Excel** под названием **SpecFlow+ Excel**. 
Имеются **SpecFlow** расширения для **Microsoft Visual Studio**, облегчающие разработку.

[SpecFlow - specflow.org](https://specflow.org/)

[SpecFlow - github.com](https://github.com/SpecFlowOSS/SpecFlow)

### 3.4.2. Альтернативы

***Xunit.Gherkin.Quick*** - фреймворк, который позиционирует себя как легкий 
кроссплатформенный фреймворк **BDD** тестирования.

[Xunit.Gherkin.Quick - github.com](https://github.com/ttutisani/Xunit.Gherkin.Quick)

***xBehave.net*** - фреймворк, который хорошо работает в паре с **xUnit.net**. 
Основное отличие **xBehave.net** заключается в том, что пошаговые сценарии пишутся непосредственно в коде, 
а не в отдельных текстовых (так называемых feature) файлах.

[xBehave.net - github.com](https://github.com/adamralph/xbehave.net)

***LightBDD*** - фреймворк, который более легковесный, по сравнению с остальными.
Как правило, применяет некоторые приемы при работе с partial (частичными) классами для большей читабельности кода.

[LightBDD - github.com](https://github.com/LightBDD/LightBDD)

***NSpec*** - фреймворк, который похож на **RSpec** и **Mocha** и активно использует лямбда-выражения.

[NSpec - nspec.org](http://nspec.org/)

[NSpec - github.com](https://github.com/nspec/NSpec)

***Concordion.NET*** - фреймворк, который предлагает несколько интересных решений для написания **BDD** тестов.

[Concordion - concordion.org](https://concordion.org/)

[Concordion.NET - github.com](https://github.com/concordion/concordion.net)

## 3.5. Java И JVM

### 3.5.1. Основные

Самыми главными конкурентами в **Java** являются такие фреймворки, как **JBehave** и **Cucumber-JVM**.

***JBehave*** - один из первых и наиболее распространенных **BDD** фреймворков на рынке. 
Его разработал **Дена Норт (Dan North)**, который считается **отцом BDD**. 
Однако, в **JBehave** отсутствуют ключевые особенности **Gherkin**, 
такие как **backgrounds**, **doc strings** и **tags**. 
Также он являлся первым решением на чистой **Java** и существовал еще до появления **Cucumber-JVM**.

[JBehave - jbehave.org](https://jbehave.org/)

[JBehave - github.com](https://github.com/jbehave/jbehave-core)

***Cucumber-JVM*** - официальная версия **Cucumber** для языка **Java** и 
других **JVM** языков (**Groovy**, **Scala**, **Clojure** и т.д.). 
Он полностью совместим с **Gherkin** и генерирует красивые отчеты. 
Драйвер **Cucumber-JVM** также может быть кастомизирован.

[Cucumber - cucumber.io](https://cucumber.io/)

[Cucumber-JVM - github.com](https://github.com/cucumber/cucumber-jvm)

Оба фреймворка широко используются, для них имеются плагины в большинстве IDE и устанавливаются с помощью Maven пакетов.

### 3.5.2. Альтернативы

***JGiven*** - фреймворк, который применяет fluent API для создания сценариев, 
а красочные HTML отчеты выводятся вместе с результатами тестов. Его синтаксис вполне лаконичен.

[JGiven - jgiven.org](https://jgiven.org/)

[JGiven - github.com](https://github.com/TNG/JGiven)

***Spock*** - фреймворк, который представляет собой spec фреймворк.
Есть собственный очень выразительный язык, который отличает его от других фреймворков **BDD**, 
и он совместим с большинством IDE, инструментов сборки и серверов CI.

[Spock - spockframework.org](https://spockframework.org/)

[Spock - github.com](https://github.com/spockframework/spock)

***Concordion*** - фреймворк, который наиболее известен своей привлекательной и 
гибкой живой документацией и надежным инструментарием.

[Concordion - concordion.org](https://concordion.org/)

[Concordion Java - github.com](https://github.com/concordion/concordion)

## 3.6. Какой фреймворк лучше?

На этот вопрос нет правильного ответа – 
**лучший BDD фреймворк - это тот, который лучше всего удовлетворяет ваши потребности**. 

Однако, нужно учитывать несколько моментов при выборе:

* какой язык программирования мне использовать для автоматизации?
* является ли этот фреймворк популярным и широко используемым?
* активно ли поддерживается фреймворк?
* язык спецификаций совместим с **Gherkin**?
* для какого вида тестирования вы будете использовать фреймворк?
* какие ограничения устанавливаются фреймворком в сравнении с другими?

Фреймворки, которые отделяют текст сценариев от кода хороши для **shift-left** тестирования. 
Фреймворки, которые определяют текст сценариев непосредственно в исходный код, 
лучше подходят для тестирования **белого ящика**, но они могут быть непонятны менее опытным разработчикам.

***

# 4. Cucumber

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

* [Cucumber](https://docs.cucumber.io/)
* [Настройка проекта Cucumber-JVM](https://docs.cucumber.io/docs/installation/java/)
* [Гайды по Cucumber](https://docs.cucumber.io/docs/guides/)
* [Описание Cucumber](https://docs.cucumber.io/docs/cucumber/)
* [Описание Gherkin](https://docs.cucumber.io/docs/gherkin/)

Первоначально **Cucumber** был разработан **Ruby**-сообществом,
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**).

**Cucumber** использует легко читаемый предметно-ориентированный язык
для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему,
понимать и писать их может любой участник проекта.

Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых кейсов для спецификаций.
Тестовые кейсы могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.).
Тестовые кейсы на **Gherkin** сопоставляются с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, его можно использовать
в связке со многими другими популярными инструментами:

* **JUnit**, **TestNG** - фреймворки для Unit тестов в **Java**
* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов
  и т д.

Существуют множество различных реализацией [Cucumber](https://cucumber.io/docs/installation/)
для многих языков программирования

***

# 5. Плюсы и минусы

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Плюсы:

1. Использование понятного всем языка

Сценарии **Gherkin**, определяющие поведение системы, описываются в простой форме и
могут быть понятны всем участникам проекта (заказчикам, аналитикам, разработчикам, тестировщикам).

2. Проектная документация + автотесты

Значительная часть функциональных спецификаций может быть написана в виде пользовательских историй на **Gherkin**.
Файлы, содержащие в себе спецификации, одновременно являются и исполняемыми автотестами.

3. Эффективный инструмент для автоматизации тестирования

* разделение тест-кейсов и кода тестов
* тестовая документация и программный код автотестов хранятся в одном проекте и неотделимы друг от друга
* сценарии тестирования **Gherkin** напрямую связывают приемочные тесты с автоматизированными тестами
* наличие словаря доступных шагов допускает вариативность сценариев и позволяет тестировщикам составлять новые автотесты,
  не обращаясь к программному коду.

Минусы:

1. Обязательное наличие высокой степени деловой активности и сотрудничества между всеми заинтересованными лицами
   (представители бизнеса, аналитики, разработчики, тестировщики)

2. Может работать не во всех сценариях

3. Плохо написанные тесты могут легко увеличить расходы на обслуживание тестов.

***

# 6. Старт проекта с Cucumber

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 6.1. Настройка способа написания реализации шагов Gherkin

### 6.1.1. Настройка проекта для работы через аннотации Java

#### 6.1.1.1. Зависимости

**cucumber-java** - для работы через аннотации **Java**

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-java</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

[cucumber-java](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-java)

#### 6.1.1.2. Реализация шагов через аннотации Java

*Пример*

```java
@Дано("Дано что то там")
public void givenMethod() {...}

@Когда("Когда что то там")
public void whenMethod() {...}

@Тогда("Тогда что то там")
public void thenMethod() {...}
```

### 6.1.2. Настройка проекта для работы через лямбда выражения Java

#### 6.1.2.1. Зависимости

**cucumber-java8** - для работы через лямбда выражения **Java**

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-java8</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

[cucumber-java8](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-java8)

#### 6.1.2.2. Реализация шагов через лямбда выражения Java

*Пример*

```java
@Дано("Дано что то там"), () -> {...});

@Когда("Когда что то там"), () -> {...});

@Тогда("Тогда что то там"), () -> {...});
```

## 6.2. Настройка связки с тестовым фрймворком

### 6.2.1. Настройка проекта под JUnit 4

#### 6.2.1.1. Зависимости

**cucumber-junit** - для запуска с **JUnit** (JUnit 4)

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-junit</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

Данная зависимость уже содержит зависимости:

* *junit*
* *junit-jupiter*
* *junit-vintage-engine*

[cucumber-junit](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-junit)

**junit** - JUnit 4

#### 6.2.1.2. Плагины

**maven-surefire-plugin**

```xml
<build>
    <plugins>
        <plugin>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>${maven-surefire-plugin.version}</version>  
            <configuration>
                <parallel>both</parallel>
                <threadCount>4</threadCount>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 6.2.1.3. Раннер

*Пример*

```java
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

// @RunWith
// Класс для запуска тестов
@RunWith(Cucumber.class)
// @CucumberOptions
// Опции для запуска сценариев
@CucumberOptions(
    // Список папок с feature файлами - фичи/сценарии
    features = {"src/test/resources/features"},
    // Спиcок пакетов с steps файлами - шаги
    glue = {"steps", "hooks"}
)
public class RunCucumberTest {
}
```

### 6.2.2. Настройка проекта под JUnit 5

#### 6.2.2.1. Зависимости

**cucumber-junit-platform-engine** - для запуска с **JUnit** (JUnit 5)

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-junit-platform-engine</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

Данная зависимость уже содержит зависимости:

* *junit-platform-engine*
* *junit-jupiter-engine*
* *junit-jupiter-api*

[cucumber-junit-platform-engine](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-junit-platform-engine)

**junit-jupiter-api**

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <scope>test</scope>
</dependency>
```

**junit-platform-suite**

```xml
<dependency>
    <groupId>org.junit.platform</groupId>
    <artifactId>junit-platform-suite</artifactId>
    <scope>test</scope>
</dependency>
```

**junit-platform-console**

```xml
<dependency>
    <groupId>org.junit.platform</groupId>
    <artifactId>junit-platform-console</artifactId>
    <scope>test</scope>
</dependency>
```

#### 6.2.2.2. Плагины

**maven-surefire-plugin**

```xml
<build>
    <plugins>
        <plugin>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>${maven-surefire-plugin.version}</version>  
            <configuration>
                <parallel>both</parallel>
                <threadCount>4</threadCount>
                <properties>
                    <configurationParameters>
                        cucumber.junit-platform.naming-strategy=long
                    </configurationParameters>
                </properties>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 6.2.2.3. Раннер

*Пример*

```java
import org.junit.platform.suite.api.ConfigurationParameter;
import org.junit.platform.suite.api.IncludeEngines;
import org.junit.platform.suite.api.SelectClasspathResource;
import org.junit.platform.suite.api.Suite;

import static io.cucumber.core.options.Constants.*;

// @Suite
// Набор тестов
@Suite
// @IncludeEngines
// Тестовый движок
@IncludeEngines("cucumber")
// @SelectClasspathResource
// Папка с BDD сценариями на Gherkin
@SelectClasspathResource("features")
// @ConfigurationParameter
// Опции для запуска сценариев
@ConfigurationParameter(key = GLUE_PROPERTY_NAME, value = "steps, hooks")
@ConfigurationParameter(key = PLUGIN_PUBLISH_QUIET_PROPERTY_NAME, value = "true")
public class RunCucumberTest {
}
```

### 6.2.3. Настройка проекта под TestNG

#### 6.2.3.1. Зависимости

**cucumber-testng** - для запуска с **TestNG**

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-testng</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

Данная зависимость уже содержит зависимости:

* **testng**

[cucumber-testng](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-testng)

#### 6.2.3.2. Плагины

```xml

```

#### 6.2.3.3. Раннер

```java
import io.cucumber.testng.AbstractTestNGCucumberTests;
import io.cucumber.testng.CucumberOptions;
import org.testng.annotations.DataProvider;

// @CucumberOptions
// Опции для запуска сценариев
@CucumberOptions(
    plugin = { "html:target/results.html", "message:target/results.ndjson" }
)
public class RunCucumberTest extends AbstractTestNGCucumberTests {
    @DataProvider(parallel = true)
    @Override
    public Object[][] scenarios() {
        return super.scenarios();
    }
}
```

***

# 7. Структура проекта Cucumber

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Проект **Cucumber** состоит из следующих частей:

1. **Описание сценариев (Features)** - описание тестовых сценариев (поведения системы) на **Gherkin** 
(файлы с текстами сценариев **.feature**)
2. **Реализация шагов сценариев (Step Defs)** - реализация шагов тестовых сценариев на **Java** 
(файлы с исходным кодом **.java**)
3. **Хуки (Hooks)** - действия выполняемые до и после запуска сценариев описанных в **.feature** файлах 
(файлы с исходным кодом **.java**)
4. **Теги (Tags)** - метки для классификации и организации запуска тестовых сценариев
5. **Раннер (Runner)** - специальный класс **Java** для запуска тестовых сценариев на **Gherkin**
6. Прочие файлы

## 7.1. Описание сценариев (Features)

***Описание сценариев (Features)*** – текстовые файлы с расширением **.feature**,
которые содержат текст исполняемых спецификаций на языке **Gherkin**.

**Описание сценариев (Features)** представляет собой текст на естественном языке
в свободной форме с использованием ключевых слов **Gherkin**.

*Пример*

```gherkin
# language: ru
# encoding: utf-8
Функция: Смартфоны

  Я как посетитель сайта ДНС хочу просматривать раздел со смартфонами.
  Это позволит мне выбрать понравившийся смартфон и просмотреть его характеристики.

  Сценарий: Просмотр страницы Смартфоны
    Дано Запущен браузер и открыта Главная страница ДНС
    Когда Выполнен переход на страницу Смартфоны
    Тогда Проверить: В заголовке страницы отображается текст Смартфоны
```

Особенности:

1. Каждый файл **.feature** должен содержать описание только одной фичи

Описание фичи начинается с ключевого слова **Функция (Function)** и поэтому каждый файл содержит только одно ключевое слово.

2. Каждый файл **.feature** может содержать от 0 и более сценариев

3. Текст сценариев должен начинаться с **# language: ru**, если используется русский язык

Эта строка указывает **Cucumber**, что в сценарии используется русский язык (по умолчанию используется английский язык).
Если её не указать, фреймворк, встретив в сценарии русский текст, выбросит исключение **LexingError** и тест не запустится.

4. Каждый сценарий должен иметь следующую структуру:

* получение начального состояние системы
* выполнение действий по изменению состояния системы
* получение и проверка нового состояние системы

## 7.2. Реализация шагов сценариев (Step Defs)

***Реализация шагов сценариев (Step Defs)*** - файлы с расширением **.java**,
содержащие код для взаимодействия с разрабатываемой системой, на который мапятся шаги в описании сценариев.

**Cucumber** не знает как взаимодействовать с системой в рамках
исполнения шагов сценариев написанных на **Gherkin** в файлах **.feature**.

**Реализация шагов сценариев (Step Defs)** связывает шаги описанные в тексте на **Gherkin** в файлах **.feature**
с кодом по взаимодействию с системой на **Java**, чтобы сценарии могли исполниться.

**Реализация шагов сценариев (Step Defs)** представляет собой текст с записанным выражением-паттерном
(регулярным выражением или выражением Cucumber), который содержится в специальной аннотации
у каждого метода реализующего определенный шаг.

Сам код на **Java** может тестировать:

* Web UI (**Selenium WebDriver**)
* REST API (**REST Assured**)
* SOAP
* БД
  и т д.

*Пример*

```java
@Дано("Запущен браузер и открыта Главная страница ДНС")
public void startDriverAndOpenStartPage() {
    // Запустить драйвер
    driver = WebDriverFactory.getDriver(BrowserName.fromString("Chrome"));
    logger.info("Драйвер стартовал!");
    // Открыть страницу https://www.dns-shop.ru/
    driver.get("https://www.dns-shop.ru/");
    logger.info("Открыта Стартовая страница сайта DNS");
}

@Когда("Выполнен переход на страницу Смартфоны")
public void openSmartphonesPage() {
    StartPage startPage = new StartPage(driver);
    startPage.linkYes().click();
    startPage.linkSmartsAndGadget().focusOnLink();
    startPage.linkSmarts().click();
    logger.info("Выполнен переход на страницу Смартфоны");
}

@Тогда("Проверить: В заголовке страницы отображается текст Смартфоны")
public void assertTitle() {
    SmartphonesPage smartphonesPage = new SmartphonesPage(driver);
    // Проверка заголовка страницы
    Assertions.assertTrue(smartphonesPage.getPageTitle().contains("Смартфоны"));
    // Если драйвер еще существует
    if(driver != null) {
        // Закрываем его
        driver.quit();
        logger.info("Драйвер остановлен!");
    }
}
```

Каждая реализация шага должна иметь аннотацию, соответствующую типу шага.

Аннотации для **Реализации шагов сценариев (Step Defs)**:

| Аннотация  | Описание                                           |
|------------|----------------------------------------------------|
| **@Дано**  | Получение начального состояние системы             |
| **@Когда** | Выполнение действий по изменению состояния системы |
| **@Тогда** | Получение и проверка нового состояние системы      |

При выполнении тестов **Cucumber** для каждого шага **.feature** на **Gherkin**
ищет его реализацию в коде на **Java**, посредством сравнения с выражением-паттерном в аннотации.
Таким образом, шаги в файлах **.feature** на **Gherkin** можно рассматривать как вызов методов **Java**.

Особенности:

1. Каждая **Реализация шагов сценариев (Step Defs)** должна совпадать по количеству аргументов с шагами описанными в **.feature**
2. Каждая **Реализация шагов сценариев (Step Defs)** должна иметь уникальный паттерн описанный в аннотации

Если задать два разных метода с одним и тем же паттерном, 
то при выполнении тестов возникнет исключение **DuplicateStepException**.
Такое же исключение можно словить, если задать два разных метода 
с одним и тем же паттерном в разных файлах **.java** в одном пакете **Java**.

3. Каждая **Реализация шагов сценариев (Step Defs)** может быть повторно использована в различных файлах **.feature**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

4. Каждая **Реализация шагов сценариев (Step Defs)** может быть использована в одном файле **.feature**
   совместно с другими реализациями шагов из разных файлов **.java**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

## 7.3. Хуки (Hooks)

***Хуки (Hooks)*** - методы выполняемые на разных этапах запуска сценариев.

**Хуки (Hooks)** представляют собой методы помеченные специальными аннотациями.

Аннотации для **Хуков (Hooks)**:

| Аннотация       | Описание                                   |
|-----------------|--------------------------------------------|
| **@Before**     | Выполнение действий перед каждым сценарием |
| **@After**      | Выполнение действий после каждого сценария |
| **@BeforeStep** | Выполнение действий перед каждым шагом     |
| **@AfterStep**  | Выполнение действий после каждого шага     |

**Хуки (Hooks)** используются для того, чтобы выполнить какие-либо действия до или после сценария / шага.
Например, подготовить тестируемую систему или вернуть ее в изначальное состояние.

**Хуки (Hooks)** не влияют на сами сценарии или шаги.

*Пример*

```java
import cucumber.api.java.After;
import cucumber.api.java.Before;

public class Hooks {
    @Before
    public void prepareData() {
        //подготовить данные
    }
    
    @After
    public void clearData() {
        //очистить данные
    }
}
```

Особенности:

1. **Хуки (Hooks)** можно определить в любом классе.

2. Классы с **Хуками (Hooks)** должны находиться в пакете, указанном в опциях фреймворка

3. **Хукам (Hooks)** можно задать порядок, в котором они будут выполняться

Для этого необходимо в аннотации указать параметр **order**. По умолчанию значение **order** равно 10000.

Для **@Before** чем меньше это значение, тем раньше выполнится метод

*Пример*

```java
// первым выполнится метод connectToServer()
@Before(order = 10)
    public void connectToServer() {
    // подключиться к серверу
}
// затем prepareData()
@Before(order = 20)
    public void prepareData() {
    // подготовить данные
}
```

Для **@After** отрабатывает в обратном порядке.

3. **Хукам (Hooks) @Before, @After, @Around** можно задать теги, чтобы задать фильтрацию сценариев, 
для которых будут применяться хуки.

В параметре **value** нужно указать теги сценариев, для которых будут отрабатывать **Хуки (Hooks)**.
Список тегов сценариев в одной строке обрабатывается как **ИЛИ**, а отдельные аргументы обрабатываются как **И**.
Символ **~** означает «за исключением».

*Пример*

```java
// метод connectToServer() будет выполнен для всех сценариев с тегом correct
@Before(value = "@correct", order = 30)
public void connectToServer() {
    //сделай что-нибудь
}
        
// метод prepareData() будет выполнен для всех сценариев за исключением сценариев с тэгом fail
@Before(value = "~@fail", order = 20)
public void prepareData() {
    //сделай что-нибудь
}
```

4. **Хукам (Hooks)** можно передать в качестве параметра объект класса **Scenario**

Если в определении **Хука (Hooks)** в аргументе указать объект класса **Scenario**,
то в данном методе можно будет узнать много полезной информации о запущенном сценарии.

*Пример*

Метод **getScenarioInfo(Scenario scenario)**

```java
@After
public void getScenarioInfo(Scenario scenario) {
    System.out.println(scenario.getId());
    System.out.println(scenario.getName());
    System.out.println(scenario.getStatus());
    System.out.println(scenario.isFailed());
    System.out.println(scenario.getSourceTagNames());
}
```

Для сценария

```gherkin
# language: ru
@all
Функция: Аутентификация банковской карты
  
    Банкомат должен спросить у пользователя PIN-код банковской карты
    Банкомат должен выдать предупреждение если пользователь ввел неправильный PIN-код
    Аутентификация успешна если пользователь ввел правильный PIN-код

    Предыстория:
    Допустим пользователь вставляет в банкомат банковскую карту
    И банкомат выдает сообщение о необходимости ввода PIN-кода

    @correct
    Сценарий: Успешная аутентификация
    Если пользователь вводит корректный PIN-код
    То банкомат отображает меню и количество доступных денег на счету
```

Выведет в консоль следующее

```text
аутентификация-банковской-карты;успешная-аутентификация
Успешная аутентификация
passed
false
[@correct, @all]
```

5. Необходимо помнить про нюансы работы с **Хуками (Hooks)**

* тестовый фреймворк может также добавить выполнение кода до и после выполнения каждого метода
* сценарии в **Cucumber** выполняются независимо друг от друга
* шаги описанные в **Предыстории (Background)** выполняются перед каждым сценарием

## 7.4. Теги (Tags)

***Теги (Tags)*** - метки для классификации и организации запуска сценариев.

**Теги (Tags)** представляют собой строки начинающиеся с символа **@** и располагающиеся перед строками с ключевыми словами.

**Тегами (Tags)** в файле **.feature** можно пометить:

* фичи (**Функции (Feature)**)
* сценарии (**Сценарии (Scenario)** и **Структуры сценариев (Scenario Outline)**)
* примеры (**Примеры (Examples)**)

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

Применение:

1. *Использование тегов для документации*

Тегами можно указать к какому проекту относятся разрабатываемые фичи.

```gherkin
@mega-project @super-duber-system
```

2. *Ссылка на другие документы*

Теги могут ссылаться на идентификаторы артефактов во внешних системах: 

* задачи  (**Issue Tracking System (ITS)**) - **Jira**, **TFS**, **Trello**
* баги (**Bug Tracking System (BTS)**) - **Jira**, **TFS**, **Bugzilla**, **YouTrack**
* требования (**Requirement Management System (RMS)**) - **Jira + Confluence**, **TFS**
* тест кейсы (**Test Management System (TMS)**) - **Jira + Zephyr**, **Test IT**, **TestRail**

*Пример*

```gherkin
@issue-232
```

Можно использовать настраиваемый плагин отчетов **Cucumber**, 
который превратит теги в ссылки, указывающие на документы в вашем внешнем инструменте.

3. *Рабочий процесс*

Теги можно использовать, чтобы отметить, на каком этапе находится фича.

*Пример*

```gherkin
@backlog @dev-in-progress @qa-ready @done
```

4. **Тестовые среды**

Теги могут указывать на какой тестовой среде нужно прогонять сценарии.

*Пример*

Можно задать теги, чтобы поделить тестовые сценарии на те, 
что будут запускаться на деве, и на те, что будут запускаться на инте.

```gherkin
@dev @int
```

5. **Виды тестов**

С помощью тегов можно задать классификацию и группировку сценариев,
а также организацию запуска сценариев, независимо от их расположения в файлах и папках проекта.

*Пример*

Можно задать теги, чтобы поделить тестовые сценарии на регрессионные и смоук.

```gherkin
@smoke @regression
```

В конфигах указывать теги, чтобы при запуске выполнить только определенные сценарии.

```java
tags = {"~@smoke"}
tags = {"@regression"}
```

Особенности:

1. Можно использовать множество тегов, разделяя их пробелом

*Пример*

```gherkin
@important @maintenance @db @auth
```

2. Теги наследуется

Любой тег из **Функции (Feature)** будет наследоваться в **Сценарии (Scenario)**,
**Структуры сценариев (Scenario Outline)** или **Примеры (Examples)**.

## 7.5. Раннер (Runner)

***Раннер (Runner)*** - класс для запуска сценариев.

**Раннер (Runner)** представляет собой специальный класс **Java** с аннотацией **@RunWith(Cucumber.class)**.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
        plugin = {"pretty", "html:target/htmlreport", "json:report.json", "junit:report.xml"},
        monochrome = true, 
//      name = "^Успешное|Успешная.*"
)
public class RunnerTest {
    
}

```

В классе-раннере через аннотацию **@CucumberOptions** задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(tags = {"@foo", "not @bar"})
public class RunCucumberTest {
}
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(tags = {"@foo", "not @bar"})
public class RunCucumberTest {
}
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(dryRun=true)
public class RunCucumberTest {
}
```

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(strict=false)
public class RunCucumberTest {
}
```

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — параметры форматирования для отчетов

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(plugin = {"pretty", "html:target/cucumber"})
public class RunCucumberTest {
}
```

* *monochrome* — вывод в консоль

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(monochrome=true)
public class RunCucumberTest {
}
```

## 7.6. Прочие файлы

PageObjects, ConfigFiles e t c

***

# 8. Схема работы

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

При запуске теста **Cucumber** выполняет следующее:

1. Проходит по cценарию шаг за шагом
2. Взяв шаг, он отделяет ключевое слово от описания шага
3. Пытается найти в **Java** классах пакета указанного в опции glue аннотацию с регулярным выражением,
   подходящим описанию в шаге

Возможные результаты:

* **Шаг пройденный успешно (Success)** помечается *зеленым цветом*

Найдя совпадение, фреймворк вызывает метод с найденной аннотацией.
Если код в методе не вызывает ошибку, шаг считается пройденным успешно.
Все, что возвращается из определения шага, не имеет никакого значения.

* **Шаг пройденный неуспешно (Failed)** помечается *красным цветом*

Найдя совпадение, фреймворк вызывает метод с найденной аннотацией.
Если код в методе вызывает ошибку, шаг считается пройденным неуспешно.
Все, что возвращается из определения шага, не имеет никакого значения.
Возврат **null** или **false** не будет считаться неуспешно пройденным шагом.

* **Шаг неопределенный (Undefined)** помечается *желтым цветом*

Когда **Cucumber** не может найти подходящее определение шага,
шаг помечается как неопределенный, и все последующие шаги в сценарии пропускаются.
Если используется **--strict**, это приведет к выходу **Cucumber** с 1.

* **Шаг ожидающий реализацию (Pending)** помечается *желтым цветом*

Когда **Cucumber** находит определение шага, который вызывает исключение**PendingException**,
шаг помечается как ожидающий реализацию на **Java**.
Если используется **--strict**, это приведет к выходу **Cucumber** с 1.

* **Шаг пропущенный (Skipped)** помечается *голубым цветом*

Шаги, следующие за неопределенными, ожидающими реализацию или неудачными,
никогда не выполняются, даже если есть соответствующее определение шага.

* **Шаг двусмысленный (Ambiguous)**

Определения шагов должны быть уникальными, чтобы **Cucumber** знал, что выполнять.
Если используются неоднозначные определения шагов, **Cucumber** вызывает исключение
**AmbiguousStepDefinitionsException**, предлагая исправить неоднозначность.

4. Если все шаги сценария прошли успешно, то сценарий считается пройденным успешно
5. Если все сценарии выполнились успешно, то функция считается проверенной успешно

Схема:

| **Шаги на Gherkin**  | *мапятся на*   | **Реализация шагов** | *управляет*   | **Система** | 
|----------------------|----------------|----------------------|---------------|-------------|
| **Steps in Gherkin** | *matched with* | **Step Definitions** | *manipulates* | **System**  |

***

# 9. Запуск (Run)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Запустить тестовые сценарии **Cucumber** можно разными способами:

* с помощью **IntelliJ IDEA**
* с помощью **JUnit** раннера
* c помощью **Maven**
* с помощью **Cucumber CLI**

При запуске считываются параметры (по приоритету) из:

* переменных среды
* **-D** параметров
* **@CucumberOptions**
* **junit-platform.properties**

## 9.1. Запуск с помощью встроенных возможностей IDE Jetbrains

IDE от Jetbrains имеют поддержку **Cucumber**.

[Cucumber](https://www.jetbrains.com/help/idea/cucumber-support.html)

Для этого необходимо установить соответствующие плагины: **Gherkin** и **Cucumber for Java**.

[Enable Cucumber support](https://www.jetbrains.com/help/idea/enabling-cucumber-support-in-project.html)

Также есть подробное описание способов запуска сценариев:

[Run Cucumber tests](https://www.jetbrains.com/help/idea/running-cucumber-tests.html)

### 9.1.1. Простой запуск

Можно запустить сценарии прямо из **.feature** файла.

* Для того чтобы запустить *один сценарий в фиче* нужно:

1. Нажать на иконку запуска рядом с выбранным сценарием

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/08.png "Run Cucumber tests")

2. Нажать **Run \[Название сценария\]**

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/09.png "Run Cucumber tests")

* Для того чтобы запустить *все сценарии в фиче* нужно:

1. Нажать на иконку запуска рядом с выбранной фичей

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/10.png "Run Cucumber tests")

2. Нажать **Run \[Название фичи\]**

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/11.png "Run Cucumber tests")

* Для того чтобы запустить *все фичи со всеми сценариями в папке* нужно:

1. Нажать правой кнопкой по папке с фичами* нужно:

2. Нажать **Run** - **All Features in: [Название папки\]**

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/12.png "Run Cucumber tests")

### 9.1.2. Запуск с помощью новой конфигурации

Можно запустить сценарии с помощью своей конфигурации запуска тестов.

[Run/Debug Configuration: Cucumber Java](https://www.jetbrains.com/help/idea/run-debug-configuration-cucumber-java.html)

Для этого нужно:

1. Нажать **Run** - **Edit Configurations**

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/14.png "Run Cucumber tests")

2. Нажать на **+** и выбрать **Cucumber Java**

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/15.png "Run Cucumber tests")

3. Заполнить поля

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/16.png "Run Cucumber tests")

Примерно так:

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/17.png "Run Cucumber tests")

4. Нажать **Apply** -> **OK**

5. Запустить сценарии выбрав свою конфигурацию запуска

## 9.2. Запуск с помощью JUnit раннера 

Можно запустить сценарии с помощью **JUnit** раннера.

Для этого нужно:

1. Добавить класс раннер 

Для **JUnit4** с аннотациями:

* в **@RunWith** - класс для запуска тестов (**Cucumber.class**)
* в **@CucumberOptions** - опции для запуска сценариев с **Cucumber**

*Пример*

```java
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

// @RunWith
// Класс для запуска тестов
@RunWith(Cucumber.class)
// @CucumberOptions
// Опции для запуска сценариев
@CucumberOptions(
    // Список папок с feature файлами - фичи/сценарии
    features = {"src/test/resources/features"},
    // Спиcок пакетов с steps файлами - шаги
    glue = {"steps", "hooks"}
)
public class RunCucumberTest {
}
```

Для **JUnit5** с аннотациями:

* в **@Suite** - набор тестов в **JUnit5**
* в **@IncludeEngines** - тестовый движок
* в **@SelectClasspathResource** - папка с **BDD** сценариями на **Gherkin**
* в **@ConfigurationParameter** - опции для запуска сценариев

*Пример*

```java
import org.junit.platform.suite.api.ConfigurationParameter;
import org.junit.platform.suite.api.IncludeEngines;
import org.junit.platform.suite.api.SelectClasspathResource;
import org.junit.platform.suite.api.Suite;

import static io.cucumber.core.options.Constants.*;

// @Suite
// Набор тестов
@Suite
// @IncludeEngines
// Тестовый движок
@IncludeEngines("cucumber")
// @SelectClasspathResource
// Папка с BDD сценариями на Gherkin
@SelectClasspathResource("features")
// @ConfigurationParameter
// Опции для запуска сценариев
@ConfigurationParameter(key = GLUE_PROPERTY_NAME, value = "steps, hooks")
@ConfigurationParameter(key = PLUGIN_PUBLISH_QUIET_PROPERTY_NAME, value = "true")
public class RunCucumberTest {
}
```

2. Запустить сценарии нажатием на кнопку рядом с названием класса раннера - **Run \[Название раннера\]**

![Run Cucumber tests](_Files/1.%20TDD,%20BDD,%20ETC/13.png "Run Cucumber tests")

## 9.3. Запуск с помощью Maven в JUnit 5

Можно запустить сценарии с помощью команды **Maven**.

Для этого нужно:

1. Добавить в проект зависимость **junit-vintage-engine**:

```xml
<dependency>
    <groupId>org.junit.vintage</groupId>
    <artifactId>junit-vintage-engine</artifactId>
    <version>5.8.0</version>
    <scope>test</scope>
</dependency>
```

**Cucumber** основан на **JUnit 4**. Для запуска через **Maven** 
сценариев **Cucumber** с **JUnit5** нужно подключить модуль **JUnit Vintage**.

В отличие от предыдущих версий **JUnit**, **JUnit 5** состоит из нескольких разных модулей.
Модуль **JUnit Vintage** предоставляет возможности для запуска тестов на основе **JUnit 3** и **JUnit 4**.

2. Добавить **JUnit** раннер (см выше)

3. Запустить сценарии командой **Maven**

* запуск всех сценариев

```shell
mvn clean test -Dtest=RunCucumberTest
mvn clean test
```

* запуск файла с фичами

```shell
mvn clean test -Dcucumber.features=src/test/resources/features/Smartphone.feature
```

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)