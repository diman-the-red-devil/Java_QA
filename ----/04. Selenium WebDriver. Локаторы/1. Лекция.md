Java_QA / 04. Selenium WebDriver. Локаторы

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Локаторы, XML, HTML, DOM](#1-локаторы-xml-html-dom)
  * [1.1. Что такое XML?](#11-что-такое-xml)
  * [1.2. Что такое HTML?](#12-что-такое-html)
  * [1.3. Что такое DOM?](#13-что-такое-dom)
  * [1.4. Что такое веб элементы?](#14-что-такое-веб-элементы)
  * [1.5. Что такое локаторы?](#15-что-такое-локаторы)
* [2. Поиск веб элементов](#2-поиск-веб-элементов)
  * [2.1. Интерфейс WebDriver](#21-интерфейс-webdriver)
    * [2.1.1. Поиск одного веб элемента](#211-поиск-одного-веб-элемента)
    * [2.1.2. Поиск набора веб элементов](#212-поиск-набора-веб-элементов)
    * [2.1.3. Поиск одного веб элемента в веб элементе](#213-поиск-одного-веб-элемента-в-веб-элементе)
    * [2.1.4. Поиск набора веб элементов в веб элементе](#214-поиск-набора-веб-элементов-в-веб-элементе)
    * [2.1.5. Цепочка из findElement](#215-цепочка-из-findelement)
  * [2.2. Исключения](#22-исключения)
    * [2.2.1. NoSuchElementException](#221-nosuchelementexception)
* [3. Простые локаторы](#3-простые-локаторы)
  * [3.1. Класс By](#31-класс-by)
    * [3.1.1. Поиск элемента по атрибуту id (By.id)](#311-поиск-элемента-по-атрибуту-id-byid)
    * [3.1.2. Поиск элемента по атрибуту name (By.name)](#312-поиск-элемента-по-атрибуту-name-byname)
    * [3.1.3. Поиск элемента по атрибуту class (By.className)](#313-поиск-элемента-по-атрибуту-class-byclassname)
    * [3.1.4. Поиск элемента по имени тега (By.tagName)](#314-поиск-элемента-по-имени-тега-bytagname)
    * [3.1.5. Поиск элемента по тексту ссылки (By.linkText)](#315-поиск-элемента-по-тексту-ссылки-bylinktext)
    * [3.1.6. Поиск элемента по частичному тексту ссылки (By.partialLinkText)](#316-поиск-элемента-по-частичному-тексту-ссылки-bypartiallinktext)
    * [3.1.7. Поиск элемента с помощью CSS селектора (By.cssSelector)](#317-поиск-элемента-с-помощью-css-селектора-bycssselector)
    * [3.1.8. Поиск элемента с помощью XPATH запроса (By.xPath)](#318-поиск-элемента-с-помощью-xpath-запроса-byxpath)
  * [3.2. Исключения](#32-исключения)
    * [3.2.1. InvalidSelectorException](#321-invalidselectorexception)
      * [3.2.1.1. Причины](#3211-причины)
      * [3.2.1.2. Решения](#3212-решения)
    * [3.2.2. NoSuchElementException](#322-nosuchelementexception)
      * [3.2.2.1. Причины](#3211-причины)
      * [3.2.2.2. Решения](#3212-решения)
    * [3.2.3. UnexpectedTagNameException](#323-unexpectedtagnameexception)
      * [3.2.3.1. Причины](#3231-причины)
      * [3.2.3.2. Решения](#3232-решения)
* [4. Относительные локаторы](#4-относительные-локаторы)
  * [4.1. Класс RelativeLocator](#41-класс-relativelocator)
  * [4.2. Класс RelativeLocator.RelativeBy](#42-класс-relativelocatorrelativeby)
    * [4.2.1. Поиск элемента выше заданного элемента](#421-поиск-элемента-выше-заданного-элемента)
    * [4.2.2. Поиск элемента ниже заданного элемента](#422-поиск-элемента-ниже-заданного-элемента)
    * [4.2.3. Поиск элемента слева от заданного элемента](#423-поиск-элемента-слева-от-заданного-элемента)
    * [4.2.4. Поиск элемента справа от заданного элемента](#424-поиск-элемента-справа-от-заданного-элемента)
    * [4.2.5. Поиск элемента рядом с заданным элементом](#425-поиск-элемента-рядом-с-заданным-элементом)
  * [4.3. Исключения](#43-исключения)
* [5. Правила написания локаторов](#5-правила-написания-локаторов)
  * [5.1. Как писать хорошие локаторы?](#51-как-писать-хорошие-локаторы)
    * [5.1.1. Какой локатор будем считать оптимальным?](#511-какой-локатор-будем-считать-оптимальным)
    * [5.1.2. Какой приоритет при использовании локаторов?](#512-какой-приоритет-при-использовании-локаторов)
    * [5.1.3. Как правильно писать CSS селекторы и XPath запросы?](#513-как-правильно-писать-css-селекторы-и-xpath-запросы)
  * [5.2. Что делать, если тесты нестабильны?](#52-что-делать-если-тесты-нестабильны)
    * [5.2.1. Ожидание существования элемента перед взаимодействием с ним](#521-ожидание-существования-элемента-перед-взаимодействием-с-ним)
    * [5.2.2. Получение свежих элементов](#522-получение-свежих-элементов)

***

# 1. Локаторы, XML, HTML, DOM

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 1.1. Что такое XML?

***XML (eXtensible Markup Language)*** — расширяемый язык разметки.

Спецификация **XML** описывает **XML**-документы и частично описывает поведение **XML**-процессоров 
(программ, читающих **XML**-документы и обеспечивающих доступ к их содержимому).
**XML** разрабатывался как язык с простым формальным синтаксисом, удобный для создания и 
обработки документов как программами так и человеком, с акцентом на использование в Интернете.
Язык называется расширяемым, поскольку он не фиксирует разметку, используемую в документах: 
разработчик волен создать разметку в соответствии с потребностями к конкретной области,
будучи ограниченным лишь синтаксическими правилами языка.

***Расширение XML*** — конкретная грамматика, созданная на базе **XML** и представленная словарём тегов и их атрибутов, 
а также набором правил, определяющих, какие атрибуты и элементы могут входить в состав других элементов.

Сочетание простого формального синтаксиса, удобства для человека, расширяемости, а также базирование на кодировках
Юникод для представления содержания документов привело к широкому использованию как собственно **XML**,
так и множества производных специализированных языков на базе **XML** в самых разнообразных программных средствах.

**XML** рекомендован Консорциумом Всемирной паутины (**W3C**).
**XML** является подмножеством **SGML**.

## 1.2. Что такое HTML?

***HTML (HyperText Markup Language)*** — стандартизированный язык разметки веб-страниц во Всемирной паутине.

Код **HTML** интерпретируется браузерами; полученная в результате интерпретации страница отображается
на экране монитора компьютера или мобильного устройства.

Язык **HTML** до 5-й версии определялся как приложение **SGML** 
(стандартного обобщённого языка разметки по стандарту **ISO 8879**).
Спецификации **HTML5** формулируются в терминах **DOM** (объектной модели документа).
Строгим вариантом **HTML** является **XHTML**, он наследует синтаксис **XML** и является приложением языка **XML** 
в области разметки гипертекста.

**HTML**, как и **XML** имеет древовидную структуру.
В документе всегда имеется один корневой элемент, содержащий ряд вложенных элементов,
некоторые из которых тоже могут содержать вложенные элементы.
Так же могут встречаться текстовые узлы, комментарии и инструкции.
Можно считать, что **XML**-элемент содержит массив вложенных в него элементов и массив атрибутов.

У элементов дерева бывают **элементы-предки** и **элементы-потомки**.
У корневого элемента предков нет, а у тупиковых элементов (листьев дерева) нет потомков.
Каждый элемент дерева находится на определённом уровне вложенности (далее — **уровень**).
Элементы упорядочены в порядке расположения в тексте, и поэтому можно говорить об их предыдущих и следующих элементах.
Это очень похоже на организацию каталогов в файловой системе.

## 1.3. Что такое DOM?

***DOM (Document Object Model)*** - объектная модель документа, независящий от платформы и языка программный интерфейс,
позволяющий программам и скриптам получить доступ к содержимому **HTML**-, **XHTML**- и **XML**-документов,
а также изменять содержимое, структуру и оформление таких документов.

Согласно **DOM**-модели, документ является иерархией, состоящей из равноправных узлов дерева **DOM**.
Основные типы узлов:

* теги - **узлы-элементы (element node)**
* текст - **текстовые узлы (text node)**

Корневым элементом иерархии является **html**. У него есть два потомка.
Первый - **head**, второй - **body**. И так далее, каждый вложенный тег является потомком тега выше.

Модель **DOM** не накладывает ограничений на структуру документа. 
Любой документ известной структуры с помощью **DOM** может быть представлен в виде дерева узлов,
каждый узел которого представляет собой элемент, атрибут, текстовый, графический или любой другой объект. 
Узлы связаны между собой отношениями **Родитель - Потомок**.

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/01.jpg "Document Object Model (DOM)")

Проще говоря, **DOM** - это представление документа в виде дерева тегов.
Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, 
каждый из которых образует отдельный узел.

Основные характеристики **DOM**:

* основана на валидном **HTML**-коде
* может быть модифицирована из **JavaScript**
* не включает псевдоэлементы, созданные из **CSS**
* включает скрытые элементы (**display: none**)

Возможности **DOM**:

* поиск узлов (элементов)
* доступ к узлам вверх и вниз по иерархии (родителям и потомкам)
* получение и изменение содержимого узлов (текст, имя тега и т д)

*Пример*

Для следующего фрагмента **HTML**

```html
<html>
  <head>
    <title>Заголовок</title>
  </head>
  <body>
     Прекрасный документ
   </body>
</html>
```

будет построено следующее дерево

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/02.jpg "Document Object Model (DOM)")

>Изначально различные браузеры имели собственные модели документов (DOM), несовместимые с остальными.
Для обеспечения взаимной и обратной совместимости специалисты международного консорциума W3C классифицировали эту модель по уровням,
для каждого из которых была создана своя спецификация. Все эти спецификации объединены в общую группу, носящую название **W3C DOM**.

## 1.4. Что такое веб элементы?

***Веб элементы*** – **DOM** объекты, находящиеся на веб странице, то, что пользователь видит 
(а иногда и не видит) на странице – заголовки, кнопка **ОК**, поля ввода, текстовые блоки и т д.

Языки программирования обычно получают доступ к веб-элементам как к нодам в **объектной модели документа (DOM)**.

**Selenium WebDriver** также работает с **объектной моделью документа (DOM)**.

## 1.5. Что такое локаторы?

Поскольку **Selenium WebDriver** - инструмент для автоматизации веб приложений, 
то большая часть работы с ним - это работа с элементами.
А для того, чтобы осуществлять какие-то действия над элементами (**DOM** объектами) 
необходимо их точным образом определить (найти).
Для поиска элементов в **Selenium WebDriver** используются локаторы.

***Локатор*** – объект, который находит и возвращает веб элементы на странице по заданному запросу.

Как пользователи, люди взаимодействуют с веб-страницами визуально - 
смотрят, скроллят, кликают и печатают посредством браузера.
Тест-автоматизация, однако, взаимодействует со страницами программно - 
нужен закодированный способ поиска и манипулирования теми же самыми элементами.
Традиционная автоматизация не будет **смотреть** на страницу, как человек – 
вместо этого она будет искать через **DOM**.

То есть если обычно пользователь видит кнопку **Login** и знает, что надо нажать именно на нее,
то в случае с автоматизацией браузеру надо дать команду **нажать**, а еще обозначить,
что именно жать. Собственно, чтобы взаимодействие браузера происходило с нужным вам элементом,
а не соседним или вообще скрытым, и нужно умение писать уникальные локаторы.

***

# 2. Поиск веб элементов

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 2.1. Интерфейс WebDriver

***WebDriver*** - интерфейс для управления браузером.

Методы интерфейса **WebDriver** для поиска вэб-элементов на странице:

| Тип              | Метод               | Описание                                                     | 
|------------------|---------------------|--------------------------------------------------------------|
| WebElement       | findElement(By by)  | Поиск элемента (возвращает первый найденный элемент)         |
| List<WebElement> | findElements(By by) | Поиск всех элементов (возвращает список найденных элементов) |

[selenium/docs/api : WebDriver](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.html)

### 2.1.1. Поиск одного веб элемента

Для поиска одного веб элемента используется команда **findElement**.

*Пример*

```java
WebElement element = driver.findElement(By.tagName("p"));
System.out.println("Paragraph text:" + element.getText());
```

### 2.1.2. Поиск набора веб элементов

Для поиска набора веб элементов используется команда **findElements**.

*Пример*

```java
List<WebElement> elements = driver.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println("Paragraph text:" + element.getText());
}
```

### 2.1.3. Поиск одного веб элемента в веб элементе

В найденном веб элементе можно найти другой веб элемент.

*Пример*

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
WebElement element = rootElement.findElement(By.tagName("p"));
System.out.println(element.getText());
```

### 2.1.4. Поиск набора веб элементов в веб элементе

В найденном веб элементе можно найти другие веб элементы.

*Пример*

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
List<WebElement> elements = rootElement.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println(element.getText());
}
```

### 2.1.5. Цепочка из findElement

*Пример*

```java
WebElement element1 = driver
        .findElement(By.id("div1")
        .findElement(By.name("same");
WebElement element2 = driver
        .findElement(By.id("div2")
        .findElement(By.name("same");
```

## 2.2. Исключения

Если элемент не найден то:

* **findElement** вызовет исключение **NoSuchElementException**
* **findElements** вернет пустой ответ []

### 2.2.1. NoSuchElementException

***NoSuchElementException*** — исключение, которое вызывается методом **findElement**, 
если элемент с заданным селектором не найден на странице.

[selenium/docs/api : NoSuchElementException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/NoSuchElementException.html)

Исключение **NoSuchElementException** возникает в одном из следующих случаев

* открыта не та страница

В ходе выполнения автотеста может выполниться переход на другую страницу, а элемент находится на предыдующей странице.
В этом случае нужно проверить, что элемент есть на странице (**DevTools** в помощь).

* задан неправильный локатор

Скорее всего в локаторе есть ошибка или локатор в принципе не находит нужный элемент.
В этом случае нужно проверить, что локатор находит элемент на странице (**DevTools** в помощь).

* элемент находится внутри фрейма

Если элемент находится внутри, то драйвер его не найдет, так как фрейм считается отдельным объектом со своим **DOM**.
В этом случае нужно убедиться, что элемент не внутри фрейма (**DevTools** в помощь), 
а если все таки внутри фрейма, то вначале нужно переключиться на фрейм.

* элемент появляется не сразу

В этом случае нужно добавить ожидание элемента.

***

# 3. Простые локаторы

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 3.1. Класс By

**By** - класс реализующий методы поиска элементов с помощью простых локаторов.

Методы класса **By** (локаторы):

| Тип | Метод                                      | Описание                                   | 
|-----|--------------------------------------------|--------------------------------------------|
| By  | By.id(String id)                           | Поиск элемента по атрибуту id              |
| By  | By.name(String name)                       | Поиск элемента по атрибуту name            |
| By  | By.className(String className)             | Поиск элемента по атрибуту class           |
| By  | By.tagName(String tagName)                 | Поиск элемента по тегу                     |
| By  | By.linkText(String linkText)               | Поиск элемента по тексту ссылки            |   
| By  | By.partialLinkText(String partialLinkText) | Поиск элемента по частичному тексту ссылки |
| By  | By.cssSelector(String cssSelector)         | Поиск элемента по CSS селектору            |
| By  | By.xPath(String xpath)                     | Поиск элемента по XPATH запросу            |

[selenium/docs/api : By](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/By.html)

При этом **ID**, **Name**, **Tag name** и **Class name**— частные случаи CSS-селекторов. 
Таким образом, основные виды локаторов, с которыми придется сталкиваться — CSS-селекторы и XPath-запросы.
Далее рассмотрим каждый из них подробнее.

### 3.1.1. Поиск элемента по атрибуту id (By.id)

Для поиска элемента по атрибуту **id** используется локатор **By.id**.

*Пример*

```HTML
<div id="menu_go">
    <a href="http://go.go" id="link_go">Go!</a>
    <input type="button" id="button_go">Go!</input>
</div>
```

```java
WebElement menuGo = driver.findElement(By.id("menu_go"));
WebElement linkGo = driver.findElement(By.id("link_go"));
WebElement buttonGo = driver.findElement(By.id("button_go"));
```

### 3.1.2. Поиск элемента по атрибуту name (By.name)

Для поиска элемента по атрибуту **name** используется локатор **By.name**.

*Пример*

```HTML
<input type="submit" name="button_submit">Submit</input>
<input type="submit" name="button_cancel">Cancel</input>
```

```java
WebElement buttonSubmit = driver.findElement(By.name("button_submit");
WebElement buttonCancel = driver.findElement(By.name("button_cancel");
```

### 3.1.3. Поиск элемента по атрибуту class (By.className)

Для поиска элемента по атрибуту **class** используется локатор **By.className**.

*Пример*

```HTML
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-default btn-primary">Submit</input>
```

```java
WebElement element1 = driver.findElement(By.className("btn");
WebElement element2 = driver.findElement(By.className("btn-primary");
WebElement element3 = driver.findElement(By.className("btn btn-default");
WebElement element4 = driver.findElement(By.className("btn btn-primary");
WebElement element5 = driver.findElement(By.className("btn btn-default btn-primary");
```

Метод **className** удобен для тестирования библиотек JavaScript / CSS, 
которые обычно используют набор определенных имен классов.

*Пример*

```java
WebElement element1 = driver.findElement(By.className("editable-textarea");
WebElement element2 = driver.findElement(By.className("editable-submit");
```

### 3.1.4. Поиск элемента по имени тега (By.tagName)

Для поиска элемента по имени тега используется локатор **By.tagName**.

*Пример*

```HTML
<body>
<p>Paragraph<p>
</body>
```

```java
WebElement body = driver.findElement(By.tag_name("body"));
WebElement paragraph = body.findElement(By.tag_name("p"));
```

### 3.1.5. Поиск элемента по тексту ссылки (By.linkText)

Для поиска элемента по тексту ссылки используется локатор **By.linkText**.

*Пример*

```HTML
<a href="/submit">Submit</a>
<a href="/cancel">Cancel</a>
```

```java
WebElement link1 = driver.findElement(By.link_text("Submit"));
WebElement link2 = driver.findElement(By.link_text("Cancel"));
```

### 3.1.6. Поиск элемента по частичному тексту ссылки (By.partialLinkText)

Для поиска элемента по частичному тексту ссылки используется локатор **By.partialLinkText**.

*Пример*

```HTML
<a href="/submit">Submit Me</a>
<a href="/cancel">Cancel Me</a>
```

```java
WebElement link1 = driver.findElement(By.partial_link_text("ubmi"));
WebElement link1 = driver.findElement(By.partial_link_text("ance"));
``` 

### 3.1.7. Поиск элемента с помощью CSS селектора (By.cssSelector)

Для поиска элемента с помощью CSS селектора используется локатор **By.cssSelector**.

***CSS селектор*** — формальное описание относительного пути до элемента/элементов HTML.

Классически, селекторы используются для задания правил стиля.
В случае с **WebDriver**, существование самих правил не обязательно, 
веб-драйвер использует синтаксис CSS только для поиска.
Поиск вернет первый элемент удовлетворяющий CSS-селектору.

*Пример*

```HTML
<input type="text" id="fistname" name="first_name" class="myForm">
```

```java
WebElement firstName = driver.findElement(By.cssSelector("input[name='first_name']"));
```

Подробнее про [CSS Селекторы](_CSS%20Selectors.md)

### 3.1.8. Поиск элемента с помощью XPATH запроса (By.xPath)

Для поиска элемента с помощью XPATH запроса используется локатор **By.xPath**.

***XPath (XML Path Language)*** - язык запросов для выбора узлов из XML документа.

Когда браузер отображает веб-страницу, он анализирует его в дереве **DOM**.
**XPath** может использоваться для ссылки на определенный узел в дереве **DOM**.
**XPath** — самый мощный и гибкий способ найти определенный веб-элемент.

*Пример*

```HTML
<input class="search-form-input" type="search" itemprop="query-input" name="s" id="search for-2" placeholder="Search this website">
```

```java
WebElement firstName = driver.findElement(By.xpath("//input[@id=searchform-2]"));
WebElement firstName = driver.findElement(By.xpath("//input[@name=’s’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@type=’search’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@class=’search-form-input’]"));
```

Подробнее про [XPATH запросы](_XPATH%20Queries.md)

## 3.2. Исключения

### 3.2.1. InvalidSelectorException

***InvalidSelectorException*** — исключение, которое вызывается, когда заданный селектор поиска не возвращает **WebElement**.

[selenium/docs/api : InvalidSelectorException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/InvalidSelectorException.html)

#### 3.2.1.1. Причины

* В **Xpath** выражении есть синтаксические ошибки

*Пример*

В примере ниже в **Xpath** выражении опечатка.

Должно быть:

```xpath
(//*[@class="ui-link menu-desktop__root-title"])[5]
```

А записано:

```xpath
(//*[@class="ui-link menu-desktop__root-title"])(5]
```

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    WebElement element = driver.findElement(
            By.xpath("(//*[@class=\"ui-link menu-desktop__root-title\"])(5]"));
    element.click();
}
```

В результате вызывается исключение **InvalidSelectorException**.

```text
org.openqa.selenium.InvalidSelectorException: invalid selector: 
Unable to locate an element with the xpath expression 
(//*[@class="ui-link menu-desktop__root-title"])(5] 
because of the following error:
SyntaxError: Failed to execute 'evaluate' on 'Document': The string 
'(//*[@class="ui-link menu-desktop__root-title"])(5]' 
is not a valid XPath expression.
```

* **Xpath** выражение не указывает на **WebElement**

*Пример*

В примере ниже в **Xpath** выражении записано выражение:

```xpath
count(.//span)
```

Данное **Xpath** выражение не возвращает веб элемент.

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    WebElement element = driver.findElement(By.xpath("count(.//span)"));
    element.click();
}
```

В результате вызывается исключение **InvalidSelectorException**.

```text
org.openqa.selenium.InvalidSelectorException: invalid selector: 
Unable to locate an element with the xpath expression 
count(.//span) 
because of the following error:
TypeError: Failed to execute 'evaluate' on 'Document': 
The result is not a node set, and therefore cannot be converted to the desired type.
```

* Использование составного имени класса в **By.className**

*Пример*

В примере ниже в **By.className** записано два класса:

```css
ui-link menu-desktop__root-title
```

В **By.className** не допускается использование составного имени класса.

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    WebElement element = driver.findElement(
        By.className("ui-link menu-desktop__root-title"));
    element.click();
}
```

В результате вызывается исключение **InvalidSelectorException**.

```text
org.openqa.selenium.InvalidSelectorException: Compound class names not permitted
```

* Использование некорректного **CSS** селектора в **By.cssSelector**

*Пример*

В примере ниже в **By.cssSelector** записано:

```css
a <|> ul
```

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    WebElement element = driver.findElement(
        By.cssSelector("a <|> ul"));
    element.click();
}
```

В результате вызывается исключение **InvalidSelectorException**.

```text
org.openqa.selenium.InvalidSelectorException: invalid selector: An invalid or illegal selector was specified
```

#### 3.2.1.2. Решения

* Проверка используемого **Xpath** выражения в браузере

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    // Сперва Xpath выражение необходимо проверить в браузере
    WebElement element = driver.findElement(
            By.xpath("(//*[@class=\"ui-link menu-desktop__root-title\"])[5]"));
    element.click();
}
```

* Проверка параметра в **By.className**

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    // Можно указать только один класс
    WebElement element = driver.findElement(
            By.className("ui-link"));
    element.click();
}
```

* Проверка используемого **CSS** селектора браузере

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    // Сперва CSS селектор необходимо проверить в браузере
    WebElement element = driver.findElement(
            By.cssSelector("a.ui-link"));
    element.click();
}
```

Ниже пример перехвата исключения.

*Пример*

```java
    @Test
public void test() {
    try {
        driver.manage().window().maximize();
        driver.get("https://www.dns-shop.ru/");
        WebElement element = driver.findElement(
            By.xpath("(//*[@class=\"ui-link menu-desktop__root-title\"])(5]"));
        element.click();
    } catch (InvalidSelectorException e) {
        logger.info("InvalidSelectorException: " + e.getRawMessage());
    }
}
```

### 3.2.2. NoSuchElementException

***NoSuchElementException*** — исключение, которое вызывается, когда **Selenium WebDriver** не может найти элементы.

[selenium/docs/api : NoSuchElementException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/NoSuchElementException.html)

#### 3.2.2.1. Причины

* Некорректный локатор веб элемента в методе **findElement**

*Пример*

В примере ниже в **Xpath** выражении ошибка.

Должно быть:

```xpath
(//*[@class="ui-link menu-desktop__root-title"])[5]
```

А записано:

```xpath
(//*[@class="ui-link menu-desktop__root"])
```

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    String xpath = "(//*[@class=\"ui-link menu-desktop__root\"])";
    WebElement element = driver.findElement(By.xpath(xpath));
    element.click();
}
```

В результате вызывается исключение **NoSuchElementException**.

```text
org.openqa.selenium.NoSuchElementException: no such element: 
Unable to locate element: {"method":"xpath","selector":"(//*[@class="ui-link menu-desktop__root"])"}
```

* Веб страница полностью не загрузилась

*Пример*

В примере ниже установлен таймаут загрузки страницы в 8 секунд.
За это время веб элемент не успевает отобразиться на странице.

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(8));
    driver.get("https://www.dns-shop.ru/");
    String xpath = "(//*[@class=\"ui-link menu-desktop__root-title\"])[5]";
    WebElement element = driver.findElement(By.xpath(xpath));
    element.click();
}
```

В результате вызывается исключение **NoSuchElementException**.

```text
org.openqa.selenium.NoSuchElementException: no such element: 
Unable to locate element: {"method":"xpath","selector":"(//*[@class="ui-link menu-desktop__root-title"])[5]"}
```

* Веб элемент не видим на странице

*Пример*

В примере ниже выполняется попытка перейти по ссылке "Смартфоны".
Но ссылка находится в блоке, который отображается только при наведении курсора мыши на ссылку "Смартфоны и гаджеты".

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    driver.findElement(By.xpath("//span[text()=\"Всё верно\"]/parent::button")).click();
    Actions actions = new Actions(driver);
    actions.moveToElement(
        driver.findElement(
            By.xpath("(//a[contains(text(), \"Смартфоны и гаджеты\")])[1]")))
        .perform();
    driver.findElement(By.xpath("//a[text()=\"Смартфоны\"]")).click();
}
```

В результате вызывается исключение **NoSuchElementException**

```text
org.openqa.selenium.NoSuchElementException: no such element: Unable to locate element: {"method":"xpath","selector":"//a[text()="Смартфоны"]"}
```

* Веб элемент отсутствует в **DOM** на момент вызова

#### 3.2.2.2. Решения

* Проверка корректности и уникальности локаторов веб элементов

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    // Сперва Xpath выражение необходимо проверить в браузере
    String xpath = "(//*[@class=\"ui-link menu-desktop__root-title\"])[5]";
    WebElement element = driver.findElement(By.xpath(xpath));
    element.click();
}
```

* Добавление ожидания загрузки веб страницы

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    // Необходимо установить правильное время ожидания
    driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(60));
    driver.get("https://www.dns-shop.ru/");
    String xpath = "(//*[@class=\"ui-link menu-desktop__root-title\"])[5]";
    WebElement element = driver.findElement(By.xpath(xpath));
    element.click();
}
```

* Добавление явных ожиданий при работе с веб элементами

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    // Явное ожидание при работе с веб элементами позволит избежать многих проблем
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(60));
    String xpath1 = "//span[text()=\"Всё верно\"]/parent::button";
    wait.until(ExpectedConditions.presenceOfElementLocated(By.xpath(xpath1)));
    driver.findElement(By.xpath(xpath1)).click();
    String xpath2 = "(//a[contains(text(), \"Смартфоны и гаджеты\")])[1]";
    wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(xpath2)));
    Actions actions = new Actions(driver);
    actions.moveToElement(driver.findElement(By.xpath(xpath2))).perform();
    String xpath3 = "//a[text()=\"Смартфоны\"]";
    wait.until(ExpectedConditions.elementToBeClickable(By.xpath(xpath3)));
    driver.findElement(By.xpath(xpath3)).click();
}
```

Ниже пример перехвата исключения.

*Пример*

```java
@Test
public void test() {
    try {
        driver.manage().window().maximize();
        driver.get("https://www.dns-shop.ru/");    
        String xpath = "(//*[@class=\"ui-link menu-desktop__root\"])";
        WebElement element = driver.findElement(By.xpath(xpath));
        element.click();
    } catch (NoSuchElementException e) {
        logger.info("NoSuchElementException: " + e.getRawMessage());
    }
}
```

### 3.2.3. UnexpectedTagNameException

***UnexpectedTagNameException*** — исключение, которое вызывается, когда нельзя найти веб элемент ожидаемого тега.

[selenium/docs/api : UnexpectedTagNameException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/UnexpectedTagNameException.html)

#### 3.2.3.1. Причины

* Фактический тег веб элемента отличается

*Пример*

В примере ниже ожидается веб элемент **select**, но найденный веб элемент *a*.

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    WebElement element = driver.findElement(
        By.xpath("(//*[@class=\"ui-link menu-desktop__root-title\"])[5]"));
    Select select = new Select(element);
    select.selectByIndex(0);
}
```

В результате вызывается исключение **UnexpectedTagNameException**.

```text
org.openqa.selenium.support.ui.UnexpectedTagNameException: Element should have been "select" but was "a"
```

#### 3.2.3.2. Решения

* Проверка тега веб элемента, с которым будут выполнятся операции

*Пример*

```java
@Test
public void test() {
    driver.manage().window().maximize();
    driver.get("https://www.dns-shop.ru/");
    WebElement element = driver.findElement(
        By.xpath("(//*[@class=\"ui-link menu-desktop__root-title\"])[5]"));
    element.click();
}
```

Ниже пример перехвата исключения.

*Пример*

```java
@Test
public void test() {
    try {
        driver.manage().window().maximize();
        driver.get("https://www.dns-shop.ru/");
        WebElement element = driver.findElement(
            By.xpath("(//*[@class=\"ui-link menu-desktop__root-title\"])[5]"));
        Select select = new Select(element);
        select.selectByIndex(0);
    } catch (UnexpectedTagNameException e) {
        logger.info("UnexpectedTagNameException: " + e.getRawMessage());
    }
}
```

***

# 4. Относительные локаторы

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Относительные локаторы (Relative Locators)*** - локаторы, помогающие найти элементы, 
которые находятся рядом с другими элементами, выше, ниже, слева и справа от него 
(позиционный способ поиска элементов).

Этот функционал был добавлен в **Selenium 4**.

Используется для поиска элементов по их расположению на странице, а не по их положению в **DOM**.
Элементы возвращаются в порядке их близости к последнему элементу привязки, который использовался для их поиска.

Все относительные локаторы используют **прямоугольник ограничивающий элементы**,
чтобы определить, является ли что-то **левым**, **правым**, **выше** или **ниже** другого.

Если элемент **a** частично перекрывает элемент **b**, то элемент **b** не является
ни **выше**, ни **ниже**, ни **слева** или **справа** относительно элемента **a**.
Это связано с тем, как положение элементов рассчитываются с использованием блочной модели.
У ограничивающего прямоугольника **b** крайний левый край находится справа от
крайнего правого края ограничивающего прямоугольника **a**,
так что это не считается коррректным **справа** для **a**.
Аналогичная логика применима и к другим направлениям.

## 4.1. Класс RelativeLocator

***RelativeLocator*** - класс реализующий относительные локаторы.

Методы класс **RelativeLocator**:

| Тип                               | Метод                | Описание                                               | 
|-----------------------------------|----------------------|--------------------------------------------------------|
| static RelativeLocator.RelativeBy | with(String tagName) | Старт поиск элемента с помощью относительного локаторп |

[selenium/docs/api : RelativeLocator](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/locators/RelativeLocator.html)

Метод **findElement** может принимать метод **with**, 
который возвращает объект **RelativeLocator.RelativeBy** (потомок **By**).

*Пример*

```java
List<WebElements> elements = driver
        .findElements(withTagName("p").above(By.id("id")));
```

Вернет все элементы **p** выше самого низкого **WebElement**, отсортированные по близости к минимальному.
Близость определяется простым сравнением расстояния до центральной точки каждого из элементов по очереди.
Для некоторых непрямоугольных форм (например, абзацев текста, занимающих более одной строки),
это может привести к неожиданным результатам.

## 4.2. Класс RelativeLocator.RelativeBy

***RelativeLocator.RelativeBy*** - класс реализующий методы поиска элементов с помощью относительных локаторов.

Методы класса **RelativeLocator.RelativeBy** (относительные локаторы):

| Тип                        | Метод                                                | Описание                                                       | 
|----------------------------|------------------------------------------------------|----------------------------------------------------------------|
| RelativeLocator.RelativeBy | above(By locator)                                    | Искомый элемент находится над указанным элементом              |
| RelativeLocator.RelativeBy | above(WebElement element)                            | Искомый элемент находится над указанным элементом              |
| RelativeLocator.RelativeBy | below(By locator)                                    | Искомый элемент находится ниже указанного элемента             |
| RelativeLocator.RelativeBy | below(WebElement element)                            | Искомый элемент находится ниже указанного элемента             |
| List<WebElement>           | findElements(SearchContext context)                  | Поиск набора элементов                                         |
| By.Remotable.Parameters    | getRemoteParameters()                                | Получение параметров                                           |
| RelativeLocator.RelativeBy | near(By locator)                                     | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | near(By locator, int atMostDistanceInPixels)         | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | near(WebElement element)                             | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | near(WebElement element, int atMostDistanceInPixels) | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | toLeftOf(By locator)                                 | Искомый элемент находится слева от указанного элемента         |
| RelativeLocator.RelativeBy | toLeftOf(WebElement element)                         | Искомый элемент находится слева от указанного элемента         |
| RelativeLocator.RelativeBy | toRightOf(By locator)                                | Искомый элемент находится справа от указанного элемента        |
| RelativeLocator.RelativeBy | toRightOf(WebElement element)                        | Искомый элемент находится справа от указанного элемента        |

[selenium/docs/api : RelativeLocator.RelativeBy](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/locators/RelativeLocator.RelativeBy.html)

### 4.2.1. Поиск элемента выше заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//h1"))
        .above(By.xpath("//h2")));
```

### 4.2.2. Поиск элемента ниже заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//h2"))
        .below(By.xpath("//h1")));
```

### 4.2.3. Поиск элемента слева от заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//button[text()=\"Button1\"]"))
        .toLeftOf(By.xpath("//button[text()=\"Button3\"]")));
```

### 4.2.4. Поиск элемента справа от заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//button[text()=\"Button3\"]"))
        .toRightOf(By.xpath("//button[text()=\"Button1\"]")));
```

### 4.2.5. Поиск элемента рядом с заданным элементом

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//button[text()=\"Button1\"]"))
        .near(By.xpath("//button[text()=\"Button2\"]")));
```

## 4.3. Исключения

Класс **RelativeLocator.RelativeBy** генерирует те же исключения, что и **By**.

***

# 5. Правила написания локаторов

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 5.1. Как писать хорошие локаторы?

Поиск элемента – это полдела. Создание уникального запроса для локатора – вот вторая половина. 
Если локатор чересчур широк, он будет возвращать ложноположительные значения. 
При слишком узком подходе он начнет ломаться при любом изменении **DOM**, и его будет сложно читать другим людям. 
Лучший подход здесь такой – пишите наиболее простой запрос, который уникально идентифицирует целевой элемент или элементы.

### 5.1.1. Какой локатор будем считать оптимальным?

Оптимальный локатор:

* должен однозначно определять элемент, т.е. должен быть уникальным в пределах страницы (экрана)
  
Конечно, иногда нужно найти группу однотипных элементов (например, разные элементы списка), 
но даже в этом случае мы ищем локатор, позволяющий найти только эти элементы и никакие больше.  

* должен содержать как можно меньше соседних элементов

Таким образом, обеспечивается стабильность: соседние элементы могут часто меняться, а значит, 
чем их меньше в локаторе, тем реже нам придется что-то в локаторе менять.

* должен помогать ориентироваться в автотесте, т.е. нужно использовать такие атрибуты, которые что-то говорят об элементе
  
Чтобы только взглянув на локатор сразу было понятно, что это за элемент. 
Конечно, это условие выполняется реже всего, но нужно к этому стремиться.

И тут нужно сразу предостеречь желающих использовать в локаторе видимый текст элемента. 
Вроде бы, что может лучше говорить о назначении элемента, чем его текст? 
Это конечно да, только вот все то, что видит конечный пользователь, меняется гораздо чаще,
например, потому что так красивее, понятнее и сильнее привлекает внимание. 
Конечно, если совсем не за что зацепиться при составлении локатора, можно использовать текст.

### 5.1.2. Какой приоритет при использовании локаторов?

Приоритет использования локаторов (от высшего к низшему):

* поиск элемента по атрибуту **id**, если уникален (By.id)

Использование идентификаторов — самый простой и безопасный способ поиска элемента в HTML.
Если страница соответствует W3C HTML, идентификаторы должны быть уникальными и идентифицироваться в веб-элементах управления.
По сравнению с текстами тестовые сценарии, использующие идентификаторы, менее склонны к изменениям приложений
(например, разработчики могут принять решение об изменении метки, но с меньшей вероятностью изменить идентификатор).

* поиск элемента по атрибуту **name**, если уникален (By.name)

Атрибут **name** используются в элементах управления формой.
Значения имени передаются на сервер при отправке формы.
С точки зрения вероятности будущих изменений, атрибут **name**, второй по отношению к **id**.

* поиск элемента по атрибуту **class** (By.className)

Атрибут **class** элемента HTML используется для стилизации.
Он также может использоваться для идентификации элементов.
Как правило, атрибут класса элемента HTML имеет несколько значений.

* поиск элемента по **CSS селектору** (By.cssSelector)

* поиск элемента по **XPATH запросу** (By.xPath)

Одна из основных причин использования **CSS селекторов** и **XPath запросов** - 
отсутствие подходящего атрибута **id** или **name** для элемента, который вы хотите найти. 
Локаторы XPath также можно использовать для указания элементов через атрибуты, отличные от **id** и **name**.
Синтаксис **CSS селекторов**, более прост, однако использование **CSS селекторов**, 
как правило, более подвержено структурным изменениям веб-страницы.

* поиск элемента по **тексту ссылки**, только для гиперссылок (By.linkText)
  
Использование текста ссылки пожалуй, самый прямой способ щелкнуть ссылку, так как это то, что мы видим на странице.

* поиск элемента по **частичному тексту ссылки**, только для гиперссылок (By.partialLinkText)

Это может быть полезно, если текст генерируется динамически. 
Другими словами, текст на одной веб-странице может отличаться при следующем посещении. 
Мы могли бы использовать общий текст, общий для этих динамически создаваемых текстов ссылок, для их идентификации.

* поиск элемента по **тегу** (By.tagName)

В **HTML** есть ограниченный набор имен тегов. Обычно локатор **tagName** не используется для поиска элемента. 
Но часто используется с другими элементами в цепочке локаторов.

### 5.1.3. Как правильно писать CSS селекторы и XPath запросы?

Уникальные ID, имена и имена классов крайне упрощают создание локаторов: запросы будут краткими и не требуют дополнительных якорей. 
Всегда ратуйте, чтобы разработчики использовали уникальные идентификаторы (например, имена классов) для всех элементов. 
Однако у многих элементов таких идентификаторов нет, 
и локаторам приходится полагаться на более сложные **CSS селекторы** и **XPath запросы**. 

Если это случилось, вот рекомендации:

* используйте родительские элементы как якоря, если у них есть уникальный идентификатор

*Пример*

```css
#some-list > li
```

```xpath
//ul[@id=’some-list’]/li
```

* избегайте **XPath запросы** с текстом/индексированием при любой возможности

*Пример*

```xpath
//div[3]//span[text()=’hello’]
```

Это наиболее хрупкие тесты.

* используйте функцию **contains**, проверяя классы в XPath

*Пример*

```xpath
//div[contains(@class, ‘some-class’)]
```

У элементов зачастую больше одного класса. 
Функция *contains* проверит подстроку вместо полной строки класса.
Но будьте осторожны, потому что под выдачу попадут также *some-class2*!

* всегда тестируйте локаторы, в них часто встречаются ошибки синтаксиса и ложноположительные значения

**Chrome DevTools** упрощает их тестирование – нажмите Ctrl+F на вкладке элементов и вставьте запрос локатора в поле поиска. 
DevTools подсветит все соответствующие элементы по порядку. Шик-блеск-красота!

Устойчивость к изменениям вёрстки могут обеспечить:

* максимально точные критерии выбора
* как можно меньше порядковых номеров
* привязка к ближайшему уникальному элементу
* минимум прыжков по DOM

## 5.2. Что делать, если тесты нестабильны?

Тестирование через Web UI часто критикуют за нестабильность, потому что тесты часто падают из-за непредвиденных причин. 
Однако большая часть ненадежности, с которой сталкиваются тестировщики Web UI 
(и, зачастую, пользователи **Selenium WebDriver** как такового) связана с тем, 
что все Web-взаимодействия изначально создают гоночные условия. 

Автоматизация и браузер работают независимо друг от друга, и взаимодействие должно синхронизироваться с состоянием страницы. 
В противном случае WebDriver будет выдавать исключения из-за таймаутов, устаревших и не найденных элементов. 
В ряде случаев эти проблемы возникают не каждый раз, поэтому их тяжело отследить и исправить.

### 5.2.1. Ожидание существования элемента перед взаимодействием с ним

Лучший способ избежать гоночных условий таков – **всегда ожидайте существования элемента, прежде чем взаимодействовать с ним**. 
Это кажется элементарным, но про это легко забыть. 
Пакеты **Selenium WebDriver** всегда предлагают какую-то разновидность объекта **WebDriverWait**, 
заставляющего драйвер ожидать истинности определенного условия перед дальнейшими действиями. 
Простейший способ проверить, существует ли элемент – это проверить список элементов, 
возвращаемый вызовом **findElements** (для списка элементов) и убедиться, что он непустой. 
Добавление дополнительного вызова для каждого взаимодействия может показаться затратным, 
однако дизайн-шаблоны хорошо спроектированных фреймворков (например, **Screenplay**) 
могут автоматически осуществлять подобные проверки.

### 5.2.2. Получение свежих элементов

Еще одна хорошая практика – **всегда получать свежие элементы**. 
Иногда автоматизация вначале получит ряд элементов, а затем через второй запрос получит следующую часть. 
Или же, в случае с **Page Object Factory**, элементы получаются один раз при конструировании **Page Object**, 
а затем на них ссылаются. 

Вне зависимости от способа – чем дольше существует объект на веб-странице, 
тем более он подвержен тому, чтобы устареть и вызвать исключения. 
Всегда запрашивайте элемент тогда, когда он нужен – в этом случае он не успеет устареть!

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)