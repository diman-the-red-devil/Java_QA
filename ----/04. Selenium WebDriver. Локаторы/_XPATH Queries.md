 Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы

[![Лекция](https://img.shields.io/badge/-Лекция-ee99ff)](1.%20Лекция.md)

***

# Содержание

* [1. Что такое XPath?](#1-что-такое-XPath)
* [2. Синтаксис XPath](#2-синтаксис-XPath)
* [3. Узлы](#3-узлы)
  * [3.1. Элемент](#31-элемент)
  * [3.2. Корневой элемент](#32-корневой-элемент)
  * [3.3. Атрибут элемента](#33-атрибут-элемента)
  * [3.4. Текстовое содержимое элемента](#34-текстовое-содержимое-элемента)
  * [3.5. Пространства имен](#35-пространства-имен)
  * [3.6. Инструкция обработки](#36-инструкция-обработки)
  * [3.7. Комментарии](#37-комментарии)
  * [3.8. Атомарные значения](#38-атомарные-значения)
* [4. Отношения узлов](#4-отношения-узлов)
  * [4.1. Родители (Parent)](#41-родители-parent)
  * [4.2. Дети (Child)](#42-дети-child)
  * [4.3. Узлы одного уровня (Sibling)](#43-узлы-одного-уровня-sibling)
  * [4.4. Предки (Ancestor)](#44-предки-ancestor)
  * [4.5. Потомки (Descendant)](#45-потомки-descendant)
* [5. Оси XPath](#5-оси-XPath)
* [6. Выражения XPath](#6-выражения-XPath)
  * [6.1. Операторы](#61-операторы)
    * [6.1.1. Операторы выбора элементов](#611-операторы-выбора-элементов)
      * [6.1.1.1. Операторы пути](#6111-операторы-пути)
      * [6.1.1.2. Оператор группирования](#6112-оператор-группирования)
      * [6.1.1.3. Операторы фильтра](#6113-операторы-фильтра)
      * [6.1.1.4. Оператор объединения](#6114-оператор-объединения)
    * [6.1.2. Числовые операторы](#612-числовые-операторы)
    * [6.1.3. Логические операторы](#613-логические-операторы)
      * [6.1.3.1. Логика преобразования данных при сравнениях](#6131-логика-преобразования-данных-при-сравнениях)
    * [6.1.4. Приоритет операторов](#614-приоритет-операторов)
  * [6.2. Функции](#62-функции)
    * [6.2.1. Функции над множествами узлов](#621-функции-над-множествами-узлов)
    * [6.2.2. Строковые функции](#622-строковые-функции)
    * [6.2.3. Логические функции](#623-логические-функции)
    * [6.2.4. Числовые функции](#624-числовые-функции)
    * [6.2.5. Системные функции](#625-системные-функции)
* [7. Предикаты](#7-предикаты)
  * [7.1. Простые предикаты](#71-простые-предикаты)
  * [7.2. Числовые предикаты](#72-числовые-предикаты)
  * [7.3. Множественные предикаты](#73-множественные-предикаты)
* [8. Как работает XPath запрос?](#8-как-работает-XPath-запрос)
* [9. Правила использования XPath](#9-правила-использования-xpath)

***

# 1. Что такое XPath?

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***XPath (XML Path Language)*** — язык запросов к элементам XML-документа. 
Разработан для организации доступа к частям документа **XML** в файлах трансформации **XSLT** и 
является стандартом консорциума **W3C**. **XPath** призван реализовать навигацию по **DOM** в **XML**. 

В **XPath** используется компактный синтаксис, отличный от принятого в **XML**. 
Так же как и **SQL**, **XPath** является декларативным языком запросов. 
Чтобы получить нужные данные, необходимо всего лишь создать запрос, описывающий эти данные. 
Всю "чёрную" работу за вас выполнит интерпретатор языка XPath.

***

# 2. Синтаксис XPath

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

XML-документы представляют собой иерархию, или дерево узлов, 
в чем-то схожее с иерархией каталогов и файлов в файловой системе. 
Этим и объясняется сходство синтаксиса **URL** и **XPath**:

* *иерархия сущностей*

   * **URL** - *иерархия каталогов и файлов*
   * **XPath** - *иерархия элементов и других узлов* XML-документа

* *имя сущности*

   * **URL** - файлы на каждом из уровней имеют *уникальные имена* 
  
>**URL** всегда идентифицирует один файл.

   * **XPath** - элементов на каждом уровне могут иметь *неуникальные имена* 

>Шаблоны **XPath** соответствуют набору всех соответствующих элементов.

* *путь до сущности*

   * **URL** - путь вычисляется *относительно конкретного каталога*, именуемого текущим каталогом
   * **XPath** - путь вычисляется *относительно конкретного узла*, в запросе именуемого контекстом

Терминология **XPath**:

* *узлы*
* *оси*
* *предикаты*
* *функции*

***

# 3. Узлы

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

**XML**-документы обрабатываются в виде деревьев узлов.
Весь документ представляет собой узел документа.

В **XPath** существует семь видов узлов: 

* *элемент*
* *атрибут элемента*
* *текстовое содержимое элемента*
* *пространство имён*
* *инструкции обработки*
* *комментарии и узлы документа*

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore>
    <book category="fantasy">
        <!-- Книга Гарри Поттер -->
        <title lang="en">Harry Potter</title>
        <author>J. K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
        <publisher />
    </book>
</bookstore>
```

![Дерево узлов](_Files/3.%20XPath%20Queries/01.jpg "Дерево узлов")

Пример узлов в документе **XML** выше:

* **\<bookstore\>** - корневой элемент
* **\<author\>J. K. Rowling\</author\>** - элемент
* **lang="en"** - атрибут элемента
* **J. K. Rowling** - текстовое содержимое элемента 
* **xmlns="namespace"** - пространство имён 
* **\<?Processing detail="2"?\>** - инструкции обработки  
* **\<!-- Книга Гарри Поттер --\>** - комментарий

## 3.1. Элемент

***Элемент*** - базовый строительный блок **XML** (не может быть **XML** документа без элементов (тегов)).

Границы элемента задаются 2 способами:

* *начальным и конечным тегом*

>Текст межу тегами называется содержанием элемента

```xml
<имя_тега>
    <!-- Содержание -->
</имя_тега>
```

*Пример*

```xml
<title lang="en">Harry Potter</title><!-- Элемент -->
<author>J. K. Rowling</author><!-- Элемент -->
<year>2005</year><!-- Элемент -->
<price>29.99</price><!-- Элемент -->
```

* *тегом пустого элемента* 

>Пустой элемент не имеет содержания

```xml
<имя_тега />
```

*Пример*

```xml
<publisher /><!-- Пустой элемент -->
```

Вместо пустого элемента можно использовать эквивалентную ему запись начального и конечного тега: 

```xml
<book>
    <publisher></publisher><!-- Пустой элемент -->
</book>
```

Обычно элементы имеют потомков, которыми являются другие элементы, текстовые узлы или их комбинация.
Элементные узлы также являются единственным типом узлов, имеющим атрибуты.

## 3.2. Корневой элемент

***Корневой элемент*** - верхний элемент дерева.

Это тег, с которого документ начинается, и им заканчивается.

*Пример*

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore><!-- Корневой элемент -->
    <!-- Элементы -->
</bookstore>
```

## 3.3. Атрибут элемента

***Атрибут элемента*** - характеристики элемента.

```xml
<имя_тега атрибут1="значение1" атрибут2="значение2" ...>
    <!-- Содержание -->
</имя_тега>
```

**Атрибуты** содержат информацию об элементном узле, но не рассматриваются как потомки элемента.

*Пример*

```xml
<book id="num-582" year="2010"><!-- Атрибуты элемента: id и year -->
```

**Атрибуты** могут применяться либо в начальном теге, либо в теге пустого элемента.
Элемент может не иметь **атрибутов** или иметь любое их количество.

**Атрибуты** и дочерние элементы обрабатываются одинаково, и эти два типа считаются эквивалентными везде, где это возможно.
**Атрибуты** не могут содержать дочерних элементов, поэтому применение операторов пути к атрибутам порождает синтаксические ошибки.
Кроме того, к **атрибутам** нельзя применять индексы, поскольку их порядок по определению не задан.

Следует иметь в виду, что каких-либо правил относительно того, какую информацию задавать в виде элемента, а какую в виде атрибута нет.
Использовать или не использовать атрибуты, если использовать, то как – это при создании корректного XML документа определяет его разработчик, 
а при создании действительного XML документа должно быть задано в его схеме.

## 3.4. Текстовое содержимое элемента

***Текстовое содержимое элемента*** - текст, расположенный внутри элементов между открывающими и закрывающими тегами.

```xml
<имя_тега>
    Текстовое содержимое элемента
</имя_тега>
```

Эквивалентно тексту объектной модели документов (DOM) и типам узлов CDATA. Содержит, по крайней мере, один символ.

*Пример*

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore>
    <book>
        <!-- Книга Гарри Поттер -->
        <title lang="en">Harry Potter</title><!-- Текстовое содержимое: Harry Potter -->
        <author>J. K. Rowling</author><!-- Текстовое содержимое: J. K. Rowling -->
        <year>2005</year><!-- Текстовое содержимое: 2005 -->
        <price>29.99</price><!-- Текстовое содержимое: 29.99 -->
        <publisher />
    </book>
</bookstore>
```

## 3.5. Пространства имен

***Пространства имен*** - пространства имен являются зонами, в которых все имена должны быть уникальны.

```xml
<имя_тега xmlns="ссылка">
```

Кроме атрибутов, в начальный тег элемента могут быть включены объявления **пространств имен**.

*Пример*

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?><!-- Пространство имен: xmlns="namespace" -->
<?Processing detail="2"?>
<bookstore>
...
</bookstore>
```

Поддержка **пространств имен** позволяет разработчикам использовать 
информацию из разных источников или в разных целях без конфликтов.

## 3.6. Инструкция обработки

***Инструкция обработки*** – информация, специально адресованная приложению для передачи 
определенных указаний обработчику XML документа.

**Инструкция обработки** всегда должна обрамляться символами **\<?** и **?\>**

```xml
<?код содержание?>
```
где

* код – имя, идентифицирующее приложение, которому предназначена инструкция
* cодержание – текст, который передается приложению для обработки

*Пример*

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?><!-- Инструкция обработки: ?Processing detail="2"? -->
<bookstore>
  ...
</bookstore>
```

Обработчик **XML** документа, принимая такую инструкцию, должен знать, что с ней делать.
Возможный набор допустимых инструкций обработки не определяется в Рекомендации **XML**
и зависит от используемого обработчика XML документа.

Рекомендация **XML** зарезервировала имена **xml** и **XML** для собственных нужд, 
поэтому они не могут принимать значение кода инструкции обработки.

*Пример*

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
```

## 3.7. Комментарии

***Комментарии*** - информация о данных (обычно игнорируются приложением).

Текст **комментария** должен заключаться между символами **\<!--** и **--\>**

```xml
<!-- Комментарий -->
```

*Пример*

```xml
<!-- Книга Гарри Поттер -->
```

## 3.8. Атомарные значения

***Атомарные значения*** - узлы, не имеющие детей или родителей. 

Пример **атомарных значений**:

* *lang="en"* - атрибут
* *J. K. Rowling* - текстовое содержимое узла

***

# 4. Отношения узлов

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 4.1. Родители (Parent)

***Родители*** - узлы, которые вмещают в себя другие узлы (**дети**).

Каждый элемент и атрибут имеет одного **родителя**. 

*Пример*

```xml
<book><!-- Родитель элементов: title, author, year и price -->
    <title>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
</book>
```

## 4.2. Дети (Child)

***Дети*** - узлы, которые содержатся внутри других узлов (**родители**).

Узлы элементов могут иметь ноль, один или более **дочерних узлов**. 

*Пример*

```xml
<book>
    <title>Harry Potter</title><!-- Дети элемента book -->
    <author>J K. Rowling</author><!-- Дети элемента book -->
    <year>2005</year><!-- Дети элемента book -->
    <price>29.99</price><!-- Дети элемента book -->
</book>
```

## 4.3. Узлы одного уровня (Sibling)

***Узлы одного уровня*** - узлы, которые имеют одного и того же родителя. 

*Пример*

```xml
<book>
    <title>Harry Potter</title><!-- Узлы одного уровня -->
    <author>J K. Rowling</author><!-- Узлы одного уровня -->
    <year>2005</year><!-- Узлы одного уровня -->
    <price>29.99</price><!-- Узлы одного уровня -->
</book>
```

## 4.4. Предки (Ancestor)

***Предки*** - все узлы начиная от родителя, которые вмещают себя данный узел (родитель узла, родитель родителя узла и т.д.).

*Пример*

```xml
<bookstore><!-- Предки элементов title, author, year, price -->
    <book><!-- Предки элементов title, author, year, price -->
        <title>Harry Potter</title>
        <author>J K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
</bookstore>
```

## 4.5. Потомки (Descendant)

***Потомки*** - все узлы начиная от первого вложенного и далее (дети узла, дети детей узла и т.д.).

*Пример*

```xml
<bookstore> 
    <book> 
        <title>Harry Potter</title><!-- Потомки элемента book и bookstore -->
        <author>J K. Rowling</author><!-- Потомки элемента book и bookstore -->
        <year>2005</year><!-- Потомки элемента book и bookstore -->
        <price>29.99</price><!-- Потомки элемента book и bookstore -->
    </book>
</bookstore>
```

***

# 5. Оси XPath

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Оси*** — направление поиска XML-данных по отношению к
контекстному узлу, перемещения по дереву узлов.

**Оси** являются базой языка XPath. 

| Ось                  | Значение                                                                                                                                                        |
|----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| child::              | содержит множество элементов-потомков (элементов, расположенных на один уровень ниже).<br>Это название сокращается полностью, то есть его можно вовсе опускать. |
| descendant::         | содержит полное множество элементов-потомков (то есть, как ближайших элементов-потомков, так и всех их элементов-потомков).                                     |
| descendant-or-self:: | содержит полное множество элементов-потомков и текущий элемент.                                                                                                 |
| ancestor::           | содержит множество элементов-предков.                                                                                                                           |
| ancestor-or-self::   | содержит множество элементов-предков и текущий элемент.                                                                                                         |
| parent::             | содержит элемент-предок на один уровень назад.                                                                                                                  |
| self::               | содержит текущий элемент.                                                                                                                                       |
| following::          | содержит множество элементов, расположенных ниже текущего элемента по дереву (на всех уровнях и слоях), исключая собственных потомков.                          |
| following-sibling::  | содержит множество братских элементов того же уровня, следующих за текущим слоем.                                                                               |
| preceding::          | содержит множество элементов, расположенных выше текущего элемента по дереву (на всех уровнях и слоях), исключая множество собственных предков.                 |
| preceding-sibling::  | содержит множество братских элементов того же уровня, предшествующих текущему слою.                                                                             |
| attribute::          | содержит множество атрибутов текущего элемента.                                                                                                                 |
| namespace::          | содержит множество элементов, относящихся к тому или иному пространству имён (то есть присутствует атрибут *xmlns*).                                            |

![Оси](_Files/3.%20XPath%20Queries/02.jpg "Оси")

Для некоторых осей существуют сокращённые обозначения.

| Ось                  | Сокращение                                                             |
|----------------------|------------------------------------------------------------------------|
| child::              | Это обращение сокращается полностью, то есть его можно вовсе опускать. |
| descendant-or-self:: | Это обращение можно заменить на *//*.                                  |
| parent::             | Это обращение можно заменить на *..*.                                  |
| self::               | Это обращение можно заменить на *.*.                                   |
| attribute::          | Это обращение можно заменить на *@*.                                   |

***

# 6. Выражения XPath

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Центральная конструкция XPath – **выражение пути**.

***Путь*** – последовательность шагов, разделенная знаком «/».

Основа – система адресации **Uniformed Resource Identifier (URI)**:

*Пример*

```xpath
http://someaddress/somepage
NodeX/NodeY/NodeX
```

Каждый шаг в **выражении** пути состоит из трех частей:

* ось
* проверка узла
* предикаты

В рамках содержимого оси отбор выполняется согласно **выражению**, определяющему отбираемые элементы.
**XPath** использует **выражения** для выбора отдельных узлов или набора узлов в документе **XML**.
С помощью **выражений** **XPath** для выбора узлов в документе XML можно выбрать узел, следуя пути или шагам.

В качестве **выражения** может быть указано:

* конкретное имя, тогда отбираются элементы оси, соответствующие этому имени
* символ *, что отберёт все элементы оси
* выражение, составленное из функций, и тогда будут отобраны результаты вычисления выражения в контексте каждого элемента оси

Эти выражения очень похожи на выражения, которые вы видите, когда работаете с традиционной файловой системой компьютера.

**Выражения XPath** возвращают набор узлов, строки, булевы или числовые значения.

Типы адресации в **XPath**:

* *абсолютный путь* 

**Абсолютный путь** – путь, берущий начало из корня дерева (контекстный узел – корень)

* *относительный путь* 

**Относительный путь** – путь, берущий начало из контекстных узлов (выражение, задающее относительный путь, 
не может начинаться с символа **/**)

## 6.1. Операторы

### 6.1.1. Операторы выбора элементов

| Оператор | Значение                                                                                                                                                      |
|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| /        | Получение дочерних элементов коллекции, находящейся слева от него.<br>При использовании в начале шаблона означает поиск от корневого элемента.                |
| //       | Получение указанного элемента на любой глубине (*Рекурсивный спуск*).<br>При использовании в начале шаблона означает рекурсивный поиск от корневого элемента. |
| ..       | Получение родительского элемента.                                                                                                                             |
| .        | Получение текущего элемента (*Текущий контекст*).                                                                                                             |
| *        | Получение всех элементов, независимо от имени (*Wildcard*).                                                                                                   |
| @        | Получение атрибута (*Префикс имени атрибута*).<br>При использовании без имени атрибута выбирает все атрибуты, независимо от их имени.                         |
| :        | Отделение префикса пространства имен от имени элемента или атрибута (*Сепаратор пространств имен*).                                                           |
| ( )      | Явное задание очередности (*Группировка операции*).                                                                                                           |
| [ ]      | 1. Фильтрация результатов поиска.<br>2. Индексация элементов коллекции.                                                                                       |
| &#124;   | Объединение результатов вычисление двух наборов узлов.                                                                                                        |

#### 6.1.1.1. Операторы пути

***Операторы пути / и //*** изменяют контекст по мере выполнения запроса. 

Соединив несколько операторов пути, можно просмотреть все дерево документа.

#### 6.1.1.2. Оператор группирования

***Оператор группирования ()*** применим только для выражения пути верхнего уровня:

* *допустимая операция группирования*

*Пример*

```xpath
(//author/degree | //author/name) 
```

* *недопустимая операция группирования*

*Пример*

```xpath
//author/(degree | name)
```

#### 6.1.1.3. Операторы фильтра

***Операторы фильтра []*** имеют более высокий приоритет, чем операторы пути / и //.

* выбирает все комментарии с индексом, равным 3, связанные с родительским элементом комментария в любом месте документа

*Пример*

```xpath
//comment()[3] 
```

* выбирает третий комментарий из множества всех комментариев, связанных с родительским элементом

*Пример*

```xpath
(//comment())[3] 
```

Первое выражение может вернуть несколько комментариев, а второе - только один.

#### 6.1.1.4. Оператор объединения

***Оператор объединения |*** возвращает объединенные результаты двух запросов.
Можно использовать несколько операторов объединения для объединения результатов нескольких запросов. 
Оператор объединения сохраняет порядок документа и не возвращает дубликатов.

### 6.1.2. Числовые операторы

| Оператор | Значение             |
|----------|----------------------|
| +        | Сложение             |
| −        | Вычитание            |
| *        | Умножение            |
| div      | Деление (не нацело!) |
| mod      | Остаток от деления   |

### 6.1.3. Логические операторы

| Оператор | Значение                       |
|----------|--------------------------------|
| or       | Логическое *ИЛИ*               |
| and      | Логическое *И*                 |
| =        | Логическое *Равно*             |
| !=       | Логическое *Не Равно*          |
| <        | Логическое *Меньше*            |
| <=       | Логическое *Меньше либо Равно* |
| >        | Логическое *Больше*            |
| >=       | Логическое *Больше либо Равно* |

#### 6.1.3.1. Логика преобразования данных при сравнениях

При сравнении операндов разных типов данных производятся следующие преобразования.

* если хотя бы один операнд – это Boolean, каждый оператор будет сперва конвертирован в Boolean
* иначе, если хотя бы один операнд является числом, каждый оператор будет конвертирован в число
* иначе, если хотя бы один операнд является датой, каждый оператор будет конвертирован в дату
* в других случаях оба оператора конвертируются в строки

### 6.1.4. Приоритет операторов

| Очередность | Оператор           | Значение         |
|-------------|--------------------|------------------|
| 1           | ()                 | Группирование    |
| 2           | []                 | Фильтры          |
| 3           | /<br>//            | Пути             |
| 4           | <<br><=<br>><br>>= | Сравнение        |
| 5           | =<br>!=            | Сравнение        |
| 6           | &#124;             | Объединение      |
| 7           | not()              | Логическое *НЕ*  |
| 8           | and                | Логическое *И*   |
| 9           | or                 | Логическое *ИЛИ* |

## 6.2. Функции

**XPath** включает в себя более 100 встроенных функций. 
Есть функции для строковых и числовых значений, даты и времени, сравнения узлов и манипулирования QName, 
управления последовательностями, булевых значений, и многое другое.

Функции делятся на 5 групп:

* *функции над множеством узлов*
* *строковые функции*
* *логические функции*
* *числовые функции*
* *системные функции*

### 6.2.1. Функции над множествами узлов

| Тип      | Функция                  | Описание                                                          |
|----------|--------------------------|-------------------------------------------------------------------|
| node-set | node()                   | Возвращает сам узел                                               |
| string   | text()	                  | Возвращает узел, если он текстовый                                |
| node-set | current()                | Возвращает множество из одного элемента, который является текущим |
| number   | position()               | Возвращает позицию элемента в множестве элементов оси             |
| number   | last()                   | Возвращает номер последнего элемента в множестве элементов оси    |
| number   | count(node-set)          | Возвращает количество элементов в node-set.                       |
| string   | name(node-set?)          | Возвращает полное имя первого тега в множестве                    |
| string   | namespace-url(node-set?) | Возвращает ссылку на URL, определяющий пространство имён          |
| string   | local-name(node-set?)    | Возвращает имя первого тега в множестве, без пространства имён    |
| node-set | id(object)               | Находит элемент с уникальным идентификатором                      |

Вместо функции **node()** часто используют заменитель *, но, в отличие от звёздочки, 
функция **node()** возвращает и текстовые узлы.

Функция **current()** при обработке множества с предикатами, 
является единственным способом дотянуться из предиката до текущего элемента.

Функции **position()** и **last()** корректно работают только в цикле **<xsl:for-each/>**.

### 6.2.2. Строковые функции

| Тип     | Функция                            | Описание                                                                                                                                              |
|---------|------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| string  | string(object?)                    | Возвращает текстовое содержимое элемента.<br>По сути, возвращает объединённое множество текстовых элементов на один уровень ниже.                     |
| string  | concat(string, string, string*)    | Соединяет строки, указанные в аргументах.                                                                                                             |
| number  | string-length(string?)             | Возвращает длину строки.                                                                                                                              |
| boolean | contains(string, string)           | Возвращает true, если первая строка содержит вторую, иначе — false.                                                                                   |
| string  | substring(string, number, number?) | Возвращает строку, вырезанную из строки, начиная с указанного номера, и, если указан второй номер, — количество символов.                             |
| string  | substring-before(string, string)   | Если найдена вторая строка в первой, возвращает строку до первого вхождения второй строки.                                                            |
| string  | substring-after(string, string)    | Если найдена вторая строка в первой, возвращает строку после первого вхождения второй строки.                                                         |
| boolean | starts-with(string, string)        | Возвращает true, если вторая строка входит в начало первой, иначе — false.                                                                            |
| boolean | ends-with(string, string)          | Возвращает true, если вторая строка входит в конец первой, иначе — false.                                                                             |
| string  | normalize-space(string?)           | Убирает лишние и повторные пробелы, а также управляющие символы, заменяя их пробелами.                                                                |
| string  | translate(string, string, string)  | Заменяет символы первой строки, которые встречаются во второй строке, на соответствующие позиции символам из второй строки символы из третьей строки. |

### 6.2.3. Логические функции 

| Тип     | Функция         | Описание                                                   |
|---------|-----------------|------------------------------------------------------------|
| boolean | boolean(object) | Приводит объект к логическому типу                         |
| boolean | true()          | Возвращает истину                                          |
| boolean | false()         | Возвращает ложь                                            |
| boolean | not(boolean)    | Отрицание, возвращает истину если аргумент ложь и наоборот |

### 6.2.4. Числовые функции 

| Тип    | Функция         | Описание                                                                                              |
|--------|-----------------|-------------------------------------------------------------------------------------------------------|
| number | number(object?) | Переводит объект в число.                                                                             |
| number | sum(node-set)   | Вернёт сумму множества.<br>Каждый тег множества будет преобразован в строку и из него получено число. |
| number | floor(number)   | Возвращает наибольшее целое число, не большее, чем аргумент (округление к меньшему).                  |
| number | ceiling(number) | Возвращает наименьшее целое число, не меньшее, чем аргумент (округление к большему).                  |
| number | round(number)   | Округляет число по математическим правилам.                                                           |

### 6.2.5. Системные функции

| Тип      | Функция                                | Описание                                                                                                                                              |
|----------|----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| node-set | document(object, node-set?)            | Возвращает документ, указанный в параметре object.                                                                                                    |
| string   | format-number(number, string, string?) | Форматирует число согласно образцу, указанному во втором параметре.<br>Третий параметр указывает именованный формат числа, который должен быть учтён. |
| string   | generate-id(node-set?)                 | Возвращает строку, являющуюся уникальным идентификатором.                                                                                             |
| node-set | key(string, object)                    | Возвращает множество с указанным ключом (аналогично функции id для идентификаторов).                                                                  |
| string   | unparsed-entity-uri(string)            | Возвращает непроанализированный URI.<br>Если такового нет, возвращает пустую строку.                                                                  |
| boolean  | element-available(string)              | Проверяет, доступен ли элемент или множество, указанное в параметре.<br>Параметр рассматривается как XPath.                                           |
| boolean  | function-available(string)             | Проверяет, доступна ли функция, указанная в параметре.<br>Параметр рассматривается как XPath.                                                         |
| object   | system-property(string)                | Параметры, возвращающие системные переменные.                                                                                                         |
| boolean  | lang(string)                           | Возвращает true, если у текущего тега есть атрибут *xml: lang*, или его родитель имеет атрибут *xml: lang* и в нём указан совпадающий строке символ.  |

В **system-property(string)** могут быть переданы следующие параметры: 

* *xsl: version* — возвращает версию **XSLT** процессора
* *xsl: vendor* — возвращает производителя **XSLT** процессора
* *xsl: vendor-url* —  возвращает **URL**, идентифицирующий производителя
* *неизвестный параметр* - возвращает пустую строку

***

# 7. Предикаты

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Предикаты*** - логические выражения в квадратных скобках (составленные по тем же принципам, что и выражение отбора), 
фильтрующее набор узлов относительно оси и создающее новый набор узлов.

Каждый **предикат** заключается в квадратные скобки, и подразумевает логическое выражение для проверки отбираемых элементов.

Выражения, возвращающие не логическое значение, а пустой набор элементов, считаются **ложными**.

Выражение, возвращающее число, считается выражением, сравнивающим число с **position()**.
Когда **предикатов** более одного, каждый из них фильтрует результаты фильтрации предыдущим **предикатом**.

**Предикаты** используются для поиска специфического узла или узла, который содержит специфическое значение.
**Предикаты** всегда обрамляются квадратными скобками.

## 7.1. Простые предикаты

***Предикат с простым условием*** предусматривает проверку значения определенного элемента или атрибута

*Пример*

```xpath
Students/Student[LName='Иванов']
Students/Student[@rcb='111111']
Students/Student[Group/num='10']
```

## 7.2. Числовые предикаты

***Числовой предикат*** — это предикат с предикативным выражением в виде положительного целого числа

*Пример*

```xpath
Students/Student[1] =
Students/Student[position()=1]
Students/Student[position()=last()]
```

## 7.3. Множественные предикаты

Множественные предикаты

*Пример*

```xpath
Students/Student[1][Group/spec='ПИЭ'][Group/year='5'][Group/num='10']
Students/Student[FIO/LName='Иванов'][FIO/FName='Иван'][FIO/MName='Иванович‘]
```

***

# 8. Как работает XPath запрос?

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Строка **XPath** описывает способ выбора нужных элементов из массива элементов, которые могут содержать вложенные элементы.
Начинается отбор с переданного множества элементов, на каждом шаге пути отбираются элементы, соответствующие выражению шага,
и в результате оказывается отобрано подмножество элементов, соответствующих данному пути.

При исполнении **XPath**-запроса всегда имеется так называемый контекст исполнения, 
то есть текущая ветка, относительно которой производится поиск. 
Это сходно с активным каталогом при выполнении команды CD файловой системы. 
Как контекст **XPath**-запроса может использоваться любой узел **XML**-документа. 
В **XSLT** контекстом для запроса является узел, в данный момент обрабатываемый элементами <xsl:template> или <xsl:for-each>. 
При использовании XPath непосредственно из **DOM** вы определяете контекст, выполняя запрос из конкретного узла.

Путь состоит из шагов адресации, которые разделяются символом **/** (косая черта).

Каждый шаг адресации состоит из трёх частей:

* *ось* (по умолчанию **child::**, ось элементов)

Кроме отбора по оси вложенных элементов, можно отбирать разным другим осям элементов 
и по оси атрибутов (**attribute::**, она же обозначается символом @).

* *выражение* - определяющее отбираемые элементы 
  
* *предикаты* - дополнительные условия отбора (их может быть несколько)

Если предиката нет, то отбираются все подходящие элементы.

Пример **HTML** документа:

```html
<html>
 <body>
    <div>Первый слой
      <span>блок текста в первом слое</span>
    </div>
    <div>Второй слой</div>
    <div>Третий слой
      <span class="text">первый блок в третьем слое</span>
      <span class="text">второй блок в третьем слое</span>
      <span>третий блок в третьем слое</span>
    </div>
    <span>Четвёртый слой</span>
    <img />
 </body>
</html>
```

**XPath**-путь:

```xpath
/html/body/*/span[@class]
```

будет соответствовать в нём двум элементам исходного документа:

* первый блок в третьем слое 

```html
<span class="text">первый блок в третьем слое</span>
```
* второй блок в третьем слое

```html
<span class="text">второй блок в третьем слое</span>
```

Элементы пути преимущественно пишутся в **XPath** в краткой форме.
Полная форма приведённого выше пути имеет вид

```xpath
/child::html/child::body/child::*/child::span[attribute::class]
```

Анализ пути ведётся слева направо, и начинается либо в контексте первого элемента корневого узла 
(в данном примере это элемент **html**), и тогда по оси **child::** будут вложенные в него элементы 
(в данном примере это один элемент body). Это удобно в случае обработки обычного **XML**-документа с одним корневым узлом, 
либо, если в начале XPath указан символ **/**,в контексте со всеми корневыми элементами переданого **XML** по оси **child::**
(в даном примере это будет один элемент **html**).

На каждом шаге адресации в текущем контексте отбираются элементы, подходящие под указанные в шаге условия,
и их перечень берётся как контекст для следующего шага или как возвращаемый результат.

Таким образом 

* первый шаг 

```xpath  
/child::html
```

Явным образом задается текущим контекстом для следующего шага перечень из одного элемента *html*,
что было бы и так сделано неявно, если этот шаг не был обозначен

* второй шаг 

```xpath  
/child::body
```  
 
Контекстом является перечень из одного элемента **html**.
Ось **child::** говорит о том, что необходимо смотреть на имена вложенных элементов в текущем контексте,
а условие проверки **body** говорит о том, что в формируемый набор элементов нужно включить те узлы, у которых имя **body**.
Таким образом, в ходе второго шага адресации получаем набор узлов, состоящий всего из одного элемента **body**,
который и становится контекстом для третьего шага.

* третий шаг

```xpath  
/child::*
```

Ось **child::** содержит всех непосредственных потомков элемента **body**, а условие проверки * говорит о том, 
что в формируемый перечень нужно включить элементы основного типа с любым именем.
В ходе этого шага получаем перечень, состоящий из трёх элементов **div**, 
одного **span** и одного элемента **img** — итого, пять элементов.

* четвёртый шаг

```xpath  
child::span/@class. 
```

Его контекстом является **перечень из пяти элементов**, 
поэтому исходящий перечень создаётся в пять проходов (за пять итераций):

1) *первая итерация*
    
Узлом контекста становится первый **div**. Согласно заданной оси **child::** и правилу проверки **span**,
в набор должны включаться непосредственные потомки этого **div**, имя которых равно **span**. Там такой один. 

2) *второй итерации*
    
В набор ничего добавляться не будет, так как у второго **div** нет потомков.

3) *третья итерация*

В набор попадут сразу три элемента **span**.

4) *четвёртая итерация*
    
Ничего не увидит, так как у элемента **span** нет потомков **span**, а то что он сам **span** — 
не важно, ведь просматриваются именно потомки. 

5) *пятая итерация*
    
Тоже ничего не увидит, у элемента **img** тоже нет потомков **span**.

Итак, в ходе проверки мог бы быть получен набор узлов, состоящий из четырёх элементов **span**.
Это и было бы контекстом для последующей обработки, не будь на этом шаге указано предиката.

Но так как предикат на четвёртом шаге есть, по мере выполнения каждого из пяти проходов будет 
производиться дополнительная фильтрация отбираемых элементов.
В данном случае у предиката ось **attribute::** говорит о необходимости проверить, есть ли у отбираемого узла атрибуты,
а условие **class** требует оставить лишь те узлы, у которых задан атрибут с именем **class**.
И поэтому на первой итерации единственный найденный **span** фильтрацию предикатом не пройдёт,
на третьей итерации фильтрацию пройдут два элемента из трёх.

И в итоге, несмотря на то, что фильтрация происходит за пять итераций, 
в окончательный набор попадают только два элемента **span**.

***

# 9. Правила использования XPath

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Несколько правил использования **XPath**:

* никогда не использовать плагины или копирование **XPath** из кода страницы средствами браузера или веб-разработчика

Вот например как показывает одну ссылку плагин к Файрфокс: 

*Пример*

```xpath
//header/div/ul/li[2]/a
```
 
Из этой ссылки непонятно, о каком элементе речь и что мы ищем.
Взглянув на локатор в коде или в тексте исключения мы должны понять о каком элементе идет речь. 
Любой код, основанный на таких локаторах упадет при любом малейшем изменении верстки. 


* писать **XPath** как можно короче и понятнее
  
Нужно использовать все его возможности и схожесть с языком программирования, 
чтобы и через месяц можно было понять о каком элементе речь и что нужно поправить в случае изменения верстки.

* по возможности использовать атрибуты **id** и **name** или попросить разработчиков внести в код

* использовать отношения элементов: **предок, потомок, сестринский элемент**, вместо длинной цепочки слешей

* использовать логические операции: **and, not , or**

* не использовать фильтры с номером элемента в стиле **[2]**

* нормальный **XPath** всегда начинается с **//**

[Хороший мануал по XPath](_Files/3.%20XPath%20Queries/Мануал%20по%20XPath.docx)