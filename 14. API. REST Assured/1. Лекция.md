Java_QA / 14. API. REST Assured

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* []()
* []()
* []()
* []()

***

# 1. REST Assured

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***REST Assured*** — **Java** библиотека для тестирования **REST** сервисов, предоставляющая **DSL** в **BDD** стиле. 

Библиотека **REST Assured** интегрируется с любым фреймворком автоматизации, основанным на **Java**.

Это решение появилось более девяти лет назад и стало популярным из-за своей простоты и удобного функционала.

Ссылки:

* [REST Assured](https://rest-assured.io/)
* [REST Assured. Github](https://github.com/rest-assured/rest-assured)
* [REST Assured. Github. GettingStarted](https://github.com/rest-assured/rest-assured/wiki/GettingStarted)
* [REST Assured. Github. Usage Guide](https://github.com/rest-assured/rest-assured/wiki/Usage)
* [REST Assured. Javadoc](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/index.html)

Ключевые слова **given**, **when** и **then** формируют запрос:

* **given** - условия (заголовки, параметры, тело запроса и т д)
* **when** – действие (отправка запроса с заданными условиями, методом и ендпоинтом запроса)
* **then** – проверка (проверка ответа)

Кроме этого, можно извлечь тело ответа в виде объекта типа **JsonPath** или **XmlPath**.

***

# 2. Класс RestAssured 

**RestAssured** - класс предоставляющий DSL.

Методы класса **RestAssured**:

[io/restassured : RestAssured](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

## 2.1. Given, With, Expect, When

### 2.1.1. Given

**Given** - параметры отправляемого запроса / получаемого ответа.

| Тип                         | Метод                                                                       | Описание                                                                                                                   | 
|-----------------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| static RequestSpecification | given()                                                                     | Параметры отправляемого запроса                                                                                            |
| static RequestSpecification | given(RequestSpecification requestSpec)                                     | Параметры отправляемого запроса на основе спецификации запроса                                                             |
| static RequestSender        | given(RequestSpecification requestSpec, ResponseSpecification responseSpec) | Параметры <br/>отправляемого запроса на основе спецификации запроса, <br/>получаемого ответа на основе спецификации ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    .given()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
    .when()
        .get("/character")
    .then().statusCode(200);
```

### 2.1.2. With

**With** - параметры отправляемого запроса.

| Тип                         | Метод   | Описание                        | 
|-----------------------------|---------|---------------------------------|
| static RequestSpecification | with()  | Параметры отправляемого запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
        .with()
            .accept(ContentType.JSON)
            .queryParam("name","Rick Sanchez")
        .when()
            .get("/character")
        .then().statusCode(200);
```

### 2.1.3. Expect

**Expect** - параметры получаемого ответа (для проверки).

| Тип                          | Метод    | Описание                     | 
|------------------------------|----------|------------------------------|
| static ResponseSpecification | expect() | Параметры получаемого ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    .with()
    	.accept(ContentType.JSON)
    	.queryParam("name","Rick Sanchez")
    .expect()
    	.statusCode(200)
    	.contentType(ContentType.JSON)
    .when()
    	.get("/character");
```

### 2.1.4. When

**When** - отправка запроса.

| Тип                  | Метод   | Описание         | 
|----------------------|---------|------------------|
| static RequestSender | when()  | Отправка запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
        .given()
            .accept(ContentType.JSON)
            .queryParam("name","Rick Sanchez")
        .when()
            .get("/character")
        .then().statusCode(200);
```

***

## 2.2. Get, Post, Put, Patch, Delete, Request

### 2.2.1. Get

**Get** - отправка **HTTP** запроса **GET**.

| Тип              | Метод                                      | Описание                                                              | 
|------------------|--------------------------------------------|-----------------------------------------------------------------------|
| static Response  | get()                                      | Отправка **HTTP** запроса **GET** по **path** (http://localhost:8080) |
| static Response  | get(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **GET** по **path**                         |
| static Response  | get(String path, Object... pathParams)     | Отправка **HTTP** запроса **GET** по **path**                         |
| static Response  | get(URI uri)                               | Отправка **HTTP** запроса **GET** по **uri**                          |
| static Response  | get(URL url)                               | Отправка **HTTP** запроса **GET** по **url**                          |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.baseUri("https://restful-booker.herokuapp.com/booking");

Response response = request.get();
ValidatableResponse valRes = response.then();
valRes.statusCode(200);
valRes.statusLine("HTTP/1.1 200 OK");
```

*Пример*

**BDD** стиль.

```java
RestAssured
// Given
.given()
	.baseUri("https://restful-booker.herokuapp.com")
// When
.when()
	.get("/booking")
// Then
.then()
	.statusCode(200)
	.statusLine("HTTP/1.1 200 OK")
	.body("bookingid.sum()", Matchers.hasSize(10))
	.body("bookingid[3]", Matchers.equalTo(1));
```

### 2.2.2. Post

**Post** - отправка **HTTP** запроса **POST**.

| Тип             | Метод                                       | Описание                                                                                   | 
|-----------------|---------------------------------------------|--------------------------------------------------------------------------------------------|
| static Response | post()                                      | Отправка **HTTP** запроса **POST** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | post(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **POST** по **path**                                             |                                     
| static Response | post(String path, Object... pathParams)     | Отправка **HTTP** запроса **POST** по **path**                                             |                                 
| static Response | post(URI uri)                               | Отправка **HTTP** запроса **POST** по **uri**                                              |
| static Response | post(URL url)                               | Отправка **HTTP** запроса **POST** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.baseUri("https://restful-booker.herokuapp.com/auth");
request.body(jsonString);

Response response = request.post();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("token", Matchers.notNullValue());
validatableResponse.body("token.length()", Matchers.is(15));
validatableResponse.body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RestAssured
// Given  
.given()
    .baseUri("https://restful-booker.herokuapp.com/auth")
    .contentType(ContentType.JSON)
    .body(jsonString)
// When
.when()
    .post()
// Then
.then()
    .assertThat()
    .statusCode(200)
    .body("token", Matchers.notNullValue())
    .body("token.length()", Matchers.is(15))
    .body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

### 2.2.3. Put

**Put** - отправка **HTTP** запроса **PUT**.

| Тип             | Метод                                  | Описание                                                                                  | 
|-----------------|----------------------------------------|-------------------------------------------------------------------------------------------|
| static Response | put()                                  | Отправка **HTTP** запроса **PUT** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | put(String path, Object... pathParams) | Отправка **HTTP** запроса **PUT** по **path**                                             |
| static Response | put(URI uri)                           | Отправка **HTTP** запроса **PUT** по **uri**                                              |
| static Response | put(URL url)                           | Отправка **HTTP** запроса **PUT** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "fa0d5b1138a0d1f");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.put();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RestAssured
// Given
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
    .cookie("token", "e88375c0fde687a")
    .contentType(ContentType.JSON)
    .body(jsonString)
// When
.when()
    .put()
// Then
.then()
    .assertThat()
    .statusCode(200)
    .body("firstname", Matchers.equalTo("Amod"))
    .body("lastname", Matchers.equalTo("Mahajan"));
```

### 2.2.4. Patch

**Patch** - отправка **HTTP** запроса **PATCH**.

| Тип              | Метод                                        | Описание                                                                                    | 
|------------------|----------------------------------------------|---------------------------------------------------------------------------------------------|
| static Response  | patch()                                      | Отправка **HTTP** запроса **PATCH** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response  | patch(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| static Response  | patch(String path, Object... pathParams)     | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| static Response  | patch(URI uri)                               | Отправка **HTTP** запроса **PATCH** по **uri**                                              |
| static Response  | patch(URL url)                               | Отправка **HTTP** запроса **PATCH** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "974c253452ba510");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.patch();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RestAssured
// Given
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
    .cookie("token", "6608dc75eedd44f")
    .contentType(ContentType.JSON)
    .body(jsonString)
// When
.when()
    .patch()
// Then
.then()
    .assertThat()
    .statusCode(200)
    .body("firstname", Matchers.equalTo("Amod"))
    .body("lastname", Matchers.equalTo("Mahajan"));
```

### 2.2.5. Delete

**Delete** - отправка **HTTP** запроса **DELETE**.

| Тип             | Метод                                         | Описание                                                                                     | 
|-----------------|-----------------------------------------------|----------------------------------------------------------------------------------------------|
| static Response | delete()                                      | Отправка **HTTP** запроса **DELETE** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | delete(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| static Response | delete(String path, Object... pathParams)     | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| static Response | delete(URI uri)                               | Отправка **HTTP** запроса **DELETE** по **uri**                                              |
| static Response | delete(URL url)                               | Отправка **HTTP** запроса **DELETE** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.cookie("token", "f4e70e7b9bbcd05");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response response = request.delete();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(201);

RequestSpecification getRequestSpec = RestAssured.given();
getRequestSpec.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response res = getRequestSpec.get();
ValidatableResponse valRes = res.then();
valRes.statusCode(404);
```

*Пример*

**BDD** стиль.

```java
RestAssured
// Given
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
    .cookie("token", "f7dddb1093eab19")
// When
.when()
    .delete()
// Then
.then()
    .assertThat()
    .statusCode(201);
RestAssured
// Given   
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
// When
.when()
    .get()
// Then
.then()
    .statusCode(404);
```

### 2.2.6. Request

**Request** - отправка **HTTP** запроса.

| Тип             | Метод                                                     | Описание                                                                          | 
|-----------------|-----------------------------------------------------------|-----------------------------------------------------------------------------------|
| static Response | request(Method method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | request(Method method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                             |
| static Response | request(Method method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                              |
| static Response | request(Method method, URL url)                           | Отправка **HTTP** запроса по **url**                                              |
| static Response | request(String method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | request(String method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                             |
| static Response | request(String method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                              |
| static Response | request(String method, URL url)                           | Отправка **HTTP** запроса по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.contentType(ContentType.JSON);
```

*Пример*

**BDD** стиль.

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    .given()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
    .expect()
        .statusCode(200)
        .contentType(ContentType.JSON)
    .when()
        .request("GET","/character");
```

***

# 3. Интерфейс RequestSender

**RequestSender** - интерфейс, содержащий методы для отправки **HTTP** запросов.

Методы класса **RequestSender**:

[io/restassured : RequestSender](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/RequestSender.html)

Далее рассмотрим основные методы.

| Тип | Метод | Описание | 
|-----|-------|----------|
|     |       |          |

***

# 4. Интерфейс Response

***Response*** - интерфейс, содержащий методы для обработки **HTTP** ответа.

Интерфейс **Response** наследует следующие интерфейсы:

* **ResponseBody<Response>**
* **ResponseBodyData**
* **ResponseBodyExtractionOptions**
* **ResponseOptions<Response>**
* **Validatable<ValidatableResponse,Response>**

Методы интерфейса **Response**:

[io/restassured : Response](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/response/Response.html)

***

# 5. Интерфейс ResponseBody<Response>

## 5.1. Вывод тела запроса

### 5.1.1. Peek, PrettyPeek

| Тип     | Метод         | Описание                                                           |
|---------|---------------|--------------------------------------------------------------------|
| T       | peek()        | Вывод в консоль в не отфоратированном виде                         |
| T       | prettyPeek()  | Вывод в консоль в отфоратированном виде                            |
| String  | print()       | Вывод в консоль в не отфоратированном виде и возврат в виде строки |
| String  | prettyPrint() | Вывод в консоль в отфоратированном виде и возврат в виде строки    |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
response.prettyPeek();
```

*Пример*

**BDD** стиль.

```java
RestAssured
    .given()
	    .accept(ContentType.JSON)
	    .queryParam("name","Rick Sanchez")
    .when()
	    .request("GET","/character")
	    .prettyPeek()
    .then()
	    .statusCode(200)
	    .contentType(ContentType.JSON);
```

*Результат*

```json
{
    "info": {
        "count": 4,
        "pages": 1,
        "next": null,
        "prev": null
    },
    "results": [
        {
            "id": 1,
            "name": "Rick Sanchez",
            "status": "Alive",
            "species": "Human",
            "type": "",
            "gender": "Male",
            "origin": {
                "name": "Earth (C-137)",
                "url": "https://rickandmortyapi.com/api/location/1"
            },
            "location": {
                "name": "Citadel of Ricks",
                "url": "https://rickandmortyapi.com/api/location/3"
            },
            "image": "https://rickandmortyapi.com/api/character/avatar/1.jpeg",
            "episode": [
                "https://rickandmortyapi.com/api/episode/1",
                "https://rickandmortyapi.com/api/episode/2",
                "https://rickandmortyapi.com/api/episode/3",
                "https://rickandmortyapi.com/api/episode/4",
                "https://rickandmortyapi.com/api/episode/5",
                "https://rickandmortyapi.com/api/episode/6",
                "https://rickandmortyapi.com/api/episode/7",
                "https://rickandmortyapi.com/api/episode/8",
                "https://rickandmortyapi.com/api/episode/9",
                "https://rickandmortyapi.com/api/episode/10",
                "https://rickandmortyapi.com/api/episode/11",
                "https://rickandmortyapi.com/api/episode/12",
                "https://rickandmortyapi.com/api/episode/13",
                "https://rickandmortyapi.com/api/episode/14",
                "https://rickandmortyapi.com/api/episode/15",
                "https://rickandmortyapi.com/api/episode/16",
                "https://rickandmortyapi.com/api/episode/17",
                "https://rickandmortyapi.com/api/episode/18",
                "https://rickandmortyapi.com/api/episode/19",
                "https://rickandmortyapi.com/api/episode/20",
                "https://rickandmortyapi.com/api/episode/21",
                "https://rickandmortyapi.com/api/episode/22",
                "https://rickandmortyapi.com/api/episode/23",
                "https://rickandmortyapi.com/api/episode/24",
                "https://rickandmortyapi.com/api/episode/25",
                "https://rickandmortyapi.com/api/episode/26",
                "https://rickandmortyapi.com/api/episode/27",
                "https://rickandmortyapi.com/api/episode/28",
                "https://rickandmortyapi.com/api/episode/29",
                "https://rickandmortyapi.com/api/episode/30",
                "https://rickandmortyapi.com/api/episode/31",
                "https://rickandmortyapi.com/api/episode/32",
                "https://rickandmortyapi.com/api/episode/33",
                "https://rickandmortyapi.com/api/episode/34",
                "https://rickandmortyapi.com/api/episode/35",
                "https://rickandmortyapi.com/api/episode/36",
                "https://rickandmortyapi.com/api/episode/37",
                "https://rickandmortyapi.com/api/episode/38",
                "https://rickandmortyapi.com/api/episode/39",
                "https://rickandmortyapi.com/api/episode/40",
                "https://rickandmortyapi.com/api/episode/41",
                "https://rickandmortyapi.com/api/episode/42",
                "https://rickandmortyapi.com/api/episode/43",
                "https://rickandmortyapi.com/api/episode/44",
                "https://rickandmortyapi.com/api/episode/45",
                "https://rickandmortyapi.com/api/episode/46",
                "https://rickandmortyapi.com/api/episode/47",
                "https://rickandmortyapi.com/api/episode/48",
                "https://rickandmortyapi.com/api/episode/49",
                "https://rickandmortyapi.com/api/episode/50",
                "https://rickandmortyapi.com/api/episode/51"
            ],
            "url": "https://rickandmortyapi.com/api/character/1",
            "created": "2017-11-04T18:48:46.250Z"
        },
        {
            "id": 290,
            "name": "Rick Sanchez",
            "status": "Dead",
            "species": "Human",
            "type": "",
            "gender": "Male",
            "origin": {
                "name": "Earth (Evil Rick's Target Dimension)",
                "url": "https://rickandmortyapi.com/api/location/34"
            },
            "location": {
                "name": "Earth (Evil Rick's Target Dimension)",
                "url": "https://rickandmortyapi.com/api/location/34"
            },
            "image": "https://rickandmortyapi.com/api/character/avatar/290.jpeg",
            "episode": [
                "https://rickandmortyapi.com/api/episode/10"
            ],
            "url": "https://rickandmortyapi.com/api/character/290",
            "created": "2017-12-31T20:15:25.716Z"
        },
        {
            "id": 293,
            "name": "Rick Sanchez",
            "status": "Dead",
            "species": "Human",
            "type": "",
            "gender": "Male",
            "origin": {
                "name": "Earth (Replacement Dimension)",
                "url": "https://rickandmortyapi.com/api/location/20"
            },
            "location": {
                "name": "Earth (Replacement Dimension)",
                "url": "https://rickandmortyapi.com/api/location/20"
            },
            "image": "https://rickandmortyapi.com/api/character/avatar/293.jpeg",
            "episode": [
                "https://rickandmortyapi.com/api/episode/6"
            ],
            "url": "https://rickandmortyapi.com/api/character/293",
            "created": "2017-12-31T20:22:29.032Z"
        },
        {
            "id": 631,
            "name": "Rick Sanchez",
            "status": "Alive",
            "species": "Human",
            "type": "Soulless Puppet",
            "gender": "Male",
            "origin": {
                "name": "Story Train",
                "url": "https://rickandmortyapi.com/api/location/96"
            },
            "location": {
                "name": "Story Train",
                "url": "https://rickandmortyapi.com/api/location/96"
            },
            "image": "https://rickandmortyapi.com/api/character/avatar/631.jpeg",
            "episode": [
                "https://rickandmortyapi.com/api/episode/37"
            ],
            "url": "https://rickandmortyapi.com/api/character/631",
            "created": "2020-08-06T16:39:08.485Z"
        }
    ]
}
```

***

# 6. Интерфейс ResponseBodyExtractionOptions

## 6.1. Извлечение и преобразование данных из тела запроса

| Тип      | Метод                                         | Описание                                                                                       |
|----------|-----------------------------------------------|------------------------------------------------------------------------------------------------|
| <T> T    | as(Class<T> cls)                              | Преобразование тела запроса в **Java объект**                                                  |
| <T> T    | as(Class<T> cls, ObjectMapper mapper)         | Преобразование тела запроса в **Java объект** с помощью маппера                                |
| <T> T    | as(Class<T> cls, ObjectMapperType mapperType) | Преобразование тела запроса в **Java объект** с помощью маппера конкретного типа               |
| <T> T    | as(Type cls)                                  | Преобразование тела запроса в **Java тип**                                                     |
| <T> T    | as(Type cls, ObjectMapper mapper)             | Преобразование тела запроса в **Java тип** с помощью маппера                                   |
| <T> T    | as(Type cls, ObjectMapperType mapperType)     | Преобразование тела запроса в **Java тип** с помощью маппера конкретного типа                  |
| <T> T    | as(TypeRef<T> typeRef)                        | Преобразование тела запроса дженерик тип                                                       |
| <T> T    | path(String path, String... arguments)        | Извлечение данных из тела запроса с помощью **JsonPath** или **XmlPath**                       |
| JsonPath | jsonPath()                                    | Извлечение данных из тела запроса с помощью **JsonPath**                                       |
| JsonPath | jsonPath(JsonPathConfig config)               | Извлечение данных из тела запроса с помощью **JsonPath**                                       |
| XmlPath  | xmlPath()                                     | Извлечение данных из тела запроса с помощью **XmlPath**                                        |
| XmlPath  | xmlPath(XmlPathConfig config)                 | Извлечение данных из тела запроса с помощью **XmlPath**                                        |
| XmlPath  | xmlPath(CompatibilityMode compatibilityMode)  | Извлечение данных из тела запроса с помощью **XmlPath** и **XmlPath.CompatibilityMode**        |
| XmlPath  | htmlPath()                                    | Извлечение данных из тела запроса с помощью **XmlPath** и **XmlPath.CompatibilityMode = HTML** |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String status = response.jsonPath().get("results[0].status").toString();
System.out.println(status);
```

*Пример*

**BDD** стиль.

```java

```

***

# 7. Интерфейс Интерфейс

## 7.1. Получение данных из тела запроса


| Тип         | Метод            | Описание                                                  |
|-------------|------------------|-----------------------------------------------------------|
| byte[]      | asByteArray()    | Получение данных из тела запроса a byte array.            |
| InputStream | asInputStream()  | Получение данных из тела запроса input stream.            |
| String      | asPrettyString() | Получение данных из тела запроса pretty formatted string. |
| String      | asString()       | Получение данных из тела запроса a string.                |

*Пример*

Не **BDD** стиль.

```java

```

*Пример*

**BDD** стиль.

```java

```

***

# 8. Интерфейс ResponseOptions

## 8.1. Получение тела запроса

| Тип           | Метод            | Описание                             |
|---------------|------------------|--------------------------------------|
| ResponseBody  | body()           | Получение тела запроса               |
| ResponseBody  | getBody()        | Получение тела запроса               |
| String        | contentType()    | Получение типа контента тела запроса |
| String        | getContentType() | Получение типа контента тела запроса |

*Пример*

Не **BDD** стиль.

```java

```

*Пример*

**BDD** стиль.

```java

```

## 8.2. Куки

| Тип                | Метод                          | Описание                                                                     |
|--------------------|--------------------------------|------------------------------------------------------------------------------|
| String             | cookie(String name)            | The response cookies as simple name/value pair.                              |
| String             | getCookie(String name)         | Get a single cookie value associated with the given name.                    |
| Map<String,String> | cookies()                      | The response cookies as simple name/value pair.                              |
| Map<String,String> | getCookies()                   | The response cookies as simple name/value pair.                              |
| Cookie             | detailedCookie(String name)    | Get a single cookie including all attributes associated with the given name. |
| Cookie             | getDetailedCookie(String name) | Get a single cookie including all attributes associated with the given name. |
| Cookies            | detailedCookies()              | The response cookies with all the attributes.                                |
| Cookies            | getDetailedCookies()           | The response cookies with all the attributes.                                |

*Пример*

Не **BDD** стиль.

```java

```

*Пример*

**BDD** стиль.

```java

```

## 8.3. Заголовки 

| Тип     | Метод                  | Описание                                                  |
|---------|------------------------|-----------------------------------------------------------|
| String  | header(String name)    | Get a single header value associated with the given name. |
| String  | getHeader(String name) | Get a single header value associated with the given name. |
| Headers | headers()              | The response headers.                                     |
| Headers | getHeaders()           | The response headers.                                     |

*Пример*

Не **BDD** стиль.

```java

```

*Пример*

**BDD** стиль.

```java

```

## 8.4. Статус 

| Тип    | Метод           | Описание                            | 
|--------|-----------------|-------------------------------------|
| int    | statusCode()    | Get the status code of the response |
| int    | getStatusCode() | Get the status code of the response |
| String | statusLine()    | Get the status line of the response |
| String | getStatusLine() | Get the status line of the response |

*Пример*

Не **BDD** стиль.

```java

```

*Пример*

**BDD** стиль.

```java

```

## 8.5. Время

| Тип  | Метод                        | Описание |
|------|------------------------------|----------|
| long | time()                       |          |
| long | getTime()                    |          |
| long | timeIn(TimeUnit timeUnit)    |          |
| long | getTimeIn(TimeUnit timeUnit) |          |

*Пример*

Не **BDD** стиль.

```java

```

*Пример*

**BDD** стиль.

```java

```

***

# 9. Класс RequestSpecification

**RequestSpecification** - класс .

Методы класса **RequestSpecification**:

[io/restassured : RequestSpecification](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.


***

# 6. Класс ResponseSpecification

**ResponseSpecification** - класс .

Методы класса **ResponseSpecification**:

[io/restassured : ResponseSpecification](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

***



***

# Best Practices
https://otus.ru/nest/post/1271/

1. **Выносите end-pointы в отдельное место**

С одной стороны, это очевидно. Но увы, до сих пор нередко встречается код, имеющий захардкоженные end-point'ы в запросе.
В целом же, лучше выносить end-point'ы в статические константы финального класса. Но тут есть нюанс — избегайте антипаттерна «константный интерфейс», т. к. это является плохой практикой. И помните, что REST-assured даёт возможность выносить параметры пути, к примеру:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}

given().pathParams("id", someId).get(EndPoints.users)...;
```

или так

```java
given().get(EndPoints.users, someId)....
```

Кроме того, если вы во многих запросах применяете одинаковый базовый путь,
считается хорошей практикой выносить его в отдельную константу, передавая в basePath, как в примере ниже:


имеем url приложения http://host:port/appname/rest/someEndpoints

```java
private static final basePath = "/appname/rest/";
```

можно задать базовый путь на глобальном уровне,
и он будет использоваться ко всем запросам

```java
RestAssured.basePath = basePath;

// либо на уровне одного запроса:
given().basePath(basePath)...

// либо на уровне спецификации, но об этом поговорим позже
```

То же применимо как к хосту, так и к порту тестируемого программного приложения.

2. **ContentType/Accept**

Эти заголовки применяются почти во всех HTTP-запросах.
Разработчики REST-assured прекрасно это понимают,
поэтому они обеспечили возможность их установки посредством вызова специальных методов:

```java
// вот то плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;
// а вот эта хорошая:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой станет установка данных заголовков в спецификации либо на глобальном уровне.
Результат — повышение читабельности кода.

3. **StatusCode** и т. п.
   Для выполнения проверки каждой составляющей HTTP-ответа, библиотека REST-assured предоставляет удобный синтаксис.
   Но на практике часто можно увидеть следующий код:

```java
// это плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());
```

```java
//а это хорошая:
given()...when().get(someEndpoint).then().statusCode(200);
```

4. **Используйте спецификации**
   Мы знаем, что дублировать код не есть хорошо. Для уменьшения дублирования нужно использовать спецификации.
   В REST-assured есть возможность создания спецификации и для запроса, и для ответа.
   В спецификацию запроса можно вынести всё, что можно продублировать в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// мы можем задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// либо для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

Кроме того, в спецификацию ответа можно выносить все проверки, дублируемые от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// мы можем задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// либо для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;

```

Также мы можем создавать несколько спецификаций для различных типов запросов/ответов и применять их в нужном случае.

5. **Не надо писать собственные костыли для преобразования объектов**
   Не нужно преобразовывать свои POJO в JSON, используя Jackson ObjectMapper'а, а потом передавать полученную строку в тело запроса. Почему? Потому что с этой задачей отлично справляется библиотека REST-assured. Причём применяется всё тот же Jackson либо Gson с учётом того, что находится в classpath. А чтобы выполнить преобразование в XML, применяется JAXB. Что касается исходного формата, то он определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое действует и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Вдобавок к вышесказанному, REST-assured хорошо справляется и с преобразованием HashMap в JSON и в обратном порядке.

6. Используйте всю силу Groovy
   Так как сама библиотека написана на Groovy, она даёт возможность использовать к полученному JSON/XML-ответу разные методы из Groovy. Допустим:

```java
// методы find, findAll используются к коллекции для поиска первого и всех вхождений, а метод collect — для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно, указывая на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можно явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// можно применять методы max, min, sum в целях суммирования всех значений коллекции и поиска максимального и минимально значений

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Применение методов из Groovy сократит количество кода, написанного вами в целях поиска необходимого значения из ответа.


https://qa.crtweb.ru/docs/testing/auto/api/rest-assured-best-practices/

**Используйте спецификации**

Конструкция типа

```java
given().accept(ContentType.JSON)
```

используется абсолютно в каждом запросе, и, даже если это всего две строчки, их можно сократить до вызова одного метода, увеличив тем самым читаемость кода, если вынести их в отдельный метод:

```java
public static RequestSpecification requestSpec() {
    return given()
        .accept(ContentType.JSON);
}
```

или билдер:

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setAccept(ContentType.JSON)
    .build();
```

А в каждом запросе достаточно использовать только вызов этого метода или билдера.

Кроме того, на деле вряд ли весь код, который можно было бы вынести в спецификацию запроса ограничивается двумя строками – наверняка туда можно добавить заголовки для авторизации, установку хоста и порта, настройки логирования, фильтры для Allure и что угодно еще, что необходимо выполнять при каждом запросе.

То же самое можно сделать и с ответом. В нем можно проверить статус-код, время ожидания ответа, а так же наличие необходимых полей в теле ответа или заголовков. Как и в случае с запросом, можно использовать метод:

```java
public static ValidatableResponse responseSpecOk(Response response) {
    return response
        .then()
        .statusCode(200)
        .time(lessThanOrEqualTo(responseTime));
}
```

или билдер:

```java
ResponseSpecification responseSpecOk = new ResponseSpecBuilder()
        .expectStatusCode(200)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
```

**Храните эндпойнты в отдельном месте**

Не стоит отдельно прописывать эндпойнт для каждого запроса.
Даже если их немного, при необходимости внесения изменений что-то все равно может потеряться и поиск проблемы гарантированно займет куда больше времени, чем организация корректного хранения эндпойнтов.

Тут есть несколько вариантов:

если для каждого эндпойнта существует свой собственный класс, можно просто хранить их в переменных этого класса;
можно создать отдельный класс для управления эндпойнтами, и хранить все эндпойнты в переменных этого класса;
и, наконец, эндпойнты можно хранить в отдельном property-файле.

В случае, если эндпойнт включает в себя какое-то изменяемое значение (например, ID), можно пользоваться записью такого вида:

```java
String endpoint = endpoint/{id}
```

В таком случае, подставить на место значения в фигурных скобках нужную переменную можно будет следующим образом:

```java
.get(endpoint, id)
```

Однако стоит иметь в виду, что подобная запись не всегда работает корректно, так что в некоторых проектах, возможно, придется обходиться без нее.

**Выносите base URI в properties**

Так же, как и упомянутые выше заголовки, скорее всего часть URL повторяется в каждом запросе. Ее также можно вынести в отдельное место и объявить только один раз.

Для этого удобнее всего вынести baseURI в properties-файл и получать его значение через класс типа ManageProperties. Объявить baseURI можно двумя способами:

```java
given()
    .baseUri(getProperty("baseUri"))
```

или

```java
RestAssured.baseURI = getProperty("baseUri");
```

Что касается непосредственно самого вызова baseURI, тут тоже есть пара вариантов:

Первый – вызывать его в каждом запросе. Такой вариант выглядит более громоздко, но подойдет в том случае, если в определенных случаях нужно использовать другой base URI.

Второй – объявить его однократно, например, в спецификации запроса.

**Используйте функционал Rest Assured для преобразования объектов**

Нет необходимости преобразовывать POJO в Json с помощью возможностей внешних библиотек, так как Rest Assured прекрасно справляется с этим самостоятельно. Достаточно добавить нужный POJO в тело запроса:

```java
Pojo pojo = new Pojo();
```

```java
given()
    .body(pojo)
    .post(URI);
```

Обратный процесс также работает:

```java
Pojo pojo = given()
    .get(URI)
    .then
    .extract().body().as(Pojo.class)
```

Кроме того, Rest Assured умеет преобразовывать в Json и HashMap, в том числе и вложенные:

```java
Map <Object, Object> outerMap = new HashMap<Object, Object>();
Map <Object, Object> innerMap = new HashMap<Object, Object>();

innerMap.put("key", "value");

outerMap.put("key", "value");
outerMap.put("innerMap", innerMap);

given()
    .body(outerMap)
    .post(URI);
```

**Используйте валидацию Json-схемы**

Валидация Json-схемы - это простой и надежный способ убедиться, что полученные данные соответствуют ожидаемому формату. Json-схема имеет следующий вид:

```json
{
    "type": "object",
    "properties": {
        "id": {
            "type": "integer"
        },
        "item": {
            "type": "object",
            "properties": {
                "key1": {
                    "type": ["string", "integer"]
                },
                "key2": {
                    "type": "string"
                }

            },
            "required": ["key1", "key2"]
        }
    },
    "required": ["id", "item"]
}

```

Создавать Json-схемы можно и вручную, но из-за не слишком человекоориентированного формата это может быть довольно утомительно, так что куда проще использовать для этого любой из многочисленных автоматических инструментов. Например: https://www.liquid-technologies.com/online-json-to-schema-converter

Такая схема проверяет, что полученный в ответе Json содержит в себе все поля, которые указаны как обязательные, и что тип данных в каждом из этих полей соответствует ожидаемому.

Для использования валидации Json-схем понадобится установить библиотеку json-schema-validator (в данном случае используется библиотека от io.rest-assured) и использовать следующий метод:

```java
.body(matchesJsonSchemaInClasspath("schema.json"));
```

**Выносите повторяющиеся действия в отдельные методы**

Нет никакой необходимости десять раз проверять, что ответ на запрос в десяти тестах соответствует схеме, достаточно один раз написать отдельный метод, который проводит эту проверку, и в дальнейшем просто обращаться к нему.

Это справедливо и для любых повторяющихся действий – намного удобнее читать (и тем более писать!) код, в котором все спецификации, конструкторы и проверки разбиты на отдельные блоки, из которых можно создать нужные тесты. Например, вот так:

```java
public static RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri(BASE_URI)
    .setContentType(ContentType.JSON)
    .setAccept(ContentType.JSON)
    .build();

public static ResponseSpecification responseSpec(int statusCode) {
    return new ResponseSpecBuilder()
            .expectStatusCode(statusCode)
            .expectResponseTime(lessThanOrEqualTo(responseTime))
            .build();
}

public static Response createItem(Pojo body) {
    return given()
        .spec(requestSpec)
        .body(body)
        .post(Uri);
    }

public static ValidatableResponse createItem_valid(Response response) {
    return response
            .then()
            .spec(responseSpec(200))
            .body(matchesJsonSchemaInClasspath("schemas/CreateItem.json"));
}

@Test
public void createItemTest() {
    createItem_valid(
        createItem(body))
}
```

**Используйте Hamcrest Matchers**

В случе, когда нет необходимости десериализовать ответ в POJO, мэтчеры из библиотеки Hamcrest являются самым быстрым способом повести валидацию отдельных элементов содержимого ответа.

Они позволяют проверить, что, например, ответ содержит в себе определенную строку или значение, или что конкретное поле равно определенному значению, или что массив содержит в себе некоторый набор элементов в произвольном порядке.

```java
.body("id", equals(getId()))
.body("id", greaterThanOrEqualTo(1))
.body("items", either(hasItem("a")).and(hasItem("b"))
```

Все выполняемые мэтчерами проверки, несомненно, можно произвести и другими способами, однако они позволяют сделать это в краткой и удобной для чтения форме.

С полной документацией к мэтчерам можно ознакомиться здесь: http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html

**Используйте методы для добавления заголовков**

Так как по крайней мере один из этих заголовков используется практически в любом запросе, для них был создан более краткий вариант записи:

```java
given()
	.contentType(ContentType.JSON)
	.accept(ContentType.JSON)
```

Такой вариант немного короче обычной записи заголовков через метод header и, что более важно, минимизирует шанс возникновения ошибки из-за опечатки.

Однако стоит обратить внимание на то, что при таком оформлении заголовков в Accept помимо application/json также передаются application/javascript, text/javascript и text/json. В некоторых API это может привести к ошибкам, и в таком случае enum ContentType стоит заменить на строку с указанием конкретного типа данных.

**Проверяйте статус-код без assertThat**

Запись типа

```java
.assertThat(statusCode(200))
```

просто излишня. Эта строка выполняет ту же самую работу:

```java
.statusCode(200)
```

**Передавайте статус-коды в качестве аргумента**

При наличии большого количества негативных проверок с разными ожидаемыми кодами ошибок, нет необходимости писать отдельную спецификацию под каждый статус-код, вместо этого можно просто добавить спецификацию в метод и передавать в нее ожидаемый статус-код из теста:

```java
public static ResponseSpecification responseSpecError(int statusCode) {
    return new ResponseSpecBuilder()
        .expectStatusCode(statusCode)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
}
```

**Используйте логирование для отладки тестов**

Метод .log() позволяет получить информацию как об отправленном запросе, так и о полученном ответе. В первом случае необходимо его применить до отправки запроса (get, post и т.д.), во втором случае – после.

Вам доступны следующие методы:

```java
.log().all()
.log().params()
.log().body()
.log().headers()
.log().cookies()
```

Однако оставлять логирование в тестах, которые уже дописаны и корректно работают, не стоит – объем в информации в логах может быть настолько большим, что результаты всех тестов перестанут умещаться в консоли IDE, не говоря уже о том, что просматривать результаты тестов в таком случае будет очень неудобно.

https://habr.com/ru/post/421005/

**Выносите end-point'ы в отдельное место**

Казалось бы, что это очевидно. Но нет, довольно часто приходится видеть код с захардкоженными end-point'ми в запросе.

Лучше всего выносить end-point'ы в статические константы финального класса. При этом стоит избегать антипаттерн «константный интерфейс» — это плохая практика.

Не забывайте, что REST-assured позволяет выносить параметры пути, например:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}
```

```java
given().pathParams("id", someId).get(EndPoints.users)...;

// или так

given().get(EndPoints.users, someId)....
```

Также, если во многих запросах вы используете один и тот же базовый путь, то будет хорошей практикой вынести его в отельную константу и передавать в basePath, например:

```java
// имеем следующий url приложения http://host:port/appname/rest/someEndpoints

private static final basePath = "/appname/rest/";

..

// можем задать базовый путь на глобальном уровне,
// он будет применяться ко всем запросам:
RestAssured.basePath = basePath;

// или на уровне одного запроса:
given().basePath(basePath)...

// или на уровне спецификации, но об этом далее
```

То же самое применимо к хосту и порту тестируемого приложения.

```java
ContentType/Accept
```
Данные заголовки используются практически во всех HTTP-запросах. Авторы REST-assured, понимая это, сделали возможным их установку через вызов специальных методов:

```java
// плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;

// хорошая практика написания:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой будет установить данные заголовки в спецификации или на глобальном уровне. Это повысит читабельность вашего кода.

**StatusCode и т.п.**

REST-assured предоставляет удобный синтаксис для проведения проверки каждой составляющей HTTP-ответа, однако на практике продолжаешь встречать подобный код:

```java
// плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());

// хорошая практика написания:
given()...when().get(someEndpoint).then().statusCode(200);
```

**Используйте спецификации**

Дублирование кода — это плохо. Используйте спецификации для уменьшения дублирования. В REST-assured можно создавать спецификации как для запроса, так и для ответа. В спецификацию запроса выносим всё, что может быть продублировано в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// можно задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// или для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

В спецификацию ответа выносим все проверки, которые дублируются от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// можно задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// или для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;
```

Можно создавать несколько спецификаций для разных типов запросов/ответов и использовать в нужной ситуации.

**Не пишите свои костыли для преобразования объектов**

Не стоит преобразовывать свои POJO в JSON при помощи Jackson ObjectMapperа, а потом полученную строку передавать в тело запроса. REST-assured прекрасно справляется с этой задачей. Для этого используется всё тот же Jackson или Gson, в зависимости от того, что находится в classpath. Для преобразования в XML используется JAXB. Исходный формат определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Кроме того REST-assured прекрасно справляется с преобразованием HashMap в JSON и обратно.


**Используйте всю мощь Groovy**

Сама библиотека REST-assured написана на Groovy и позволяет вам применять различные методы из Groovy к полученному JSON/XML ответу. Например:

```java
// методы find, findAll применяются к коллекции для поиска первого и всех вхождений, метод collect для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// вы можете использовать методы sum, max, min для суммирования всех значений коллекции, а также поиска максимального и минимально значения

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Использование методов из Groovy позволяет сильно сократить количество кода, написанного вами для поиска необходимого значения из ответа.

На этом всё, если у вас есть еще советы и примеры пишите их в комментариях.



***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)