Java_QA / 14. API. REST Assured

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* []()
* []()
* []()
* []()

***

# 1. REST Assured

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html

# Класс 

# Given When Then

**Given** -	keyword, lets you set a background, here, you pass the request headers, query and path param, body, cookies.
This is optional if these items are not needed in the request

**When** - keyword marks the premise of your scenario. For example, ‘when’ you get/post/put something, do something else.
with any of the CRUD operations(get/post/put/delete)

**Then** - assert and matcher conditions go here

https://devqa.io/rest-assured-api-requests-examples/

# Given

**Given** -	keyword, lets you set a background, here, you pass the request headers, query and path param, body, cookies.
This is optional if these items are not needed in the request

static RequestSpecification	given()
Start building the request part of the test io.restassured.specification.

https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/RequestSpecification.html

# When

**When** - keyword marks the premise of your scenario. For example, ‘when’ you get/post/put something, do something else.
with any of the CRUD operations(get/post/put/delete)

static RequestSender	when()
Start building the DSL expression by sending a request without any parameters or headers etc.

https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/RequestSender.html

# Then

**Then** - assert and matcher conditions go here

T	then()
Returns a validatable response that's lets you validate the response.




# Get

The HTTP GET request is used to fetch a resource from a server.
The following example uses the get() method from REST-assured library.

GET Request

```java
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;

public class RestAssuredRequests {

    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";
    }

    @Test
    public void getRequest() {
        Response response = given()
                .contentType(ContentType.JSON)
                .when()
                .get("/posts")
                .then()
                .extract().response();

        Assertions.assertEquals(200, response.statusCode());
        Assertions.assertEquals("qui est esse", response.jsonPath().getString("title[1]"));
    }
}
```

GET Request With Query Params

```java
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;

public class RestAssuredRequests {

    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";
    }

    @Test
    public void getRequestWithQueryParam() {
        Response response = given()
                .contentType(ContentType.JSON)
                .param("postId", "2")
                .when()
                .get("/comments")
                .then()
                .extract().response();

        Assertions.assertEquals(200, response.statusCode());
        Assertions.assertEquals("Meghan_Littel@rene.us", response.jsonPath().getString("email[3]"));
    }
}
```

Non-BDD Style Code

```java
package RestfulBooker.getExamples;

import org.testng.annotations.Test;

import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class NonBDDStyleGetRequest {
	// Without static import and builder pattern
	@Test
	public void GetBookingIds_VerifyStatusCode() {
		// Create a request specification 
		RequestSpecification request= RestAssured.given();
		//Adding URI
		request.baseUri("https://restful-booker.herokuapp.com/booking");
		// Calling GET method on URI. After hitting we get Response
		Response response = request.get();
		// Let's print response body.
		String resString = response.asString();
		System.out.println("Respnse Details : " + resString);
		/*
		 * To perform validation on response like status code or value, we need to get
		 * ValidatableResponse type of response using then() method of Response
		 * interface. ValidatableResponse is also an interface.
		 */
		ValidatableResponse valRes = response.then();
		// It will check if status code is 200
		valRes.statusCode(200);
		// It will check if status line is as expected
		valRes.statusLine("HTTP/1.1 200 OK");
	}
}
```

```java
package RestfulBooker.getExamples;
 
import org.testng.annotations.Test;
 
import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;
 
public class NonBDDStyleGetRequest {
 
	// Without static import and builder pattern
	@Test
	public void GetBookingIds_VerifyStatusCode() {
		// Create a request specification 
		RequestSpecification request= RestAssured.given();
		//Adding URI
		request.baseUri("https://restful-booker.herokuapp.com/booking");
		// Calling GET method on URI. After hitting we get Response
		Response response = request.get();
		// Let's print response body.
		String resString = response.asString();
		System.out.println("Respnse Details : " + resString);
		/*
		 * To perform validation on response like status code or value, we need to get
		 * ValidatableResponse type of response using then() method of Response
		 * interface. ValidatableResponse is also an interface.
		 */
		ValidatableResponse valRes = response.then();
		// It will check if status code is 200
		valRes.statusCode(200);
		// It will check if status line is as expected
		valRes.statusLine("HTTP/1.1 200 OK");
	}
}
```



```java
package RestfulBooker.getExamples;

import org.hamcrest.Matchers;
import org.testng.annotations.Test;

import io.restassured.RestAssured;

public class BDDStyleGetRequest {
	@Test
	public void GetBookingIds_VerifyStatusCode() {
		// Given
		RestAssured.given()
			.baseUri("https://restful-booker.herokuapp.com")
		// When
		.when()
			.get("/booking")
		// Then
		.then()
			.statusCode(200)
			.statusLine("HTTP/1.1 200 OK")
			// To verify booking count
			.body("bookingid.sum()", Matchers.hasSize(10))
			// To verify booking id at index 3
			.body("bookingid[3]", Matchers.equalTo(1));			
	}
}
```

```java
package RestfulBooker.getExamples;

import static org.hamcrest.Matchers.*;
import static io.restassured.RestAssured.*;
import org.testng.annotations.Test;

public class BDDStyleGetRequestWithStaticImport {
	@Test
	public void GetBookingIds_VerifyStatusCode() {
		// Given
		given()
			.baseUri("https://restful-booker.herokuapp.com")
		// When
		.when()
			.get("/booking")
		// Then
		.then()
			.statusCode(200)
			.statusLine("HTTP/1.1 200 OK")
			// To verify booking count
			.body("bookingid", hasSize(10))
			// To verify booking id at index 3
			.body("bookingid[3]", equalTo(1));			
	}
}
```

# Post

HTTP POST request is used to post data or create a resource on a server.
To send a POST request in REST-assured, we use the post() method.

POST Request

```java
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;

public class RestAssuredRequests {

    private static String requestBody = "{\n" +
            "  \"title\": \"foo\",\n" +
            "  \"body\": \"bar\",\n" +
            "  \"userId\": \"1\" \n}";

    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";
    }

    @Test
    public void postRequest() {
        Response response = given()
                .header("Content-type", "application/json")
                .and()
                .body(requestBody)
                .when()
                .post("/posts")
                .then()
                .extract().response();

        Assertions.assertEquals(201, response.statusCode());
        Assertions.assertEquals("foo", response.jsonPath().getString("title"));
        Assertions.assertEquals("bar", response.jsonPath().getString("body"));
        Assertions.assertEquals("1", response.jsonPath().getString("userId"));
        Assertions.assertEquals("101", response.jsonPath().getString("id"));
    }
}
```

Non-BDD Style

```java
package RestfulBooker.postExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class NonBDDStylePostRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within double 
        // quotes. It will automatically add escape sequence as required. 
        String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";
        // Create a request specification 
        RequestSpecification request= RestAssured.given();
        // Setting content type to specify format in which request payload will be sent.
        // ContentType is an ENUM. 
        request.contentType(ContentType.JSON);
        //Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/auth");
        // Adding body as string
        request.body(jsonString);
        // Calling POST method on URI. After hitting we get Response
        Response response = request.post();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 200
        validatableResponse.statusCode(200);
        // Validate token field is null
        // SInce response is one to one mapping so passing key name will give you value.
        // Below method validates that value of token is not null.
        validatableResponse.body("token", Matchers.notNullValue());
        // Validate token length is 15
        validatableResponse.body("token.length()", Matchers.is(15));
        // Validate token is an alphanumeric value
        validatableResponse.body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
    }
}
```

```java
package RestfulBooker.postExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class NonBDDStylePostRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within double 
        // quotes. It will automatically add escape sequence as required. 
        String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";
        // Create a request specification 
        RequestSpecification request= RestAssured.given();
        // Setting content type to specify format in which request payload will be sent.
        // ContentType is an ENUM. 
        request.contentType(ContentType.JSON);
        //Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/auth");
        // Adding body as string
        request.body(jsonString);
        // Calling POST method on URI. After hitting we get Response
        Response response = request.post();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 200
        validatableResponse.statusCode(200);
        // Validate token field is null
        // SInce response is one to one mapping so passing key name will give you value.
        // Below method validates that value of token is not null.
        validatableResponse.body("token", Matchers.notNullValue());
        // Validate token length is 15
        validatableResponse.body("token.length()", Matchers.is(15));
        // Validate token is an alphanumeric value
        validatableResponse.body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
    }
}
```

BDD Style

```java
package RestfulBooker.postExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;

public class BDDStylePostRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within double 
        // quotes. It will automatically add escape sequence as required. 
        String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";
        //GIVEN
        RestAssured
        .given()
            .baseUri("https://restful-booker.herokuapp.com/auth")
            .contentType(ContentType.JSON)
            .body(jsonString)
        // WHEN
        .when()
            .post()
        // THEN
        .then()
            .assertThat()
            .statusCode(200)
            .body("token", Matchers.notNullValue())
            .body("token.length()", Matchers.is(15))
            .body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
    }
}
```

```java
package RestfulBooker.postExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;

public class BDDStylePostRequest {

    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within double 
        // quotes. It will automatically add escape sequence as required. 
        String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";
        //GIVEN
        RestAssured
        .given()
            .baseUri("https://restful-booker.herokuapp.com/auth")
            .contentType(ContentType.JSON)
            .body(jsonString)
        // WHEN
        .when()
            .post()
        // THEN
        .then()
            .assertThat()
            .statusCode(200)
            .body("token", Matchers.notNullValue())
            .body("token.length()", Matchers.is(15))
            .body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
    }
}
```

# Put

The PUT request updates a resource but requires the full JSON payload.
To send a PUT request in REST-assured, we use the put() method

PUT Request

```java
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;

public class RestAssuredRequests {

    private static String requestBody = "{\n" +
            "  \"title\": \"foo\",\n" +
            "  \"body\": \"baz\",\n" +
            "  \"userId\": \"1\",\n" +
            "  \"id\": \"1\" \n}";

    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";
    }

    @Test
    public void putRequest() {
        Response response = given()
                .header("Content-type", "application/json")
                .and()
                .body(requestBody)
                .when()
                .put("/posts/1")
                .then()
                .extract().response();

        Assertions.assertEquals(200, response.statusCode());
        Assertions.assertEquals("foo", response.jsonPath().getString("title"));
        Assertions.assertEquals("baz", response.jsonPath().getString("body"));
        Assertions.assertEquals("1", response.jsonPath().getString("userId"));
        Assertions.assertEquals("1", response.jsonPath().getString("id"));
    }
}
```

Non-BDD Style

```java
package RestfulBooker.putExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class NonBDDPutRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
                + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
                + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
                + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";
        // Create a request specification
        RequestSpecification request = RestAssured.given();
        // Setting content type to specify format in which request payload will be sent.
        // ContentType is an ENUM.
        request.contentType(ContentType.JSON);
        // Setting a cookie for authentication as per API documentation
        request.cookie("token", "fa0d5b1138a0d1f");
        // Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Adding body as string
        request.body(jsonString);
        // Calling PUT method on URI. After hitting we get Response
        Response response = request.put();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 200
        validatableResponse.statusCode(200);
        // Validate value of firstName is updated
        validatableResponse.body("firstname", Matchers.equalTo("Amod"));
        // Validate value of lastName is updated
        validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

```java
package RestfulBooker.putExamples;
    
import org.hamcrest.Matchers;
    
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;
    
public class NonBDDPutRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
                + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
                + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
                + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";
        // Create a request specification
        RequestSpecification request = RestAssured.given();
        // Setting content type to specify format in which request payload will be sent.
        // ContentType is an ENUM.
        request.contentType(ContentType.JSON);
        // Setting a cookie for authentication as per API documentation
        request.cookie("token", "fa0d5b1138a0d1f");
        // Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Adding body as string
        request.body(jsonString);
        // Calling PUT method on URI. After hitting we get Response
        Response response = request.put();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 200
        validatableResponse.statusCode(200);
        // Validate value of firstName is updated
        validatableResponse.body("firstname", Matchers.equalTo("Amod"));
        // Validate value of lastName is updated
        validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

BDD Style:-

```java
package RestfulBooker.putExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class BDDStylePutRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
                + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
                + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
                + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";
        //GIVEN
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
                    .cookie("token", "e88375c0fde687a")
                    .contentType(ContentType.JSON)
                    .body(jsonString)
            // WHEN
            .when()
                    .put()
            // THEN
            .then()
                    .assertThat()
                    .statusCode(200)
                    .body("firstname", Matchers.equalTo("Amod"))
                    .body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

```java
package RestfulBooker.putExamples;
    
import org.hamcrest.Matchers;
    
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;
    
public class BDDStylePutRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
                + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
                + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
                + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";
        //GIVEN
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
                    .cookie("token", "e88375c0fde687a")
                    .contentType(ContentType.JSON)
                    .body(jsonString)
            // WHEN
            .when()
                    .put()
            // THEN
            .then()
                    .assertThat()
                    .statusCode(200)
                    .body("firstname", Matchers.equalTo("Amod"))
                    .body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

# Patch

The PATCH request updates a resource but requires only the field(s) which is being updated in the payload

PATCH request

```java
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;

public class RestAssuredRequests {

    private static String requestBody = "{\n" +
            "  \"title\": \"bax\" \n}";

    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";
    }

    @Test
    public void patchRequest() {
        Response response = given()
                .header("Content-type", "application/json")
                .and()
                .body(requestBody)
                .when()
                .patch("/posts/1")
                .then()
                .extract().response();

        Assertions.assertEquals(200, response.statusCode());
        Assertions.assertEquals("bax", response.jsonPath().getString("title"));
        Assertions.assertEquals("1", response.jsonPath().getString("userId"));
        Assertions.assertEquals("1", response.jsonPath().getString("id"));
    }
}
```

Non-BDD Style

```java
package RestfulBooker.patchExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class NonBDDPatchRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + 
                "    \"firstname\" : \"Amod\",\r\n" + 
                "    \"lastname\" : \"Mahajan\"}";
        // Create a request specification
        RequestSpecification request = RestAssured.given();
        // Setting content type to specify format in which request payload will be sent.
        // ContentType is an ENUM.
        request.contentType(ContentType.JSON);
        // Setting a cookie for authentication as per API documentation
        request.cookie("token", "974c253452ba510");
        // Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Adding body as string
        request.body(jsonString);
        // Calling PATCH method on URI. After hitting we get Response
        Response response = request.patch();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 200
        validatableResponse.statusCode(200);
        // Validate value of firstName is updated
        validatableResponse.body("firstname", Matchers.equalTo("Amod"));
        // Validate value of lastName is updated
        validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

```java
package RestfulBooker.patchExamples;
    
import org.hamcrest.Matchers;
    
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;
    
public class NonBDDPatchRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + 
                "    \"firstname\" : \"Amod\",\r\n" + 
                "    \"lastname\" : \"Mahajan\"}";
        // Create a request specification
        RequestSpecification request = RestAssured.given();
        // Setting content type to specify format in which request payload will be sent.
        // ContentType is an ENUM.
        request.contentType(ContentType.JSON);
        // Setting a cookie for authentication as per API documentation
        request.cookie("token", "974c253452ba510");
        // Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Adding body as string
        request.body(jsonString);
        // Calling PATCH method on URI. After hitting we get Response
        Response response = request.patch();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 200
        validatableResponse.statusCode(200);
        // Validate value of firstName is updated
        validatableResponse.body("firstname", Matchers.equalTo("Amod"));
        // Validate value of lastName is updated
        validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

BDD Style

```java
package RestfulBooker.patchExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class BDDStylePatchRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + 
                "    \"firstname\" : \"Amod\",\r\n" + 
                "    \"lastname\" : \"Mahajan\"}";
        //GIVEN
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
                    .cookie("token", "6608dc75eedd44f")
                    .contentType(ContentType.JSON)
                    .body(jsonString)
            // WHEN
            .when()
                    .patch()
            // THEN
            .then()
                    .assertThat()
                    .statusCode(200)
                    .body("firstname", Matchers.equalTo("Amod"))
                    .body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

```java
package RestfulBooker.patchExamples;

import org.hamcrest.Matchers;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class BDDStylePatchRequest {
    public static void main(String[] args) {
        // There is no need to add escape character manually. Just paste string within
        // double
        // quotes. It will automatically add escape sequence as required.
        String jsonString = "{\r\n" + 
                "    \"firstname\" : \"Amod\",\r\n" + 
                "    \"lastname\" : \"Mahajan\"}";
        //GIVEN
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
                    .cookie("token", "6608dc75eedd44f")
                    .contentType(ContentType.JSON)
                    .body(jsonString)
            // WHEN
            .when()
                    .patch()
            // THEN
            .then()
                    .assertThat()
                    .statusCode(200)
                    .body("firstname", Matchers.equalTo("Amod"))
                    .body("lastname", Matchers.equalTo("Mahajan"));
    }
}
```

# Delete

The DELETE request is used to delete a resource from a server.
To send a DELETE request in REST-assured, we use the delete() method

DELETE Request

```java
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;

public class RestAssuredRequests {

    @BeforeAll
    public static void setup() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";
    }

    @Test
    public void deleteRequest() {
        Response response = given()
                .header("Content-type", "application/json")
                .when()
                .delete("/posts/1")
                .then()
                .extract().response();

        Assertions.assertEquals(200, response.statusCode());
    }
}
```

Non-BDD Style

```java
package RestfulBooker.deleteExamples;

import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;

public class NonBDDDeleteRequest {
    public static void main(String[] args) {
        // Create a request specification
        RequestSpecification request = RestAssured.given();
        // Setting a cookie for authentication as per API documentation
        request.cookie("token", "f4e70e7b9bbcd05");
        // Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Calling PUT method on URI. After hitting we get Response
        Response response = request.delete();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 201 as per API documentation
        validatableResponse.statusCode(201);
        // Validate if booking is actually deleted. 
        RequestSpecification getRequestSpec = RestAssured.given();
        // Adding URI
        getRequestSpec.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Calling GET request
        Response res = getRequestSpec.get();
        // Get Validatable response to perform validation
        ValidatableResponse valRes = res.then();
        // It will check if status code is 404 as booking id should not be found
        valRes.statusCode(404);
    }
}
```

```java
package RestfulBooker.deleteExamples;
    
import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.response.ValidatableResponse;
import io.restassured.specification.RequestSpecification;
    
public class NonBDDDeleteRequest {
    public static void main(String[] args) {
        // Create a request specification
        RequestSpecification request = RestAssured.given();
        // Setting a cookie for authentication as per API documentation
        request.cookie("token", "f4e70e7b9bbcd05");
        // Adding URI
        request.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Calling PUT method on URI. After hitting we get Response
        Response response = request.delete();
        // Printing Response as string
        System.out.println(response.asString());
        // Get Validatable response to perform validation
        ValidatableResponse validatableResponse = response.then();
        // Validate status code as 201 as per API documentation
        validatableResponse.statusCode(201);
        // Validate if booking is actually deleted. 
        RequestSpecification getRequestSpec = RestAssured.given();
        // Adding URI
        getRequestSpec.baseUri("https://restful-booker.herokuapp.com/booking/1");
        // Calling GET request
        Response res = getRequestSpec.get();
        // Get Validatable response to perform validation
        ValidatableResponse valRes = res.then();
        // It will check if status code is 404 as booking id should not be found
        valRes.statusCode(404);
    }
}
```

BDD Style

```java    
package RestfulBooker.deleteExamples;

import io.restassured.RestAssured;

public class BDDStyleDeleteRequest {
    public static void main(String[] args) {
        // Delete Booking
        //GIVEN
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
                    .cookie("token", "f7dddb1093eab19")
            // WHEN
            .when()
                    .delete()
            // THEN
            .then()
                    .assertThat()
                    .statusCode(201);
        // Verifying booking is deleted
        // Given
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
        // When
            .when()
                    .get()
        // Then
            .then()
                    .statusCode(404);
    }
}

package RestfulBooker.deleteExamples;
    
import io.restassured.RestAssured;
    
public class BDDStyleDeleteRequest {
    public static void main(String[] args) {
        // Delete Booking
        RestAssured
            //GIVEN
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
                    .cookie("token", "f7dddb1093eab19")
            // WHEN
            .when()
                    .delete()
            // THEN
            .then()
                    .assertThat()
                    .statusCode(201);
        // Verifying booking is deleted
        // Given
        RestAssured
            .given()
                    .baseUri("https://restful-booker.herokuapp.com/booking/1")
        // When
            .when()
                    .get()
        // Then
            .then()
                    .statusCode(404);
    }
}
```

#


# Best Practices
https://otus.ru/nest/post/1271/

1. **Выносите end-pointы в отдельное место**

С одной стороны, это очевидно. Но увы, до сих пор нередко встречается код, имеющий захардкоженные end-point'ы в запросе.
В целом же, лучше выносить end-point'ы в статические константы финального класса. Но тут есть нюанс — избегайте антипаттерна «константный интерфейс», т. к. это является плохой практикой. И помните, что REST-assured даёт возможность выносить параметры пути, к примеру:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}

given().pathParams("id", someId).get(EndPoints.users)...;
```

или так

```java
given().get(EndPoints.users, someId)....
```

Кроме того, если вы во многих запросах применяете одинаковый базовый путь,
считается хорошей практикой выносить его в отдельную константу, передавая в basePath, как в примере ниже:


имеем url приложения http://host:port/appname/rest/someEndpoints

```java
private static final basePath = "/appname/rest/";
```

можно задать базовый путь на глобальном уровне,
и он будет использоваться ко всем запросам

```java
RestAssured.basePath = basePath;

// либо на уровне одного запроса:
given().basePath(basePath)...

// либо на уровне спецификации, но об этом поговорим позже
```

То же применимо как к хосту, так и к порту тестируемого программного приложения.

2. **ContentType/Accept**

Эти заголовки применяются почти во всех HTTP-запросах.
Разработчики REST-assured прекрасно это понимают,
поэтому они обеспечили возможность их установки посредством вызова специальных методов:

```java
// вот то плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;
// а вот эта хорошая:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой станет установка данных заголовков в спецификации либо на глобальном уровне.
Результат — повышение читабельности кода.

3. **StatusCode** и т. п.
   Для выполнения проверки каждой составляющей HTTP-ответа, библиотека REST-assured предоставляет удобный синтаксис.
   Но на практике часто можно увидеть следующий код:

```java
// это плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());
```

```java
//а это хорошая:
given()...when().get(someEndpoint).then().statusCode(200);
```

4. **Используйте спецификации**
   Мы знаем, что дублировать код не есть хорошо. Для уменьшения дублирования нужно использовать спецификации.
   В REST-assured есть возможность создания спецификации и для запроса, и для ответа.
   В спецификацию запроса можно вынести всё, что можно продублировать в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// мы можем задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// либо для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

Кроме того, в спецификацию ответа можно выносить все проверки, дублируемые от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// мы можем задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// либо для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;

```

Также мы можем создавать несколько спецификаций для различных типов запросов/ответов и применять их в нужном случае.

5. **Не надо писать собственные костыли для преобразования объектов**
   Не нужно преобразовывать свои POJO в JSON, используя Jackson ObjectMapper'а, а потом передавать полученную строку в тело запроса. Почему? Потому что с этой задачей отлично справляется библиотека REST-assured. Причём применяется всё тот же Jackson либо Gson с учётом того, что находится в classpath. А чтобы выполнить преобразование в XML, применяется JAXB. Что касается исходного формата, то он определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое действует и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Вдобавок к вышесказанному, REST-assured хорошо справляется и с преобразованием HashMap в JSON и в обратном порядке.

6. Используйте всю силу Groovy
   Так как сама библиотека написана на Groovy, она даёт возможность использовать к полученному JSON/XML-ответу разные методы из Groovy. Допустим:

```java
// методы find, findAll используются к коллекции для поиска первого и всех вхождений, а метод collect — для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно, указывая на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можно явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// можно применять методы max, min, sum в целях суммирования всех значений коллекции и поиска максимального и минимально значений

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Применение методов из Groovy сократит количество кода, написанного вами в целях поиска необходимого значения из ответа.


https://qa.crtweb.ru/docs/testing/auto/api/rest-assured-best-practices/

**Используйте спецификации**

Конструкция типа

```java
given().accept(ContentType.JSON)
```

используется абсолютно в каждом запросе, и, даже если это всего две строчки, их можно сократить до вызова одного метода, увеличив тем самым читаемость кода, если вынести их в отдельный метод:

```java
public static RequestSpecification requestSpec() {
    return given()
        .accept(ContentType.JSON);
}
```

или билдер:

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setAccept(ContentType.JSON)
    .build();
```

А в каждом запросе достаточно использовать только вызов этого метода или билдера.

Кроме того, на деле вряд ли весь код, который можно было бы вынести в спецификацию запроса ограничивается двумя строками – наверняка туда можно добавить заголовки для авторизации, установку хоста и порта, настройки логирования, фильтры для Allure и что угодно еще, что необходимо выполнять при каждом запросе.

То же самое можно сделать и с ответом. В нем можно проверить статус-код, время ожидания ответа, а так же наличие необходимых полей в теле ответа или заголовков. Как и в случае с запросом, можно использовать метод:

```java
public static ValidatableResponse responseSpecOk(Response response) {
    return response
        .then()
        .statusCode(200)
        .time(lessThanOrEqualTo(responseTime));
}
```

или билдер:

```java
ResponseSpecification responseSpecOk = new ResponseSpecBuilder()
        .expectStatusCode(200)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
```

**Храните эндпойнты в отдельном месте**

Не стоит отдельно прописывать эндпойнт для каждого запроса.
Даже если их немного, при необходимости внесения изменений что-то все равно может потеряться и поиск проблемы гарантированно займет куда больше времени, чем организация корректного хранения эндпойнтов.

Тут есть несколько вариантов:

если для каждого эндпойнта существует свой собственный класс, можно просто хранить их в переменных этого класса;
можно создать отдельный класс для управления эндпойнтами, и хранить все эндпойнты в переменных этого класса;
и, наконец, эндпойнты можно хранить в отдельном property-файле.

В случае, если эндпойнт включает в себя какое-то изменяемое значение (например, ID), можно пользоваться записью такого вида:

```java
String endpoint = endpoint/{id}
```

В таком случае, подставить на место значения в фигурных скобках нужную переменную можно будет следующим образом:

```java
.get(endpoint, id)
```

Однако стоит иметь в виду, что подобная запись не всегда работает корректно, так что в некоторых проектах, возможно, придется обходиться без нее.

**Выносите base URI в properties**

Так же, как и упомянутые выше заголовки, скорее всего часть URL повторяется в каждом запросе. Ее также можно вынести в отдельное место и объявить только один раз.

Для этого удобнее всего вынести baseURI в properties-файл и получать его значение через класс типа ManageProperties. Объявить baseURI можно двумя способами:

```java
given()
    .baseUri(getProperty("baseUri"))
```

или

```java
RestAssured.baseURI = getProperty("baseUri");
```

Что касается непосредственно самого вызова baseURI, тут тоже есть пара вариантов:

Первый – вызывать его в каждом запросе. Такой вариант выглядит более громоздко, но подойдет в том случае, если в определенных случаях нужно использовать другой base URI.

Второй – объявить его однократно, например, в спецификации запроса.

**Используйте функционал Rest Assured для преобразования объектов**

Нет необходимости преобразовывать POJO в Json с помощью возможностей внешних библиотек, так как Rest Assured прекрасно справляется с этим самостоятельно. Достаточно добавить нужный POJO в тело запроса:

```java
Pojo pojo = new Pojo();
```

```java
given()
    .body(pojo)
    .post(URI);
```

Обратный процесс также работает:

```java
Pojo pojo = given()
    .get(URI)
    .then
    .extract().body().as(Pojo.class)
```

Кроме того, Rest Assured умеет преобразовывать в Json и HashMap, в том числе и вложенные:

```java
Map <Object, Object> outerMap = new HashMap<Object, Object>();
Map <Object, Object> innerMap = new HashMap<Object, Object>();

innerMap.put("key", "value");

outerMap.put("key", "value");
outerMap.put("innerMap", innerMap);

given()
    .body(outerMap)
    .post(URI);
```

**Используйте валидацию Json-схемы**

Валидация Json-схемы - это простой и надежный способ убедиться, что полученные данные соответствуют ожидаемому формату. Json-схема имеет следующий вид:

```json
{
    "type": "object",
    "properties": {
        "id": {
            "type": "integer"
        },
        "item": {
            "type": "object",
            "properties": {
                "key1": {
                    "type": ["string", "integer"]
                },
                "key2": {
                    "type": "string"
                }

            },
            "required": ["key1", "key2"]
        }
    },
    "required": ["id", "item"]
}

```

Создавать Json-схемы можно и вручную, но из-за не слишком человекоориентированного формата это может быть довольно утомительно, так что куда проще использовать для этого любой из многочисленных автоматических инструментов. Например: https://www.liquid-technologies.com/online-json-to-schema-converter

Такая схема проверяет, что полученный в ответе Json содержит в себе все поля, которые указаны как обязательные, и что тип данных в каждом из этих полей соответствует ожидаемому.

Для использования валидации Json-схем понадобится установить библиотеку json-schema-validator (в данном случае используется библиотека от io.rest-assured) и использовать следующий метод:

```java
.body(matchesJsonSchemaInClasspath("schema.json"));
```

**Выносите повторяющиеся действия в отдельные методы**

Нет никакой необходимости десять раз проверять, что ответ на запрос в десяти тестах соответствует схеме, достаточно один раз написать отдельный метод, который проводит эту проверку, и в дальнейшем просто обращаться к нему.

Это справедливо и для любых повторяющихся действий – намного удобнее читать (и тем более писать!) код, в котором все спецификации, конструкторы и проверки разбиты на отдельные блоки, из которых можно создать нужные тесты. Например, вот так:

```java
public static RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri(BASE_URI)
    .setContentType(ContentType.JSON)
    .setAccept(ContentType.JSON)
    .build();

public static ResponseSpecification responseSpec(int statusCode) {
    return new ResponseSpecBuilder()
            .expectStatusCode(statusCode)
            .expectResponseTime(lessThanOrEqualTo(responseTime))
            .build();
}

public static Response createItem(Pojo body) {
    return given()
        .spec(requestSpec)
        .body(body)
        .post(Uri);
    }

public static ValidatableResponse createItem_valid(Response response) {
    return response
            .then()
            .spec(responseSpec(200))
            .body(matchesJsonSchemaInClasspath("schemas/CreateItem.json"));
}

@Test
public void createItemTest() {
    createItem_valid(
        createItem(body))
}
```

**Используйте Hamcrest Matchers**

В случе, когда нет необходимости десериализовать ответ в POJO, мэтчеры из библиотеки Hamcrest являются самым быстрым способом повести валидацию отдельных элементов содержимого ответа.

Они позволяют проверить, что, например, ответ содержит в себе определенную строку или значение, или что конкретное поле равно определенному значению, или что массив содержит в себе некоторый набор элементов в произвольном порядке.

```java
.body("id", equals(getId()))
.body("id", greaterThanOrEqualTo(1))
.body("items", either(hasItem("a")).and(hasItem("b"))
```

Все выполняемые мэтчерами проверки, несомненно, можно произвести и другими способами, однако они позволяют сделать это в краткой и удобной для чтения форме.

С полной документацией к мэтчерам можно ознакомиться здесь: http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html

**Используйте методы для добавления заголовков**

Так как по крайней мере один из этих заголовков используется практически в любом запросе, для них был создан более краткий вариант записи:

```java
given()
	.contentType(ContentType.JSON)
	.accept(ContentType.JSON)
```

Такой вариант немного короче обычной записи заголовков через метод header и, что более важно, минимизирует шанс возникновения ошибки из-за опечатки.

Однако стоит обратить внимание на то, что при таком оформлении заголовков в Accept помимо application/json также передаются application/javascript, text/javascript и text/json. В некоторых API это может привести к ошибкам, и в таком случае enum ContentType стоит заменить на строку с указанием конкретного типа данных.

**Проверяйте статус-код без assertThat**

Запись типа

```java
.assertThat(statusCode(200))
```

просто излишня. Эта строка выполняет ту же самую работу:

```java
.statusCode(200)
```

**Передавайте статус-коды в качестве аргумента**

При наличии большого количества негативных проверок с разными ожидаемыми кодами ошибок, нет необходимости писать отдельную спецификацию под каждый статус-код, вместо этого можно просто добавить спецификацию в метод и передавать в нее ожидаемый статус-код из теста:

```java
public static ResponseSpecification responseSpecError(int statusCode) {
    return new ResponseSpecBuilder()
        .expectStatusCode(statusCode)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
}
```

**Используйте логирование для отладки тестов**

Метод .log() позволяет получить информацию как об отправленном запросе, так и о полученном ответе. В первом случае необходимо его применить до отправки запроса (get, post и т.д.), во втором случае – после.

Вам доступны следующие методы:

```java
.log().all()
.log().params()
.log().body()
.log().headers()
.log().cookies()
```

Однако оставлять логирование в тестах, которые уже дописаны и корректно работают, не стоит – объем в информации в логах может быть настолько большим, что результаты всех тестов перестанут умещаться в консоли IDE, не говоря уже о том, что просматривать результаты тестов в таком случае будет очень неудобно.

https://habr.com/ru/post/421005/

**Выносите end-point'ы в отдельное место**

Казалось бы, что это очевидно. Но нет, довольно часто приходится видеть код с захардкоженными end-point'ми в запросе.

Лучше всего выносить end-point'ы в статические константы финального класса. При этом стоит избегать антипаттерн «константный интерфейс» — это плохая практика.

Не забывайте, что REST-assured позволяет выносить параметры пути, например:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}
```

```java
given().pathParams("id", someId).get(EndPoints.users)...;

// или так

given().get(EndPoints.users, someId)....
```

Также, если во многих запросах вы используете один и тот же базовый путь, то будет хорошей практикой вынести его в отельную константу и передавать в basePath, например:

```java
// имеем следующий url приложения http://host:port/appname/rest/someEndpoints

private static final basePath = "/appname/rest/";

..

// можем задать базовый путь на глобальном уровне,
// он будет применяться ко всем запросам:
RestAssured.basePath = basePath;

// или на уровне одного запроса:
given().basePath(basePath)...

// или на уровне спецификации, но об этом далее
```

То же самое применимо к хосту и порту тестируемого приложения.

```java
ContentType/Accept
```
Данные заголовки используются практически во всех HTTP-запросах. Авторы REST-assured, понимая это, сделали возможным их установку через вызов специальных методов:

```java
// плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;

// хорошая практика написания:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой будет установить данные заголовки в спецификации или на глобальном уровне. Это повысит читабельность вашего кода.

**StatusCode и т.п.**

REST-assured предоставляет удобный синтаксис для проведения проверки каждой составляющей HTTP-ответа, однако на практике продолжаешь встречать подобный код:

```java
// плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());

// хорошая практика написания:
given()...when().get(someEndpoint).then().statusCode(200);
```

**Используйте спецификации**

Дублирование кода — это плохо. Используйте спецификации для уменьшения дублирования. В REST-assured можно создавать спецификации как для запроса, так и для ответа. В спецификацию запроса выносим всё, что может быть продублировано в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// можно задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// или для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

В спецификацию ответа выносим все проверки, которые дублируются от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// можно задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// или для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;
```

Можно создавать несколько спецификаций для разных типов запросов/ответов и использовать в нужной ситуации.

**Не пишите свои костыли для преобразования объектов**

Не стоит преобразовывать свои POJO в JSON при помощи Jackson ObjectMapperа, а потом полученную строку передавать в тело запроса. REST-assured прекрасно справляется с этой задачей. Для этого используется всё тот же Jackson или Gson, в зависимости от того, что находится в classpath. Для преобразования в XML используется JAXB. Исходный формат определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Кроме того REST-assured прекрасно справляется с преобразованием HashMap в JSON и обратно.


**Используйте всю мощь Groovy**

Сама библиотека REST-assured написана на Groovy и позволяет вам применять различные методы из Groovy к полученному JSON/XML ответу. Например:

```java
// методы find, findAll применяются к коллекции для поиска первого и всех вхождений, метод collect для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// вы можете использовать методы sum, max, min для суммирования всех значений коллекции, а также поиска максимального и минимально значения

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Использование методов из Groovy позволяет сильно сократить количество кода, написанного вами для поиска необходимого значения из ответа.

На этом всё, если у вас есть еще советы и примеры пишите их в комментариях.



***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)