Java_QA / 14. API. REST Assured

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* []()
* []()
* []()
* []()

***

# 1. REST Assured

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***REST Assured*** — **Java** библиотека для тестирования **REST** сервисов, предоставляющая **DSL** в **BDD** стиле. 

Библиотека **REST Assured** интегрируется с любым фреймворком автоматизации, основанным на **Java**.

Это решение появилось более девяти лет назад и стало популярным из-за своей простоты и удобного функционала.

Ссылки:

* [REST Assured](https://rest-assured.io/)
* [REST Assured. Github](https://github.com/rest-assured/rest-assured)
* [REST Assured. Github. GettingStarted](https://github.com/rest-assured/rest-assured/wiki/GettingStarted)
* [REST Assured. Github. Usage Guide](https://github.com/rest-assured/rest-assured/wiki/Usage)
* [REST Assured. Javadoc](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/index.html)

## Given When Then

Ключевые слова **given**, **when** и **then** формируют запрос:

* **given** - условия (заголовки, параметры, тело запроса и т д)
* **when** – действие (отправка запроса с заданными условиями, методом и ендпоинтом запроса)
* **then** – проверка (проверка ответа)

Кроме этого, можно извлечь тело ответа в виде объекта типа **JsonPath** или **XmlPath**

***

# 2. Класс RestAssured 

**RestAssured** - класс предоставляющий DSL.

Методы класса **RestAssured**:

[io/restassured : RestAssured](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

## 2.1. Given, When, With

### 2.1.1. Given

**Given** - необязательный метод, который задает условия запроса.

Здесь можно передать:

* заголовки запроса
* параметр строки запроса 
* параметр пути запроса
* тело запроса 
* файлы 
* cookie

| Тип                         | Метод                                                                       | Описание                                                            | 
|-----------------------------|-----------------------------------------------------------------------------|---------------------------------------------------------------------|
| static RequestSpecification | given()                                                                     | Условия запроса                                                     |
| static RequestSpecification | given(RequestSpecification requestSpec)                                     | Условия запроса на основе спецификации запроса                      |
| static RequestSender        | given(RequestSpecification requestSpec, ResponseSpecification responseSpec) | Условия запроса на основе спецификации запроса, спецификации ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
        .given()
            .accept(ContentType.JSON)
            .queryParam("name","Rick Sanchez")
        .when()
            .get("/character")
        .then().statusCode(200);
}
```

### 2.1.2. When

**When** - метод, который отправляет запрос.

| Тип                  | Метод   | Описание         | 
|----------------------|---------|------------------|
| static RequestSender | when()  | Отправка запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
        .given()
            .accept(ContentType.JSON)
            .queryParam("name","Rick Sanchez")
        .when()
            .get("/character")
        .then().statusCode(200);
```

### 2.1.3. With

**With** - метод, который задает условия запроса.

| Тип                         | Метод   | Описание        | 
|-----------------------------|---------|-----------------|
| static RequestSpecification | with()  | Условия запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
        .with()
            .accept(ContentType.JSON)
            .queryParam("name","Rick Sanchez")
        .when()
            .get("/character")
        .then().statusCode(200);
```

Единственная разница между with() и given() — синтаксическая.

***

## 2.2. Get, Post, Put, Patch, Delete

### 2.2.1. Get

**Get** - метод **GET**

| Тип              | Метод                                      | Описание                                           | 
|------------------|--------------------------------------------|----------------------------------------------------|
| static Response  | get()                                      | **GET** запрос по **path** (http://localhost:8080) |
| static Response  | get(String path, Map<String,?> pathParams) | **GET** запрос по **path**                         |
| static Response  | get(String path, Object... pathParams)     | **GET** запрос по **path**                         |
| static Response  | get(URI uri)                               | **GET** запрос по **uri**                          |
| static Response  | get(URL url)                               | **GET** запрос по **url**                          |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.baseUri("https://restful-booker.herokuapp.com/booking");

Response response = request.get();
ValidatableResponse valRes = response.then();
valRes.statusCode(200);
valRes.statusLine("HTTP/1.1 200 OK");
```

*Пример*

**BDD** стиль.

```java
RestAssured
// Given
.given()
	.baseUri("https://restful-booker.herokuapp.com")
// When
.when()
	.get("/booking")
// Then
.then()
	.statusCode(200)
	.statusLine("HTTP/1.1 200 OK")
	.body("bookingid.sum()", Matchers.hasSize(10))
	.body("bookingid[3]", Matchers.equalTo(1));
```

### 2.2.2. Post

**Post** - метод **POST**.

| Тип             | Метод                                       | Описание                                            | 
|-----------------|---------------------------------------------|-----------------------------------------------------|
| static Response | post()                                      | **POST** запрос по **path** (http://localhost:8080) |
| static Response | post(String path, Map<String,?> pathParams) | **POST** запрос по **path**                         |                                     
| static Response | post(String path, Object... pathParams)     | **POST** запрос по **path**                         |                                 
| static Response | post(URI uri)                               | **POST** запрос по **uri**                          |
| static Response | post(URL url)                               | **POST** запрос по **url**                          |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.baseUri("https://restful-booker.herokuapp.com/auth");
request.body(jsonString);

Response response = request.post();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("token", Matchers.notNullValue());
validatableResponse.body("token.length()", Matchers.is(15));
validatableResponse.body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RestAssured
// Given  
.given()
    .baseUri("https://restful-booker.herokuapp.com/auth")
    .contentType(ContentType.JSON)
    .body(jsonString)
// When
.when()
    .post()
// Then
.then()
    .assertThat()
    .statusCode(200)
    .body("token", Matchers.notNullValue())
    .body("token.length()", Matchers.is(15))
    .body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

### 2.2.3. Put

**Put** - метод **PUT**.

| Тип             | Метод                                  | Описание                                           | 
|-----------------|----------------------------------------|----------------------------------------------------|
| static Response | put()                                  | **PUT** запрос по **path** (http://localhost:8080) |
| static Response | put(String path, Object... pathParams) | **PUT** запрос по **path**                         |
| static Response | put(URI uri)                           | **PUT** запрос по **uri**                          |
| static Response | put(URL url)                           | **PUT** запрос по **url**                          |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "fa0d5b1138a0d1f");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.put();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RestAssured
// Given
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
    .cookie("token", "e88375c0fde687a")
    .contentType(ContentType.JSON)
    .body(jsonString)
// When
.when()
    .put()
// Then
.then()
    .assertThat()
    .statusCode(200)
    .body("firstname", Matchers.equalTo("Amod"))
    .body("lastname", Matchers.equalTo("Mahajan"));
```

### 2.2.4. Patch

**Patch** - метод **PATCH**.

| Тип              | Метод                                        | Описание                                             | 
|------------------|----------------------------------------------|------------------------------------------------------|
| static Response  | patch()                                      | **PATCH** запрос по **path** (http://localhost:8080) |
| static Response  | patch(String path, Map<String,?> pathParams) | **PATCH** запрос по **path**                         |
| static Response  | patch(String path, Object... pathParams)     | **PATCH** запрос по **path**                         |
| static Response  | patch(URI uri)                               | **PATCH** запрос по **uri**                          |
| static Response  | patch(URL url)                               | **PATCH** запрос по **url**                          |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "974c253452ba510");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.patch();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RestAssured
// Given
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
    .cookie("token", "6608dc75eedd44f")
    .contentType(ContentType.JSON)
    .body(jsonString)
// When
.when()
    .patch()
// Then
.then()
    .assertThat()
    .statusCode(200)
    .body("firstname", Matchers.equalTo("Amod"))
    .body("lastname", Matchers.equalTo("Mahajan"));
```

### 2.2.5. Delete

**Delete** - метод **DELETE**.

| Тип             | Метод                                         | Описание                                              | 
|-----------------|-----------------------------------------------|-------------------------------------------------------|
| static Response | delete()                                      | **DELETE** запрос по **path** (http://localhost:8080) |
| static Response | delete(String path, Map<String,?> pathParams) | **DELETE** запрос по **path**                         |
| static Response | delete(String path, Object... pathParams)     | **DELETE** запрос по **path**                         |
| static Response | delete(URI uri)                               | **DELETE** запрос по **uri**                          |
| static Response | delete(URL url)                               | **DELETE** запрос по **url**                          |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.cookie("token", "f4e70e7b9bbcd05");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response response = request.delete();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(201);

RequestSpecification getRequestSpec = RestAssured.given();
getRequestSpec.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response res = getRequestSpec.get();
ValidatableResponse valRes = res.then();
valRes.statusCode(404);
```

*Пример*

**BDD** стиль.

```java
RestAssured
// Given
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
    .cookie("token", "f7dddb1093eab19")
// When
.when()
    .delete()
// Then
.then()
    .assertThat()
    .statusCode(201);
RestAssured
// Given   
.given()
    .baseUri("https://restful-booker.herokuapp.com/booking/1")
// When
.when()
    .get()
// Then
.then()
    .statusCode(404);
```

## 2.3. Expect, Request

***

# 3. Класс RequestSender

**RequestSender** - класс .

Методы класса **RequestSender**:

[io/restassured : RequestSender](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

***

# 4. Класс Response

**Response** - класс .

Методы класса **Response**:

[io/restassured : Response](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.


***

# 5. Класс RequestSpecification

**RequestSpecification** - класс .

Методы класса **RequestSpecification**:

[io/restassured : RequestSpecification](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.


***

# 6. Класс ResponseSpecification

**ResponseSpecification** - класс .

Методы класса **ResponseSpecification**:

[io/restassured : ResponseSpecification](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

***



***

# Best Practices
https://otus.ru/nest/post/1271/

1. **Выносите end-pointы в отдельное место**

С одной стороны, это очевидно. Но увы, до сих пор нередко встречается код, имеющий захардкоженные end-point'ы в запросе.
В целом же, лучше выносить end-point'ы в статические константы финального класса. Но тут есть нюанс — избегайте антипаттерна «константный интерфейс», т. к. это является плохой практикой. И помните, что REST-assured даёт возможность выносить параметры пути, к примеру:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}

given().pathParams("id", someId).get(EndPoints.users)...;
```

или так

```java
given().get(EndPoints.users, someId)....
```

Кроме того, если вы во многих запросах применяете одинаковый базовый путь,
считается хорошей практикой выносить его в отдельную константу, передавая в basePath, как в примере ниже:


имеем url приложения http://host:port/appname/rest/someEndpoints

```java
private static final basePath = "/appname/rest/";
```

можно задать базовый путь на глобальном уровне,
и он будет использоваться ко всем запросам

```java
RestAssured.basePath = basePath;

// либо на уровне одного запроса:
given().basePath(basePath)...

// либо на уровне спецификации, но об этом поговорим позже
```

То же применимо как к хосту, так и к порту тестируемого программного приложения.

2. **ContentType/Accept**

Эти заголовки применяются почти во всех HTTP-запросах.
Разработчики REST-assured прекрасно это понимают,
поэтому они обеспечили возможность их установки посредством вызова специальных методов:

```java
// вот то плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;
// а вот эта хорошая:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой станет установка данных заголовков в спецификации либо на глобальном уровне.
Результат — повышение читабельности кода.

3. **StatusCode** и т. п.
   Для выполнения проверки каждой составляющей HTTP-ответа, библиотека REST-assured предоставляет удобный синтаксис.
   Но на практике часто можно увидеть следующий код:

```java
// это плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());
```

```java
//а это хорошая:
given()...when().get(someEndpoint).then().statusCode(200);
```

4. **Используйте спецификации**
   Мы знаем, что дублировать код не есть хорошо. Для уменьшения дублирования нужно использовать спецификации.
   В REST-assured есть возможность создания спецификации и для запроса, и для ответа.
   В спецификацию запроса можно вынести всё, что можно продублировать в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// мы можем задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// либо для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

Кроме того, в спецификацию ответа можно выносить все проверки, дублируемые от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// мы можем задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// либо для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;

```

Также мы можем создавать несколько спецификаций для различных типов запросов/ответов и применять их в нужном случае.

5. **Не надо писать собственные костыли для преобразования объектов**
   Не нужно преобразовывать свои POJO в JSON, используя Jackson ObjectMapper'а, а потом передавать полученную строку в тело запроса. Почему? Потому что с этой задачей отлично справляется библиотека REST-assured. Причём применяется всё тот же Jackson либо Gson с учётом того, что находится в classpath. А чтобы выполнить преобразование в XML, применяется JAXB. Что касается исходного формата, то он определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое действует и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Вдобавок к вышесказанному, REST-assured хорошо справляется и с преобразованием HashMap в JSON и в обратном порядке.

6. Используйте всю силу Groovy
   Так как сама библиотека написана на Groovy, она даёт возможность использовать к полученному JSON/XML-ответу разные методы из Groovy. Допустим:

```java
// методы find, findAll используются к коллекции для поиска первого и всех вхождений, а метод collect — для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно, указывая на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можно явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// можно применять методы max, min, sum в целях суммирования всех значений коллекции и поиска максимального и минимально значений

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Применение методов из Groovy сократит количество кода, написанного вами в целях поиска необходимого значения из ответа.


https://qa.crtweb.ru/docs/testing/auto/api/rest-assured-best-practices/

**Используйте спецификации**

Конструкция типа

```java
given().accept(ContentType.JSON)
```

используется абсолютно в каждом запросе, и, даже если это всего две строчки, их можно сократить до вызова одного метода, увеличив тем самым читаемость кода, если вынести их в отдельный метод:

```java
public static RequestSpecification requestSpec() {
    return given()
        .accept(ContentType.JSON);
}
```

или билдер:

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setAccept(ContentType.JSON)
    .build();
```

А в каждом запросе достаточно использовать только вызов этого метода или билдера.

Кроме того, на деле вряд ли весь код, который можно было бы вынести в спецификацию запроса ограничивается двумя строками – наверняка туда можно добавить заголовки для авторизации, установку хоста и порта, настройки логирования, фильтры для Allure и что угодно еще, что необходимо выполнять при каждом запросе.

То же самое можно сделать и с ответом. В нем можно проверить статус-код, время ожидания ответа, а так же наличие необходимых полей в теле ответа или заголовков. Как и в случае с запросом, можно использовать метод:

```java
public static ValidatableResponse responseSpecOk(Response response) {
    return response
        .then()
        .statusCode(200)
        .time(lessThanOrEqualTo(responseTime));
}
```

или билдер:

```java
ResponseSpecification responseSpecOk = new ResponseSpecBuilder()
        .expectStatusCode(200)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
```

**Храните эндпойнты в отдельном месте**

Не стоит отдельно прописывать эндпойнт для каждого запроса.
Даже если их немного, при необходимости внесения изменений что-то все равно может потеряться и поиск проблемы гарантированно займет куда больше времени, чем организация корректного хранения эндпойнтов.

Тут есть несколько вариантов:

если для каждого эндпойнта существует свой собственный класс, можно просто хранить их в переменных этого класса;
можно создать отдельный класс для управления эндпойнтами, и хранить все эндпойнты в переменных этого класса;
и, наконец, эндпойнты можно хранить в отдельном property-файле.

В случае, если эндпойнт включает в себя какое-то изменяемое значение (например, ID), можно пользоваться записью такого вида:

```java
String endpoint = endpoint/{id}
```

В таком случае, подставить на место значения в фигурных скобках нужную переменную можно будет следующим образом:

```java
.get(endpoint, id)
```

Однако стоит иметь в виду, что подобная запись не всегда работает корректно, так что в некоторых проектах, возможно, придется обходиться без нее.

**Выносите base URI в properties**

Так же, как и упомянутые выше заголовки, скорее всего часть URL повторяется в каждом запросе. Ее также можно вынести в отдельное место и объявить только один раз.

Для этого удобнее всего вынести baseURI в properties-файл и получать его значение через класс типа ManageProperties. Объявить baseURI можно двумя способами:

```java
given()
    .baseUri(getProperty("baseUri"))
```

или

```java
RestAssured.baseURI = getProperty("baseUri");
```

Что касается непосредственно самого вызова baseURI, тут тоже есть пара вариантов:

Первый – вызывать его в каждом запросе. Такой вариант выглядит более громоздко, но подойдет в том случае, если в определенных случаях нужно использовать другой base URI.

Второй – объявить его однократно, например, в спецификации запроса.

**Используйте функционал Rest Assured для преобразования объектов**

Нет необходимости преобразовывать POJO в Json с помощью возможностей внешних библиотек, так как Rest Assured прекрасно справляется с этим самостоятельно. Достаточно добавить нужный POJO в тело запроса:

```java
Pojo pojo = new Pojo();
```

```java
given()
    .body(pojo)
    .post(URI);
```

Обратный процесс также работает:

```java
Pojo pojo = given()
    .get(URI)
    .then
    .extract().body().as(Pojo.class)
```

Кроме того, Rest Assured умеет преобразовывать в Json и HashMap, в том числе и вложенные:

```java
Map <Object, Object> outerMap = new HashMap<Object, Object>();
Map <Object, Object> innerMap = new HashMap<Object, Object>();

innerMap.put("key", "value");

outerMap.put("key", "value");
outerMap.put("innerMap", innerMap);

given()
    .body(outerMap)
    .post(URI);
```

**Используйте валидацию Json-схемы**

Валидация Json-схемы - это простой и надежный способ убедиться, что полученные данные соответствуют ожидаемому формату. Json-схема имеет следующий вид:

```json
{
    "type": "object",
    "properties": {
        "id": {
            "type": "integer"
        },
        "item": {
            "type": "object",
            "properties": {
                "key1": {
                    "type": ["string", "integer"]
                },
                "key2": {
                    "type": "string"
                }

            },
            "required": ["key1", "key2"]
        }
    },
    "required": ["id", "item"]
}

```

Создавать Json-схемы можно и вручную, но из-за не слишком человекоориентированного формата это может быть довольно утомительно, так что куда проще использовать для этого любой из многочисленных автоматических инструментов. Например: https://www.liquid-technologies.com/online-json-to-schema-converter

Такая схема проверяет, что полученный в ответе Json содержит в себе все поля, которые указаны как обязательные, и что тип данных в каждом из этих полей соответствует ожидаемому.

Для использования валидации Json-схем понадобится установить библиотеку json-schema-validator (в данном случае используется библиотека от io.rest-assured) и использовать следующий метод:

```java
.body(matchesJsonSchemaInClasspath("schema.json"));
```

**Выносите повторяющиеся действия в отдельные методы**

Нет никакой необходимости десять раз проверять, что ответ на запрос в десяти тестах соответствует схеме, достаточно один раз написать отдельный метод, который проводит эту проверку, и в дальнейшем просто обращаться к нему.

Это справедливо и для любых повторяющихся действий – намного удобнее читать (и тем более писать!) код, в котором все спецификации, конструкторы и проверки разбиты на отдельные блоки, из которых можно создать нужные тесты. Например, вот так:

```java
public static RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri(BASE_URI)
    .setContentType(ContentType.JSON)
    .setAccept(ContentType.JSON)
    .build();

public static ResponseSpecification responseSpec(int statusCode) {
    return new ResponseSpecBuilder()
            .expectStatusCode(statusCode)
            .expectResponseTime(lessThanOrEqualTo(responseTime))
            .build();
}

public static Response createItem(Pojo body) {
    return given()
        .spec(requestSpec)
        .body(body)
        .post(Uri);
    }

public static ValidatableResponse createItem_valid(Response response) {
    return response
            .then()
            .spec(responseSpec(200))
            .body(matchesJsonSchemaInClasspath("schemas/CreateItem.json"));
}

@Test
public void createItemTest() {
    createItem_valid(
        createItem(body))
}
```

**Используйте Hamcrest Matchers**

В случе, когда нет необходимости десериализовать ответ в POJO, мэтчеры из библиотеки Hamcrest являются самым быстрым способом повести валидацию отдельных элементов содержимого ответа.

Они позволяют проверить, что, например, ответ содержит в себе определенную строку или значение, или что конкретное поле равно определенному значению, или что массив содержит в себе некоторый набор элементов в произвольном порядке.

```java
.body("id", equals(getId()))
.body("id", greaterThanOrEqualTo(1))
.body("items", either(hasItem("a")).and(hasItem("b"))
```

Все выполняемые мэтчерами проверки, несомненно, можно произвести и другими способами, однако они позволяют сделать это в краткой и удобной для чтения форме.

С полной документацией к мэтчерам можно ознакомиться здесь: http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html

**Используйте методы для добавления заголовков**

Так как по крайней мере один из этих заголовков используется практически в любом запросе, для них был создан более краткий вариант записи:

```java
given()
	.contentType(ContentType.JSON)
	.accept(ContentType.JSON)
```

Такой вариант немного короче обычной записи заголовков через метод header и, что более важно, минимизирует шанс возникновения ошибки из-за опечатки.

Однако стоит обратить внимание на то, что при таком оформлении заголовков в Accept помимо application/json также передаются application/javascript, text/javascript и text/json. В некоторых API это может привести к ошибкам, и в таком случае enum ContentType стоит заменить на строку с указанием конкретного типа данных.

**Проверяйте статус-код без assertThat**

Запись типа

```java
.assertThat(statusCode(200))
```

просто излишня. Эта строка выполняет ту же самую работу:

```java
.statusCode(200)
```

**Передавайте статус-коды в качестве аргумента**

При наличии большого количества негативных проверок с разными ожидаемыми кодами ошибок, нет необходимости писать отдельную спецификацию под каждый статус-код, вместо этого можно просто добавить спецификацию в метод и передавать в нее ожидаемый статус-код из теста:

```java
public static ResponseSpecification responseSpecError(int statusCode) {
    return new ResponseSpecBuilder()
        .expectStatusCode(statusCode)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
}
```

**Используйте логирование для отладки тестов**

Метод .log() позволяет получить информацию как об отправленном запросе, так и о полученном ответе. В первом случае необходимо его применить до отправки запроса (get, post и т.д.), во втором случае – после.

Вам доступны следующие методы:

```java
.log().all()
.log().params()
.log().body()
.log().headers()
.log().cookies()
```

Однако оставлять логирование в тестах, которые уже дописаны и корректно работают, не стоит – объем в информации в логах может быть настолько большим, что результаты всех тестов перестанут умещаться в консоли IDE, не говоря уже о том, что просматривать результаты тестов в таком случае будет очень неудобно.

https://habr.com/ru/post/421005/

**Выносите end-point'ы в отдельное место**

Казалось бы, что это очевидно. Но нет, довольно часто приходится видеть код с захардкоженными end-point'ми в запросе.

Лучше всего выносить end-point'ы в статические константы финального класса. При этом стоит избегать антипаттерн «константный интерфейс» — это плохая практика.

Не забывайте, что REST-assured позволяет выносить параметры пути, например:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}
```

```java
given().pathParams("id", someId).get(EndPoints.users)...;

// или так

given().get(EndPoints.users, someId)....
```

Также, если во многих запросах вы используете один и тот же базовый путь, то будет хорошей практикой вынести его в отельную константу и передавать в basePath, например:

```java
// имеем следующий url приложения http://host:port/appname/rest/someEndpoints

private static final basePath = "/appname/rest/";

..

// можем задать базовый путь на глобальном уровне,
// он будет применяться ко всем запросам:
RestAssured.basePath = basePath;

// или на уровне одного запроса:
given().basePath(basePath)...

// или на уровне спецификации, но об этом далее
```

То же самое применимо к хосту и порту тестируемого приложения.

```java
ContentType/Accept
```
Данные заголовки используются практически во всех HTTP-запросах. Авторы REST-assured, понимая это, сделали возможным их установку через вызов специальных методов:

```java
// плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;

// хорошая практика написания:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой будет установить данные заголовки в спецификации или на глобальном уровне. Это повысит читабельность вашего кода.

**StatusCode и т.п.**

REST-assured предоставляет удобный синтаксис для проведения проверки каждой составляющей HTTP-ответа, однако на практике продолжаешь встречать подобный код:

```java
// плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());

// хорошая практика написания:
given()...when().get(someEndpoint).then().statusCode(200);
```

**Используйте спецификации**

Дублирование кода — это плохо. Используйте спецификации для уменьшения дублирования. В REST-assured можно создавать спецификации как для запроса, так и для ответа. В спецификацию запроса выносим всё, что может быть продублировано в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// можно задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// или для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

В спецификацию ответа выносим все проверки, которые дублируются от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// можно задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// или для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;
```

Можно создавать несколько спецификаций для разных типов запросов/ответов и использовать в нужной ситуации.

**Не пишите свои костыли для преобразования объектов**

Не стоит преобразовывать свои POJO в JSON при помощи Jackson ObjectMapperа, а потом полученную строку передавать в тело запроса. REST-assured прекрасно справляется с этой задачей. Для этого используется всё тот же Jackson или Gson, в зависимости от того, что находится в classpath. Для преобразования в XML используется JAXB. Исходный формат определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Кроме того REST-assured прекрасно справляется с преобразованием HashMap в JSON и обратно.


**Используйте всю мощь Groovy**

Сама библиотека REST-assured написана на Groovy и позволяет вам применять различные методы из Groovy к полученному JSON/XML ответу. Например:

```java
// методы find, findAll применяются к коллекции для поиска первого и всех вхождений, метод collect для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// вы можете использовать методы sum, max, min для суммирования всех значений коллекции, а также поиска максимального и минимально значения

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Использование методов из Groovy позволяет сильно сократить количество кода, написанного вами для поиска необходимого значения из ответа.

На этом всё, если у вас есть еще советы и примеры пишите их в комментариях.



***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)