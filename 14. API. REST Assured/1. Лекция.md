Java_QA / 14. API. REST Assured

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* []()
* []()
* []()
* []()

***

# 1. REST Assured

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***REST Assured*** — **Java** библиотека для тестирования **REST** сервисов, предоставляющая **DSL** в **BDD** стиле. 

Библиотека **REST Assured** интегрируется с любым фреймворком автоматизации, основанным на **Java**.

Это решение появилось более девяти лет назад и стало популярным из-за своей простоты и удобного функционала.

Ссылки:

* [REST Assured](https://rest-assured.io/)
* [REST Assured. Github](https://github.com/rest-assured/rest-assured)
* [REST Assured. Github. GettingStarted](https://github.com/rest-assured/rest-assured/wiki/GettingStarted)
* [REST Assured. Github. Usage Guide](https://github.com/rest-assured/rest-assured/wiki/Usage)
* [REST Assured. Javadoc](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/index.html)

Ключевые слова **given**, **when** и **then** формируют запрос:

* **given** - условия (заголовки, параметры, тело запроса и т д)
* **when** – действие (отправка запроса с заданными условиями, методом и ендпоинтом запроса)
* **then** – проверка (проверка ответа)

Кроме этого, можно извлечь тело ответа в виде объекта типа **JsonPath** или **XmlPath**.

***

# 2. Класс RestAssured 

**RestAssured** - класс предоставляющий DSL.

Методы класса **RestAssured**:

[io/restassured : RestAssured](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

## 2.1. Given, With, Expect, When

### 2.1.1. Given

**Given** - параметры отправляемого запроса / получаемого ответа.

| Тип                         | Метод                                                                       | Описание                                                                                                                   | 
|-----------------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| static RequestSpecification | given()                                                                     | Параметры отправляемого запроса                                                                                            |
| static RequestSpecification | given(RequestSpecification requestSpec)                                     | Параметры отправляемого запроса на основе спецификации запроса                                                             |
| static RequestSender        | given(RequestSpecification requestSpec, ResponseSpecification responseSpec) | Параметры <br/>отправляемого запроса на основе спецификации запроса, <br/>получаемого ответа на основе спецификации ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    // Given
	.given()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
    // When
	.when()
        .get("/character")
    // Then
	.then()
		.statusCode(200);
```

### 2.1.2. With

**With** - параметры отправляемого запроса.

| Тип                         | Метод  | Описание                        | 
|-----------------------------|--------|---------------------------------|
| static RequestSpecification | with() | Параметры отправляемого запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    // Given
	.with()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
    // When
	.when()
        .get("/character")
    // Then
	.then()
		.statusCode(200);
```

### 2.1.3. Expect

**Expect** - параметры получаемого ответа (для проверки).

| Тип                          | Метод    | Описание                     | 
|------------------------------|----------|------------------------------|
| static ResponseSpecification | expect() | Параметры получаемого ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    // Given
	.with()
    	.accept(ContentType.JSON)
    	.queryParam("name","Rick Sanchez")
    // Then
	.expect()
    	.statusCode(200)
    	.contentType(ContentType.JSON)
	// When		
    .when()
    	.get("/character");
```

### 2.1.4. When

**When** - отправка запроса.

| Тип                  | Метод   | Описание         | 
|----------------------|---------|------------------|
| static RequestSender | when()  | Отправка запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    // Given	
    .given()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
    // When	
    .when()
        .get("/character")
	// Then
    .then()
		.statusCode(200);
```

***

## 2.2. Get, Post, Put, Patch, Delete, Request

### 2.2.1. Get

**Get** - отправка **HTTP** запроса **GET**.

| Тип              | Метод                                      | Описание                                                              | 
|------------------|--------------------------------------------|-----------------------------------------------------------------------|
| static Response  | get()                                      | Отправка **HTTP** запроса **GET** по **path** (http://localhost:8080) |
| static Response  | get(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **GET** по **path**                         |
| static Response  | get(String path, Object... pathParams)     | Отправка **HTTP** запроса **GET** по **path**                         |
| static Response  | get(URI uri)                               | Отправка **HTTP** запроса **GET** по **uri**                          |
| static Response  | get(URL url)                               | Отправка **HTTP** запроса **GET** по **url**                          |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.baseUri("https://restful-booker.herokuapp.com/booking");

Response response = request.get();
ValidatableResponse valRes = response.then();
valRes.statusCode(200);
valRes.statusLine("HTTP/1.1 200 OK");
```

*Пример*

**BDD** стиль.

```java
RestAssured
	// Given
	.given()
		.baseUri("https://restful-booker.herokuapp.com")
	// When
	.when()
		.get("/booking")
	// Then
	.then()
		.statusCode(200)
		.statusLine("HTTP/1.1 200 OK")
		.body("bookingid.sum()", Matchers.hasSize(10))
		.body("bookingid[3]", Matchers.equalTo(1));
```

### 2.2.2. Post

**Post** - отправка **HTTP** запроса **POST**.

| Тип             | Метод                                       | Описание                                                                                   | 
|-----------------|---------------------------------------------|--------------------------------------------------------------------------------------------|
| static Response | post()                                      | Отправка **HTTP** запроса **POST** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | post(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **POST** по **path**                                             |                                     
| static Response | post(String path, Object... pathParams)     | Отправка **HTTP** запроса **POST** по **path**                                             |                                 
| static Response | post(URI uri)                               | Отправка **HTTP** запроса **POST** по **uri**                                              |
| static Response | post(URL url)                               | Отправка **HTTP** запроса **POST** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.baseUri("https://restful-booker.herokuapp.com/auth");
request.body(jsonString);

Response response = request.post();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("token", Matchers.notNullValue());
validatableResponse.body("token.length()", Matchers.is(15));
validatableResponse.body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RestAssured
	// Given  
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/auth")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	// When
	.when()
	    .post()
	// Then
	.then()
	    .assertThat()
	    .statusCode(200)
	    .body("token", Matchers.notNullValue())
	    .body("token.length()", Matchers.is(15))
	    .body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

### 2.2.3. Put

**Put** - отправка **HTTP** запроса **PUT**.

| Тип             | Метод                                  | Описание                                                                                  | 
|-----------------|----------------------------------------|-------------------------------------------------------------------------------------------|
| static Response | put()                                  | Отправка **HTTP** запроса **PUT** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | put(String path, Object... pathParams) | Отправка **HTTP** запроса **PUT** по **path**                                             |
| static Response | put(URI uri)                           | Отправка **HTTP** запроса **PUT** по **uri**                                              |
| static Response | put(URL url)                           | Отправка **HTTP** запроса **PUT** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "fa0d5b1138a0d1f");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.put();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RestAssured
	// Given
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "e88375c0fde687a")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	// When
	.when()
	    .put()
	// Then
	.then()
	    .assertThat()
	    .statusCode(200)
	    .body("firstname", Matchers.equalTo("Amod"))
	    .body("lastname", Matchers.equalTo("Mahajan"));
```

### 2.2.4. Patch

**Patch** - отправка **HTTP** запроса **PATCH**.

| Тип              | Метод                                        | Описание                                                                                    | 
|------------------|----------------------------------------------|---------------------------------------------------------------------------------------------|
| static Response  | patch()                                      | Отправка **HTTP** запроса **PATCH** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response  | patch(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| static Response  | patch(String path, Object... pathParams)     | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| static Response  | patch(URI uri)                               | Отправка **HTTP** запроса **PATCH** по **uri**                                              |
| static Response  | patch(URL url)                               | Отправка **HTTP** запроса **PATCH** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "974c253452ba510");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.patch();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RestAssured
	// Given
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "6608dc75eedd44f")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	// When
	.when()
	    .patch()
	// Then
	.then()
	    .assertThat()
	    .statusCode(200)
	    .body("firstname", Matchers.equalTo("Amod"))
	    .body("lastname", Matchers.equalTo("Mahajan"));
```

### 2.2.5. Delete

**Delete** - отправка **HTTP** запроса **DELETE**.

| Тип             | Метод                                         | Описание                                                                                     | 
|-----------------|-----------------------------------------------|----------------------------------------------------------------------------------------------|
| static Response | delete()                                      | Отправка **HTTP** запроса **DELETE** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | delete(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| static Response | delete(String path, Object... pathParams)     | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| static Response | delete(URI uri)                               | Отправка **HTTP** запроса **DELETE** по **uri**                                              |
| static Response | delete(URL url)                               | Отправка **HTTP** запроса **DELETE** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.cookie("token", "f4e70e7b9bbcd05");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response response = request.delete();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(201);

RequestSpecification getRequestSpec = RestAssured.given();
getRequestSpec.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response res = getRequestSpec.get();
ValidatableResponse valRes = res.then();
valRes.statusCode(404);
```

*Пример*

**BDD** стиль.

```java
RestAssured
	// Given
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "f7dddb1093eab19")
	// When
	.when()
	    .delete()
	// Then
	.then()
	    .assertThat()
	    .statusCode(201);
RestAssured
	// Given   
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	// When
	.when()
	    .get()
	// Then
	.then()
	    .statusCode(404);
```

### 2.2.6. Request

**Request** - отправка **HTTP** запроса.

| Тип             | Метод                                                     | Описание                                                                          | 
|-----------------|-----------------------------------------------------------|-----------------------------------------------------------------------------------|
| static Response | request(Method method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | request(Method method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                             |
| static Response | request(Method method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                              |
| static Response | request(Method method, URL url)                           | Отправка **HTTP** запроса по **url**                                              |
| static Response | request(String method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | request(String method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                             |
| static Response | request(String method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                              |
| static Response | request(String method, URL url)                           | Отправка **HTTP** запроса по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.contentType(ContentType.JSON);
```

*Пример*

**BDD** стиль.

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
	// Given	
    .given()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
	// Then		
    .expect()
        .statusCode(200)
        .contentType(ContentType.JSON)
	// When	
    .when()
        .request("GET","/character");
```

***

# 3. Интерфейс RequestSender

**RequestSender** - интерфейс, содержащий методы для отправки **HTTP** запросов.

Методы класса **RequestSender**:

[io/restassured : RequestSender](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/RequestSender.html)

Далее рассмотрим основные методы.

| Тип | Метод | Описание | 
|-----|-------|----------|
|     |       |          |

***

# 4. Интерфейс Response

***Response*** - интерфейс, содержащий методы для обработки **HTTP** ответа.

Интерфейс **Response** наследует следующие интерфейсы:

* **ResponseBody<Response>**
* **ResponseBodyData**
* **ResponseBodyExtractionOptions**
* **ResponseOptions<Response>**
* **Validatable<ValidatableResponse,Response>**

Методы интерфейса **Response**:

[io/restassured : Response](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/response/Response.html)

***

# 5. Интерфейс ResponseBody\<Response\>

***ResponseBody*** - интерфейс, содержащий методы для вывода в консоль.

Методы интерфейса **ResponseBody**:

[io/restassured : ResponseBody](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/response/ResponseBody.html)

## 5.1. Вывод в консоль

### 5.1.1. Peek

| Тип     | Метод         | Описание                                   |
|---------|---------------|--------------------------------------------|
| T       | peek()        | Вывод в консоль в не отфоратированном виде |
| T       | prettyPeek()  | Вывод в консоль в отфоратированном виде    |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    .given()
	    .accept(ContentType.JSON)
	    .queryParam("name","Rick Sanchez")
    .when()
	    .request("GET","/character")
	    .prettyPeek()
    .then()
	    .statusCode(200)
	    .contentType(ContentType.JSON);
```

### 5.1.2. Print

| Тип     | Метод         | Описание                                                           |
|---------|---------------|--------------------------------------------------------------------|
| String  | print()       | Вывод в консоль в не отфоратированном виде и возврат в виде строки |
| String  | prettyPrint() | Вывод в консоль в отфоратированном виде и возврат в виде строки    |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String print  = response.prettyPrint();
```

***

# 6. Интерфейс ResponseBodyExtractionOptions

***ResponseBodyExtractionOptions*** - интерфейс, содержащий методы для преобразования и извлечения данных из тела запроса.

Методы интерфейса **ResponseBodyExtractionOptions**:

[io/restassured : ResponseBodyExtractionOptions](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/response/ResponseBodyExtractionOptions.html)

## 6.1. Преобразование данных из тела запроса

### 6.1.1. As Class

| Тип   | Метод                                         | Описание                                                                         |
|-------|-----------------------------------------------|----------------------------------------------------------------------------------|
| <T> T | as(Class<T> cls)                              | Преобразование тела запроса в **Java объект**                                    |
| <T> T | as(Class<T> cls, ObjectMapper mapper)         | Преобразование тела запроса в **Java объект** с помощью маппера                  |
| <T> T | as(Class<T> cls, ObjectMapperType mapperType) | Преобразование тела запроса в **Java объект** с помощью маппера конкретного типа |

*Пример*

Java объект

```java
public class Message {
    private String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
```

Ответ

```json
{
  "message": "My message"
}
```

Преобразование

```java
Message message = get("/message").as(Message.class);
```

### 6.1.2. As Type

| Тип   | Метод                                     | Описание                                                                      |
|-------|-------------------------------------------|-------------------------------------------------------------------------------|
| <T> T | as(Type cls)                              | Преобразование тела запроса в **Java тип**                                    |
| <T> T | as(Type cls, ObjectMapper mapper)         | Преобразование тела запроса в **Java тип** с помощью маппера                  |
| <T> T | as(Type cls, ObjectMapperType mapperType) | Преобразование тела запроса в **Java тип** с помощью маппера конкретного типа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
RickSanchez rickSanchez = response.as(RickSanchez.class);
System.out.println("rickSanchez: " + rickSanchez.toString());
```

### 6.1.3. As TypeRef

| Тип   | Метод                  | Описание                                 |
|-------|------------------------|------------------------------------------|
| <T> T | as(TypeRef<T> typeRef) | Преобразование тела запроса дженерик тип |

*Пример*

```java

```

## 6.2. Извлечение данных из тела запроса

### 6.2.1. Path

| Тип   | Метод                                  | Описание                                                                 |
|-------|----------------------------------------|--------------------------------------------------------------------------|
| <T> T | path(String path, String... arguments) | Извлечение данных из тела запроса с помощью **JsonPath** или **XmlPath** |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String name = response.path("results[0].name");
System.out.println("name: " + name);
```

### 6.2.2. JsonPath

| Тип      | Метод                           | Описание                                                 |
|----------|---------------------------------|----------------------------------------------------------|
| JsonPath | jsonPath()                      | Извлечение данных из тела запроса с помощью **JsonPath** |
| JsonPath | jsonPath(JsonPathConfig config) | Извлечение данных из тела запроса с помощью **JsonPath** |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String name = response.jsonPath().getString("results[0].name");
System.out.println("name: " + name);
```

### 6.2.3. XmlPath

| Тип     | Метод                                        | Описание                                                                                |
|---------|----------------------------------------------|-----------------------------------------------------------------------------------------|
| XmlPath | xmlPath()                                    | Извлечение данных из тела запроса с помощью **XmlPath**                                 |
| XmlPath | xmlPath(XmlPathConfig config)                | Извлечение данных из тела запроса с помощью **XmlPath**                                 |
| XmlPath | xmlPath(CompatibilityMode compatibilityMode) | Извлечение данных из тела запроса с помощью **XmlPath** и **XmlPath.CompatibilityMode** |

*Пример*

```java
RequestSpecification request = RestAssured.given();

Response response = request.request("GET","https://chercher.tech/sample/api/books.xml");
String book = response.xmlPath().getString("bookstore.book.title");
System.out.println("book: " + book);
```

### 6.2.4. HtmlPath

| Тип      | Метод      | Описание                                                                                       |
|----------|------------|------------------------------------------------------------------------------------------------|
| XmlPath  | htmlPath() | Извлечение данных из тела запроса с помощью **XmlPath** и **XmlPath.CompatibilityMode = HTML** |

*Пример*

```java
RequestSpecification request = RestAssured.given();

Response response = request.request("GET","https://github.com/");
String title = response.htmlPath().getString("html.head.title");
System.out.println("title: " + title);
```

***

# 7. Интерфейс ResponseBodyData

***ResponseBodyData*** - интерфейс, содержащий методы для получения данных из тела запроса.

Методы интерфейса **ResponseBodyData**:

[io/restassured : ResponseBodyData](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/response/ResponseBodyData.html)

## 7.1. Получение данных из тела запроса

### 7.1.1. 

| Тип         | Метод            | Описание                                                        |
|-------------|------------------|-----------------------------------------------------------------|
| byte[]      | asByteArray()    | Получение данных из тела запроса в **byte array**.              |
| InputStream | asInputStream()  | Получение данных из тела запроса в **input stream**.            |
| String      | asPrettyString() | Получение данных из тела запроса в **pretty formatted string**. |
| String      | asString()       | Получение данных из тела запроса в **string**.                  |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
byte[] asByteArray = response.asByteArray();
System.out.println("asByteArray length: " + asByteArray.length);
```

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String asPrettyString = response.asPrettyString();
System.out.println("asPrettyString: " + asPrettyString);
```

***

# 8. Интерфейс ResponseOptions

***ResponseOptions*** - интерфейс, содержащий методы для обработки ответа.

Методы интерфейса **ResponseOptions**:

[io/restassured : ResponseOptions](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/response/ResponseOptions.html)

## 8.1. Получение тела запроса

### 8.1.1. Body

| Тип          | Метод     | Описание               |
|--------------|-----------|------------------------|
| ResponseBody | body()    | Получение тела запроса |
| ResponseBody | getBody() | Получение тела запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
ResponseBody body = response.body();
System.out.println("body: " + body.asPrettyString());
```

### 8.1.2. ContentType

| Тип    | Метод            | Описание                             |
|--------|------------------|--------------------------------------|
| String | contentType()    | Получение типа контента тела запроса |
| String | getContentType() | Получение типа контента тела запроса |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String contentType = response.contentType();
System.out.println("contentType: " + contentType);
```

## 8.2. Куки

### 8.2.1. Cookie

| Тип    | Метод                  | Описание                |
|--------|------------------------|-------------------------|
| String | cookie(String name)    | Получение куки по имени |
| String | getCookie(String name) | Получение куки по имени |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String cookie = response.cookie("Cookie 1");
System.out.println("cookie: " + cookie);
```

### 8.2.2. Cookies

| Тип                | Метод        | Описание            |
|--------------------|--------------|---------------------|
| Map<String,String> | cookies()    | Получение всех куки |
| Map<String,String> | getCookies() | Получение всех куки |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
Map<String,String> cookies = response.cookies();
for(Map.Entry<String, String> entry : cookies.entrySet()) {
   System.out.println(
           "key: " + entry.getKey() + 
           "value: " + entry.getValue()
   );
}
```

### 8.2.3. DetailedCookie

| Тип    | Метод                          | Описание                |
|--------|--------------------------------|-------------------------|
| Cookie | detailedCookie(String name)    | Получение куки по имени |
| Cookie | getDetailedCookie(String name) | Получение куки по имени |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
Cookie detailedCookie  = response.detailedCookie("Cookie 1");
System.out.println("detailedCookie: " + detailedCookie.toString());
```

### 8.2.4. DetailedCookies

| Тип     | Метод                | Описание            |
|---------|----------------------|---------------------|
| Cookies | detailedCookies()    | Получение всех куки |
| Cookies | getDetailedCookies() | Получение всех куки |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
Cookies detailedCookies  = response.detailedCookies();
System.out.println("detailedCookies: " + detailedCookies.toString());
```

## 8.3. Заголовки 

### 8.3.1. Header

| Тип    | Метод                  | Описание                   |
|--------|------------------------|----------------------------|
| String | header(String name)    | Получение заголовка ответа |
| String | getHeader(String name) | Получение заголовка ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String header  = response.header("Date");
System.out.println("header: " + header);
```

### 8.3.2. Headers

| Тип     | Метод        | Описание                         |
|---------|--------------|----------------------------------|
| Headers | headers()    | Получение всех заголовков ответа |
| Headers | getHeaders() | Получение всех заголовков ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
Headers headers  = response.headers();
System.out.println("headers: " + headers.toString());
```

## 8.4. Статус 

## 8.4.1. StatusCode

| Тип | Метод           | Описание                      | 
|-----|-----------------|-------------------------------|
| int | statusCode()    | Получение кода статуса ответа |
| int | getStatusCode() | Получение кода статуса ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
int statusCode  = response.statusCode();
System.out.println("statusCode: " + statusCode);
```

## 8.4.2. StatusLine

| Тип    | Метод           | Описание                 | 
|--------|-----------------|--------------------------|
| String | statusLine()    | Получение статуса ответа |
| String | getStatusLine() | Получение статуса ответа |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
String statusLine  = response.statusLine();
System.out.println("statusLine: " + statusLine);
```

## 8.5. Время

## 8.5.1. Time

| Тип  | Метод     | Описание                                             |
|------|-----------|------------------------------------------------------|
| long | time()    | Получение времени выполнения запроса в миллисекундах |
| long | getTime() | Получение времени выполнения запроса в миллисекундах |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
long time  = response.time();
System.out.println("time: " + time);
```

## 8.5.2. TimeIn

| Тип  | Метод                        | Описание                                                                   |
|------|------------------------------|----------------------------------------------------------------------------|
| long | timeIn(TimeUnit timeUnit)    | Получение времени выполнения запроса в заданных единицах измерения времени |
| long | getTimeIn(TimeUnit timeUnit) | Получение времени выполнения запроса в заданных единицах измерения времени |

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
long timeIn  = response.timeIn(TimeUnit.MILLISECONDS);
System.out.println("timeIn: " + timeIn);
```

***

# 9. Интерфейс RequestSpecification

**RequestSpecification** - интерфейс, содержащий методы для   .

Методы класса **RequestSpecification**:

[io/restassured : RequestSpecification](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/RequestSpecification.html)

Далее рассмотрим основные методы.


***

# 10. Интерфейс ResponseSpecification

**ResponseSpecification** - интерфейс, содержащий методы для   .

Методы класса **ResponseSpecification**:

[io/restassured : ResponseSpecification](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/ResponseSpecification.html)

Далее рассмотрим основные методы.

***



***

# Best Practices

https://otus.ru/nest/post/1271/

1. **Выносите end-pointы в отдельное место**

С одной стороны, это очевидно. Но увы, до сих пор нередко встречается код, имеющий захардкоженные end-point'ы в запросе.
В целом же, лучше выносить end-point'ы в статические константы финального класса. Но тут есть нюанс — избегайте антипаттерна «константный интерфейс», т. к. это является плохой практикой. И помните, что REST-assured даёт возможность выносить параметры пути, к примеру:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}

given().pathParams("id", someId).get(EndPoints.users)...;
```

или так

```java
given().get(EndPoints.users, someId)....
```

Кроме того, если вы во многих запросах применяете одинаковый базовый путь,
считается хорошей практикой выносить его в отдельную константу, передавая в basePath, как в примере ниже:


имеем url приложения http://host:port/appname/rest/someEndpoints

```java
private static final basePath = "/appname/rest/";
```

можно задать базовый путь на глобальном уровне,
и он будет использоваться ко всем запросам

```java
RestAssured.basePath = basePath;

// либо на уровне одного запроса:
given().basePath(basePath)...

// либо на уровне спецификации, но об этом поговорим позже
```

То же применимо как к хосту, так и к порту тестируемого программного приложения.

2. **ContentType/Accept**

Эти заголовки применяются почти во всех HTTP-запросах.
Разработчики REST-assured прекрасно это понимают,
поэтому они обеспечили возможность их установки посредством вызова специальных методов:

```java
// вот то плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;
// а вот эта хорошая:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой станет установка данных заголовков в спецификации либо на глобальном уровне.
Результат — повышение читабельности кода.

3. **StatusCode** и т. п.
   Для выполнения проверки каждой составляющей HTTP-ответа, библиотека REST-assured предоставляет удобный синтаксис.
   Но на практике часто можно увидеть следующий код:

```java
// это плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());
```

```java
//а это хорошая:
given()...when().get(someEndpoint).then().statusCode(200);
```

4. **Используйте спецификации**
   Мы знаем, что дублировать код не есть хорошо. Для уменьшения дублирования нужно использовать спецификации.
   В REST-assured есть возможность создания спецификации и для запроса, и для ответа.
   В спецификацию запроса можно вынести всё, что можно продублировать в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// мы можем задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// либо для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

Кроме того, в спецификацию ответа можно выносить все проверки, дублируемые от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// мы можем задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// либо для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;

```

Также мы можем создавать несколько спецификаций для различных типов запросов/ответов и применять их в нужном случае.

5. **Не надо писать собственные костыли для преобразования объектов**
   Не нужно преобразовывать свои POJO в JSON, используя Jackson ObjectMapper'а, а потом передавать полученную строку в тело запроса. Почему? Потому что с этой задачей отлично справляется библиотека REST-assured. Причём применяется всё тот же Jackson либо Gson с учётом того, что находится в classpath. А чтобы выполнить преобразование в XML, применяется JAXB. Что касается исходного формата, то он определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое действует и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Вдобавок к вышесказанному, REST-assured хорошо справляется и с преобразованием HashMap в JSON и в обратном порядке.

6. Используйте всю силу Groovy
   Так как сама библиотека написана на Groovy, она даёт возможность использовать к полученному JSON/XML-ответу разные методы из Groovy. Допустим:

```java
// методы find, findAll используются к коллекции для поиска первого и всех вхождений, а метод collect — для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно, указывая на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можно явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// можно применять методы max, min, sum в целях суммирования всех значений коллекции и поиска максимального и минимально значений

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Применение методов из Groovy сократит количество кода, написанного вами в целях поиска необходимого значения из ответа.


https://qa.crtweb.ru/docs/testing/auto/api/rest-assured-best-practices/

**Используйте спецификации**

Конструкция типа

```java
given().accept(ContentType.JSON)
```

используется абсолютно в каждом запросе, и, даже если это всего две строчки, их можно сократить до вызова одного метода, увеличив тем самым читаемость кода, если вынести их в отдельный метод:

```java
public static RequestSpecification requestSpec() {
    return given()
        .accept(ContentType.JSON);
}
```

или билдер:

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setAccept(ContentType.JSON)
    .build();
```

А в каждом запросе достаточно использовать только вызов этого метода или билдера.

Кроме того, на деле вряд ли весь код, который можно было бы вынести в спецификацию запроса ограничивается двумя строками – наверняка туда можно добавить заголовки для авторизации, установку хоста и порта, настройки логирования, фильтры для Allure и что угодно еще, что необходимо выполнять при каждом запросе.

То же самое можно сделать и с ответом. В нем можно проверить статус-код, время ожидания ответа, а так же наличие необходимых полей в теле ответа или заголовков. Как и в случае с запросом, можно использовать метод:

```java
public static ValidatableResponse responseSpecOk(Response response) {
    return response
        .then()
        .statusCode(200)
        .time(lessThanOrEqualTo(responseTime));
}
```

или билдер:

```java
ResponseSpecification responseSpecOk = new ResponseSpecBuilder()
        .expectStatusCode(200)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
```

**Храните эндпойнты в отдельном месте**

Не стоит отдельно прописывать эндпойнт для каждого запроса.
Даже если их немного, при необходимости внесения изменений что-то все равно может потеряться и поиск проблемы гарантированно займет куда больше времени, чем организация корректного хранения эндпойнтов.

Тут есть несколько вариантов:

если для каждого эндпойнта существует свой собственный класс, можно просто хранить их в переменных этого класса;
можно создать отдельный класс для управления эндпойнтами, и хранить все эндпойнты в переменных этого класса;
и, наконец, эндпойнты можно хранить в отдельном property-файле.

В случае, если эндпойнт включает в себя какое-то изменяемое значение (например, ID), можно пользоваться записью такого вида:

```java
String endpoint = endpoint/{id}
```

В таком случае, подставить на место значения в фигурных скобках нужную переменную можно будет следующим образом:

```java
.get(endpoint, id)
```

Однако стоит иметь в виду, что подобная запись не всегда работает корректно, так что в некоторых проектах, возможно, придется обходиться без нее.

**Выносите base URI в properties**

Так же, как и упомянутые выше заголовки, скорее всего часть URL повторяется в каждом запросе. Ее также можно вынести в отдельное место и объявить только один раз.

Для этого удобнее всего вынести baseURI в properties-файл и получать его значение через класс типа ManageProperties. Объявить baseURI можно двумя способами:

```java
given()
    .baseUri(getProperty("baseUri"))
```

или

```java
RestAssured.baseURI = getProperty("baseUri");
```

Что касается непосредственно самого вызова baseURI, тут тоже есть пара вариантов:

Первый – вызывать его в каждом запросе. Такой вариант выглядит более громоздко, но подойдет в том случае, если в определенных случаях нужно использовать другой base URI.

Второй – объявить его однократно, например, в спецификации запроса.

**Используйте функционал Rest Assured для преобразования объектов**

Нет необходимости преобразовывать POJO в Json с помощью возможностей внешних библиотек, так как Rest Assured прекрасно справляется с этим самостоятельно. Достаточно добавить нужный POJO в тело запроса:

```java
Pojo pojo = new Pojo();
```

```java
given()
    .body(pojo)
    .post(URI);
```

Обратный процесс также работает:

```java
Pojo pojo = given()
    .get(URI)
    .then
    .extract().body().as(Pojo.class)
```

Кроме того, Rest Assured умеет преобразовывать в Json и HashMap, в том числе и вложенные:

```java
Map <Object, Object> outerMap = new HashMap<Object, Object>();
Map <Object, Object> innerMap = new HashMap<Object, Object>();

innerMap.put("key", "value");

outerMap.put("key", "value");
outerMap.put("innerMap", innerMap);

given()
    .body(outerMap)
    .post(URI);
```

**Используйте валидацию Json-схемы**

Валидация Json-схемы - это простой и надежный способ убедиться, что полученные данные соответствуют ожидаемому формату. Json-схема имеет следующий вид:

```json
{
    "type": "object",
    "properties": {
        "id": {
            "type": "integer"
        },
        "item": {
            "type": "object",
            "properties": {
                "key1": {
                    "type": ["string", "integer"]
                },
                "key2": {
                    "type": "string"
                }

            },
            "required": ["key1", "key2"]
        }
    },
    "required": ["id", "item"]
}

```

Создавать Json-схемы можно и вручную, но из-за не слишком человекоориентированного формата это может быть довольно утомительно, так что куда проще использовать для этого любой из многочисленных автоматических инструментов. Например: https://www.liquid-technologies.com/online-json-to-schema-converter

Такая схема проверяет, что полученный в ответе Json содержит в себе все поля, которые указаны как обязательные, и что тип данных в каждом из этих полей соответствует ожидаемому.

Для использования валидации Json-схем понадобится установить библиотеку json-schema-validator (в данном случае используется библиотека от io.rest-assured) и использовать следующий метод:

```java
.body(matchesJsonSchemaInClasspath("schema.json"));
```

**Выносите повторяющиеся действия в отдельные методы**

Нет никакой необходимости десять раз проверять, что ответ на запрос в десяти тестах соответствует схеме, достаточно один раз написать отдельный метод, который проводит эту проверку, и в дальнейшем просто обращаться к нему.

Это справедливо и для любых повторяющихся действий – намного удобнее читать (и тем более писать!) код, в котором все спецификации, конструкторы и проверки разбиты на отдельные блоки, из которых можно создать нужные тесты. Например, вот так:

```java
public static RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri(BASE_URI)
    .setContentType(ContentType.JSON)
    .setAccept(ContentType.JSON)
    .build();

public static ResponseSpecification responseSpec(int statusCode) {
    return new ResponseSpecBuilder()
            .expectStatusCode(statusCode)
            .expectResponseTime(lessThanOrEqualTo(responseTime))
            .build();
}

public static Response createItem(Pojo body) {
    return given()
        .spec(requestSpec)
        .body(body)
        .post(Uri);
    }

public static ValidatableResponse createItem_valid(Response response) {
    return response
            .then()
            .spec(responseSpec(200))
            .body(matchesJsonSchemaInClasspath("schemas/CreateItem.json"));
}

@Test
public void createItemTest() {
    createItem_valid(
        createItem(body))
}
```

**Используйте Hamcrest Matchers**

В случе, когда нет необходимости десериализовать ответ в POJO, мэтчеры из библиотеки Hamcrest являются самым быстрым способом повести валидацию отдельных элементов содержимого ответа.

Они позволяют проверить, что, например, ответ содержит в себе определенную строку или значение, или что конкретное поле равно определенному значению, или что массив содержит в себе некоторый набор элементов в произвольном порядке.

```java
.body("id", equals(getId()))
.body("id", greaterThanOrEqualTo(1))
.body("items", either(hasItem("a")).and(hasItem("b"))
```

Все выполняемые мэтчерами проверки, несомненно, можно произвести и другими способами, однако они позволяют сделать это в краткой и удобной для чтения форме.

С полной документацией к мэтчерам можно ознакомиться здесь: http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html

**Используйте методы для добавления заголовков**

Так как по крайней мере один из этих заголовков используется практически в любом запросе, для них был создан более краткий вариант записи:

```java
given()
	.contentType(ContentType.JSON)
	.accept(ContentType.JSON)
```

Такой вариант немного короче обычной записи заголовков через метод header и, что более важно, минимизирует шанс возникновения ошибки из-за опечатки.

Однако стоит обратить внимание на то, что при таком оформлении заголовков в Accept помимо application/json также передаются application/javascript, text/javascript и text/json. В некоторых API это может привести к ошибкам, и в таком случае enum ContentType стоит заменить на строку с указанием конкретного типа данных.

**Проверяйте статус-код без assertThat**

Запись типа

```java
.assertThat(statusCode(200))
```

просто излишня. Эта строка выполняет ту же самую работу:

```java
.statusCode(200)
```

**Передавайте статус-коды в качестве аргумента**

При наличии большого количества негативных проверок с разными ожидаемыми кодами ошибок, нет необходимости писать отдельную спецификацию под каждый статус-код, вместо этого можно просто добавить спецификацию в метод и передавать в нее ожидаемый статус-код из теста:

```java
public static ResponseSpecification responseSpecError(int statusCode) {
    return new ResponseSpecBuilder()
        .expectStatusCode(statusCode)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
}
```

**Используйте логирование для отладки тестов**

Метод .log() позволяет получить информацию как об отправленном запросе, так и о полученном ответе. В первом случае необходимо его применить до отправки запроса (get, post и т.д.), во втором случае – после.

Вам доступны следующие методы:

```java
.log().all()
.log().params()
.log().body()
.log().headers()
.log().cookies()
```

Однако оставлять логирование в тестах, которые уже дописаны и корректно работают, не стоит – объем в информации в логах может быть настолько большим, что результаты всех тестов перестанут умещаться в консоли IDE, не говоря уже о том, что просматривать результаты тестов в таком случае будет очень неудобно.

https://habr.com/ru/post/421005/

**Выносите end-point'ы в отдельное место**

Казалось бы, что это очевидно. Но нет, довольно часто приходится видеть код с захардкоженными end-point'ми в запросе.

Лучше всего выносить end-point'ы в статические константы финального класса. При этом стоит избегать антипаттерн «константный интерфейс» — это плохая практика.

Не забывайте, что REST-assured позволяет выносить параметры пути, например:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}
```

```java
given().pathParams("id", someId).get(EndPoints.users)...;

// или так

given().get(EndPoints.users, someId)....
```

Также, если во многих запросах вы используете один и тот же базовый путь, то будет хорошей практикой вынести его в отельную константу и передавать в basePath, например:

```java
// имеем следующий url приложения http://host:port/appname/rest/someEndpoints

private static final basePath = "/appname/rest/";

..

// можем задать базовый путь на глобальном уровне,
// он будет применяться ко всем запросам:
RestAssured.basePath = basePath;

// или на уровне одного запроса:
given().basePath(basePath)...

// или на уровне спецификации, но об этом далее
```

То же самое применимо к хосту и порту тестируемого приложения.

```java
ContentType/Accept
```
Данные заголовки используются практически во всех HTTP-запросах. Авторы REST-assured, понимая это, сделали возможным их установку через вызов специальных методов:

```java
// плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;

// хорошая практика написания:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой будет установить данные заголовки в спецификации или на глобальном уровне. Это повысит читабельность вашего кода.

**StatusCode и т.п.**

REST-assured предоставляет удобный синтаксис для проведения проверки каждой составляющей HTTP-ответа, однако на практике продолжаешь встречать подобный код:

```java
// плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());

// хорошая практика написания:
given()...when().get(someEndpoint).then().statusCode(200);
```

**Используйте спецификации**

Дублирование кода — это плохо. Используйте спецификации для уменьшения дублирования. В REST-assured можно создавать спецификации как для запроса, так и для ответа. В спецификацию запроса выносим всё, что может быть продублировано в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// можно задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// или для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

В спецификацию ответа выносим все проверки, которые дублируются от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// можно задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// или для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;
```

Можно создавать несколько спецификаций для разных типов запросов/ответов и использовать в нужной ситуации.

**Не пишите свои костыли для преобразования объектов**

Не стоит преобразовывать свои POJO в JSON при помощи Jackson ObjectMapperа, а потом полученную строку передавать в тело запроса. REST-assured прекрасно справляется с этой задачей. Для этого используется всё тот же Jackson или Gson, в зависимости от того, что находится в classpath. Для преобразования в XML используется JAXB. Исходный формат определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Кроме того REST-assured прекрасно справляется с преобразованием HashMap в JSON и обратно.


**Используйте всю мощь Groovy**

Сама библиотека REST-assured написана на Groovy и позволяет вам применять различные методы из Groovy к полученному JSON/XML ответу. Например:

```java
// методы find, findAll применяются к коллекции для поиска первого и всех вхождений, метод collect для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// вы можете использовать методы sum, max, min для суммирования всех значений коллекции, а также поиска максимального и минимально значения

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Использование методов из Groovy позволяет сильно сократить количество кода, написанного вами для поиска необходимого значения из ответа.

На этом всё, если у вас есть еще советы и примеры пишите их в комментариях.



***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)