Java_QA / 14. API. REST Assured

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. REST Assured](#1-rest-assured)
* [2. Класс RestAssured](#2-класс-restassured)
  * [2.1. Given, With, Expect, When](#21-given-with-expect-when)
    * [2.1.1. Given](#211-given)
    * [2.1.2. With](#212-with)
    * [2.1.3. Expect](#213-expect)
    * [2.1.4. When](#214-when)
  * [2.2. Get, Post, Put, Patch, Delete, Request](#22-get-post-put-patch-delete-request)
    * [2.2.1. Get](#221-get)
    * [2.2.2. Post](#222-post)
    * [2.2.3. Put](#223-put)
    * [2.2.4. Patch](#224-patch)
    * [2.2.5. Delete](#225-delete)
    * [2.2.6. Request](#226-request)
* [3. Интерфейс RequestSender](#3-интерфейс-requestsender)
* [4. Интерфейс Response](#4-интерфейс-response)
* [5. Интерфейс ResponseBody<Response>](#5-интерфейс-responsebodyresponse)
  * [5.1. Вывод в консоль](#51-вывод-в-консоль)
    * [5.1.1. Peek](#511-peek)
    * [5.1.2. Print](#512-print)
* [6. Интерфейс ResponseBodyExtractionOptions](#6-интерфейс-responsebodyextractionoptions)
  * [6.1. Преобразование данных из тела запроса](#61-преобразование-данных-из-тела-запроса)
    * [6.1.1. As Class](#611-as-class)
    * [6.1.2. As Type](#612-as-type)
    * [6.1.3. As TypeRef](#613-as-typeref)
  * [6.2. Извлечение данных из тела запроса](#62-извлечение-данных-из-тела-запроса)
    * [6.2.1. Path](#621-path)
    * [6.2.2. JsonPath](#622-jsonpath)
    * [6.2.3. XmlPath](#623-xmlpath)
    * [6.2.4. HtmlPath](#624-htmlpath)
* [7. Интерфейс ResponseBodyData](#7-интерфейс-responsebodydata)
  * [7.1. Получение данных из тела запроса](#71-получение-данных-из-тела-запроса)
    * [7.1.1.](#711)
* [8. Интерфейс ResponseOptions](#8-интерфейс-responseoptions)
  * [8.1. Получение тела запроса](#81-получение-тела-запроса)
    * [8.1.1. Body](#811-body)
    * [8.1.2. ContentType](#812-contenttype)
  * [8.2. Куки](#82-куки)
    * [8.2.1. Cookie](#821-cookie)
    * [8.2.2. Cookies](#822-cookies)
    * [8.2.3. DetailedCookie](#823-detailedcookie)
    * [8.2.4. DetailedCookies](#824-detailedcookies)
  * [8.3. Заголовки](#83-заголовки)
    * [8.3.1. Header](#831-header)
    * [8.3.2. Headers](#832-headers)
  * [8.4. Статус](#84-статус)
    * [8.4.1. StatusCode](#841-statuscode)
    * [8.4.2. StatusLine](#842-statusline)
  * [8.5. Время](#85-время)
    * [8.5.1. Time](#851-time)
    * [8.5.2. TimeIn]()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
* []()
*
***

# 1. REST Assured

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***REST Assured*** — **Java** библиотека для тестирования **REST** сервисов, предоставляющая **DSL** в **BDD** стиле. 

Библиотека **REST Assured** интегрируется с любым фреймворком автоматизации, основанным на **Java**.

Это решение появилось более девяти лет назад и стало популярным из-за своей простоты и удобного функционала.

Ссылки:

* [REST Assured](https://rest-assured.io/)
* [REST Assured. Github](https://github.com/rest-assured/rest-assured)
* [REST Assured. Github. GettingStarted](https://github.com/rest-assured/rest-assured/wiki/GettingStarted)
* [REST Assured. Github. Usage Guide](https://github.com/rest-assured/rest-assured/wiki/Usage)
* [REST Assured. Javadoc](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/index.html)

Ключевые слова **given**, **when** и **then** формируют запрос:

* **given** - условия (заголовки, параметры, тело запроса и т д)
* **when** – действие (отправка запроса с заданными условиями, методом и ендпоинтом запроса)
* **then** – проверка (проверка ответа)

Кроме этого, можно извлечь тело ответа в виде объекта типа **JsonPath** или **XmlPath**.

***

# 2. Класс RestAssured 

**RestAssured** - класс предоставляющий DSL.

Методы класса **RestAssured**:

[io/restassured : RestAssured](https://www.javadoc.io/doc/io.rest-assured/rest-assured/latest/io/restassured/RestAssured.html)

Далее рассмотрим основные методы.

## 2.1. Параметры запроса и ответа

| Тип                          | Метод                                                                | Описание                                                                                                                   | 
|------------------------------|----------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| static RequestSpecification  | given()                                                              | Параметры отправляемого запроса                                                                                            |
| static RequestSpecification  | given(RequestSpecification rqstSpec)                                 | Параметры отправляемого запроса на основе спецификации запроса                                                             |
| static RequestSender         | given(RequestSpecification rqstSpec, ResponseSpecification rspsSpec) | Параметры <br/>отправляемого запроса на основе спецификации запроса, <br/>получаемого ответа на основе спецификации ответа |
| static RequestSpecification  | with()                                                               | Параметры отправляемого запроса                                                                                            |
| static ResponseSpecification | expect()                                                             | Параметры получаемого ответа                                                                                               |
| static RequestSender         | when()                                                               | Отправка запроса                                                                                                           |

### 2.1.1. Метод given

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
	.given().queryParam("name","Rick Sanchez")
	.when().get("/character")
	.then().statusCode(200);
```

### 2.1.2. Метод with

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
	.with().queryParam("name","Rick Sanchez")
	.when().get("/character")
	.then().statusCode(200);
```

### 2.1.3. Метод expect

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
	.with().queryParam("name","Rick Sanchez")
	.expect().contentType(ContentType.JSON)
    .when().get("/character");
```

### 2.1.4. Метод when

*Пример*

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    .given().queryParam("name","Rick Sanchez")
    .when().get("/character")
    .then().statusCode(200);
```

## 2.2. Отправка HTTP запроса

| Тип             | Метод                                                     | Описание                                                                                     | 
|-----------------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------|
| static Response | request(Method method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**)            |
| static Response | request(Method method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                                        |
| static Response | request(Method method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                                         |
| static Response | request(Method method, URL url)                           | Отправка **HTTP** запроса по **url**                                                         |
| static Response | request(String method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**)            |
| static Response | request(String method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                                        |
| static Response | request(String method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                                         |
| static Response | request(String method, URL url)                           | Отправка **HTTP** запроса по **url**                                                         |

*Пример*

```java

```

## 2.3. Отправка запроса GET

| Тип             | Метод                                      | Описание                                                                  | 
|-----------------|--------------------------------------------|---------------------------------------------------------------------------|
| static Response | get()                                      | Отправка **HTTP** запроса **GET** по **path** (**http://localhost:8080**) |
| static Response | get(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **GET** по **path**                             |
| static Response | get(String path, Object... pathParams)     | Отправка **HTTP** запроса **GET** по **path**                             |
| static Response | get(URI uri)                               | Отправка **HTTP** запроса **GET** по **uri**                              |
| static Response | get(URL url)                               | Отправка **HTTP** запроса **GET** по **url**                              |

*Пример*

```java
.baseUri("https://restful-booker.herokuapp.com")
.get("/booking")
```

## 2.4. Отправка запроса POST

| Тип             | Метод                                       | Описание                                                                   | 
|-----------------|---------------------------------------------|----------------------------------------------------------------------------|
| static Response | post()                                      | Отправка **HTTP** запроса **POST** по **path** (**http://localhost:8080**) |
| static Response | post(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **POST** по **path**                             |
| static Response | post(String path, Object... pathParams)     | Отправка **HTTP** запроса **POST** по **path**                             |
| static Response | post(URI uri)                               | Отправка **HTTP** запроса **POST** по **uri**                              |
| static Response | post(URL url)                               | Отправка **HTTP** запроса **POST** по **url**                              |

*Пример*

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

.baseUri("https://restful-booker.herokuapp.com/auth")
.contentType(ContentType.JSON)
.body(jsonString)
.post()
```

## 2.5. Отправка запроса PUT

| Тип             | Метод                                  | Описание                                                                                  | 
|-----------------|----------------------------------------|-------------------------------------------------------------------------------------------|
| static Response | put()                                  | Отправка **HTTP** запроса **PUT** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | put(String path, Object... pathParams) | Отправка **HTTP** запроса **PUT** по **path**                                             |
| static Response | put(URI uri)                           | Отправка **HTTP** запроса **PUT** по **uri**                                              |
| static Response | put(URL url)                           | Отправка **HTTP** запроса **PUT** по **url**                                              |

*Пример*

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "e88375c0fde687a")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	    .put()
```

## 2.6. Отправка запроса PATCH

| Тип             | Метод                                        | Описание                                                                                    | 
|-----------------|----------------------------------------------|---------------------------------------------------------------------------------------------|
| static Response | patch()                                      | Отправка **HTTP** запроса **PATCH** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | patch(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| static Response | patch(String path, Object... pathParams)     | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| static Response | patch(URI uri)                               | Отправка **HTTP** запроса **PATCH** по **uri**                                              |
| static Response | patch(URL url)                               | Отправка **HTTP** запроса **PATCH** по **url**                                              |

*Пример*

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

.baseUri("https://restful-booker.herokuapp.com/booking/1")
.cookie("token", "6608dc75eedd44f")
.contentType(ContentType.JSON)
.body(jsonString)
.patch()
```

## 2.7. Отправка запроса DELETE

| Тип             | Метод                                         | Описание                                                                                     | 
|-----------------|-----------------------------------------------|----------------------------------------------------------------------------------------------|
| static Response | delete()                                      | Отправка **HTTP** запроса **DELETE** по **path** (по умолчанию на **http://localhost:8080**) |
| static Response | delete(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| static Response | delete(String path, Object... pathParams)     | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| static Response | delete(URI uri)                               | Отправка **HTTP** запроса **DELETE** по **uri**                                              |
| static Response | delete(URL url)                               | Отправка **HTTP** запроса **DELETE** по **url**                                              |

*Пример*

```java
.baseUri("https://restful-booker.herokuapp.com/booking/1")
.cookie("token", "f7dddb1093eab19")
.delete()
```

***

# 3. Интерфейс RequestSender

**RequestSender** - интерфейс, содержащий методы для отправки **HTTP** запросов.

Методы класса **RequestSender**:

[io/restassured : RequestSender](https://www.javadoc.io/static/io.rest-assured/rest-assured/5.2.0/io/restassured/specification/RequestSender.html)

Далее рассмотрим основные методы.

## 3.1. Отправка HTTP запроса

| Тип | Метод                                                     | Описание                                                                                     | 
|-----|-----------------------------------------------------------|----------------------------------------------------------------------------------------------|
| R   | request(Method method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**)            |
| R   | request(Method method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                                        |
| R   | request(Method method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                                         |
| R   | request(Method method, URL url)                           | Отправка **HTTP** запроса по **url**                                                         |
| R   | request(String method)                                    | Отправка **HTTP** запроса по **path** (по умолчанию на **http://localhost:8080**)            |
| R   | request(String method, String path, Object... pathParams) | Отправка **HTTP** запроса по **path**                                                        |
| R   | request(String method, URI uri)                           | Отправка **HTTP** запроса по **uri**                                                         |
| R   | request(String method, URL url)                           | Отправка **HTTP** запроса по **url**                                                         |

*Пример*

Не **BDD** стиль.

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RequestSpecification request = RestAssured.given();
request.accept(ContentType.JSON);
request.queryParam("name","Rick Sanchez");

Response response = request.request("GET","/character");
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.contentType(ContentType.JSON);
```

*Пример*

**BDD** стиль.

```java
RestAssured.baseURI = "https://rickandmortyapi.com/api/";
RestAssured
    .given()
        .accept(ContentType.JSON)
        .queryParam("name","Rick Sanchez")
    .expect()
        .statusCode(200)
        .contentType(ContentType.JSON)
    .when()
        .request("GET","/character");
```

## 3.2. Отправка запроса GET

| Тип | Метод                                      | Описание                                                                  | 
|-----|--------------------------------------------|---------------------------------------------------------------------------|
| R   | get()                                      | Отправка **HTTP** запроса **GET** по **path** (**http://localhost:8080**) |
| R   | get(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **GET** по **path**                             |
| R   | get(String path, Object... pathParams)     | Отправка **HTTP** запроса **GET** по **path**                             |
| R   | get(URI uri)                               | Отправка **HTTP** запроса **GET** по **uri**                              |
| R   | get(URL url)                               | Отправка **HTTP** запроса **GET** по **url**                              |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.baseUri("https://restful-booker.herokuapp.com/booking");

Response response = request.get();
ValidatableResponse valRes = response.then();
valRes.statusCode(200);
valRes.statusLine("HTTP/1.1 200 OK");
```

*Пример*

**BDD** стиль.

```java
RestAssured
	.given()
		.baseUri("https://restful-booker.herokuapp.com")
	.when()
		.get("/booking")
	.then()
		.statusCode(200)
		.statusLine("HTTP/1.1 200 OK")
		.body("bookingid.sum()", Matchers.hasSize(10))
		.body("bookingid[3]", Matchers.equalTo(1));
```

## 3.3. Отправка запроса POST

| Тип | Метод                                       | Описание                                                                   | 
|-----|---------------------------------------------|----------------------------------------------------------------------------|
| R   | post()                                      | Отправка **HTTP** запроса **POST** по **path** (**http://localhost:8080**) |
| R   | post(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **POST** по **path**                             |
| R   | post(String path, Object... pathParams)     | Отправка **HTTP** запроса **POST** по **path**                             |
| R   | post(URI uri)                               | Отправка **HTTP** запроса **POST** по **uri**                              |
| R   | post(URL url)                               | Отправка **HTTP** запроса **POST** по **url**                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.baseUri("https://restful-booker.herokuapp.com/auth");
request.body(jsonString);

Response response = request.post();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("token", Matchers.notNullValue());
validatableResponse.body("token.length()", Matchers.is(15));
validatableResponse.body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\"username\" : \"admin\",\"password\" : \"password123\"}";

RestAssured
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/auth")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	.when()
	    .post()
	.then()
	    .assertThat()
	    .statusCode(200)
	    .body("token", Matchers.notNullValue())
	    .body("token.length()", Matchers.is(15))
	    .body("token", Matchers.matchesRegex("^[a-z0-9]+$"));
```

## 3.4. Отправка запроса PUT

| Тип | Метод                                  | Описание                                                                                  | 
|-----|----------------------------------------|-------------------------------------------------------------------------------------------|
| R   | put()                                  | Отправка **HTTP** запроса **PUT** по **path** (по умолчанию на **http://localhost:8080**) |
| R   | put(String path, Object... pathParams) | Отправка **HTTP** запроса **PUT** по **path**                                             |
| R   | put(URI uri)                           | Отправка **HTTP** запроса **PUT** по **uri**                                              |
| R   | put(URL url)                           | Отправка **HTTP** запроса **PUT** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "fa0d5b1138a0d1f");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.put();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + "    \"firstname\" : \"Amod\",\r\n" + "    \"lastname\" : \"Mahajan\",\r\n"
        + "    \"totalprice\" : 111,\r\n" + "    \"depositpaid\" : true,\r\n" + "    \"bookingdates\" : {\r\n"
        + "        \"checkin\" : \"2018-01-01\",\r\n" + "        \"checkout\" : \"2019-01-01\"\r\n"
        + "    },\r\n" + "    \"additionalneeds\" : \"Breakfast\"\r\n" + "}";

RestAssured
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "e88375c0fde687a")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	.when()
	    .put()
	.then()
	    .assertThat()
	    .statusCode(200)
	    .body("firstname", Matchers.equalTo("Amod"))
	    .body("lastname", Matchers.equalTo("Mahajan"));
```

## 3.5. Отправка запроса PATCH

| Тип | Метод                                        | Описание                                                                                    | 
|-----|----------------------------------------------|---------------------------------------------------------------------------------------------|
| R   | patch()                                      | Отправка **HTTP** запроса **PATCH** по **path** (по умолчанию на **http://localhost:8080**) |
| R   | patch(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| R   | patch(String path, Object... pathParams)     | Отправка **HTTP** запроса **PATCH** по **path**                                             |
| R   | patch(URI uri)                               | Отправка **HTTP** запроса **PATCH** по **uri**                                              |
| R   | patch(URL url)                               | Отправка **HTTP** запроса **PATCH** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RequestSpecification request = RestAssured.given();
request.contentType(ContentType.JSON);
request.cookie("token", "974c253452ba510");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");
request.body(jsonString);

Response response = request.patch();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(200);
validatableResponse.body("firstname", Matchers.equalTo("Amod"));
validatableResponse.body("lastname", Matchers.equalTo("Mahajan"));
```

*Пример*

**BDD** стиль.

```java
String jsonString = "{\r\n" + 
        "    \"firstname\" : \"Amod\",\r\n" + 
        "    \"lastname\" : \"Mahajan\"}";

RestAssured
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "6608dc75eedd44f")
	    .contentType(ContentType.JSON)
	    .body(jsonString)
	.when()
	    .patch()
	.then()
	    .assertThat()
	    .statusCode(200)
	    .body("firstname", Matchers.equalTo("Amod"))
	    .body("lastname", Matchers.equalTo("Mahajan"));
```

## 3.6. Отправка запроса DELETE

| Тип | Метод                                         | Описание                                                                                     | 
|-----|-----------------------------------------------|----------------------------------------------------------------------------------------------|
| R   | delete()                                      | Отправка **HTTP** запроса **DELETE** по **path** (по умолчанию на **http://localhost:8080**) |
| R   | delete(String path, Map<String,?> pathParams) | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| R   | delete(String path, Object... pathParams)     | Отправка **HTTP** запроса **DELETE** по **path**                                             |
| R   | delete(URI uri)                               | Отправка **HTTP** запроса **DELETE** по **uri**                                              |
| R   | delete(URL url)                               | Отправка **HTTP** запроса **DELETE** по **url**                                              |

*Пример*

Не **BDD** стиль.

```java
RequestSpecification request = RestAssured.given();
request.cookie("token", "f4e70e7b9bbcd05");
request.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response response = request.delete();
ValidatableResponse validatableResponse = response.then();
validatableResponse.statusCode(201);

RequestSpecification getRequestSpec = RestAssured.given();
getRequestSpec.baseUri("https://restful-booker.herokuapp.com/booking/1");

Response res = getRequestSpec.get();
ValidatableResponse valRes = res.then();
valRes.statusCode(404);
```

*Пример*

**BDD** стиль.

```java
RestAssured
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	    .cookie("token", "f7dddb1093eab19")
	.when()
	    .delete()
	.then()
	    .assertThat()
	    .statusCode(201);
RestAssured
	.given()
	    .baseUri("https://restful-booker.herokuapp.com/booking/1")
	.when()
	    .get()
	.then()
	    .statusCode(404);
```

***



***



***



***

# Best Practices

https://otus.ru/nest/post/1271/

1. **Выносите end-pointы в отдельное место**

С одной стороны, это очевидно. Но увы, до сих пор нередко встречается код, имеющий захардкоженные end-point'ы в запросе.
В целом же, лучше выносить end-point'ы в статические константы финального класса. Но тут есть нюанс — избегайте антипаттерна «константный интерфейс», т. к. это является плохой практикой. И помните, что REST-assured даёт возможность выносить параметры пути, к примеру:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}

given().pathParams("id", someId).get(EndPoints.users)...;
```

или так

```java
given().get(EndPoints.users, someId)....
```

Кроме того, если вы во многих запросах применяете одинаковый базовый путь,
считается хорошей практикой выносить его в отдельную константу, передавая в basePath, как в примере ниже:


имеем url приложения http://host:port/appname/rest/someEndpoints

```java
private static final basePath = "/appname/rest/";
```

можно задать базовый путь на глобальном уровне,
и он будет использоваться ко всем запросам

```java
RestAssured.basePath = basePath;

// либо на уровне одного запроса:
given().basePath(basePath)...

// либо на уровне спецификации, но об этом поговорим позже
```

То же применимо как к хосту, так и к порту тестируемого программного приложения.

2. **ContentType/Accept**

Эти заголовки применяются почти во всех HTTP-запросах.
Разработчики REST-assured прекрасно это понимают,
поэтому они обеспечили возможность их установки посредством вызова специальных методов:

```java
// вот то плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;
// а вот эта хорошая:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой станет установка данных заголовков в спецификации либо на глобальном уровне.
Результат — повышение читабельности кода.

3. **StatusCode** и т. п.
   Для выполнения проверки каждой составляющей HTTP-ответа, библиотека REST-assured предоставляет удобный синтаксис.
   Но на практике часто можно увидеть следующий код:

```java
// это плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());
```

```java
//а это хорошая:
given()...when().get(someEndpoint).then().statusCode(200);
```

4. **Используйте спецификации**
   Мы знаем, что дублировать код не есть хорошо. Для уменьшения дублирования нужно использовать спецификации.
   В REST-assured есть возможность создания спецификации и для запроса, и для ответа.
   В спецификацию запроса можно вынести всё, что можно продублировать в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// мы можем задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// либо для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

Кроме того, в спецификацию ответа можно выносить все проверки, дублируемые от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// мы можем задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// либо для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;

```

Также мы можем создавать несколько спецификаций для различных типов запросов/ответов и применять их в нужном случае.

5. **Не надо писать собственные костыли для преобразования объектов**
   Не нужно преобразовывать свои POJO в JSON, используя Jackson ObjectMapper'а, а потом передавать полученную строку в тело запроса. Почему? Потому что с этой задачей отлично справляется библиотека REST-assured. Причём применяется всё тот же Jackson либо Gson с учётом того, что находится в classpath. А чтобы выполнить преобразование в XML, применяется JAXB. Что касается исходного формата, то он определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое действует и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Вдобавок к вышесказанному, REST-assured хорошо справляется и с преобразованием HashMap в JSON и в обратном порядке.

6. Используйте всю силу Groovy
   Так как сама библиотека написана на Groovy, она даёт возможность использовать к полученному JSON/XML-ответу разные методы из Groovy. Допустим:

```java
// методы find, findAll используются к коллекции для поиска первого и всех вхождений, а метод collect — для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно, указывая на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можно явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// можно применять методы max, min, sum в целях суммирования всех значений коллекции и поиска максимального и минимально значений

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Применение методов из Groovy сократит количество кода, написанного вами в целях поиска необходимого значения из ответа.


https://qa.crtweb.ru/docs/testing/auto/api/rest-assured-best-practices/

**Используйте спецификации**

Конструкция типа

```java
given().accept(ContentType.JSON)
```

используется абсолютно в каждом запросе, и, даже если это всего две строчки, их можно сократить до вызова одного метода, увеличив тем самым читаемость кода, если вынести их в отдельный метод:

```java
public static RequestSpecification requestSpec() {
    return given()
        .accept(ContentType.JSON);
}
```

или билдер:

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setAccept(ContentType.JSON)
    .build();
```

А в каждом запросе достаточно использовать только вызов этого метода или билдера.

Кроме того, на деле вряд ли весь код, который можно было бы вынести в спецификацию запроса ограничивается двумя строками – наверняка туда можно добавить заголовки для авторизации, установку хоста и порта, настройки логирования, фильтры для Allure и что угодно еще, что необходимо выполнять при каждом запросе.

То же самое можно сделать и с ответом. В нем можно проверить статус-код, время ожидания ответа, а так же наличие необходимых полей в теле ответа или заголовков. Как и в случае с запросом, можно использовать метод:

```java
public static ValidatableResponse responseSpecOk(Response response) {
    return response
        .then()
        .statusCode(200)
        .time(lessThanOrEqualTo(responseTime));
}
```

или билдер:

```java
ResponseSpecification responseSpecOk = new ResponseSpecBuilder()
        .expectStatusCode(200)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
```

**Храните эндпойнты в отдельном месте**

Не стоит отдельно прописывать эндпойнт для каждого запроса.
Даже если их немного, при необходимости внесения изменений что-то все равно может потеряться и поиск проблемы гарантированно займет куда больше времени, чем организация корректного хранения эндпойнтов.

Тут есть несколько вариантов:

если для каждого эндпойнта существует свой собственный класс, можно просто хранить их в переменных этого класса;
можно создать отдельный класс для управления эндпойнтами, и хранить все эндпойнты в переменных этого класса;
и, наконец, эндпойнты можно хранить в отдельном property-файле.

В случае, если эндпойнт включает в себя какое-то изменяемое значение (например, ID), можно пользоваться записью такого вида:

```java
String endpoint = endpoint/{id}
```

В таком случае, подставить на место значения в фигурных скобках нужную переменную можно будет следующим образом:

```java
.get(endpoint, id)
```

Однако стоит иметь в виду, что подобная запись не всегда работает корректно, так что в некоторых проектах, возможно, придется обходиться без нее.

**Выносите base URI в properties**

Так же, как и упомянутые выше заголовки, скорее всего часть URL повторяется в каждом запросе. Ее также можно вынести в отдельное место и объявить только один раз.

Для этого удобнее всего вынести baseURI в properties-файл и получать его значение через класс типа ManageProperties. Объявить baseURI можно двумя способами:

```java
given()
    .baseUri(getProperty("baseUri"))
```

или

```java
RestAssured.baseURI = getProperty("baseUri");
```

Что касается непосредственно самого вызова baseURI, тут тоже есть пара вариантов:

Первый – вызывать его в каждом запросе. Такой вариант выглядит более громоздко, но подойдет в том случае, если в определенных случаях нужно использовать другой base URI.

Второй – объявить его однократно, например, в спецификации запроса.

**Используйте функционал Rest Assured для преобразования объектов**

Нет необходимости преобразовывать POJO в Json с помощью возможностей внешних библиотек, так как Rest Assured прекрасно справляется с этим самостоятельно. Достаточно добавить нужный POJO в тело запроса:

```java
Pojo pojo = new Pojo();
```

```java
given()
    .body(pojo)
    .post(URI);
```

Обратный процесс также работает:

```java
Pojo pojo = given()
    .get(URI)
    .then
    .extract().body().as(Pojo.class)
```

Кроме того, Rest Assured умеет преобразовывать в Json и HashMap, в том числе и вложенные:

```java
Map <Object, Object> outerMap = new HashMap<Object, Object>();
Map <Object, Object> innerMap = new HashMap<Object, Object>();

innerMap.put("key", "value");

outerMap.put("key", "value");
outerMap.put("innerMap", innerMap);

given()
    .body(outerMap)
    .post(URI);
```

**Используйте валидацию Json-схемы**

Валидация Json-схемы - это простой и надежный способ убедиться, что полученные данные соответствуют ожидаемому формату. Json-схема имеет следующий вид:

```json
{
    "type": "object",
    "properties": {
        "id": {
            "type": "integer"
        },
        "item": {
            "type": "object",
            "properties": {
                "key1": {
                    "type": ["string", "integer"]
                },
                "key2": {
                    "type": "string"
                }

            },
            "required": ["key1", "key2"]
        }
    },
    "required": ["id", "item"]
}

```

Создавать Json-схемы можно и вручную, но из-за не слишком человекоориентированного формата это может быть довольно утомительно, так что куда проще использовать для этого любой из многочисленных автоматических инструментов. Например: https://www.liquid-technologies.com/online-json-to-schema-converter

Такая схема проверяет, что полученный в ответе Json содержит в себе все поля, которые указаны как обязательные, и что тип данных в каждом из этих полей соответствует ожидаемому.

Для использования валидации Json-схем понадобится установить библиотеку json-schema-validator (в данном случае используется библиотека от io.rest-assured) и использовать следующий метод:

```java
.body(matchesJsonSchemaInClasspath("schema.json"));
```

**Выносите повторяющиеся действия в отдельные методы**

Нет никакой необходимости десять раз проверять, что ответ на запрос в десяти тестах соответствует схеме, достаточно один раз написать отдельный метод, который проводит эту проверку, и в дальнейшем просто обращаться к нему.

Это справедливо и для любых повторяющихся действий – намного удобнее читать (и тем более писать!) код, в котором все спецификации, конструкторы и проверки разбиты на отдельные блоки, из которых можно создать нужные тесты. Например, вот так:

```java
public static RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri(BASE_URI)
    .setContentType(ContentType.JSON)
    .setAccept(ContentType.JSON)
    .build();

public static ResponseSpecification responseSpec(int statusCode) {
    return new ResponseSpecBuilder()
            .expectStatusCode(statusCode)
            .expectResponseTime(lessThanOrEqualTo(responseTime))
            .build();
}

public static Response createItem(Pojo body) {
    return given()
        .spec(requestSpec)
        .body(body)
        .post(Uri);
    }

public static ValidatableResponse createItem_valid(Response response) {
    return response
            .then()
            .spec(responseSpec(200))
            .body(matchesJsonSchemaInClasspath("schemas/CreateItem.json"));
}

@Test
public void createItemTest() {
    createItem_valid(
        createItem(body))
}
```

**Используйте Hamcrest Matchers**

В случе, когда нет необходимости десериализовать ответ в POJO, мэтчеры из библиотеки Hamcrest являются самым быстрым способом повести валидацию отдельных элементов содержимого ответа.

Они позволяют проверить, что, например, ответ содержит в себе определенную строку или значение, или что конкретное поле равно определенному значению, или что массив содержит в себе некоторый набор элементов в произвольном порядке.

```java
.body("id", equals(getId()))
.body("id", greaterThanOrEqualTo(1))
.body("items", either(hasItem("a")).and(hasItem("b"))
```

Все выполняемые мэтчерами проверки, несомненно, можно произвести и другими способами, однако они позволяют сделать это в краткой и удобной для чтения форме.

С полной документацией к мэтчерам можно ознакомиться здесь: http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html

**Используйте методы для добавления заголовков**

Так как по крайней мере один из этих заголовков используется практически в любом запросе, для них был создан более краткий вариант записи:

```java
given()
	.contentType(ContentType.JSON)
	.accept(ContentType.JSON)
```

Такой вариант немного короче обычной записи заголовков через метод header и, что более важно, минимизирует шанс возникновения ошибки из-за опечатки.

Однако стоит обратить внимание на то, что при таком оформлении заголовков в Accept помимо application/json также передаются application/javascript, text/javascript и text/json. В некоторых API это может привести к ошибкам, и в таком случае enum ContentType стоит заменить на строку с указанием конкретного типа данных.

**Проверяйте статус-код без assertThat**

Запись типа

```java
.assertThat(statusCode(200))
```

просто излишня. Эта строка выполняет ту же самую работу:

```java
.statusCode(200)
```

**Передавайте статус-коды в качестве аргумента**

При наличии большого количества негативных проверок с разными ожидаемыми кодами ошибок, нет необходимости писать отдельную спецификацию под каждый статус-код, вместо этого можно просто добавить спецификацию в метод и передавать в нее ожидаемый статус-код из теста:

```java
public static ResponseSpecification responseSpecError(int statusCode) {
    return new ResponseSpecBuilder()
        .expectStatusCode(statusCode)
        .expectResponseTime(lessThanOrEqualTo(responseTime))
        .build();
}
```

**Используйте логирование для отладки тестов**

Метод .log() позволяет получить информацию как об отправленном запросе, так и о полученном ответе. В первом случае необходимо его применить до отправки запроса (get, post и т.д.), во втором случае – после.

Вам доступны следующие методы:

```java
.log().all()
.log().params()
.log().body()
.log().headers()
.log().cookies()
```

Однако оставлять логирование в тестах, которые уже дописаны и корректно работают, не стоит – объем в информации в логах может быть настолько большим, что результаты всех тестов перестанут умещаться в консоли IDE, не говоря уже о том, что просматривать результаты тестов в таком случае будет очень неудобно.

https://habr.com/ru/post/421005/

**Выносите end-point'ы в отдельное место**

Казалось бы, что это очевидно. Но нет, довольно часто приходится видеть код с захардкоженными end-point'ми в запросе.

Лучше всего выносить end-point'ы в статические константы финального класса. При этом стоит избегать антипаттерн «константный интерфейс» — это плохая практика.

Не забывайте, что REST-assured позволяет выносить параметры пути, например:

```java
public final class EndPoints {
    public static final String users = "/users/{id}";
...
}
```

```java
given().pathParams("id", someId).get(EndPoints.users)...;

// или так

given().get(EndPoints.users, someId)....
```

Также, если во многих запросах вы используете один и тот же базовый путь, то будет хорошей практикой вынести его в отельную константу и передавать в basePath, например:

```java
// имеем следующий url приложения http://host:port/appname/rest/someEndpoints

private static final basePath = "/appname/rest/";

..

// можем задать базовый путь на глобальном уровне,
// он будет применяться ко всем запросам:
RestAssured.basePath = basePath;

// или на уровне одного запроса:
given().basePath(basePath)...

// или на уровне спецификации, но об этом далее
```

То же самое применимо к хосту и порту тестируемого приложения.

```java
ContentType/Accept
```
Данные заголовки используются практически во всех HTTP-запросах. Авторы REST-assured, понимая это, сделали возможным их установку через вызов специальных методов:

```java
// плохая практика написания:
given().header("content-type", "application/json").header("accept", "application/json")...;

// хорошая практика написания:
given().contentType(ContentType.JSON).accept(ContentType.JSON)...;
```

Хорошей практикой будет установить данные заголовки в спецификации или на глобальном уровне. Это повысит читабельность вашего кода.

**StatusCode и т.п.**

REST-assured предоставляет удобный синтаксис для проведения проверки каждой составляющей HTTP-ответа, однако на практике продолжаешь встречать подобный код:

```java
// плохая практика написания:
Response response = given()...when().get(someEndpoint);
Assert.assertEquals(200, response.then().extract().statusCode());

// хорошая практика написания:
given()...when().get(someEndpoint).then().statusCode(200);
```

**Используйте спецификации**

Дублирование кода — это плохо. Используйте спецификации для уменьшения дублирования. В REST-assured можно создавать спецификации как для запроса, так и для ответа. В спецификацию запроса выносим всё, что может быть продублировано в запросах.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("http://localhost")
    .setPort(8080)
    .setAccept(ContentType.JSON)
    .setContentType(ContentType.ANY)
...
    .log(LogDetail.ALL)
    .build();

// можно задать одну спецификацию для всех запросов:
RestAssured.requestSpecification = requestSpec;

// или для отдельного:
given().spec(requestSpec)...when().get(someEndpoint);
```

В спецификацию ответа выносим все проверки, которые дублируются от запроса к запросу.

```java
ResponseSpecification responseSpec = new ResponseSpecBuilder()
    .expectStatusCode(200)
    .expectBody(containsString("success"))
    .build();

// можно задать одну спецификацию для всех ответов:
RestAssured.responseSpecification = responseSpec;

// или для отдельного:
given()...when().get(someEndpoint).then().spec(responseSpec)...;
```

Можно создавать несколько спецификаций для разных типов запросов/ответов и использовать в нужной ситуации.

**Не пишите свои костыли для преобразования объектов**

Не стоит преобразовывать свои POJO в JSON при помощи Jackson ObjectMapperа, а потом полученную строку передавать в тело запроса. REST-assured прекрасно справляется с этой задачей. Для этого используется всё тот же Jackson или Gson, в зависимости от того, что находится в classpath. Для преобразования в XML используется JAXB. Исходный формат определяется автоматически по значению Content-Type.

```java
given().contentType(ContentType.JSON).body(somePojo)
    .when().post(EndPoints.add)
    .then()
    .statusCode(201);

// то же самое работает и в обратную сторону:
SomePojo pojo = given().
    .when().get(EndPoints.get)
    .then().extract().body().as(SomePojo.class);
```

Кроме того REST-assured прекрасно справляется с преобразованием HashMap в JSON и обратно.


**Используйте всю мощь Groovy**

Сама библиотека REST-assured написана на Groovy и позволяет вам применять различные методы из Groovy к полученному JSON/XML ответу. Например:

```java
// методы find, findAll применяются к коллекции для поиска первого и всех вхождений, метод collect для  создания новой коллекции из найденных результатов. 

// переменная it создается неявно и указывает на текущий элемент коллекции
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.find { it.title =~ 'anythingRegExp'}");

// можете явно задать название переменной, указывающей на текущий элемент
Map<String, ?> map = get(EndPoints.anyendpoint).path("rootelement.findAll { element -> element.title.length() > 4 }");

// вы можете использовать методы sum, max, min для суммирования всех значений коллекции, а также поиска максимального и минимально значения

String expensiveCar = get(EndPoints.cars).path("cars.find { it.title == 'Toyota Motor Corporation'}.models.max { it.averagePrice }.title");
```

Использование методов из Groovy позволяет сильно сократить количество кода, написанного вами для поиска необходимого значения из ответа.

На этом всё, если у вас есть еще советы и примеры пишите их в комментариях.



***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)