Java_QA / 11. Паттерны

***



***

# 1. Паттерн Одиночка (Singleton)

***Одиночка (Singleton)*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

![Паттерн Одиночка (Singleton)](./_images/1.%20Singleton/01.jpg "Паттерн Одиночка (Singleton)")

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод,
который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

## 1.1. Структура паттерна

![Структура паттерна Одиночка (Singleton)](./_images/1.%20Singleton/02.jpg "Паттерн Одиночка (Singleton)")

1. *Одиночка (Singleton)*

***Одиночка (Singleton)*** - класс определяющий статический метод **getInstance**,
который возвращает единственный экземпляр своего класса.

Конструктор **Одиночки (Singleton)** должен быть скрыт от клиентов.
Вызов метода **getInstance** должен стать единственным способом получить объект этого класса.

## 1.2. Шаги реализации паттерна

1. *Добавление в класс приватного статического поля, содержащее одиночный объект*
2. *Создание статического метода для получения одиночного объекта*
3. *Добавление ленивой инициализации в метод для получения одиночного объекта*
4. *Создание приавтного конструктора*
5. *Вызов в клиентском коде метода получения одиночного объекта*

## 1.3. Применимость паттерна

1. *В программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам*

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода.
Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

2. *Больше контроля над глобальными переменными*

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса,
поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек,
поменяв код в одном месте (метод **getInstance**).

## 1.4. Плюсы и минусы применения паттерна

### 1.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Одиночка (Singleton)**:

* гарантия наличие единственного экземпляра класса
* предоставление к единственному экземпляру класса глобальной точки доступа
* реализация отложенной инициализацию объекта-одиночки

### 1.4.2. Минусы применения паттерна

Минусы применения паттерна **Одиночка (Singleton)**:

* нарушение принципа единственной ответственности класса
* маскирование плохого дизайна
* проблемы многопоточности
* требование постоянного создания Mock-объектов при юнит-тестировании.

## 1.5. Применение паттерна в автотестах

### 1.5.1. Передача тестовых данных в автотестах

#### 1.5.1.1. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

#### 1.5.1.2. После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja

***

# 2. Паттерн Декоратор (Decorator)

***Декоратор (Decorator)*** - паттерн, который позволяет динамически добавлять объектам новую функциональность.
Декораторы предоставляют гибкую альтернативу подклассам для расширения функциональности.

![Паттерн Декоратор (Decorator)](./_images/2.%20Decorator/01.jpg "Паттерн Декоратор (Decorator)")

Паттерн **Декоратор (Decorator)** имеет альтернативное название — **Обёртка**.
Оно более точно описывает суть паттерна: целевой объект-оригинал помещается в другой объект-обёртку,
который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы,
с каким объектом работать — оригиналом или обёрткой.
Вы можете использовать несколько разных обёрток одновременно —
результат будет иметь объединённое поведение всех обёрток сразу.

Пример использования паттерна в библиотеке **Selenium** - **EventFiringDecorator** и **FieldDecorator**.

## 2.1. Структура паттерна

![Структура паттерна  Декоратор (Decorator)](./_images/2.%20Decorator/02.jpg "Паттерн Декоратор (Decorator)")

1. *Базовый компонент (Component)*

***Базовый компонент (Component)*** – общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных компонентов (ConcreteComponent)** и **Базового декоратора (Decorator)**.

2. *Конкретный компонент (ConcreteComponent)*

***Конкретный компонент (ConcreteComponent)*** – конкретный класс со своей бизнес логикой, реализующий **Базовый компонент (Component)**,
функциональность которого необходимо модифицировать декораторами.

Декоратор способен работать как с самим исходным компонентом, так и его наследниками.
Однако, не следует использовать большое количество декораторов с тяжеловесными классами,
так как это может повлечь за собой большие накладные расходы.

3. *Базовый декоратор (Decorator)*

***Базовый декоратор (Decorator)*** – базовый класс для всех декораторов, реализующий **Базовый компонент (Component)** и
хранящий ссылку на экземпляр **Конкретного компонента (ConcreteComponent)**.

**Базовый декоратор (Decorator)** реализует тот же самый интерфейс чтобы:

* замещать конкретный компонент
* создавать цепочку декораторов

4. *Конкретный декоратор (ConcreteDecorator)*

***Конкретный декоратор (ConcreteDecorator)*** - конкретный класс, наследующий **Базовый декоратор (Decorator)** и
добавляющий определенные функции компоненту.

Добавление новой функциональности осуществляется подменой экземпляра оригинального компонента.
Такой объект может использоваться как вместо декорируемого компонента, так и самостоятельно.

**Конкретный декоратор (ConcreteDecorator)**:

* создает механизм подключения и хранения компонента
* реализует переадресацию всех методов и свойств
* добавляет новые свойства и методы

## 2.2. Шаги реализации паттерна

1. *Проверка наличия в задаче одного основного компонента и нескольких дополнительных опциональных дополнений или надстроек над ним*

2. *Создание Базового компонента*

Базовый компонент описывает общие методы как для основного компонента, так и для его дополнений.

3. *Создание Конкретного компонента*

Конкретный компонент содержит основную бизнес-логику.

4. *Создание Базового декоратора*

Базовый декоратор имеет поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора делегируют действие вложенному объекту.

5. *Создание Конкретных декораторов*

Конкретный декоратор выполняет свою добавочную функцию,
а затем (или перед этим) вызывает эту же операцию обёрнутого объекта.

## 2.3. Применимость паттерна

1. *Реализация множественного наследования*

В таких языках как **Java** и **C#** нет множественного наследования классов.
И когда требуется реализовать множество различных функциональностей и их комбинаций,
то для каждой такой функциональности и их комбинаций придется наследовать отдельный класс.
Структура классов при этом может очень сильно разрастись, что в свою очередь усложнит ее понимание и поддержку.

Применение паттерна **Декоратор (Decorator)** позволяет реализовать аналог множественного наследования, в языках его не поддерживающих,
путем вложения одного декоратора в другой и создания из них цепочек, поскольку паттерн реализует интерфейс исходного компонента.
Таким образом у объектов расширяются возможности без использования одиночного наследования.
Что в свою очередь разрешает проблему усложнения структуры классов путем уменьшения числа создаваемых классов
по сравнению с результатами использования одиночного наследования.

2. *Невозможность расширить обязанности объекта с помощью наследования*

Во многих языках программирования есть ключевое слово, с помощью которого можно заблокировать наследование класса.

Применение паттерна **Декоратор (Decorator)** позволяет добавить функциональность классу,
определение которого может быть скрыто или иным образом недоступно для подклассов, то есть когда наследование невозможно.

3. *Динамическое добавление новых возможностей на лету, незаметно для кода, который их использует*

Применение паттерна **Декоратор (Decorator)** обеспечивает динамическое добавление объекту новых функциональных возможностей.
Объекты помещаются в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс,
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

Позволяет комбинировать классы в процессе выполнения программы. дважды применить один и тот же Декоратор.

## 2.4. Плюсы и минусы применения паттерна

### 2.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Декоратор (Decorator)**:

* большая гибкость, чем у наследования
* добавление обязанности на лету
* добавление нескольких новых обязанностей сразу
* изменение функциональности не только применением самих Декораторов, но и различным порядком их вложенности

### 2.4.2. Минусы применения паттерна

Минусы применения паттерна **Декоратор (Decorator)**:

* трудность конфигурирования многократно обёрнутых объектов
* обилие крошечных классов
* несколько мелких объектов вместо одного объекта на все случаи жизни

## 2.5. Применение паттерна в автотестах

### 2.5.1. Декоратор WebElement

#### 2.5.1.1. До применения паттерна

Страница (Page Objects)

*Пример*

```java

```

Интерфейс **WebElement** не всегда удобно использовать.
Его невозможно расширить и добавить свои методы для работы с элементом.
Использовать свои методы можно только создавая классы-обвертки(CheckBox, Button и т.п.),
которые просто делегируют вызов методов настоящему **WebElement**.

#### 2.5.1.2. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

### 2.5.2. Декоратор Page object

#### 2.5.2.1. До применения паттерна



#### 2.5.2.2. После применения паттерна

***

# 3. Паттерн Заместитель (Proxy)

***Заместитель (Proxy)*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заместители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

![Паттерн Заместитель (Proxy)](./_images/3.%20Proxy/01.jpg "Паттерн Заместитель (Proxy)")

Паттерн **Заместитель (Proxy)** предлагает создать новый объект-заместитель, имеющий тот же интерфейс, что и оригинальный объект.
Ни интерфейс ни функциональность замещенного объекта, с точки зрения клиента, не изменяются.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр оригинального объекта и
переадресовывал бы ему всю реальную работу.

## 3.1. Структура паттерна

![Структура паттерна Заместитель (Proxy)](./_images/3.%20Proxy/02.jpg "Структура паттерна Заместитель (Proxy)")

1. *Базовый объект (Subject)*

***Базовый объект (Subject)*** – общий интерфейс / абстрактный класс для всех замещаемых объектов и заместителей.

Конкретная реализация скрыта от **Заместителя (Proxy)** и он может работать практически со всеми **Реальными объектами (RealSubject)**,
поддерживающими данный интерфейс.

2. *Реальный объект (RealSubject)*

***Реальный объект (RealSubject)*** – конкретный класс с полезной бизнес логикой, реализующий **Базовый объект (Subject)**,
который будет замещен **Заместителем**.

3. *Заместитель (Proxy)*

***Заместитель (Proxy)*** - класс, реализующий **Базовый объект (Subject)**, который замещает **Конкретный объект (RealSubject)** и перехватывает обращения к нему.

**Заместитель (Proxy)** :

* выполняет дополнительные действия (инициализацию, логирование и т д.) до или после вызова вложенного в него **Конкретного объекта (RealSubject)**
* отвечает за создание и удаление **Конкретного объекта (RealSubject)**.

Паттерн не накладывает ограничения на вложения одного заместителя в другой.
Такой подход позволяет строить их различные конфигурации в процессе работы программы.

## 3.2. Шаги реализации паттерна

1. *Определение интерфейса, который бы сделал заместитель и оригинальный объект взаимозаменяемыми*

2. *Создание Заместителя*

Заместитель должен содержать ссылку на оригинальный объект. Чаще всего, оригинальный объект создаётся самим заместителем.
В редких случаях заместитель получает готовый оригинальный объект от клиента через конструктор.

3. *Реализация методов Заместителя в зависимости от его предназначения*

В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос оригинальному объекту.

4. *Создание Фабрики*

Фабрика будет решать, какой из объектов создавать — заместитель или оригинальный объект.

5 *Реализация ленивой инициализации оригинального объекта*

При первом обращении клиента к методам заместителя.

## 3.3. Применимость паттерна

1. *Ленивая инициализация (Виртуальный Прокси (Virtual Proxy))*

Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда,
когда он действительно понадобится.

2. *Защита доступа (Защищающий Прокси (Protection Proxy))*

Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа.
Например, если ваши объекты — это важная часть операционной системы,
а пользователи — сторонние программы (хорошие или вредоносные).

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. *Локальный запуск сервиса (Удаленный Прокси (Remote Proxy))*

Когда настоящий сервисный объект находится на удалённом сервере.
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. *Логирование запросов (Логирующий Прокси (Logging Proxy))*

Когда требуется хранить историю обращений к сервисному объекту.
Заместитель может сохранять историю обращения клиента к сервисному объекту.

5. *Кеширование объектов (Умная Ссылка (Smart Reference))*

Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.
Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными.
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект.
Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

## 3.4. Плюсы и минусы применения паттерна

### 3.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Заместитель (Proxy)**:

* контроль оригинального объекта незаметно для клиента
* возможность работы, даже если оригинальный объект ещё не создан
* возможность контроля жизненного цикла служебного объекта

### 3.4.2. Минусы применения паттерна

Минусы применения паттерна **Заместитель (Proxy)**:

* усложнение кода программы из-за введения дополнительных классов
* увеличение времени отклика от сервиса

## 3.5. Применение паттерна в автотестах

### 3.5.1. Создание заместителя для WebDriver в UI автотестах Selenium WebDriver

#### 3.5.1.1. До применения паттерна

*Пример*

```java

```

#### 3.5.1.2. После применения паттерна

*Пример*

```java

```

***


***

# 4. Паттерн Цепочка обязанностей (Chain of Invocations / Fluent)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Цепочка обязанностей (Chain of Invocations / Fluent)*** - паттерн, который позволяет передавать запросы
последовательно по цепочке обработчиков. Каждый последующий обработчик решает,
может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

![Паттерн Цепочка обязанностей (Chain of Invocations / Fluent)](./_images/4.%20Chain%20of%20Invocations/01.jpg "Цепочка обязанностей (Chain of Invocations / Fluent)")

Паттерн **Цепочка обязанностей (Chain of Invocations / Fluent)** предлагает связать объекты обработчиков в одну цепь.
Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет
не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, можно быть уверенным в том, что все объекты в цепи смогут его обработать.
При этом длина цепочки не имеет никакого значения.

Обработчик необязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

## 4.1. Структура паттерна

![Структура паттерна Цепочка обязанностей (Chain of Invocations / Fluent)](./_images/4.%20Chain%20of%20Invocations/02.jpg "Структура паттерна Цепочка обязанностей (Chain of Invocations / Fluent)")

1. *Обработчик (Handler)*

***Обработчик (Handler)*** - интерфейс, определяющий метод обработки запросов, и иногда метод выставления следующего обработчика.

2. *Базовый Обработчик (BaseHandler)*

**Базовый Обработчик (BaseHandler)**- опциональный класс, который позволяет избавиться от
дублирования одного и того же кода во всех конкретных обработчиках

Обычно **Базовый Обработчик (BaseHandler)** имеет поле для хранения ссылки на следующий обработчик в цепочке.
**Клиент (Client)** связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля.
Также здесь можно реализовать базовый метод обработки,
который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.

3. *Конкретный Обработчик (ConcreteHandler)*

***Конкретный Обработчик (ConcreteHandler)*** - класс, содержащие код обработки

При получении запроса каждый **Конкретный Обработчик (ConcreteHandler)** решает, может ли он обработать запрос,
а также стоит ли передать его следующему объекту.

В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми,
получив все нужные детали через параметры конструктора.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который может либо сформировать цепочку обработчиков единожды,
либо перестраивать её динамически, в зависимости от логики программы.

**Клиент (Client)*** может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику,
либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами,
опираясь на конфигурацию приложения или параметры окружения.

**Клиент (Client)** может посылать запросы любому обработчику в цепи, а не только первому.
Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик
не откажется передавать его дальше, либо когда будет достигнут конец цепи.

**Клиент (Client)** должен знать о динамической природе цепочки и быть готов к таким случаям:

* цепочка может состоять из единственного объекта.
* запросы могут не достигать конца цепи.
* запросы могут достигать конца, оставаясь необработанными.

Обычно, если вы хотите прервать цепочку методов, все, что вам нужно сделать,
это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.

## 4.2. Шаги реализации паттерна

1. *Создание интерфейса Обработчик (Handler)*

2. *Создание абстрактного класса Базовый Обработчик (BaseHandler)*

3. *Создание классов Конкретный Обработчик (ConcreteHandler)*

## 4.3. Применимость паттерна

1. *Когда программа должна обрабатывать разнообразные запросы несколькими способами,
   но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся*

С помощью Цепочки обязанностей вы можете связать потенциальных обработчиков в одну цепь и
при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

2. *Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке*

Цепочка обязанностей позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

3. *Когда набор объектов, способных обработать запрос, должен задаваться динамически*

В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

## 4.4. Плюсы и минусы применения паттерна

### 4.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Цепочка обязанностей (Chain of Invocations / Fluent)**:

* уменьшение зависимости между клиентом и обработчиками
* реализация принципа единственной обязанности
* реализация принципа открытости/закрытости

### 4.4.2. Минусы применения паттерна

Минусы применения паттерна **Цепочка обязанностей (Chain of Invocations / Fluent)**:

* запрос может остаться никем не обработанным

## 4.5. Применение паттерна в автотестах

### 4.5.1. Цепочка вызовов методов объектов страниц

Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив **Fluent Invocations**, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

#### 4.5.1.1. До применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage {
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
  
    // Конструктор
    public HomePage(WebDriver driver){
      this.driver = driver;
    }
  
    // Отображается элемент?
    public boolean isTextDisplyed() {
      return driver.findElement(tеxtBy).isDisplayed();
    }
  
    // Получение текста 
    public String getText() {
      return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

#### 4.5.1.2. После применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage {
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
  
    // Конструктор
    public HomePage(WebDriver driver){
      this.driver = driver;
    }
  
    // Отображается элемент?
    public boolean isTextDisplyed() {
      return driver.findElement(tеxtBy).isDisplayed();
    }
  
    // Получение текста 
    public String getText() {
      return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
    // Arrange
    String login = "login";
    String password = "password";
    String expected = "Стартовая страница";
    
    // Act
    HomePage homePage = getPageAfterLogin("login", "password")
    
    // Assert
    // Проверить что отображается текст "Стартовая страница"
    HomePageAssert homePageAssert = new HomePageAssert(homePage);
    homePageAssert.displayedTextAfterLogin();
    homePageAssert.textAfterLoginIs(expected);
    }
    
    public HomePage getPageAfterLogin(String email, String password) {
    // Страница "Sign In"
    SignInPage signInPage = new SignInPage(driver);
    // Вход с логином и паролем
    // Страница "Home"
    return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

***

# 5. Паттерн Легковес (Flyweight / Object Pool)

***Легковес (Flyweight / Object Pool)*** - паттерн, который позволяет вместить большее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой (внутреннее и внешнее),
вместо хранения одинаковых данных в каждом объекте.

![Паттерн Легковес (Flyweight / Object Pool)](./_images/5.%20Flyweight/01.jpg "Паттерн Легковес (Flyweight / Object Pool)")

***Внутреннее состояние*** - неизменяемые данные, которые хранятся в легковесном объекте и не используются за пределами объекта.
Внутреннее состояние не зависит от контекста, в котором используется объект-легковес.

***Внешнее состояние*** - изменяющиеся данные, которые не хранятся в легковесном объекте и используются за пределами объекта.
Внешнее состояние зависит от контекста. Клиенты несут ответственность за переход во внешнее состояние.

Паттерн **Легковес (Flyweight / Object Pool)** предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием,
а оно имеет не так много вариаций.

## 5.1. Структура паттерна

![Структура паттерна Легковес (Flyweight / Object Pool)](./_images/5.%20Flyweight/02.jpg "Структура паттерна Легковес (Flyweight / Object Pool)")

1. *Базовый легковес (Flyweight)*

***Базовый легковес (Flyweight)*** - интерфейс, общий для всех легковесов,
через который легковесы могут получать внешнее состояние или воздействовать на него.

2. *Конкретный легковес (ConcreteFlyweight)*

***Конкретный легковес (ConcreteFlyweight)*** - класс, который реализует **Базовый легковес (Flyweight)**
и добавляет хранилище для внутреннего состояния, если оно есть.

**Конкретный легковес (ConcreteFlyweight)** содержит состояние, которое повторялось во множестве первоначальных объектов.
Один и тот же легковес можно использовать в связке со множеством контекстов.

**Контекст**:

* содержит внешнюю часть состояния, уникальную для каждого объекта
* связан с одним из легковесов, хранящих внутреннюю часть состояния

3. *Фабрика легковесов (FlyweightFactory)*

***Фабрика легковесов (FlyweightFactory)*** - класс, который управляет созданием и повторным использованием легковесов.

Клиент должен запрашивать из фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
Фабрика легковесов получает запросы, в которых указано желаемое состояние легковеса.
Все созданные раннее легковесы хранятся в пуле. Если легковес с таким состоянием уже создан,
фабрика легковесов сразу его возвращает из пула, а если нет — создаёт новый объект, помещает его в пул и возвращает клиенту.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вычисляет или хранит контекст, то есть внешнее состояние легковесов.

Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.

## 5.2. Шаги реализации паттерна

1. *Разделение полей класса, который станет легковесом на две части: внутреннее и внешнее состояние*

2. *Создание фабрики, которая будет кешировать и повторно отдавать уже созданные объекты*

3. *Хранение или вычисление значения внешнего состояния (контекст) клиентом и передача его в методы объекта легковеса*

## 5.3. Применимость паттерна

1. *Большое количество однообразных объектов*

При использовании большого количества однообразных объектов происходит выделение
большого количества памяти для поддержки всех нужных объектов.
Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.

В зависимости от сложности структуры, хранящей разделяемые объекты, особенно если имеется большое количество легковесов,
то может увеличиваться время на поиск нужного легковеса.

## 5.4. Плюсы и минусы применения паттерна

### 5.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Легковес (Flyweight / Object Pool)**:

* экономия оперативной памяти

### 5.4.2. Минусы применения паттерна

Минусы применения паттерна **Легковес (Flyweight / Object Pool)**:

* расход процессорного времени на поиск/вычисление контекста
* усложнение кода программы из-за введения множества дополнительных классов

## 5.5. Применение паттерна в автотестах

### 5.5.1. Пул страниц

Не нужно ждать, пока откроется нужная страница, если все тесты начинаются с одной страницы.
Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать,
пока тест не обнаружит его в готовом к использованию состоянии.

#### 5.5.1.1. До применения паттерна

*Пример*

```java

```

#### 5.5.1.2. После применения паттерна

*Пример*

```java

```

### 5.5.2. Пул тестовых данных

#### 5.5.2.1. До применения паттерна

*Пример*

```java

```

#### 5.5.2.2. После применения паттерна

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
	USER_POOL.releaseUser(user);
}
```



