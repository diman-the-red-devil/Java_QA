Java_QA / 13. Сucumber. Gherkin

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Интерфейс командной строки Cucumber (Cucumber Command-Line Interface Runner (Cucumber CLI Runner))](#1-интерфейс-командной-строки-cucumber-cucumber-command-line-interface-runner-cucumber-cli-runner)
  * [1.1. Опции командной строки Cucumber](#11-опции-командной-строки-cucumber)
    * [1.1.1. Версия Cucumber](#111-версия-cucumber)
    * [1.1.2. Справка по опциям командной строки Cucumber](#112-справка-по-опциям-командной-строки-cucumber)
    * [1.1.3. Список пакетов Java с кодом шагов, хуков и т д.](#113-список-пакетов-java-с-кодом-шагов-хуков-и-т-д)
    * [1.1.4. Количество параллельных потоков при запуске сценариев](#114-количество-параллельных-потоков-при-запуске-сценариев)
    * [1.1.5. Список плагинов](#115-список-плагинов)
    * [1.1.6. Порядок выполнения сценариев](#116-порядок-выполнения-сценариев)
    * [1.1.7. Количество выполняемых сценариев](#117-количество-выполняемых-сценариев)
    * [1.1.8. Фильтрация сценариев по наименованию](#118-фильтрация-сценариев-по-наименованию)
    * [1.1.9. Фильтрация сценариев по тегам](#119-фильтрация-сценариев-по-тегам)
    * [1.1.10. Пропуск сценариев с тегом @wip (Работа в процессе (Work In Progress)](#1110-пропуск-сценариев-с-тегом-wip-работа-в-процессе-work-in-progress)
    * [1.1.11. Запуск сценариев без выполнения кода шагов сценариев](#1111-запуск-сценариев-без-выполнения-кода-шагов-сценариев)
    * [1.1.12. Черно-белый / цветной вывод в консоль](#1112-черно-белый--цветной-вывод-в-консоль)
    * [1.1.13. Стиль наименовании для сгенерированных методов](#1113-стиль-наименовании-для-сгенерированных-методов)
    * [1.1.14. Список ключевых слов для определенного языка](#1114-список-ключевых-слов-для-определенного-языка)
  * [1.2. Путь к фичам и сценариям](#12-путь-к-фичам-и-сценариям)
    * [1.2.1. Путь к фичам и сценариям не указан](#121-путь-к-фичам-и-сценариям-не-указан)
    * [1.2.2. Путь к папке с .feature файлами](#122-путь-к-папке-с-feature-файлами)
    * [1.2.3. Путь к конкретному .feature файлу](#123-путь-к-конкретному-feature-файлу)
    * [1.2.4. Путь к конкретному .feature файлу с указанием classpath](#124-путь-к-конкретному-feature-файлу-с-указанием-classpath)
    * [1.2.5. Путь к конкретному .feature файлу с указанием с указанием строк сценария](#125-путь-к-конкретному-feature-файлу-с-указанием-с-указанием-строк-сценария)
* [2. Опции запуска](#2-опции-запуска)
  * [2.1. Файл cucumber.properties](#21-файл-cucumberproperties)
    * [2.1.1. Список пакетов Java с кодом шагов, хуков и т д.](#211-список-пакетов-java-с-кодом-шагов-хуков-и-т-д)
    * [2.1.2. Папки с фичами и сценариями](#212-папки-с-фичами-и-сценариями)
    * [2.1.3. Список плагинов](#213-список-плагинов)
    * [2.1.4. Порядок выполнения сценариев](#214-порядок-выполнения-сценариев)
    * [2.1.5. Количество выполняемых сценариев](#215-количество-выполняемых-сценариев)
    * [2.1.6. Фильтрация сценариев по наименованию](#216-фильтрация-сценариев-по-наименованию)
    * [2.1.7. Фильтрация сценариев по тегам](#217-фильтрация-сценариев-по-тегам)
    * [2.1.8. Пропуск сценариев с тегом @wip (Работа в процессе (Work In Progress)](#218-пропуск-сценариев-с-тегом-wip-работа-в-процессе-work-in-progress)
    * [2.1.9. Запуск сценариев без выполнения кода шагов сценариев](#219-запуск-сценариев-без-выполнения-кода-шагов-сценариев)
    * [2.1.10. Черно-белый / цветной вывод в консоль](#2110-черно-белый--цветной-вывод-в-консоль)
    * [2.1.11. Стиль именования для сгенерированных методов](#2111-стиль-именования-для-сгенерированных-методов)
    * [2.1.12. Наименование класса object factory.](#2112-наименование-класса-object-factory)
    * [2.1.13. Публикация отчета после выполнения теста](#2113-публикация-отчета-после-выполнения-теста)
    * [2.1.14. Запрет баннера публикации отчета после выполнения теста](#2114-запрет-баннера-публикации-отчета-после-выполнения-теста)
    * [2.1.15. Токен для публикации отчета после выполнения теста](#2115-токен-для-публикации-отчета-после-выполнения-теста)
    * [2.1.16. Ссылка на хранилище для публикации отчета после выполнения теста](#2116-ссылка-на-хранилище-для-публикации-отчета-после-выполнения-теста)
  * [2.2. Файл junit-platform.properties](#22-файл-junit-platformproperties)
    * [2.2.1. Список пакетов Java с кодом шагов, хуков и т д.](#221-список-пакетов-java-с-кодом-шагов-хуков-и-т-д)
    * [2.2.2. Список плагинов](#222-список-плагинов)
    * [2.2.3. Фильтрация сценариев по наименованию](#223-фильтрация-сценариев-по-наименованию)
    * [2.2.4. Фильтрация сценариев по тегам](#224-фильтрация-сценариев-по-тегам)
    * [2.2.5. Запуск сценариев без выполнения кода шагов сценариев](#225-запуск-сценариев-без-выполнения-кода-шагов-сценариев)
    * [2.2.6. Черно-белый / цветной вывод в консоль](#226-черно-белый--цветной-вывод-в-консоль)
    * [2.2.7. Стиль именования для сгенерированных методов](#227-стиль-именования-для-сгенерированных-методов)
    * [2.2.8. Наименование класса object factory.](#228-наименование-класса-object-factory)
    * [2.2.9. Публикация отчета после выполнения теста](#229-публикация-отчета-после-выполнения-теста)
    * [2.2.10. Запрет баннера публикации отчета после выполнения теста](#2210-запрет-баннера-публикации-отчета-после-выполнения-теста)
    * [2.2.11. Токен для публикации отчета после выполнения теста](#2211-токен-для-публикации-отчета-после-выполнения-теста)
    * [2.2.12. Параллельный запуск](#2212-параллельный-запуск)
    * [2.2.13. Стратегия параллельного запуска](#2213-стратегия-параллельного-запуска)
    * [2.2.14. Фиксированное количество потоков](#2214-фиксированное-количество-потоков)
    * [2.2.15. Динамическое количество потоков](#2215-динамическое-количество-потоков)
    * [2.2.16. Кастомный класс для параллельного запуска](#2216-кастомный-класс-для-параллельного-запуска)
    * [2.2.18.](#2218)
    * [2.2.19.](#2219)
* [3. Формирование отчетов (Reports)](#3-формирование-отчетов-reports)
  * [3.1. Встроенные плагины отчетов (Built-in Reporter Plugins)](#31-встроенные-плагины-отчетов-built-in-reporter-plugins)
    * [3.1.1. Плагин отчета html](#311-плагин-отчета-html)
    * [3.1.2. Плагин отчета json](#312-плагин-отчета-json)
    * [3.1.3. Плагин отчета junit](#313-плагин-отчета-junit)
    * [3.1.4. Плагин отчета pretty](#314-плагин-отчета-pretty)
    * [3.1.5. Плагин отчета message](#315-плагин-отчета-message)
  * [3.2. Кастомные Форматтеры (Custom formatters)](#32-кастомные-форматтеры-custom-formatters)
  * [3.3. Cucumber Reports Service](#33-cucumber-reports-service)
* [4. Gherkin](#4-gherkin)
  * [4.1. Функция (Feature)](#41-функция-feature)
  * [4.2. Подробное описание (Descriptions)](#42-подробное-описание-descriptions)
  * [4.3. Сценарий (Scenario)](#43-сценарий-scenario)
  * [4.4. Шаги (Steps)](#44-шаги-steps)
    * [4.4.1. Дано (Given)](#441-дано-given)
    * [4.4.2. Когда (When)](#442-когда-when)
    * [4.4.3. Тогда (Then)](#443-тогда-then)
    * [4.4.4. И (And), Но (But), * (Asterisk)](#444-и-and-но-but--asterisk)
  * [4.5. Предыстория (Background)](#45-предыстория-background)
  * [4.6. Структура сценария (Scenario outline)](#46-структура-сценария-scenario-outline)
* [5. Выражения (Expressions)](#5-выражения-expressions)
  * [5.1. Регулярные выражения (Regular Expression)](#51-регулярные-выражения-regular-expression)
  * [5.2. Выражения Cucumber (Cucumber Expressions)](#52-выражения-cucumber-cucumber-expressions)
    * [5.2.1. Параметры](#521-параметры)
    * [5.2.2. Параметры кастомных типов (Custom Parameter Types)](#522-параметры-кастомных-типов-custom-parameter-types)
    * [5.2.3. Опциональный текст (Optional text)](#523-опциональный-текст-optional-text)
    * [5.2.4. Альтернативный текст (Alternative text)](#524-альтернативный-текст-alternative-text)
    * [5.2.5. Экранирование (Escaping)](#525-экранирование-escaping)
* [6. Передача данных в шаги](#6-передача-данных-в-шаги)
  * [6.1. Данные перечисленные через запятую](#61-данные-перечисленные-через-запятую)
  * [6.2. Данные в виде таблицы с одной колонкой](#62-данные-в-виде-таблицы-с-одной-колонкой)
  * [6.3. Данные в виде таблицы с двумя колонками](#63-данные-в-виде-таблицы-с-двумя-колонками)
  * [6.4. Данные в виде таблицы с множеством колонок (Data Tables)](#64-данные-в-виде-таблицы-с-множеством-колонок-data-tables)
    * [6.4.1. Преобразование таблицы в список ассоциативных массивов](#641-преобразование-таблицы-в-список-ассоциативных-массивов)
    * [6.4.2. Преобразование таблицы в список списков](#642-преобразование-таблицы-в-список-списков)
    * [6.4.3. Преобразование таблицы в список списков строк](#643-преобразование-таблицы-в-список-списков-строк)
    * [6.4.4. Экранирование (Table Cell Escaping)](#644-экранирование-table-cell-escaping)
  * [6.5. Использование классов](#65-использование-классов)
    * [6.5.1. Наименование полей класса в первой строке](#651-наименование-полей-класса-в-первой-строке)
    * [6.5.2. Наименование полей класса в первом столбце](#652-наименование-полей-класса-в-первом-столбце)
  * [6.6. Докстринг (Doc Strings)](#66-докстринг-doc-strings)
* [7. Преобразование данных](#7-преобразование-данных)
* [8. Лучшие практики](#8-лучшие-практики)
  * [8.1. Советы](#81-советы)
  * [8.2. Анти паттерны](#82-анти-паттерны)

***

# 1. Интерфейс командной строки Cucumber (Cucumber Command-Line Interface Runner (Cucumber CLI Runner))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Фреймворк **Cucumber** поставляется с встроенным интерфейсом командной строки (**Cucumber CLI Runner**).

***Интерфейс командной строки Cucumber (Cucumber Command-Line Interface Runner (Cucumber CLI Runner))*** -
исполняемый класс **Java**, который можно запустить из командной строки (**io.cucumber.core.cli.Main**).

Формат команды:

```text
java io.cucumber.core.cli.Main [options] [ [DIR|DIR URI] | [ [FILE|FILE URI][:LINE]* ] | @[FILE|FILE URI] ]+
```

## 1.1. Опции командной строки Cucumber

## 1.1.1. Версия Cucumber

***--version*** ***-v*** - вывод версии **Cucumber**.

```text
java io.cucumber.core.cli.Main --version
java io.cucumber.core.cli.Main -v
```

## 1.1.2. Справка по опциям командной строки Cucumber

***--help*** или ***-h*** - справка по опциям командной строки **Cucumber**.

```text
java io.cucumber.core.cli.Main --help
java io.cucumber.core.cli.Main -h
```

## 1.1.3. Список пакетов Java с кодом шагов, хуков и т д.

***--glue*** или ***-g*** - список пакетов **Java** с кодом шагов, хуков и т д.

```text
java io.cucumber.core.cli.Main --glue PATH
java io.cucumber.core.cli.Main -g PATH
```

Параметры:

* *PATH* - список полных путей до пакетов **Java**

По умолчанию (если опция не указана): **Cucumber** будет искать код шагов, хуков и т д в **classpath**.

*Пример*

```text
java io.cucumber.core.cli.Main --glue step_definitions features
java io.cucumber.core.cli.Main -g step_definitions features
```

## 1.1.4. Количество параллельных потоков при запуске сценариев

***--threads*** - количество параллельных потоков при запуске сценариев.

```text
java io.cucumber.core.cli.Main --threads COUNT
```

Параметры:

* *COUNT* - число параллельных потоков

По умолчанию (если опция не указана): сценарии запускаются в один поток.

*Пример*

```text
java io.cucumber.core.cli.Main --threads 10 features
```

## 1.1.5. Список плагинов

***--plugin*** или ***-p*** - список плагинов.

```text
java io.cucumber.core.cli.Main --plugin PLUGIN[:[PATH|[URI [OPTIONS]]]
java io.cucumber.core.cli.Main -p PLUGIN[:[PATH|[URI [OPTIONS]]]
```

Параметры:

* *PLUGIN* - список наименований/типов плагинов

Встроенные плагины форматов: *html*, *json*, *pretty*, *junit*, *testng*, *teamcity*, *progress*, *rerun*,*timeline*, *message*, *usage*.

Встроенные плагины описания: *summary*, *null_summary*, *unused*

В **PLUGIN** можно указать полностью определенное имя класса, чтобы подключать сторонние плагины.

* *URI*- ссылка на ресурс (http:// или https://) 

На данный адрес будет отправлен вывод как запрос PUT.
Это можно изменить, предоставив дополнительные параметры.

* *OPTIONS* - поддержка команд **cUrls** *-X* и *-H*

По умолчанию (если опция не указана): сценарии запускаются без плагина.

*Пример*

```text
java io.cucumber.core.cli.Main --plugin pretty features
java io.cucumber.core.cli.Main -p pretty features
```

Можно указать несколько плагинов

*Пример*

```text
java io.cucumber.core.cli.Main --plugin pretty --plugin html:cukes.html --plugin rerun:rerun.txt features
java io.cucumber.core.cli.Main -p pretty -p html:cukes.html -p rerun:rerun.txt features
```

## 1.1.6. Порядок выполнения сценариев

***--order*** - порядок выполнения сценариев.

```text
java io.cucumber.core.cli.Main --order ORDER
```

Параметры:

* *ORDER* - порядок выполнения сценариев
  * *reverse* - в обратном порядке
  * *random* - рандомно

По умолчанию (если опция не указана): сценарии запускаются по порядку.

*Пример*

```text
java io.cucumber.core.cli.Main --order reverse
java io.cucumber.core.cli.Main --order random
```

## 1.1.7. Количество выполняемых сценариев

**--count** - количество выполняемых сценариев.

```text
java io.cucumber.core.cli.Main --count COUNT
```

Параметры:

* *COUNT* - число выполняемых сценариев

По умолчанию (если опция не указана): сценарии запускаются без ограничений по количеству.

*Пример*

```text
java io.cucumber.core.cli.Main --count 50
java io.cucumber.core.cli.Main --count 500
```

## 1.1.8. Фильтрация сценариев по наименованию

***--name*** или ***-n*** - фильтрация сценариев по наименованию.

```text
java io.cucumber.core.cli.Main --name REGEXP
java io.cucumber.core.cli.Main -n REGEXP
```

Параметры:

* *REGEXP* - регулярное выражение для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по наименованию.

*Пример*

```text
java io.cucumber.core.cli.Main --name logout
java io.cucumber.core.cli.Main -n logout
```

## 1.1.9. Фильтрация сценариев по тегам

***--tags*** или ***-t*** - фильтрация сценариев по тегам.

```text
java io.cucumber.core.cli.Main --tags TAG_EXPRESSION
java io.cucumber.core.cli.Main -t TAG_EXPRESSION
```

Параметры:

* *TAG_EXPRESSION* - список тегов для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по тегам.

*Пример*

```text
java io.cucumber.core.cli.Main --tags @smoke features
java io.cucumber.core.cli.Main -t @smoke features
```

Указанные в **--tags** через запятую теги интерпретируются как указанные через логическое **ИЛИ (OR)**.

*Пример*

```text
java io.cucumber.core.cli.Main --tags @task1,@task2 features
java io.cucumber.core.cli.Main -t @task1,@task2 features
```

Указанные в нескольких **--tags** теги интерпретируются как указанные через логическое **И (AND)**.

*Пример*

```text
java io.cucumber.core.cli.Main --tags @task1 --tags @task2 features
java io.cucumber.core.cli.Main -t @task1 -t @task2 features
```

Указанные в **--tags** с тильдой **~** теги интерпретируются как указанные через логическое **НЕ (NOT)**.

*Пример*

```text
java io.cucumber.core.cli.Main --tags @task1 --tags @task2 features
java io.cucumber.core.cli.Main -t @task1 -t @task2 features
```

## 1.1.10. Пропуск сценариев с тегом @wip (Работа в процессе (Work In Progress)

***--wip*** или ***-w*** - пропуск сценариев с тегом **@wip** (**Работа в процессе (Work In Progress**)

```text
java io.cucumber.core.cli.Main --wip
java io.cucumber.core.cli.Main -w
```

По умолчанию (если опция не указана): сценарии запускаются без пропуска.

## 1.1.11. Запуск сценариев без выполнения кода шагов сценариев

***--dry-run*** или ***-d true*** - запуск сценариев без выполнения кода шагов сценариев.

***--no-dry-run*** или ***-d false*** - запуск сценариев с выполнением кода шагов сценариев.

```text
java io.cucumber.core.cli.Main --dry-run
java io.cucumber.core.cli.Main --no-dry-run
java io.cucumber.core.cli.Main -d true 
java io.cucumber.core.cli.Main -d false 
```

По умолчанию (если опция не указана): сценарии запускаются с выполнением кода шагов сценариев.

*Пример*

```text

```

## 1.1.12. Черно-белый / цветной вывод в консоль

***--monochrome*** или ***-m true*** - цветной вывод в консоль.

***--no-monochrome*** или ***-m false*** - черно-белый вывод в консоль.

```text
java io.cucumber.core.cli.Main --monochrome
java io.cucumber.core.cli.Main --no-monochrome
java io.cucumber.core.cli.Main -m true 
java io.cucumber.core.cli.Main -m false 
```

По умолчанию (если опция не указана): сценарии запускаются с цветным выводом в консоль.

## 1.1.13. Стиль наименовании для сгенерированных методов 

***--snippets*** - стиль наименовании для сгенерированных методов.

```text
java io.cucumber.core.cli.Main --snippets STYLE
```
Параметры:

* *STYLE* - стиль именования методов
  * *underscore* - сгенерированные методы будут именоваться в **змеином** стиле (нижнее подчеркивание)
  * *camelcase* - сгенерированные методы будут именоваться в **верблюжьем** стиле (заглавные буквы)

По умолчанию (если опция не указана): сгенерированные методы будут именоваться в **змеином** стиле (нижнее подчеркивание).

*Пример*

```text
java io.cucumber.core.cli.Main --snippets underscore features
java io.cucumber.core.cli.Main --snippets camelcase features
```

## 1.1.14. Список ключевых слов для определенного языка

***--i18n*** - язык сценариев

```text
java io.cucumber.core.cli.Main --i18n LANG
```

Параметры:

* *LANG* - язык сценариев
  * *help* - вывод списка всех языков

*Пример*

```text
java io.cucumber.core.cli.Main --i18n en
java io.cucumber.core.cli.Main --i18n ru
java io.cucumber.core.cli.Main --i18n help
```

## 1.2. Путь к фичам и сценариям

### 1.2.1. Путь к фичам и сценариям не указан

Если путь к **.feature** файлам не указан, **Cucumber** просканирует корневую папку и все подпапки.

*Пример*

```text
java io.cucumber.core.cli.Main
```

### 1.2.2. Путь к папке с **.feature** файлами

Загрузка **.feature** файлов из папки **\<path\>** и всех подпапок.

```text
java io.cucumber.core.cli.Main <path>
```

*Пример*

```text
java io.cucumber.core.cli.Main ./src/tests/resources/features
```

### 1.2.3. Путь к конкретному **.feature** файлу

Загрузка **.feature** файла с именем **\<name\>.feature** из папки **\<path\>**.

```text
java io.cucumber.core.cli.Main <path>/<name>.feature
```

*Пример*

```text
java io.cucumber.core.cli.Main ./src/tests/resources/features/feature.feature
```

### 1.2.4. Путь к конкретному **.feature** файлу с указанием **classpath**

Загрузка **.feature** файла с именем **\<name\>** из папки **\<path\>** относительно **classpath**.

```text
java io.cucumber.core.cli.Main classpath:<path>/<name>.feature
```

*Пример*

```text
java io.cucumber.core.cli.Main classpath:src/tests/resources/features/Smartphones.feature
```

### 1.2.5. Путь к конкретному **.feature** файлу с указанием с указанием строк сценария

Загрузка **.feature** файла с именем **\<name\>** из папки **\<path\>** с указанием строк **с 3 по 9** сценария.

```text
java io.cucumber.core.cli.Main <path>/<name>.feature:3:9
```

*Пример*

```text
java io.cucumber.core.cli.Main ./src/tests/resources/features/feature.feature:3:9
```

***

# 2. Опции запуска

Напрямую работать с **Cucumber Command-Line Interface (CLI)** нет никакой необходимости.

**Cucumber** будет анализировать свойства в порядке приоритета из:

* переменных системы
* переменных окружения
* аннотации **@CucumberOptions**
* файла **cucumber.properties**
* файла **junit.properties**

Аргументы передаваемые в **Cucumber Command-Line Interface (CLI)** имеют приоритет над всеми.

## 2.1. Файл cucumber.properties

[Cucumber Core](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-core#properties-environment-variables-system-options)

### 2.1.1. Список пакетов Java с кодом шагов, хуков и т д.

***cucumber.glue*** - список пакетов **Java** с кодом шагов, хуков и т д.

```text
cucumber.glue=PATH
```

Параметры:

* *PATH* - список разделенных запятыми полных путей до пакетов **Java**

По умолчанию (если опция не указана): **Cucumber** будет искать код шагов, хуков и т д в **classpath**.

*Пример*

```text
cucumber.glue=com.example.glue
```

*Пример*

```text
mvn test -Dcucumber.glue=com.example.glue
```

### 2.1.2. Папки с фичами и сценариями

***cucumber.features*** - папки с фичами и сценариями.

```text
cucumber.features=PATH
```

Параметры:

* *PATH* - список разделенных запятыми полных путей до папок с фичами и сценариями

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.features=path/to/example.feature, path/to/other.feature
```

*Пример*

```text
mvn test -Dcucumber.features=path/to/example.feature, path/to/other.feature
```

### 2.1.3. Список плагинов

***cucumber.plugin*** - список плагинов.

```text
cucumber.plugin=PLUGIN[:[PATH|[URI [OPTIONS]]]
```

Параметры:

* *PLUGIN* - список разделенных запятыми наименований/типов плагинов

Встроенные плагины форматов: *html*, *json*, *pretty*, *junit*, *testng*, *teamcity*, *progress*, *rerun*,*timeline*, *message*, *usage*.

Встроенные плагины описания: *summary*, *null_summary*, *unused*

В **PLUGIN** можно указать полностью определенное имя класса, чтобы подключать сторонние плагины.

* *URI*- ссылка на ресурс (http:// или https://)

На данный адрес будет отправлен вывод как запрос PUT.
Это можно изменить, предоставив дополнительные параметры.

* *OPTIONS* - поддержка команд **cUrls** *-X* и *-H*

По умолчанию (если опция не указана): сценарии запускаются без плагина.

*Пример*

```text
cucumber.plugin=pretty, json:path/to/report.json
```

*Пример*

```text
mvn test -Dcucumber.plugin=pretty, json:path/to/report.json
```

### 2.1.4. Порядок выполнения сценариев

***cucumber.execution.order*** - порядок выполнения сценариев (CLI only).

```text
cucumber.execution.order= 
```

Параметры:

* *ORDER* - порядок выполнения сценариев
  * *lexical* - по порядку
  * *reverse* - в обратном порядке
  * *random* - рандомно
  * *random:[seed]* - рандомно
    
По умолчанию (если опция не указана): сценарии запускаются по порядку.

*Пример*

```text
cucumber.execution.order=reverse
```

*Пример*

```text
mvn test -Dcucumber.execution.order=reverse
```

### 2.1.5. Количество выполняемых сценариев

***cucumber.execution.limit*** - количество выполняемых сценариев (CLI only).

```text
cucumber.execution.limit=COUNT
```

Параметры:

* *COUNT* - число выполняемых сценариев

По умолчанию (если опция не указана): сценарии запускаются без ограничений по количеству.

*Пример*

```text
cucumber.execution.limit=100
```

*Пример*

```text
mvn test -Dcucumber.execution.limit=100
```

### 2.1.6. Фильтрация сценариев по наименованию

***cucumber.filter.name*** - фильтрация сценариев по наименованию.

```text
cucumber.filter.name=REGEXP
```

Параметры:

* *REGEXP* - регулярное выражение для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по наименованию.

*Пример*

```text
cucumber.filter.name=^Hello (World|Cucumber)$
```

*Пример*

```text
mvn test -Dcucumber.filter.name=^Hello (World|Cucumber)$
```

### 2.1.7. Фильтрация сценариев по тегам

***cucumber.filter.tags*** - фильтрация сценариев по тегам.

```text
cucumber.filter.tags=TAG_EXPRESSION
```

Параметры:

* *TAG_EXPRESSION* - список тегов для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по тегам.

*Пример*

```text
cucumber.filter.tags=@Cucumber and not (@Gherkin or @Zucchini)
```

*Пример*

```text
mvn test -Dcucumber.filter.tags=@Cucumber and not (@Gherkin or @Zucchini)
```

### 2.1.8. Пропуск сценариев с тегом @wip (Работа в процессе (Work In Progress)

***cucumber.execution.wip*** - пропуск сценариев с тегом **@wip** (**Работа в процессе (Work In Progress**) (CLI only).

```text
cucumber.execution.wip=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): сценарии запускаются без пропуска (false).

*Пример*

```text
cucumber.execution.wip=true
```

*Пример*

```text
mvn test -Dcucumber.execution.wip=true
```

### 2.1.9. Запуск сценариев без выполнения кода шагов сценариев

***cucumber.execution.dry-run*** - запуск сценариев без выполнения кода шагов сценариев.

```text
cucumber.execution.dry-run=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): сценарии запускаются с выполнением кода шагов сценариев (false).

*Пример*

```text
cucumber.execution.dry-run=true
```

*Пример*

```text
mvn test -Dcucumber.execution.dry-run=true
```

### 2.1.10. Черно-белый / цветной вывод в консоль

***cucumber.ansi-colors.disabled*** - черно-белый / цветной вывод в консоль.

```text
cucumber.ansi-colors.disabled=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): сценарии запускаются с цветным выводом в консоль (false).

*Пример*

```text
cucumber.ansi-colors.disabled=true
```

*Пример*

```text
mvn test -Dcucumber.ansi-colors.disabled=true
```

### 2.1.11. Стиль именования для сгенерированных методов

***cucumber.snippet-type*** - стиль именования для сгенерированных методов.

```text
cucumber.snippet-type=STYLE
```

Параметры:

* *STYLE* - стиль именования для сгенерированных методов
  * *underscore* - сгенерированные методы будут именоваться в **змеином** стиле (нижнее подчеркивание)
  * *camelcase* - сгенерированные методы будут именоваться в **верблюжьем** стиле (заглавные буквы)

По умолчанию (если опция не указана): сгенерированные методы будут именоваться в **змеином** стиле (underscore).

*Пример*

```text
cucumber.snippet-type=camelcase
```

*Пример*

```text
mvn test -Dcucumber.snippet-type=camelcase
```

### 2.1.12. Наименование класса object factory.

***cucumber.object-factory*** - наименование класса object factory.

```text
cucumber.object-factory=CLASS
```

Параметры:

* *CLASS* - наименование класса object factory

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.object-factory=com.example.MyObjectFactory
```

*Пример*

```text
mvn test -Dcucumber.object-factory=com.example.MyObjectFactory
```

### 2.1.13. Публикация отчета после выполнения теста

***cucumber.publish.enabled*** - публикация отчета.

```text
cucumber.publish.enabled=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): публикация отчета нет (false).

*Пример*

```text
cucumber.publish.enabled=true
```

*Пример*

```text
mvn test -Dcucumber.publish.enabled=true
```

### 2.1.14. Запрет баннера публикации отчета после выполнения теста

***cucumber.publish.quiet*** - запрет баннера публикации отчета после выполнения теста.

```text
cucumber.publish.quiet=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): запрета баннера публикации отчета после выполнения теста нет (false).

*Пример*

```text
cucumber.publish.quiet=true
```

*Пример*

```text
mvn test -Dcucumber.publish.quiet=true
```

### 2.1.15. Токен для публикации отчета после выполнения теста

***cucumber.publish.token*** - токен для публикации отчета после выполнения теста.

```text
cucumber.publish.token=TOKEN
```

Параметры:

* *TOKEN* - токен для публикации отчета после выполнения теста

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.publish.token=fh34rfh-f4nf43f-2f2fjdl
```

*Пример*

```text
mvn test -Dcucumber.publish.token=fh34rfh-f4nf43f-2f2fjdl
```

### 2.1.16. Ссылка на хранилище для публикации отчета после выполнения теста

***cucumber.publish.url*** - ссылка на хранилище для публикации отчета после выполнения теста.

```text
cucumber.publish.url=URL
```

Параметры:

* *URL* - ссылка на хранилище для публикации отчета после выполнения теста.

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.publish.url=https://reports.com
```

*Пример*

```text
mvn test -Dcucumber.publish.url=https://reports.com
```

## 2.2. Файл junit-platform.properties

[Cucumber JUnit Platform Engine](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-junit-platform-engine)

## 2.2.1. Список пакетов Java с кодом шагов, хуков и т д.

***cucumber.glue*** - список пакетов **Java** с кодом шагов, хуков и т д.

```text
cucumber.glue=PATH
```

Параметры:

* *PATH* - список разделенных запятыми полных путей до пакетов **Java**

По умолчанию (если опция не указана): **Cucumber** будет искать код шагов, хуков и т д в **classpath**.

*Пример*

```text
cucumber.glue=com.example.glue
```

*Пример*

```text
mvn test -Dcucumber.glue=com.example.glue
```

### 2.2.2. Папки с фичами и сценариями

***cucumber.features*** - папки с фичами и сценариями.

```text
cucumber.features=PATH
```

Параметры:

* *PATH* - список разделенных запятыми полных путей до папок с фичами и сценариями

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.features=path/to/example.feature, path/to/other.feature
```

*Пример*

```text
mvn test -Dcucumber.features=path/to/example.feature, path/to/other.feature
```

## 2.2.3. Список плагинов

***cucumber.plugin*** - список плагинов.

```text
cucumber.plugin=PLUGIN[:[PATH|[URI [OPTIONS]]]
```

Параметры:

* *PLUGIN* - список разделенных запятыми наименований/типов плагинов

Встроенные плагины форматов: *html*, *json*, *pretty*, *junit*, *testng*, *teamcity*, *progress*, *rerun*,*timeline*, *message*, *usage*.

Встроенные плагины описания: *summary*, *null_summary*, *unused*

В **PLUGIN** можно указать полностью определенное имя класса, чтобы подключать сторонние плагины.

* *URI*- ссылка на ресурс (http:// или https://)

На данный адрес будет отправлен вывод как запрос PUT.
Это можно изменить, предоставив дополнительные параметры.

* *OPTIONS* - поддержка команд **cUrls** *-X* и *-H*

По умолчанию (если опция не указана): сценарии запускаются без плагина.

*Пример*

```text
cucumber.plugin=pretty, json:path/to/report.json
```

*Пример*

```text
mvn test -Dcucumber.plugin=pretty, json:path/to/report.json
```

## 2.2.4. Фильтрация сценариев по наименованию

***cucumber.filter.name*** - фильтрация сценариев по наименованию.

```text
cucumber.filter.name=REGEXP
```

Параметры:

* *REGEXP* - регулярное выражение для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по наименованию.

*Пример*

```text
cucumber.filter.name=^Hello (World|Cucumber)$
```

*Пример*

```text
mvn test -Dcucumber.filter.name=^Hello (World|Cucumber)$
```

## 2.2.5. Фильтрация сценариев по тегам

***cucumber.filter.tags*** - фильтрация сценариев по тегам.

```text
cucumber.filter.tags=TAG_EXPRESSION  
```

Параметры:

* *TAG_EXPRESSION* - список тегов для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по тегам.

*Пример*

```text
cucumber.filter.tags=@Cucumber and not (@Gherkin or @Zucchini)
```

*Пример*

```text
mvn test -Dcucumber.filter.tags=@Cucumber and not (@Gherkin or @Zucchini)
```

## 2.2.6. Запуск сценариев без выполнения кода шагов сценариев

***cucumber.execution.dry-run*** - запуск сценариев без выполнения кода шагов сценариев.

```text
cucumber.execution.dry-run=BOOL  
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): сценарии запускаются с выполнением кода шагов сценариев (false).

*Пример*

```text
cucumber.execution.dry-run=true
```

*Пример*

```text
mvn test -Dcucumber.execution.dry-run=true
```

## 2.2.7. Черно-белый / цветной вывод в консоль

***cucumber.ansi-colors.disabled*** - черно-белый / цветной вывод в консоль.

```text
cucumber.ansi-colors.disabled=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): сценарии запускаются с цветным выводом в консоль (false).

*Пример*

```text
cucumber.ansi-colors.disabled=true
```

*Пример*

```text
mvn test -Dcucumber.ansi-colors.disabled=true
```

## 2.2.8. Стиль именования для сгенерированных методов

***cucumber.snippet-type*** - стиль именования для сгенерированных методов.

```text
cucumber.snippet-type=STYLE
```

Параметры:

* *STYLE* - стиль именования для сгенерированных методов
  * *underscore* - сгенерированные методы будут именоваться в **змеином** стиле (нижнее подчеркивание)
  * *camelcase* - сгенерированные методы будут именоваться в **верблюжьем** стиле (заглавные буквы)

По умолчанию (если опция не указана): сгенерированные методы будут именоваться в **змеином** стиле (underscore).

*Пример*

```text
cucumber.snippet-type=camelcase
```

*Пример*

```text
mvn test -Dcucumber.snippet-type=camelcase 
```

## 2.2.9. Наименование класса object factory.

***cucumber.object-factory*** - наименование класса object factory.

```text
cucumber.object-factory=CLASS
```

Параметры:

* *CLASS* - наименование класса object factory

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.object-factory=com.example.MyObjectFactory
```

*Пример*

```text
mvn test -Dcucumber.object-factory=com.example.MyObjectFactory
```

## 2.2.10. Публикация отчета после выполнения теста

***cucumber.publish.enabled*** - публикация отчета.

```text
cucumber.publish.enabled=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): публикация отчета нет (false).

*Пример*

```text
cucumber.publish.enabled=true
```

*Пример*

```text
mvn test -Dcucumber.publish.enabled=true
```

## 2.2.11. Запрет баннера публикации отчета после выполнения теста

***cucumber.publish.quiet*** - запрет баннера публикации отчета после выполнения теста.

```text
cucumber.publish.quiet=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): запрета баннера публикации отчета после выполнения теста нет (false).

*Пример*

```text
cucumber.publish.quiet=true
```

*Пример*

```text
mvn test -Dcucumber.publish.quiet=true
```

## 2.2.12. Токен для публикации отчета после выполнения теста

***cucumber.publish.token*** - токен для публикации отчета после выполнения теста.

```text
cucumber.publish.token=TOKEN
```

Параметры:

* *TOKEN* - токен для публикации отчета после выполнения теста

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.publish.token=fh34rfh-f4nf43f-2f2fjdl
```

*Пример*

```text
mvn test -Dcucumber.publish.token=fh34rfh-f4nf43f-2f2fjdl 
```

## 2.2.13. Параллельный запуск

***cucumber.execution.parallel.enabled*** - параллельный запуск.

```text
cucumber.execution.parallel.enabled=BOOL
```

Параметры:

* *BOOL* - true/false

По умолчанию (если опция не указана): запуск в один поток (false).

*Пример*

```text
cucumber.execution.parallel.enabled=true
```

*Пример*

```text
mvn test -Dcucumber.execution.parallel.enabled=true
```

## 2.2.14. Стратегия параллельного запуска

***cucumber.execution.parallel.config.strategy*** - стратегия параллельного запуска.

```text
cucumber.execution.parallel.config.strategy=STRATEGY
```

Параметры:

* *STRATEGY* - стратегия параллельного запуска
  * *dynamic* - динамическое количество потоков
  * *fixed* - фиксированное количество потоков
  * *custom* - кастомная стратегия

По умолчанию (если опция не указана): стратегия параллельного запуска динамическая (dynamic).

*Пример*

```text
cucumber.execution.parallel.config.strategy=fixed
```

*Пример*

```text
mvn test -Dcucumber.execution.parallel.config.strategy=fixed
```

## 2.2.15. Фиксированное количество потоков

***cucumber.execution.parallel.config.fixed.parallelism*** - фиксированное количество потоков.

```text
cucumber.execution.parallel.config.fixed.parallelism=THREADS
```

Параметры:

* *THREADS* - фиксированное количество потоков

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.execution.parallel.config.fixed.parallelism=8
```

*Пример*

```text
mvn test -Dcucumber.execution.parallel.config.fixed.parallelism=8
```

## 2.2.16. Динамическое количество потоков

***cucumber.execution.parallel.config.dynamic.factor*** - динамическое количество потоков.

```text
cucumber.execution.parallel.config.dynamic.factor=FACTOR
```

Параметры:

* *FACTOR* - динамическое количество потоков

По умолчанию (если опция не указана): (1.0).

*Пример*

```text
cucumber.execution.parallel.config.dynamic.factor=2.2
```

*Пример*

```text
mvn test -Dcucumber.execution.parallel.config.dynamic.factor=2.2
```

## 2.2.17. Кастомный класс для параллельного запуска

***cucumber.execution.parallel.config.custom.class*** - кастомный класс для параллельного запуска.

```text
cucumber.execution.parallel.config.custom.class=CLASS
```

Параметры:

* *CLASS* - кастомный класс для параллельного запуска

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.execution.parallel.config.custom.class=com.example.MyCustomParallelStrategy
```

*Пример*

```text
mvn test -Dcucumber.execution.parallel.config.custom.class=com.example.MyCustomParallelStrategy
```

## 2.2.18. 

***cucumber.execution.exclusive-resources.<tag-name>.read-write*** -

```text
cucumber.execution.exclusive-resources.<tag-name>.read-write=RESOURCES
```

Параметры:

* *RESOURCES* - a comma separated list of strings

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.execution.exclusive-resources.<tag-name>.read-write=resource-a, resource-b
```

*Пример*

```text
mvn test -Dcucumber.execution.exclusive-resources.<tag-name>.read-write=resource-a, resource-b
```

## 2.2.19. 

***cucumber.execution.exclusive-resources.<tag-name>.read*** -

```text
cucumber.execution.exclusive-resources.<tag-name>.read=RESOURCES
```

Параметры:

* *RESOURCES* - a comma separated list of strings

По умолчанию (если опция не указана): .

*Пример*

```text
cucumber.execution.exclusive-resources.<tag-name>.read=resource-a, resource-b
```

*Пример*

```text
mvn test -Dcucumber.execution.exclusive-resources.<tag-name>.read=resource-a, resource-b
```

## 2.2.20. 

***cucumber.junit-platform.naming-strategy*** - include parent descriptor name in test descriptor

```text
cucumber.junit-platform.naming-strategy=STRATEGY
```

Параметры:

* *STRATEGY* - 
  * *long* - 
  * *short* - 

По умолчанию (если опция не указана): (short).

*Пример*

```text
cucumber.junit-platform.naming-strategy=  
```

*Пример*

```text
mvn test -Dcucumber.junit-platform.naming-strategy=  
```

***

# 3. Формирование отчетов (Reports)

После прогона тестовых сценариев **Cucumber** формирует отчет по результатам запуска.
В отчетах содержится информация о запуске - успешные и неуспешные сценарии / шаги / фичи и т д.
Для построения отчетов **Cucumber** использует специальные **Плагины отчетов (Reporter Plugins)**.

Существует множество различных **Плагины отчетов (Reporter Plugins)**:
некоторые из них встроены в сам фреймворк, другие устанавливаются отдельно.


## 3.1. Встроенные плагины отчетов (Built-in Reporter Plugins)

В **Cucumber** встроена возможность локальной генерации отчетов с помощью встроенных **Плагины отчетов (Reporter Plugins)**.
Встроенные **Плагины отчетов (Reporter Plugins)** еще называются **Форматтеры (Formatters)**.

Существуют следующие встроенные **Плагины отчетов (Reporter Plugins)**:

* *html* (вывод отчета в *HTML* файл)
* *json* (вывод отчета в **JSON** файл)
* *junit* (вывод отчета в формат **JUnit**)
* *testng* (вывод отчета в формат **TestNG**)
* *pretty* (вывод отчета по шагам в консоль)
* *message* (вывод отчета в консоль)
* *progress* (вывод отчета в консоль)
* *rerun*

### 3.1.1. Плагин отчета html 

*Пример*

```properties
cucumber.features=src/test/resources/features
cucumber.glue=steps, hooks
cucumber.plugin=html:report.html
```

![html](_Files/1.%20Lection/3.%20Reports/01.jpg)

[Отчет сгенерированный плагином html](_Files/1.%20Lection/3.%20Reports/report.html)

### 3.1.2. Плагин отчета json

*Пример*

```properties
cucumber.features=src/test/resources/features
cucumber.glue=steps, hooks
cucumber.plugin=json:report.json
```

![json](_Files/1.%20Lection/3.%20Reports/02.jpg)

[Отчет сгенерированный плагином json](_Files/1.%20Lection/3.%20Reports/report.json)

### 3.1.3. Плагин отчета junit

*Пример*

```properties
cucumber.features=src/test/resources/features
cucumber.glue=steps, hooks
cucumber.plugin=junit:report.xml
```

![junit](_Files/1.%20Lection/3.%20Reports/03.jpg)

[Отчет сгенерированный плагином junit](_Files/1.%20Lection/3.%20Reports/report.xml)

### 3.1.4. Плагин отчета pretty

*Пример*

```properties
cucumber.features=src/test/resources/features
cucumber.glue=steps, hooks
cucumber.plugin=pretty
```

![pretty](_Files/1.%20Lection/3.%20Reports/04.jpg)

### 3.1.5. Плагин отчета message

*Пример*

```properties
cucumber.features=src/test/resources/features
cucumber.glue=steps, hooks
cucumber.plugin=message
```

![message](_Files/1.%20Lection/3.%20Reports/05.jpg)

## 3.2. Кастомные Форматтеры (Custom formatters)

В **Cucumber** есть возможность создания своего кастомного форматтера,
путем имплементации или расширения стандартного форматтера или использования сторонних форматтеров.

Чтобы указать свой форматтер, достаточно просто добавить флаг **--format**.

```text
cucumber --format CustomFormatter
```

## 3.3. Cucumber Reports Service

***Cucumber Reports Service*** - облачный сервис для размещения и хранения отчетов запсука тестов **Cucumber**.

Чтобы разместить отчетв нужно выполнить следующие шаги:

1. Перейти по адресу [reports.cucumber.io](https://reports.cucumber.io/)
2. Авторизоваться
3. Создать новую коллекцию отчетов

![reports.cucumber.io](_Files/1.%20Lection/3.%20Reports/06.jpg)

4. Скопировать токен
5. В **cucumber.properties** или **junit-platfor.properties** прописать настройки

```properties
cucumber.publish.enabled=true
cucumber.publish.quiet=true
#токен
cucumber.publish.token=f435057b-3712-422d-8d35-398dd74f1a8f 
cucumber.plugin=pretty, html:report.html
```

6. Запустить автотесты
7. Готово! Теперь отчет автоматически разместится на портале **reports.cucumber.io**

![reports.cucumber.io](_Files/1.%20Lection/3.%20Reports/07.jpg)

***

# 4. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и
использует отступы для задания структуры. Каждая строка представляет собой выражение -
шаг (**step**) и заканчивается переносом строки.

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на множество языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Список зарезервированных символов:

* *#* – обозначает комментарии
* *@* – тэгирует сценарии или функционал
* *|* – разделяет данные в табличном формате
* *"""* – обрамляет многострочные данные

## 4.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания поведения/функции системы и набора связанных с ней тестовых сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  # подробное описание
  # сценарии
```

Каждая **Функция (Feature)** описывается в отдельном файле с расширением **.feature**.
Любой документ **.feature** начинается с этого ключевого слова и краткого описания.
Каждая функция обычно состоит из списка сценариев (**Сценарий (Scenario)**, **Структура сценария (Scenario Outline)**).

На следующей строке после ключевого слова и наименования функции может идти **Подробное описание (Descriptions)**.
В **Подробное описание (Description)** можно добавить **Пользовательскую историю (User Story)**.

Наименование функции и подробное описание не имеют какого либо значения для **Cucumber**.

*Пример*

```Gherkin
Feature: Withdraw Money from ATM

  A user with an account at a bank would like to withdraw money from an ATM.
  Provided he has a valid account and debit or credit card, he should be allowed to make the transaction. 
  The ATM will tend the requested amount of money, return his card, and subtract amount of the withdrawal from the user's account.

  Scenario: Scenario 1
    Given preconditions
    When actions
    Then results

  Scenario: Scenario 2
  ...
```

## 4.2. Подробное описание (Descriptions)

***Подробное описание (Descriptions)*** - более подробное описание фичи.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

    Подробное описание
    На нескольких строках

    # сценарии
```

**Подробное описание (Descriptions)** представляет собой текст, который располагается на следующих строках
после строки с ключевым словом и размечается отступами. Количество строк никак не ограничено и
**Подробное описание (Descriptions)** продолжается до первого встреченного ключевого слова.
Эти строки будут проигнорированы **Cucumber** при выполнении тестов, но будут использованы при формировании отчетов.
Можно сказать, что **Подробное описание (Descriptions)** похоже на комментарий.

**Подробное описание (Descriptions)** можно добавлять после:

* *Примера (Example)* или *Сценария (Scenario)*
* *Предыстории (Background)*
* *Структуры сценария (Scenario Outline)*

*Пример*

```gherkin

```

## 4.3. Сценарий (Scenario)

***Сценарий (Scenario)*** - ключевое слово, предназначенное для описания конкретного тестового сценария.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
  # шаги сценария
```

**Сценарий (Scenario)** представляет собой одну из ключевых структур в языке **Gherkin**.
Каждый сценарий состоит из набора **Шагов (Steps)** - **Дано (Given)**, **Когда (When)** и **Тогда (Then)**.
Также **Сценарии (Scenario)** могут содержать **Предысторию (Background)** или
иметь множество примеров в виде **Структуры сценария (Scenario Outline)**.

**Сценарий (Scenario)** описывает поведение системы и является ее спецификацией.

*Пример*

```gherkin
#language: ru
Сценарий: Вася создает новую запись
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Лекарства"
То мне должен быть ответ "Ваша запись успешно добавлена."

Сценарий: Вася не может добавлять запись в справочник лечений
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Виды лечений"
То мне должен быть ответ "У вас нет прав доступа!"
```

## 4.4. Шаги (Steps)

***Шаги (Steps)*** - строительные блоки тестовых сценариев.

**Шаги (Steps)** представляют собой строки текста начинающиеся с одного из ключевых слов:

* *Дано (Given)* - данные
* *Когда (When)* - действия
* *То (Then)* - результаты
* *Но (But)*
* *И (And)*

Шаги **Но (But)** и **И (And)** существуют исключительно для удобства чтения и
по своим функциям повторяют ключевое слово, с которого начиналась предыдущая строка.

*Пример*

```gherkin
Scenario: A user attempts to withdraw more money than they have in their account
Given John has a valid Credit or Debit card
And his account balance is $20
When he inserts his card
And withdraws $40
Then the ATM displays an error
And returns his card
But his balance remains $20
```

Шаги должны быть параметризованными, чтобы их можно было повторно использовать.

### 4.4.1. Дано (Given)

***Дано (Given)*** - ключевое слово, предназначенное для описания предусловий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    # шаги сценария
```

Шаг ***Дано (Given)*** приводит систему в желаемое состояние перед тем
как пользователь (или внешняя система) начнет взаимодействие с системой.
Также можно рассматривать их как предусловия.

*Пример*

```gherkin
#language: ru
Дано нет пользователей в базе
Дано база данных пустая
```

### 4.4.2. Когда (When)

***Когда (When)*** - ключевое слово, предназначенное для описания событий или действий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    # шаги сценария
```

Шаг **Когда (When)** изменяет состояние системы путем взаимодействия с системой пользователя (или внешней системы).
Настоятельно рекомендуется использовать только один шаг **Когда (When)** для каждого сценария.

*Пример*

```gherkin
#language: ru
Пример: взаимодействие со страницей
Когда я открыл форму добавления учреждения
Когда я ввел "Институт радости" в поле "Наименование"
Когда я выбрал в поле "Тип" значение "Институт"
Когда я нажал на кнопку "Сохранить"
```

### 4.4.3. Тогда (Then)

***Тогда (Then)*** - ключевое слово, предназначенное для описания ожидаемых результатов.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

Шаг ***Тогда (Then)*** проверяет результирующее состояние системы после выполнения действий.
Проверки результатов должны быть связаны с явной пользой, которая указаны в описании функции.
Также необходимо помнить, что должен проверяться вывод системы (отчеты, интерфейс, сообщения), а не что-то глубоко закопанное в систему.

*Пример*

```gherkin
#language: ru

```

### 4.4.4. И (And), Но (But), * (Asterisk)

Если **Сценарии (Scenario)** есть несколько шагов **Дано (Given)**, **Когда (When)**, или **Тогда (Then)**, то можно писать их так:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
    Дано что-то первое
    Дано что-то второе
    Дано и что-то ещё
    Когда я открою свои глаза
    То я увижу что-то
    То чего-то я не увижу
```  

Или можно использовать шаги **И (And)** и **Но (But)**, превращая **Сценарии (Scenario)** в нечто более читаемое:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
И что-то второе
И и что-то ещё
Когда я открою свои глаза
То я увижу что-то
Но чего-то я не увижу
```

***И (And)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Когда Действие
    И Действие
    Тогда Результат
    И Результат
    # шаги сценария
```

***Но (But)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Но Предусловие
    Когда Действие
    И Действие
    Но Действие
    Тогда Результат
    И Результат
    Но Результат
    # шаги сценария
```

***\* (Asterisk)*** - символ, заменяющий любое ключевое слово обозначающее **Шаг (Step)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    * Предусловие
    * Предусловие
    Когда Действие
    * Действие
    * Действие
    Тогда Результат
    * Результат
    * Результат
    # шаги сценария
```

**\* (Asterisk)** используется для улучшения восприятия текста сценария.

*Пример*

```gherkin
#language: ru

```

## 4.5. Предыстория (Background)

***Предыстория (Background)*** - ключевое слово, предназначенное для добавления определенного
контекста ко всем **Сценариям (Scenario)** в пределах **Функции (Feature)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  
  Подробное описание
  На нескольких строках

  Предыстория: 
    Дано Предусловие
    
  Сценарий: Наименование сценария 1
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария

  Сценарий: Наименование сценария 2
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

В каждой **Функции (Feature)** может быть всего одна **Предыстория (Background)**
и располагается она до первого **Сценария (Scenario)** описанного в **Функции (Feature)**.

Если нужно добавить еще одну **Предыстория (Background)**,
то нужно подумать над разбиением **Функции (Feature)** на части.
Либо же настроить **Хуки (Hooks)** на определенные **Теги (Tags)**,
которыми будут помечены нужные **Сценарии (Scenario)**.

**Предыстория (Background)** по сути, представляет собой **Сценарий (Scenario)** без имени,
состоящий из **Шагов (Steps)**, которые повторно выполняются в каждом **Сценарии (Scenario)** какой-либо **Функции (Feature)**.

Основное отличие в запуске: **Предыстория (Background)** запускается перед каждым **Сценарием (Scenario)**,
но после выполнения любого **Хука (Hooks)** помеченного аннотацией **@Before**.

*Пример*

```gherkin
# language: ru
Функция: поддержка многих справочников

    Предыстория:
        Дано есть пользователь с именем "Вася"
        И есть справочник "Лекарства"
        И у пользователя "Вася" есть право на запись в  "Лекарство"
        И есть справочник "Виды лечений"

    Сценарий: Вася создает новую запись
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Лекарства"
        То мне должен быть ответ "Ваша запись успешно добавлена."

    Сценарий: Вася не может добавлять запись в справочник лечений
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Виды лечений"
        То мне должен быть ответ "У вас нет прав доступа!"
```      

## 4.6. Структура сценария (Scenario outline)

***Структура сценария (Scenario outline)*** - ключевое слово, 
предназначенное для многократного параметризованного выполнения сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  Структура сценария: Наименование сценария
    Дано Предусловие <параметр1>
    Когда Действие <параметр2>
    Тогда Результат <параметр3>

    Примеры:
      | параметр1 | параметр2 | параметр3 |
      | значение1 | значение1 | значение3 |
      | значение2 | значение2 | значение3 |
```

В некоторых случаях может потребоваться протестировать один и тот же сценарий несколько раз,
чтобы выполнить тестовые сценарии с применением техник **Эквивалентного разделения** и **Анализа граничных значений**.

*Пример*

```gherkin
#language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
```

**Структура сценария (Scenario outline)** позволяет более кратко описывать подобные наборы сценариев с помощью заглушек (\< \>).

***Примеры (Examples)*** - ключевое слово, предназначенное для определения значений параметров 
в виде таблицы значений, которые будут подставляться вместо заглушек.

Шаги указанные в **Структуре сценария (Scenario outline)** не выполняются напрямую,
а используются для подстановки в места, обозначенные символами (\< \>) значений из таблицы **Примеров (Examples)**.
Каждая строка таблицы **Примеров (Examples)** будет обрабатываться как отдельный сценарий,
а значения из строки будут подставляться в сценарий вместо заглушек.
Названия колонок должно совпадать с названием заглушек.
Количество строк может быть сколь угодном.

*Пример*

```gherkin
#language: ru
Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

***

# 5. Выражения (Expressions)

***Выражения (Expressions)*** - текст, содержащийся в аннотациях шагов, записанный с применением регулярного выражения или выражения **Cucumber**.

## 5.1. Регулярные выражения (Regular Expression)

***Регулярные выражения (Regular Expressions)*** — используемый в компьютерных программах, работающих с текстом, 
формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов 
(**Символ подстановки (Wildcard Characters)**). 

Для поиска используется строка-образец (**Шаблон (Pattern)**), состоящая из символов и метасимволов и задающая правило поиска. 
Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.

В аннотациях **Шагов (Steps)** то, что в регулярных выражениях записано в скобках передается в метод в виде аргумента.
Фреймворк **Cucumber** самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

*Пример*

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
public void they_have_their_receipt() {
    //code
}
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки)

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки)

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент.

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

## 5.2. Выражения Cucumber (Cucumber Expressions)

***Выражения Cucumber (Cucumber Expressions)*** - специальный формат записи выражений, используемый фреймворком **Cucumber** 
по функциональности похожий на **Регулярные выражения (Regular Expressions)**, но более удобный для восприятия.

По умолчанию фреймворк **Cucumber** воспринимает выражения как **Выражения Cucumber (Cucumber Expressions)**.
Чтобы фреймворк воспринимал их как **Регулярные выражения (Regular Expressions)**, то само выражение должно обрамляться: 
* или символами начала **^** и конца **$** (так называемые **Якоря (Anchors)**)
* или символами **/** в начале и в конце выражения

*Пример*

```java

```

### 5.2.1. Параметры

***Параметры*** - 

Синтаксис:

```java
Текст {параметр}
```

В **Выражения Cucumber (Cucumber Expressions)** можно передавать параметры в методы, на которые мапятся шаги.
***Параметры*** обрамляются в фигурные скобки, с указанием внутри типа.

Типы параметров в **Выражениях Cucumber (Cucumber Expressions)**:

* __{byte}__ - тип **byte / Byte** в Java

Соответствует **127**, **-128**.

* __{short}__ - тип **short / Short** в Java

Соответствует **32_767**, **-32_768**.

* __{int}__ - тип **int / Integer** в Java

Соответствует **2_147_483_647**, **-2_147_483_648**.

* __{long}__ - тип **long / Long** в Java

Соответствует **9_223_372_036_854_775_807**, **–9_223_372_036_854_775_808**.

* __{float}__ - тип **float / Float** в Java

Соответствует **3.6**, **-1.30**.

* __{double}__ - тип **double / Double** в Java

Соответствует **3.6**, **-1.30**.

* __{biginteger}__ - тип **BigInteger** в Java

Соответствует **9_223_372_036_854_775_807**, **–9_223_372_036_854_775_808**.

* __{bigdecimal}__ - тип **BigDecimal** в Java

Соответствует **71.1234567890**, **-10.1234567890**.

* __{word}__ - тип **String** в Java (без пробелов)

Соответствует **banana**, но не **banana split**.

* __{string}__ - тип **String** в Java (с пробелами, но все в кавычках)

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.
В метод будет передан только текст расположенный между парными кавычками.

* __{}__ - анонимный тип

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.

Параметр анонимного типа будет преобразован в тип параметра шага с помощью **Преобразователей объектов (Object Mapper)**.
**Cucumber** имеет встроенные **Преобразователи объектов (Object Mapper)**, которые могут обрабатывать большинство основных типов.
Помимо **Enum**, он поддерживает преобразование в **BigInteger**, **BigDecimal**, **Boolean**, **Byte**, **Short**, **Integer**, **Long**, **Float**, **Double** и **String**.
Для автоматического преобразования в другие типы рекомендуется использовать соответствующие **Преобразователи объектов (Object Mapper)**.

## 5.2.2. Параметры кастомных типов (Custom Parameter Types)

***Параметры кастомных типов*** - классы, помеченные специальной аннотацией, для создания собственных типов данных.

Синтаксис:

```java
@ParameterType("значение1|значение2")   // Регулярное выражение
...
```

**Выражения Cucumber (Cucumber Expressions)** можно расширить, чтобы они автоматически преобразовывали выходные параметры в кастомные типы.

*Пример*

```java
I have a {color} ball
```


```java
@ParameterType("red|blue|yellow") 
public Color color(String color) { // Тип и имя кастомного параметра
    return new Color(color);       
}
```

Список аргументов:

* *name* - имя, по которому тип параметра будет распознаваться
* *regexp* - регулярное выражение, с помощью которого будет сопоставляться параметр

Может включать группы захвата.

* *type* - тип значения возвращаемый методом
* *transformer* - метод, преобразующий совпадение из регулярного выражения

Должен иметь арность 1, если в регулярном выражении нет групп захвата.  
В ином случае арность должна соответствовать количеству групп захвата в регулярном выражении.

* *useForSnippets* - использование типа параметра для создания заглушек для неопределенных шагов

Если регулярное выражение часто совпадает с текстом, который не будет использоваться в качестве аргументов, 
то нужно отключить его использование для создания заглушек неопределенных шагов установив значение в **false**.
По умолчанию **true**.  

* *preferForRegexpMatch* - приоритет соответствия регулярному выражению

Если есть определения шагов, в которых используются регулярные выражения, и нужно, 
чтобы этот тип параметра имел приоритет над другими типами во время сопоставления, то нужно установить значение в **true**.
По умолчанию - **false**. 

## 5.2.3. Опциональный текст (Optional text)

***Опциональный текст (Optional text)*** - необязательный фрагмент текста, который может присутствовать в **Выражении Cucumber (Cucumber Expressions)**.

Синтаксис:

```java
Текст(необязательный текст)
```

**Опциональный текст (Optional text)** обрамляется в круглые скобки.
В регулярных выражениях круглые скобки обозначают группу захвата, 
но в **Выражении Cucumber (Cucumber Expressions)** они означают необязательный текст.

*Пример*

Грамматически неправильно говорить 1 огурцы, поэтому мы должны сделать множественное число необязательным.

```java
I have {int} cucumber(s) in my belly
```        

```java
I have 1 cucumber in my belly
```        

```java
I have 42 cucumbers in my belly
```

### 5.2.4. Альтернативный текст (Alternative text)

***Альтернативный текст (Alternative text)*** обязательный фрагмент текста, который может иметь значение на выбор из заданных вариантов. 

Синтаксис:

```java
Текст/альтернативный текст
```

**Альтернативный текст (Alternative text)** задается перечислением через слеш, без пробелов.
**Альтернативный текст (Alternative text)** работает только тогда, когда между альтернативными частями нет пробелов.

*Пример*

```java
I have {int} cucumber(s) in my belly/stomach
```

```java
I have 42 cucumbers in my belly
I have 42 cucumbers in my stomach
```


### 5.2.5. Экранирование (Escaping)

***Escape последовательности (Escape Sequence)*** - сочетание символов, состоящее из обратной косой черты *\\*,
за которой следует символ.

**Escape последовательности (Escape Sequence)** используется экранирования символов **\**, **(**, **{** или 
для представления знака новой строки, одиночной кавычки или некоторых других символов в символьной константе.

**Escape последовательности (Escape Sequence)** рассматривается как один символ и, следовательно, 
является допустимой символьной константой.

Если нужно будет использовать **()** или **{}**, можно экранировать символ **(** или **{** с помощью обратной косой черты.

*Пример*

```java
I have {int} \{what} cucumber(s) in my belly \(amazing!)
```

```gherkin
I have 1 {what} cucumber in my belly (amazing!)
I have 42 {what} cucumbers in my belly (amazing!)
```

Если нужно будет использовать **\\**, можно экранировать символ **\\** с помощью обратной косой черты.

*Пример*

```java
I have {int} \\{what} cucumber(s) in my belly \\(amazing!)
```

```gherkin
I have 1 \{what} cucumber in my belly \(amazing!)
I have 42 \{what} cucumbers in my belly \(amazing!)
```

В настоящее время нет возможности экранировать символ /.
Он всегда будет интерпретироваться как **Альтернативный текст (Alternative text)**.

***

# 6. Передача данных в шаги

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций.
Для подобной задачи в **Cucumber** есть несколько решений.

## 6.1. Данные перечисленные через запятую

Данные, перечисленные через запятую, **Cucumber** может обернуть в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## 6.2. Данные в виде таблицы с одной колонкой

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## 6.3. Данные в виде таблицы с двумя колонками

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в **Map**,
где данные из первой колонки – это ключи, а из второй – значения.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```

## 6.4. Данные в виде таблицы с множеством колонок (Data Tables)

***Таблицы данных (Data Tables)*** - конструкция для передачи списков данных в методы.

Синтаксис:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

[DataTable](https://github.com/cucumber/cucumber-jvm/tree/main/datatable)

***DataTable*** – класс, который эмулирует табличное представление данных. 

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    // что-то сделать
}
```

Для доступа к данным в **DataTable** имеется большое количество методов.

### 6.4.1. Преобразование таблицы в список ассоциативных массивов

```java
public <K,V> List<Map<K,V>> asMaps(Class<K> keyType,Class<V> valueType)
```

Конвертирует таблицу в список ассоциативных массивов. 
Первая строка таблицы используется для именования ключей, остальные как значения.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Название      | Доступен | Количество подменю |
| Файл          | true     | 5                  |
| Редактировать | false    | 8                  |
| О программе   | true     | 2                  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<Map<String, String>> table = arg.asMaps(String.class, String.class);
    System.out.println(table.get(0).get("Название"));
    System.out.println(table.get(1).get("Название"));
    System.out.println(table.get(2).get("Название"));
}
```

Данный пример выведет на консоль:

```text
Файл
Редактировать
О программе
```


### 6.4.2. Преобразование таблицы в список списков

```java
public <T> List<List<T>> asLists(Class<T> itemType)
```

Метод преобразует таблицу в список списков.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<List<String>> table = arg.asLists(String.class);
    
    System.out.print(table.get(0).get(0) + " ");
    System.out.print(table.get(0).get(1) + " ");
    System.out.println(table.get(0).get(2) + " ");
    
    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

На консоль будет выведено:

```text
Файл true 5
Редактировать false 8
```

### 6.4.3. Преобразование таблицы в список списков строк

```java
public List<List<String>> cells(int firstRow)
```

Этот метод делает то же, что и предыдущий метод, за исключением того, 
что нельзя определить какого типа данные находятся в таблице, всегда возвращает список строк – List. 
В качестве аргумента метод принимает номер первой строки:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<List<String>> table = arg.cells(1);
    
    System.out.print(table.get(0).get(0) + " ");
    System.out.print(table.get(0).get(1) + " ");
    System.out.println(table.get(0).get(2) + " ");
    
    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

Метод выведет на консоль:

```text
Редактировать false 8
О программе true 2
```

### 6.4.4. Экранирование (Table Cell Escaping)

Экранирование:

* **\n** - перевод на новую строку
* **\|** - вертикальная черта
* **\\** - обратный слэш

## 6.5. Использование классов 

Фреймворк **Cucumber** может создать объекты из табличных данных, переданных из сценария. 

Существует два способа это сделать.

### 6.5.1. Наименование полей класса в первой строке

Фреймворк **Cucumber** создает связанный список объектов из таблицы с тремя колонками. 
В первой строке таблицы должны быть указаны наименования полей класса, создаваемого объекта. 
Если какое-то поле не указать, оно не будет инициализировано.


*Пример*

```java
public class Menu {
    private String title;
    private boolean isAvailable;
    private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

```gherkin
# language: ru
Дано в меню доступны пункты
| title         | isAvailable | subMenuCount |
| Файл          | true        | 5            |
| Редактировать | false       | 8            |
| О программе   | true        | 2            |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<Menu> arg) {
    for (int i = 0; i < arg.size(); i++) {
        System.out.print(arg.get(i).getTitle() + " ");
        System.out.print(Boolean.toString(arg.get(i).getAvailable()) + " ");
        System.out.println(Integer.toString(arg.get(i).getSubMenuCount()));
    }
}
```

Вывод в консоль:

```text
Файл true 5
Редактировать false 8
О программе true 2
```

### 6.5.2. Наименование полей класса в первом столбце 

Фреймворк **Cucumber** создает связанный список объектов, но, в данном случае, 
наименования полей записывается в первой колонке таблицы.


*Пример*

```java
public class Menu {
    private String title;
    private boolean isAvailable;
    private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

```gherkin
# language: ru
Дано в меню доступны пункты
| title        | Файл | Редактировать | О программе |
| isAvailable  | true | false         | true        |
| subMenuCount | 5    | 8             | 2           |
```

А в аргументе описания шага используем аннотацию **@Transpose**.

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(@Transpose List<Menu> arg) {
    // что-то сделать
}
```

## 6.6. Докстринг (Doc Strings)

***Докстринг (Doc Strings)*** - текст экранированный тремя двойными кавычками.

Синтаксис:

```gherkin
# language: ru

"""
Текст
"""
```
Для передачи многострочных данных в аргумент метода, их необходимо экранировать тремя двойными кавычками.

```gherkin
# language: ru
Тогда отображается форма с текстом

"""
На ваш номер телефона был выслан одноразовый пароль.
Для подтверждения платежа необходимо ввести полученный
одноразовый пароль.
"""
```

В реализации шага нет необходимости находить **Докстринг (Doc Strings)** с помощью шаблона.
Он будет автоматически передан в качестве последнего аргумента в определении шага.
Данные в метод приходят в виде объекта класса **String**:

```java
@Тогда("^отображается форма с текстом$")
public void отображаетсяФормаСТекстом(String expectedText) {
// что-то сделать
}
```

***

# 7. Преобразование данных

Фреймворк самостоятельно приводит данные из сценария к типу данных, указанному в аргументе метода. 
Если это невозможно, то выбрасывает исключение ConversionException. 
Это справедливо и для классов Date и Calendar. 

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04.05.2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Все прекрасно сработало, **Cucumber** преобразовал *04.05.2017* 
в объект класса **Date** со значением *Thu May 04 00:00:00 EET 2017*.

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Дойдя до этого шага, **Cucumber** выбросил исключение:

```text
cucumber.deps.com.thoughtworks.xstream.converters.ConversionException: Couldn't convert "04-05-2017" to an instance of: [class java.util.Date]

```

Почему первый пример сработал, а второй нет?

Дело в том, что в **Cucumber** встроена поддержка форматов дат чувствительных к текущей локали. 
Если необходимо записать дату в формате, отличающемся от формата текущей локали, нужно использовать аннотацию **Format**:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (@Format("dd-MM-yyyy") Date arg) {
// что-то сделать
}
```

***

# 8. Лучшие практики

## 8.1. Советы

1. Ваши сценарии BDD должны меняться только при изменении требований, 
а не при изменении реализации (т.е. ваши сценарии BDD должны управлять реализацией, а не наоборот)

2. Если вы чувствуете необходимость добавить что-то еще, обычно это знак того, что вам следует разбить сценарий на несколько сценариев.
Постарайтесь придумать примеры, которые не предполагают никаких предположений о технологиях или пользовательском интерфейсе.
Представьте себе 1922 год, когда не было компьютеров. Детали реализации должны быть скрыты в определениях шагов.

3. Каждый сценарий должен выполняться отдельно. Каждая функция должна выполняться одновременно 

4. Информация о шагах должна отображаться независимо. 
Создавайте модульные и простые для понимания шаги.

5. Попробуйте совместить все ваши распространенные сценарии.

6. Не используйте Background для настройки сложных состояний, 
если только это состояние действительно не является чем-то, что нужно знать клиенту.
Например, если имена пользователя и сайта не имеют значения для клиента, используйте шаг более высокого уровня, 
такой как «Учитывая, что я вошел в систему как владелец сайта». 

7. Сделайте свой раздел Background коротким.
Клиент должен помнить об этом при чтении сценариев. 
Если Фон имеет длину более 4 строк, подумайте о переносе некоторых не относящихся к делу деталей на этапы более высокого уровня. 

8. Сделайте Background раздел ярким.
Используйте красочные имена и постарайтесь рассказать историю. 
Человеческий мозг гораздо лучше отслеживает истории, 
чем имена вроде «Пользователь А», «Пользователь Б», «Сайт 1» и т. Д.
Сценарии должны быть краткими, и их не должно быть слишком много.
Если раздел Background переместился за пределы экрана, у читателя больше не будет полного обзора того, что происходит. 
Подумайте об использовании шагов более высокого уровня или о разделении файла * .feature.

9. Подумайте дважды, прежде чем использовать хук Before
Все, что происходит в хуке Before, невидимо для людей, которые только читают функции.
Вам следует рассмотреть возможность использования Background как более явной альтернативы,
особенно если установка должна быть доступна для чтения нетехническим людям.
Используйте хук Before только для низкоуровневой логики, такой как запуск браузера или удаление данных из базы данных.

[Best Practices & Guidelines for BDD](https://www.oditeksolutions.com/best-practices-guidelines-for-bdd/)

[Behavior-Driven Development: Pros and Cons, Implementation, and Best Practices](https://www.altexsoft.com/blog/behavior-driven-development/)

## 8.2. Анти паттерны

[Инструмент Cucumber и анти-паттерны: Перевод статьи Томаса Сандберга](https://blog.unusual-concepts.ru/2019/04/05/cucumber/)

[Cucumber Anti-Patterns: Thomas Sundberg — 2016-06-22](http://www.thinkcode.se/blog/2016/06/22/cucumber-antipatterns)

[Паттерны и антипаттерны Cucumber BDD](https://habr.com/ru/company/clrium/blog/281643/)

[Cucumber anti-patterns (part one)](https://medium.com/@cucumberbdd/cucumber-anti-patterns-part-one-7ca25cc49426)

[Cucumber anti-patterns (part two)](https://medium.com/@cucumberbdd/cucumber-anti-patterns-part-two-6f0b021c71fa)

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)