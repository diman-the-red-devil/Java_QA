Java_QA / 11. Паттерны

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* []()
* []()
* []()
  * []()
  * []()
  * []()
  * []()
  * []()
    * []()
      * []()
      * []()
      * 
***

# 1. Простой Java Объект (Plain Old Java Object (POJO))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Простой Java Объект (Plain Old Java Object (POJO))*** - простой **Java** класс без ссылок на какие-либо 
конкретные фреймворки, не унаследованный от какого-то класса и не реализующий никаких интерфейсов сверх тех, 
которые нужны для бизнес-модели.

То есть это такой класс, который не связан какими-либо особыми ограничениями, кроме тех, что налагаются спецификацией **Java**.

![Простой Java Объект (Plain Old Java Object (POJO))](./_Files/1.%20Patterns/03.jpg "Простой Java Объект (Plain Old Java Object (POJO))")

Понятие **Простой Java Объект (Plain Old Java Object (POJO))** означает использование настолько простых классов 
насколько возможно для моделирования предметной области. Этот класс может использоваться в любом коде на **Java**, 
поскольку он не привязан к какой-либо структуре.

## 1.1. Структура класса

1. *Класс*

Класс **Простой Java Объект (Plain Old Java Object (POJO))**:

* **НЕ** должен расширять заранее заданные классы

Открытый класс, который расширяет **javax.servlet.http.HttpServlet**
**НЕ** является **Простым Java Объектом (Plain Old Java Object (POJO))**.

* **НЕ** должен реализовывать заранее заданные интерфейсы

Открытый класс, который реализует **javax.ejb.EntityBean**
**НЕ** является **Простым Java Объектом (Plain Old Java Object (POJO))**.

* **НЕ** должен содержать предварительно определенные аннотации

Открытый класс, который содержит аннотацию **@javax.persistence.Entity**
**НЕ** является **Простым Java Объектом (Plain Old Java Object (POJO))**.

2. *Поля класса*
   
Поля класса **Простой Java Объект (Plain Old Java Object (POJO))** могут иметь любые уровни доступа:

* **public** - общедоступные
* **private** - закрытые
* **default** - по умолчанию
* **protected** - защищенные

У класса **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для полей.

3. *Методы доступа класса*

Методы доступа класса **Простой Java Объект (Plain Old Java Object (POJO))** могут иметь любые уровни доступа:

* **public** - общедоступные
* **private** - закрытые
* **default** - по умолчанию
* **protected** - защищенные

*Сеттеры*

У класса **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для сеттеров.

*Геттеры*

У класса **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для геттеров.

4. *Конструктор класса*

В класс **Простой Java Объект (Plain Old Java Object (POJO))** нет необходимости добавлять специальный конструктор.
Есть конструктор по умолчанию.

5. *Переопределенные методы equals(), hashCode() и toString()*

Переопределение этих методов поможет при использовании класса **Простой Java Объект (Plain Old Java Object (POJO))** 
с различными классами коллекций **Java**.

*Пример*

```java
// Класс, который не расширяет классы, не реализует интерфейсы, не содержит аннотации  
public class EmployeePojo {
    // Поля класса с разными уровнями доступа
    public String firstName;
    public String lastName;
    private LocalDate startDate;

    // Конструктор класса с параметрами
    public EmployeePojo(String firstName, String lastName, LocalDate startDate) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.startDate = startDate;
    }

    // Методы класса
    public String name() {
        return this.firstName + " " + this.lastName;
    }

    public LocalDate getStart() {
        return this.startDate;
    }
}
```

## 1.2. Шаги реализации

1. *Создание класса, который не наследуется от какого-либо класса и не реализует какого-либо интерфейса*
2. *Создание полей класса*
3. *Создание методов доступа класса*
4. *Создание конструктора класса*
5. *Переопределение методов equals(), hashCode() и toString()*

## 1.3. Применимость

1. *Когда нет необходимости накладывать ограничения на поля класса*
  
Применение **Простого Java Объекта (Plain Old Java Object (POJO))**
не налагает каких либо ограничений на поля, и может дать полный доступ к ним.

## 1.4. Плюсы и минусы применения 

### 1.4.1. Плюсы применения паттерна

Плюсы применения **Простого Java Объекта (Plain Old Java Object (POJO))**:

* повышение читабельности
* возможность повторного использования
* упрощенное тестирование

### 1.4.2. Минусы применения паттерна

Минусы применения **Простого Java Объекта (Plain Old Java Object (POJO))**:

* отсутствие соглашения об именовании

Из-за отсутствия соглашений об именовании классы **Простой Java Объект (Plain Old Java Object (POJO))**: 

* могут быть трудными для понимания другими программистами
* могут работать некорректно при анализе с использованием **Reflection API**

## 1.5. Применение в автотестах

### 1.5.1. UI автотесты с POM + PE + AAA + Matchers + POJO

#### 1.5.1.1. До применения паттерна

1. *Базовывй класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

2. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
  
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        tbxLogin().setValue(login);
        tbxPassword().setValue(password);
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin(login, password)

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

#### 1.5.1.2. После применения паттерна

1. *Класс учетных данных - AccountPOJO*

*Пример*

```java
// Учетные данные
public class AccountPOJO {
    // Логин
    public String login;
    // Пароль
    public String password;

    // Конструктор
    public AccountPOJO(String login, String password) {
        this.login = login;
        this.password = password;
    }

    // Получение значения логина
    public String login() {
        return this.login;
    }

    // Получение значения пароля
    public String password() {
        return this.password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
  
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountPOJO accountPOJO) {
        tbxLogin().setValue(accountPOJO.login());
        tbxPassword().setValue(accountPOJO.password());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountPOJO accountPOJO = new AccountPOJO(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountPOJO);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountPOJO accountPOJO) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountPOJO);
    }
    ...
}
```

***

# 2. Java Боб (JavaBean)

***Java Боб (JavaBean)*** - класс в **Java**, особый тип **Простого Java Объекта (Plain Old Java Object (POJO))** со строгим набором соглашений.

![Java Боб (JavaBean)](./_Files/1.%20Patterns/04.jpg "Java Боб (JavaBean)")

Все классы **Java Боб (JavaBean)** являются классами **Простой Java Объект (Plain Old Java Object (POJO))**, 
но не все классы **Простой Java Объект (Plain Old Java Object (POJO))** можно назвать классами **Java Боб (JavaBean)**.

Чтобы исправить некоторые проблемы классов **Простой Java Объект (Plain Old Java Object (POJO))**, 
классы **Java Боб (JavaBean)** должны следовать некоторым стандартным правилам и соглашениям.

## 2.1. Структура класса

1. *Класс*

Класс **Java Боб (JavaBean)** должен быть сериализуемыми (то есть реализовывать интерфейс **java.io.Serializable**).
Реализация интерфейса **java.io.Serializable** позволяет хранить состояние в виде **JSON** или **XML** объектов.

2. *Поля класса*

Поля класса **Java Боб (JavaBean)** должны иметь уровни доступа **private** (закрытые).
Закрытость полей класса защищает их от случайного изменения.

3. *Методы доступа класса*

Методы доступа класса **Java Боб (JavaBean)** должны быть **public** (общедоступные).
Геттеры и сеттеры обеспечивают ограничение неконтролируемого доступа к полям класса.

*Сеттеры*

Соглашения:

* имена методов - *setX* (X - имя поля класса)
* уровень доступа - *public*
* тип возврата - *void*
* метод должен принимать параметр

*Геттеры*

Соглашения:

* имена методов 
  * в случае не логического возвращаемого значения - *getX* (X - имя поля класса) 
  * в случае логического возвращаемого значения - *isX* (X - имя поля класса) 
* уровень доступа - *public*
* тип возврата - любой, но не *void*
* метод 
  * в случае простого поля - не должен принимать параметр 
  * в случае поля коллекции - может принимать параметр индекс 

Префиксы в наименовании методов облегчают понимание назначения методов.

4. *Конструктор класса*

У класса **Java Боб (JavaBean)** должен быть конструктор без аргументов (конструктор по умолчанию).
Конструктор по умолчанию нужен для того, чтобы экземпляр класса можно было создать без предоставления аргументов.
Например, во время десериализации **JSON** объекта.

5. *Переопределенные методы equals(), hashCode() и toString()*

*Пример*

```java
// Класс, который реализует интерфейс Serializable
public class EmployeeBean implements Serializable {
    // Поля класса с уровнями доступа private
    private static final long serialVersionUID = -3760445487636086034L;
    private String firstName;
    private String lastName;
    private LocalDate startDate;

    // Конструктор класса без параметров
    public EmployeeBean() {
    }
    
    // Конструктор класса с параметрами
    public EmployeeBean(String firstName, String lastName, LocalDate startDate) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.startDate = startDate;
    }

    // Методы класса
    // Геттер 
    public String getFirstName() {
        return firstName;
    }
    
    // Сеттер
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}
```

## 2.2. Шаги реализации

1. *Создание класса, который реализует интерфейс java.io.Serializable*
2. *Создание закрытых полей класса*
3. *Создание общедоступных методов доступа класса*
4. *Создание конструктора класса без аргументов*
5. *Переопределение методов equals(), hashCode() и toString()*

## 2.3. Применимость

1. *Когда необходимо наличие стандартизированного класса*

Для работы некоторых библиотек (сериализации, рефлексии) нужны классы отвечающие требованиям **Java Боб (JavaBean)**.

## 2.4. Плюсы и минусы применения 

### 2.4.1. Плюсы применения паттерна

Плюсы применения **Java Боб (JavaBean)**:

* наличие соглашений по именованию, устраняющее минусы **Простого Java Объекта (Plain Old Java Object (POJO))**
* множество инструментов использующих спецификацию **JavaBeans**:
  * инструменты для создания на основе объектов **JavaBeans** данных определенного типа (**XML**, **JSON**, **CSV**, **DDL** и т д)
  * инструменты для чтения, управления, сопоставления объектов **JavaBeans** (**BeanUtils**, **Dozer**, **EZMorph** и т д)
  * фреймворки (MVC / ORM), которые работают с **JavaBeans** (**JPA**, **Hibernate**, **JSF**, **Spring** и т д)

### 2.4.2. Минусы применения паттерна

Минусы применения **Java Боб (JavaBean)**:

* обязательное наличие сеттеров и геттеров, даже если этого не требуется 
* все поля класса изменяемы из-за наличия обязательных методов установки (сеттеров)
* обязательное наличие конструктора класса по умолчанию

## 2.5. Применение в автотестах

### 2.5.1. UI автотесты с POM + PE + AAA + Matchers + JB

#### 2.5.1.1. До применения паттерна

1. *Класс учетных данных - AccountPOJO*

*Пример*

```java
// Учетные данные
public class AccountPOJO {
    // Логин
    public String login;
    // Пароль
    public String password;

    // Конструктор
    public AccountPOJO(String login, String password) {
        this.login = login;
        this.password = password;
    }

    // Получение значения логина
    public String login() {
        return this.login;
    }

    // Получение значения пароля
    public String password() {
        return this.password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }
    
    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountPOJO accountPOJO) {
        tbxLogin().setValue(accountPOJO.login());
        tbxPassword().setValue(accountPOJO.password());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountPOJO accountPOJO = new AccountPOJO(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountPOJO);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountPOJO accountPOJO) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountPOJO);
    }
    ...
}
```

#### 2.5.1.2. После применения паттерна

1. *Класс учетных данных - AccountJB*

*Пример*

```java
// Учетные данные
public class AccountJB implements Serializable {
    // Поля
    // Логин
    private String login;
    // Пароль
    private String password;
  
    // Конструктор
    public AccountJB(String login, String password) {
        this.login = login;
        this.password = password;
    }
  
    // Конструктор без параметров
    public AccountJB() {
  
    }
  
    // Геттеры и Сеттеры
    public String getLogin() {
        return this.login;
    }
  
    public void setLogin(String login) {
        this.login = login;
    }
  
    public String getPassword() {
        return this.password;
    }
  
    public void setPassword(String password) {
        this.password = password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountJB accountJB) {
        tbxLogin().setValue(accountJB.getLogin());
        tbxPassword().setValue(accountJB.getPassword());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountJB accountJB = new AccountJB(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountJB);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountJB accountJB) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountJB);
    }
    ...
}
```

***

# 3. Объект Значение (Value Object (VO))

***Объект Значение (Value Object (VO))*** ⎼ класс в **Java**, 
который идентифицируется по уникальности значения полей класса (**структурная эквивалентность**).

![Объект Значение (Value Object (VO))](./_Files/1.%20Patterns/05.png "Объект Значение (Value Object (VO))")

***Ссылочная эквивалентность*** - равенство двух объектов в случае, если оба объекта ссылаются на один и тот же объект в куче.

![Ссылочная эквивалентность](./_Files/1.%20Patterns/06.png "Ссылочная эквивалентность")

***Структурная эквивалентность*** - равенство двух объектов в случае, если у обоих объектов все поля полностью эквивалентны.
То есть, если два экземпляра одного класса обладают одинаковым набором свойств (полей), то они равны.

![Структурная эквивалентность](./_Files/1.%20Patterns/07.png "Структурная эквивалентность")

## 3.1. Структура класса

1. *Класс*
   
Класс **Объект Значение (Value Object (VO))**:

* представляет логически целостные объекты, для которых нет готовых стандартных типов 

Примером класса **Объект Значение (Value Object (VO))** могут быть даты, время, деньги.

* НЕ обладает неотъемлемой идентичностью, то есть идентифицируется по уникальности значения полей класса (**структурная эквивалентность**), 
  а не уникальности значения идентификатора (**эквивалентность идентификаторов**)

Два объекта класса **Объект Значение (Value Object (VO))** считаются равными, если значения всех их полей равны.

* НЕ является самостоятельной сущностью, а представляет *кирпичики* для построения сущностей

Объект класса **Объект Значение (Value Object (VO))** не может существовать сам по себе, то есть они всегда должны принадлежать одной или нескольким сущностям.
Данные, которые представляет собой **Объект Значение (Value Object (VO))**, имеют значение только в контексте какой-либо сущности.

Объект класса **Объект Значение (Value Object (VO))** не должны иметь собственной таблицы в базе данных.

* обладает нулевым жизненным циклом

Объекты класса **Объект Значение (Value Object (VO))** с легкостью создаются и уничтожаются. 
Это следствие, логично вытекающее из того, что они взаимозаменяемы.
Важны не объекты, а важны их значения. Объект здесь служит лишь способом организации кода, 
но он никак не идентифицирует хранящиеся внутри него данные.

Например, если есть 1 рубль, то все равно та же ли это монета, что была вчера.
До тех пор, пока эта монета является монетой ценностью в 1 рубль, ее можно заменить другой, точно такой же.
Концепция денег в таком случае является **объектом значением**. То же самое можно сказать и про многое другое 
(адреса доставки, страна проживания, путь до файла, адрес страницы сайта, точки на плоскости).

2. *Поля класса*

Поля класса **Объект Значение (Value Object (VO))**:

* состоят из 
  * примитивных типов данных 
  * объектов класса **Объект Значение (Value Object (VO))**
* НЕ имеют поля идентификатор
* являются неизменяемыми

Если необходимо изменить объект, то создается новый объект на основе имеющегося, вместо того чтобы изменять существующий.

* проверяются на действительность при создании

Если одно из полей недействительно, то объект не должен создаваться и должна возникать ошибка или исключение.

Например, если есть класс Age (возраст), то не имеет смысла создавать экземпляр класс Age с отрицательным значением.
В **Java** можно выбросить исключение **IllegalArgumentException** или любое другое созданное исключение.

3. *Методы доступа класса*

*Сеттеры*

У класса **Объект Значение (Value Object (VO))** отсутствуют сеттеры.
Это следствие неизменяемости полей классов.

*Геттеры*

Геттеры класса **Объект Значение (Value Object (VO))** должны возвращать неизменяемые объекты или копии.

4. *Конструктор класса*

Так как объекты класса **Объект Значение (Value Object (VO))** неизменяемые, 
то их можно создать только одним способом - инициализацией в конструкторе.

5. *Переопределенные методы equals(), hashCode() и toString()*

Метод **equals()** должен сравнивать объекты по значениям их полей.

*Пример*

```java
class Money implements Serializable {
    int value;
    String currency;

    public Money(int value, String currency) {
        this.value = value;
        this.currency = currency;
    }

    int getValue() {
        return value;
    }

    String getCurrency() {
        return currency;
    }

    public boolean equals(Money m) {
        return value == m.value and currency == m.currency;
    }
}
```

## 3.2. Шаги реализации

1. *Создание класса, моделирующего объекты, которые идентифицируется по уникальности значения полей*
2. *Создание закрытых полей класса, представленных примитивными типами данных и/или объектами-значениями*
3. *Создание общедоступных методов доступа класса, состоящих только из геттеров*
4. *Создание конструктора класса*
5. *Переопределение методов equals(), hashCode() и toString()*

## 3.3. Применимость паттерна

1. *Когда есть объекты, равенство которых определяется по значениям полей*

Данные объекты делаются неизменяемыми, т.е. чтобы после создания объекта значения его полей не изменялись.
Такие объекты можно передавать в виде значения, а не в виде ссылки на объект.
Два объекта считаются равными, если равны значения их полей. 
Обычно изменение полей объекта подразумевает полную замену старого объекта новым.

## 3.4. Плюсы и минусы применения

### 3.4.1. Плюсы применения паттерна

Плюсы применения **Объект Значение (Value Object (VO))**:

* уменьшение примитивной одержимости

***Примитивная одержимость (Primitive Obsession)*** - использование примитивов для хранения данных или в качестве параметров. 

*Пример*

Использование **String** для хранения адреса электронной почты, **double** для веса или **float** для расстояния.
Обычно это происходит потому, что создание нового класса только для хранения этого атрибута кажется излишним.

```java
String email;
double weight;
float distance;
```

* безопасность типов

Неправильная единица измерения

*Пример*

Есть следующее поле:

```java
private float distance;
```

Возможно, это расстояние в дюймах, а может, в метрах. Конечно, всегда можно назвать это **distanceInMeters**.
Теперь допустим что нужно расстояние в дюймах где-то еще в коде. Нужно будет преобразовать это расстояние перед его использованием.
Где должен быть этот код преобразования? В служебном классе? В статическом методе?
Что, если удалить этот код преобразования перед использованием расстояния?
Код все равно будет компилироваться, но будет использоваться неправильная единица измерения!
Такая ошибка может быть серьезной и может стоить компании больших денег.
Можно снизить этот риск, используя вместо этого **объект значение** Distance.

В этом случае мы бы просто сохранили Distance и больше не заботились о том, в какой единице она была создана. 
Этот класс теперь также содержит всю логику преобразования, и можно легко получить расстояние в любой единице, благодаря геттерам.

Смешивание параметров

*Пример*

Например, следующий метод:

```java
void sendEmail (String email, String тема, String body);
```

Очень легко перепутать параметры и назвать это так:

```java
sendEmail ("Некоторая тема", "Некоторое содержание", "john@doe.com");
```

Это кажется глупой ошибкой, но это может произойти при невнимательности. К сожалению, компилятор здесь не поможет.
Что произойдет, если будет необходимо отправлять составной контент? 
Или если нужно отправить электронное письмо нескольким получателям? 
Тогда нужно будет перегружать метод для каждого нового случая.

Используя **объекты значения** вместо примитивов, можно было бы получить следующее:

```java
sendEmail (адрес электронной почты получателя, тема темы, содержимое содержимого);
```

Инвертировать параметры будет невозможно, так как компилятор обнаружит ошибки. 
Тем не менее все равно нужно перегрузить метод, если понадобиться иметь 
возможность отправлять электронное письмо нескольким получателям. 
Это можно исправить, проделав еще один шаг:

```java
sendEmail (электронная почта);
```

Этот способ читать намного проще, чем первый метод. У него также есть еще одно преимущество - гибкость.

* гибкость

Продолжая предыдущий пример, теперь, когда у есть класс электронной почты, можно изменить его, чтобы он мог обрабатывать 
несколько получателей или разные типы контента без необходимости возвращаться и снова изменять сигнатуру метода.

* самопроверка

**Объект значение** должен быть действительным и неизменяемым. 
Благодаря чему, можно перестать задаваться вопросом, нужно ли проверять параметр или нет.

Если повторно использовать пример **sendEmail**, нужно будет убедиться, что адрес электронной почты действителен. 
Где это делать? Возможно, в самом методе? Почему нет. Но что, если нужно использовать электронную почту в другом месте? 
А что, если кто-то уже подтвердил электронное письмо перед вызовом метода **sendEmail**? Повсюду бы дублировался проверочный код! 
Что, если кто-то тем временем решит изменить значение электронного письма? Затем нужно будет снова его проверить.

Нет разумного места, куда поместить код проверки, и нет гарантии, что параметр допустимый.
Однако с **объектом значения** гарантируется, что он действителен, иначе он просто не существовал бы. 
Код проверки, также находится там, где должен, внутри самого объекта. 
Только этот объект должен знать, действителен он или нет.

* уменьшение дублирования

Вместо того чтобы иметь одну и ту же группу атрибутов в отдельных классах, можно вместо этого создать общий **объект значения**. 
Одним из примеров этого может быть **объект значение** адреса, который может совместно использоваться сотрудниками и офисами, 
вместо дублирования полей адреса в каждом классе. Повторное использование **объектов значений** среди сущностей или 
других **объектов значений** - хороший способ уменьшить дублирование.

* улучшение читабельности

Используя **объекты значения**, не нужно гадать, что значат переменные на самом деле. 
Вместо **List<String>** может быть **List<PhoneNumber>**. Больше не нужно беспокоиться о внутренних представлениях, 
а вместо этого думать о концепциях предметной области. Код намного выразительнее.
Кроме того, **объекты значения** централизуют логику связанной предметной области, что упрощает поиск и изменение.

* улучшение производительности

**Объекты значения** неизменяемы и поэтому могут использоваться в распараллеленном коде без риска. 
Если многие объекты используют один и тот же **объект значение** с одним и тем же значением, 
можно использовать паттерн **Легковес (Flyweight)**, разделяя один и тот же экземпляр для всех объектов. 
Так как важны только атрибуты, а не то, какой экземпляр используется.

### 3.4.2. Минусы применения паттерна

Минусы применения паттерна **Объект Значение (Value Object (VO))**:

* дополнительные классы
* увеличение объема кода

## 3.5. Применение в автотестах

### 3.5.1. UI автотесты с POM + PE + AAA + Matchers + JB + VO

#### 3.5.1.1. До применения паттерна

1. *Класс учетных данных - AccountJB*

*Пример*

```java
// Учетные данные
public class AccountJB implements Serializable {
    // Поля
    // Логин
    private String login;
    // Пароль
    private String password;
  
    // Конструктор
    public AccountJB(String login, String password) {
        this.login = login;
        this.password = password;
    }
  
    // Конструктор без параметров
    public AccountJB() {
  
    }
  
    // Геттеры и Сеттеры
    public String getLogin() {
        return this.login;
    }
  
    public void setLogin(String login) {
        this.login = login;
    }
  
    public String getPassword() {
        return this.password;
    }
  
    public void setPassword(String password) {
        this.password = password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountJB accountJB) {
        tbxLogin().setValue(accountJB.getLogin());
        tbxPassword().setValue(accountJB.getPassword());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountJB accountJB = new AccountJB(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountJB);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountJB accountJB) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountJB);
    }
    ...
}
```

#### 3.5.1.2. После применения паттерна

1. *Класс - Login*

*Пример*

```java
// Логин
public class Login implements Serializable {
    // Поле 
    private String login;
  
    // Конструктор
    public Login(String login) {
        if (!login.isBlank() && !login.isEmpty())
            this.login = login;
        else
            throw new IllegalArgumentException("Логин не может быть пустым!");
    }
  
    // Геттер
    public String getLogin() {
        return this.login;
    }
}
```

2. *Класс - Password*

*Пример*

```java
// Пароль
public class Password implements Serializable {
    // Поле
    private String password;
    
    // Конструктор
    public Password(String password) {
        if (!password.isBlank() && !password.isEmpty())
            this.password = password;
        else
            throw new IllegalArgumentException("Пароль не можеь быть пустым");
    }
    
    // Геттер
    public String getPassword() {
        return this.password;
    }
}
```

3. *Класс - FullName*

*Пример*

```java
// ФИО
public class FullName implements Serializable {
    // Поля
    private String fullName;
    private String firstName;
    private String secondName;
    private String lastName;
  
    // Конструктор
    public FullName(String fullName) {
        if (!fullName.isBlank() && !fullName.isEmpty()) {
            this.fullName = fullName;
            String[] names = fullName.split(" ");
            if (names.length == 3) {
                firstName = names[0];
                secondName = names[1];
                lastName = names[2];
            } 
            else
                throw new IllegalArgumentException("ФИО задано некорректно!");
        }
        else
          throw new IllegalArgumentException("ФИО не можеь быть пустым!");
    }
  
    // Геттеры
    public String getFullName() {
        return this.fullName;
    }
  
    public String getFirstName() {
        return this.firstName;
    }
  
    public String getSecondName() {
        return this.secondName;
    }
  
    public String getLastName() {
        return this.lastName;
    }
}
```

4. *Класс - MobilePhone*

*Пример*

```java
// Номер мобильного телефона
public class MobilePhone implements Serializable {
    // Поле
    private String mobilePhone;
  
    // Конструктор
    public MobilePhone(String mobilePhone) {
        if (!mobilePhone.isBlank() && !mobilePhone.isEmpty())
            this.mobilePhone = mobilePhone;
        else
            throw new IllegalArgumentException("Номер мобильного не можеь быть пустым");
    }
  
    // Геттер
    public String getMobilePhone() {
        return this.mobilePhone;
    }
}
```

5. *Класс учетных данных - Account*

*Пример*

```java
// Учетные данные
public class Account implements Serializable {
    // Поля
    private Login login;
    private Password password;
    private MobilePhone mobilePhone;
    private FullName fullName;
    private Date dateOfBirth;
  
    // Конструктор без параметров
    public Account() {
  
    }
  
    // Конструктор 
    public Account(Login login, Password password) {
        this.login = login;
        this.password = password;
    }
  
    // Геттеры и сеттеры
    public void setLogin(Login login) {
        this.login = login;
    }
  
    public Login getLogin() {
        return this.login;
    }
  
    public void setPassword(Password password) {
        this.password = password;
    }
  
    public Password getPassword() {
        return this.password;
    }
  
    public void setMobilePhone(MobilePhone mobilePhone) {
        this.mobilePhone = mobilePhone;
    }
  
    public MobilePhone getMobilePhone() {
        return this.mobilePhone;
    }
  
    public void setFullName(FullName fullName) {
        this.fullName = fullName;
    }
  
    public FullName getFullName() {
        return this.fullName;
    }
  
    public void setDateOfBirth(Date dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
    }
  
    public Date getDateOfBirth() {
         return this.dateOfBirth;
    }
}
```

6. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

7. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }
    
    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
  
    // Конструктор с логином и паролем
    public HomePage loginValidUser(Account account) {
        tbxLogin().setValue(account.getLogin().getLogin());
        tbxPassword().setValue(account.getPassword().getPassword());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

8. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login), 
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

# 6. Паттерн Простая Фабрика (SimpleFactory)

***Простая Фабрика (SimpleFactory)*** - паттерн, который создает экземпляр класса, скрывая детали по его созданию.

![Паттерн Простая Фабрика (Simple Factory)](./_Files/1.%20Patterns/12.jpg "Паттерн Простая Фабрика (Factory)")

## 6.1. Структура паттерна

![Структура паттерна Простая Фабрика (Simple Factory)](./_Files/1.%20Patterns/13.png "Структура паттерна Простая Фабрика (Simple Factory)")

1. *Базовый продукт (Product)*

***Базовый продукт (Product)*** - общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных продуктов (ConcreteProduct)**.

2. *Конкретный продукт (ConcreteProduct)* - конкретный класс со своей бизнес логикой, 
реализующий **Базовый продукт (Product)**, который будет создан **Простой фабрикой (SimpleFactory)**.

3. *Простая фабрика (SimpleFactory)*

***Простая фабрика (SimpleFactory)*** - класс, который содержит статический метод по созданию всех 
**Конкретных продуктов (ConcreteProduct)**.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вызывает статический метод **Простой фабрики (SimpleFactory)**, 
чтобы создать **Конкретный продукт (ConcreteProduct)**.

## 6.2. Шаги реализации паттерна

1. *Проверка наличия в задаче множества классов реализующих один интерфейс*

2. *Создание Базового продукта*

Базовый продукт описывает общие методы для всех продуктов.

3. *Создание Конкретных продуктов*

Конкретные продукты реализует свою логику.

4. *Создание Простой фабрики*

Простая фабрика создает продукты.

## 6.3. Применимость паттерна

1. *Когда нужно создавать однотипные объекты*
2. *Когда нужно вынести логику по созданию объектов*

## 6.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Простая Фабрика (Factory)**:

* скрытие логики по созданию от клиента

Минусы применения паттерна **Простая Фабрика (Factory)**:

* при добавлении новых типов конкретных продуктов метод по созданию может стать очень громоздким
* нет контроля за процессом создания объектов 

## 6.5. Применение паттерна в автотестах

### 6.5.1. Фабрика драйверов (WebDriverFactory)

#### До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    // Драйвер браузера
    protected static WebDriver driver;
    // Логгер
    private Logger logger = LogManager.getLogger(WithoutPOJOTest.class);
  
    // Перед каждым тестом
    @BeforeEach
    public void setUp() {
        // Получаем параметр запуска тестов через Maven -Dbrowser
        String browser = System
                .getProperty("browser", "chrome")
                .toLowerCase();
        // Получаем экземпляр драйвера браузера
        switch(browser) {
            case "chrome":
                driver = new ChromeDriver();
            case "firefox":
                driver = new FirefoxDriver();
            case "edge":
                driver = new EdgeDriver();
        }
        logger.info("Драйвер стартовал!");
        driver.get("https://github.com/login");
    }
  
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
  
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

#### После применения паттерна

1. *Перечисление наименований браузеров - BrowserName*

*Пример*

```java
// Имена браузеров
public enum BrowserName {
    CHROME("chrome"),   // Google Chrome
    FIREFOX("firefox"), // Mozilla Firefox
    EDGE("edge");       // Microsoft Edge

    private String browserName; // Имя браузера

    // Приватный конструктор
    private BrowserName(String browserName) {
        this.browserName = browserName;
    }

    // Переопределенный метод toString()
    @Override
    public String toString() {
        return String.valueOf(this.browserName);
    }

    // Возврат константы по строковому значению константы
    public static BrowserName fromString(String browserName) {
        if (browserName != null) {
            for(BrowserName b : BrowserName.values()) {
                if (browserName.equalsIgnoreCase(b.browserName)) {
                    return b;
                }
            }
        }
        return null;
    }

    // Получение имени браузера
    public String getBrowserName() {
        return this.browserName;
    }
}
```

2. *Класс создания драйвера браузера "Google Chrome" - ChromeBrowser*

*Пример*

```java
// Драйвера браузера "Google Chrome"
public class ChromeBrowser {
    // Получение экземпляра драйвера браузера "Google Chrome"
    public static WebDriver getDriver() {
        // Настройка файла драйвера
        WebDriverManager.chromedriver().setup();
    
        // Опции драйвера:
        ChromeOptions options = new ChromeOptions();
        // - поведение при появлении алертов "Игнорирование"
        options.setCapability(CapabilityType.UNEXPECTED_ALERT_BEHAVIOUR, UnexpectedAlertBehaviour.IGNORE);
        // - стратегия загрузки страницы "NORMAL"
        options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.NORMAL);
        // - режим "Инкогнито"
        options.addArguments("--incognito");
        // - режим "Полный экран"
        options.addArguments("--start-fullscreen");
    
        // Новый экземпляр драйвера
        return new ChromeDriver(options);
    }
}
```

3. *Класс создания драйвера браузера "Mozilla Firefox" - FirefoxBrowser*

*Пример*

```java
// Драйвера браузера "Mozilla Firefox"
public class FirefoxBrowser {
    // Получение экземпляра драйвера браузера "Mozilla Firefox"
    public static WebDriver getDriver() {
        // Настройка файла драйвера
        WebDriverManager.firefoxdriver().setup();
    
        // Опции драйвера:
        FirefoxOptions options = new FirefoxOptions();
        // - поведение при появлении алертов "Игнорирование"
        options.setCapability(CapabilityType.UNEXPECTED_ALERT_BEHAVIOUR, UnexpectedAlertBehaviour.IGNORE);
        // - стратегия загрузки страницы "NORMAL"
        options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.NORMAL);
        // - режим "Инкогнито"
        options.addArguments("-private");
        // - режим "Полный экран"
        options.addArguments("-kiosk");
    
        // Новый экземпляр драйвера
        return new FirefoxDriver(options);
    }
}
```

4. *Класс создания драйвера браузера "Microsoft Edge" - EdgeBrowser*

*Пример*

```java
// Драйвера браузера "Microsoft Edge"
public class EdgeBrowser {
    // Получение экземпляра драйвера браузера "Microsoft Edge"
    public static WebDriver getDriver() {
        // Настройка файла драйвера
        WebDriverManager.edgedriver().setup();
    
        // Опции драйвера:
        EdgeOptions options = new EdgeOptions();
        // - поведение при появлении алертов "Игнорирование"
        options.setCapability(CapabilityType.UNEXPECTED_ALERT_BEHAVIOUR, UnexpectedAlertBehaviour.IGNORE);
        // - стратегия загрузки страницы "NORMAL"
        options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.NORMAL);
        // - режим "Инкогнито"
        options.addArguments("--incognito");
        // - режим "Полный экран"
        options.addArguments("--start-fullscreen");
    
        // Новый экземпляр драйвера
        return new EdgeDriver(options);
    }
}
```

5. *Класс фабрика по созданию экземпляров драйвера браузера - WebDriverFactory*

*Пример*

```java
// Фабрика по созданию экземпляров драйвера браузера
public class WebDriverFactory {
    // Логгер
    private static Logger logger = LogManager.getLogger(WebDriverFactory.class);
  
    // Получение экземпляра драйвера по имени
    public static WebDriver getDriver(BrowserName name) {
        switch (name) {
            // Драйвер браузера Google Chrome
            case CHROME:
                logger.info("Драйвер браузера Google Chrome");
                return ChromeBrowser.getDriver();
            // Драйвер браузера Mozilla Firefox
            case FIREFOX:
                logger.info("Драйвер браузера Mozilla Firefox");
                return FirefoxBrowser.getDriver();
            // Драйвер браузера Microsoft Edge
            case EDGE:
                logger.info("Драйвер браузера Microsoft Edge");
                return EdgeBrowser.getDriver();
            // По умолчанию
            default:
                throw new RuntimeException("Некорректное наименование браузера");
        }
    }
}
```

6. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    // Драйвер браузера
    protected static WebDriver driver;
    // Логгер
    private Logger logger = LogManager.getLogger(LoginTest.class);
  
    // Перед каждым тестом
    @BeforeEach
    public void setUp() {
        // Получаем параметр запуска тестов через Maven -Dbrowser
        String browser = System
                .getProperty("browser", "chrome")
                .toLowerCase();
        // Получаем экземпляр драйвера браузера
        driver = WebDriverFactory.getDriver(browser);
        logger.info("Драйвер стартовал!");
        driver.get("https://github.com/login");
    }
  
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
  
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

#### 3.1.5.2. Фабрика страниц (PageFactory)

##### До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    // Драйвер браузера
    protected static WebDriver driver;
    // Логгер
    private Logger logger = LogManager.getLogger(LoginTest.class);
  
    // Перед каждым тестом
    @BeforeEach
    public void setUp() {
        // Получаем параметр запуска тестов через Maven -Dbrowser
        String browser = System
                .getProperty("browser", "chrome")
                .toLowerCase();
        // Получаем экземпляр драйвера браузера
        driver = WebDriverFactory.getDriver(browser);
        logger.info("Драйвер стартовал!");
        driver.get("https://github.com/login");
    }
  
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
  
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

##### После применения паттерна

1. *Перечисление наименований страниц - PageName*

*Пример*

```java
// Имена страниц (пейдж обджектов)
public enum PageName {
    HOME_PAGE("Страница \"Home\""),
    SIGN_IN_PAGE("Страница \"Sign In\"");

    private String pageName; // Имя страницы (пейдж обджекта)

    // Приватный конструктор
    private PageName(String pageName) {
        this.pageName = pageName;
    }

    // Переопределенный метод toString()
    @Override
    public String toString() {
        return String.valueOf(this.pageName);
    }

    // Возврат константы по строковому значению константы
    public static PageName fromString(String pageName) {
        if (pageName != null) {
            for(PageName p : PageName.values()) {
                if (pageName.equalsIgnoreCase(p.pageName)) {
                    return p;
                }
            }
        }
        return null;
    }

    // Получение имени страницы (пейдж обджекта)
    public String getPageName() {
        return this.pageName;
    }
}
```

2. *Класс фабрика по созданию экземпляров страниц (пейдж обджектов) - PageFactory*

*Пример*

```java
// Фабрика по созданию экземпляров страниц (пейдж обджектов)
public class PageFactory {
    // Логгер
    private static Logger logger = LogManager.getLogger(PageFactory.class);

    // Получение экземпляра страницы (пейдж обджекта)
    public static BasePage getPage(WebDriver driver, PageName name) {
        switch (name) {
            // Стартовая "Home"
            case HOME_PAGE:
                logger.info("Страница \"Home\"");
                HomePage homePage = new HomePage(driver);
                // Инициализация некоторых элементов страницы
                return homePage;
            // Страница "Sign In"
            case SIGN_IN_PAGE:
                logger.info("Страница \"Sign In\"");
                SignInPage signInPage = new SignInPage(driver);
                // Инициализация некоторых элементов страницы
                return signInPage;
            // По умолчанию
            default:
                throw new RuntimeException("Некорректное наименование страницы (пейдж обджекта)");
        }
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    // Драйвер браузера
    protected static WebDriver driver;
    // Логгер
    private Logger logger = LogManager.getLogger(LoginTest.class);
  
    // Перед каждым тестом
    @BeforeEach
    public void setUp() {
        // Получаем параметр запуска тестов через Maven -Dbrowser
        String browser = System
                .getProperty("browser", "chrome")
                .toLowerCase();
        // Получаем экземпляр драйвера браузера
        driver = WebDriverFactory.getDriver(browser);
        logger.info("Драйвер стартовал!");
        driver.get("https://github.com/login");
    }
  
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
  
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = (SignInPage) PageFactory.getPage(driver, PageName.SIGN_IN_PAGE);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

***

# 3. Паттерн Строитель (Builder)

***Строитель (Builder)*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

![Паттерн Строитель (Builder)](./_Files/1.%20Patterns/16.jpg "Паттерн Строитель (Builder)")

Паттерн **Строитель (Builder)** предлагает:

* вынести конструирование объекта за пределы его собственного класса, 
поручив это дело отдельным объектам, называемым строителями.

* разбить процесс конструирования объекта на отдельные шаги 

Чтобы создать объект, нужно поочерёдно вызывать методы строителя. 
Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.
Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов.

## 3.1. Структура паттерна

![Структура паттерна Строитель (Builder)](./_Files/1.%20Patterns/17.jpg "Паттерн Строитель (Builder)")

1. *Продукт (Product)*

***Продукт (Product)*** - класс создаваемого объекта.

Продукты, сделанные разными строителями, не обязаны иметь общий интерфейс.

2. *Базовый строитель (Builder)*

***Базовый строитель (Builder)*** - общий интерфейс / абстрактный класс, описывающий шаги конструирования продуктов, 
общие для всех строителей

3. *Конкретный строитель (ConcreteBuilder)*

***Конкретный строитель (ConcreteBuilder)*** - класс, реализующий Базовый строитель

Конкретные строители могут производить разнородные объекты, не имеющие общего интерфейса.

4. *Директор (Director)*

***Директор (Director)*** - класс определяющий порядок вызова шагов строителей.

Отдельный класс директора не является строго обязательным. 
Можно вызывать методы строителя и напрямую из клиентского кода. 
Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов, 
отличающихся порядком и наличием шагов конструирования. 
В этом случае вы сможете объединить всю эту логику в одном классе.

5. *Клиент*

***Клиент*** - класс, который создает продукты с помощью строителей.

## 3.2. Шаги реализации паттерна

1. *Создание класса Продукт(Product)*
2. *Создание интерфейса Базовый строитель (Builder)*
3. *Создание классов Конкретный строитель (ConcreteBuilder)*
4. *Создание класса Директор (Director)*

## 3.3. Применимость паттерна

1. *Когда вы хотите избавиться от «телескопического конструктора»*

Допустим, у вас есть один конструктор с десятью опциональными параметрами. 
Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. 
Всё, что они делают — это переадресуют вызов к базовому конструктору, 
подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.

Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны. 
А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и 
с помощью современных IDE подсказок более интуитивно понятным.

2. *Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома*

Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, 
которые отличаются в деталях.

Интерфейс строителей определит все возможные этапы конструирования. 
Каждому представлению будет соответствовать собственный класс-строитель. 
А порядок этапов строительства будет задавать класс-директор.

3. *Когда вам нужно собирать сложные составные объекты*

Строитель конструирует объекты пошагово, а не за один проход. 
Более того, шаги строительства можно выполнять рекурсивно. 
А без этого не построить древовидную структуру, вроде Компоновщика.

Заметьте, что Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту, 
пока тот не будет полностью готов. Это предохраняет клиентский код от получения незаконченных «битых» объектов.

## 3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Строитель (Builder)**:

* позволяет создавать продукты пошагово
* позволяет использовать один и тот же код для создания различных продуктов
* изолирует сложный код сборки продукта от его основной бизнес-логики

Минусы применения паттерна **Строитель (Builder)**:

* усложняет код программы из-за введения дополнительных классов
* клиент будет привязан к конкретным классам строителей, 
так как в интерфейсе директора может не быть метода получения результата

## 3.5. Применение паттерна в автотестах

### 3.5.1. UI автотесты с POM + PE + AAA + Matchers + JB + VO + Builder

#### До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

#### После применения паттерна

1. *Класс строитель - AccountBuilder*

```java
// Класс строитель
public class AccountBuilder {
    // Поля
    private Login login;
    private Password password;
    private MobilePhone mobilePhone;
    private FullName fullName;
    private Date dateOfBirth;

    // Конструктор
    public AccountBuilder(Login login, Password password) {
        this.login = login;
        this.password = password;
    }

    // Методы установки
    public AccountBuilder setMobilePhone(MobilePhone mobilePhone) {
        this.mobilePhone = mobilePhone;
        return this;
    }

    public AccountBuilder setFullName(FullName fullName) {
        this.fullName = fullName;
        return this;
    }

    public AccountBuilder setDateOfBirth(Date dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
        return this;
    }

    // Метод построения объекта
    public Account build() {
        Account account = new Account(this.login, this.password);
        account.setMobilePhone(this.mobilePhone);
        account.setFullName(this.fullName);
        account.setDateOfBirth(this.dateOfBirth);
        return account;
    }
}
```

2. *Класс с тестами - LoginTest*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        String mobilePhone = "89037568552";
        String fullName = "Diman The Red Devil";
        String dateOfBirth = "10-10-1980";
  
        AccountBuilder accountBuilder = new AccountBuilder(
                new Login(login),
                new Password(password))
                .setMobilePhone(new MobilePhone(mobilePhone))
                .setFullName(new FullName(fullName))
                .setDateOfBirth(new Date(dateOfBirth));
        Account account = accountBuilder.build();
  
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

***

# 4. Паттерн Одиночка (Singleton)

***Одиночка (Singleton)*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

![Паттерн Одиночка (Singleton)](./_Files/1.%20Patterns/18.jpg "Паттерн Одиночка (Singleton)")

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод,
который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

## 4.1. Структура паттерна

![Структура паттерна Одиночка (Singleton)](./_Files/1.%20Patterns/19.jpg "Паттерн Одиночка (Singleton)")

1. *Одиночка (Singleton)*

***Одиночка (Singleton)*** - класс определяющий статический метод **getInstance**,
который возвращает единственный экземпляр своего класса.

Конструктор **Одиночки (Singleton)** должен быть скрыт от клиентов.
Вызов метода **getInstance** должен стать единственным способом получить объект этого класса.

## 4.2. Шаги реализации паттерна

1. *Добавление в класс приватного статического поля, содержащее одиночный объект*
2. *Создание статического метода для получения одиночного объекта*
3. *Добавление ленивой инициализации в метод для получения одиночного объекта*
4. *Создание приавтного конструктора*
5. *Вызов в клиентском коде метода получения одиночного объекта*

## 4.3. Применимость паттерна

1. *В программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам*

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода.
Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

2. *Больше контроля над глобальными переменными*

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса,
поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек,
поменяв код в одном месте (метод **getInstance**).

## 4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Одиночка (Singleton)**:

* гарантия наличие единственного экземпляра класса
* предоставление к единственному экземпляру класса глобальной точки доступа
* реализация отложенной инициализацию объекта-одиночки

Минусы применения паттерна **Одиночка (Singleton)**:

* нарушение принципа единственной ответственности класса
* маскирование плохого дизайна
* проблемы многопоточности
* требование постоянного создания Mock-объектов при юнит-тестировании.

## 4.5. Применение паттерна в автотестах

### 4.5.1. Передача тестовых данных в автотестах

#### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

#### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja

***

# 1. Паттерн Декоратор (Decorator)

***Декоратор (Decorator)*** - паттерн, который позволяет динамически добавлять объектам новую функциональность.
Декораторы предоставляют гибкую альтернативу подклассам для расширения функциональности.

![Паттерн Декоратор (Decorator)](./_Files/1.%20Patterns/21.jpg "Паттерн Декоратор (Decorator)")

Паттерн **Декоратор (Decorator)** имеет альтернативное название — **Обёртка**.
Оно более точно описывает суть паттерна: целевой объект-оригинал помещается в другой объект-обёртку,
который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы,
с каким объектом работать — оригиналом или обёрткой.
Вы можете использовать несколько разных обёрток одновременно —
результат будет иметь объединённое поведение всех обёрток сразу.

Пример использования паттерна в библиотеке **Selenium** - **EventFiringDecorator** и **FieldDecorator**.

## 1.1. Структура паттерна

![Структура паттерна  Декоратор (Decorator)](./_Files/1.%20Patterns/22.jpg "Паттерн Декоратор (Decorator)")

1. *Базовый компонент (Component)*

***Базовый компонент (Component)*** – общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных компонентов (ConcreteComponent)** и **Базового декоратора (Decorator)**.

2. *Конкретный компонент (ConcreteComponent)*

***Конкретный компонент (ConcreteComponent)*** – конкретный класс со своей бизнес логикой, реализующий **Базовый компонент (Component)**,
функциональность которого необходимо модифицировать декораторами.

Декоратор способен работать как с самим исходным компонентом, так и его наследниками.
Однако, не следует использовать большое количество декораторов с тяжеловесными классами,
так как это может повлечь за собой большие накладные расходы.

3. *Базовый декоратор (Decorator)*

***Базовый декоратор (Decorator)*** – базовый класс для всех декораторов, реализующий **Базовый компонент (Component)** и
хранящий ссылку на экземпляр **Конкретного компонента (ConcreteComponent)**.

**Базовый декоратор (Decorator)** реализует тот же самый интерфейс чтобы:

* замещать конкретный компонент
* создавать цепочку декораторов

4. *Конкретный декоратор (ConcreteDecorator)*

***Конкретный декоратор (ConcreteDecorator)*** - конкретный класс, наследующий **Базовый декоратор (Decorator)** и
добавляющий определенные функции компоненту.

Добавление новой функциональности осуществляется подменой экземпляра оригинального компонента.
Такой объект может использоваться как вместо декорируемого компонента, так и самостоятельно.

**Конкретный декоратор (ConcreteDecorator)**:

* создает механизм подключения и хранения компонента
* реализует переадресацию всех методов и свойств
* добавляет новые свойства и методы

## 1.2. Шаги реализации паттерна

1. *Проверка наличия в задаче одного основного компонента и нескольких дополнительных опциональных дополнений или надстроек над ним*

2. *Создание Базового компонента*

Базовый компонент описывает общие методы как для основного компонента, так и для его дополнений.

3. *Создание Конкретного компонента*

Конкретный компонент содержит основную бизнес-логику.

4. *Создание Базового декоратора*

Базовый декоратор имеет поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора делегируют действие вложенному объекту.

5. *Создание Конкретных декораторов*

Конкретный декоратор выполняет свою добавочную функцию,
а затем (или перед этим) вызывает эту же операцию обёрнутого объекта.

## 1.3. Применимость паттерна

1. *Реализация множественного наследования*

В таких языках как **Java** и **C#** нет множественного наследования классов.
И когда требуется реализовать множество различных функциональностей и их комбинаций,
то для каждой такой функциональности и их комбинаций придется наследовать отдельный класс.
Структура классов при этом может очень сильно разрастись, что в свою очередь усложнит ее понимание и поддержку.

Применение паттерна **Декоратор (Decorator)** позволяет реализовать аналог множественного наследования, в языках его не поддерживающих,
путем вложения одного декоратора в другой и создания из них цепочек, поскольку паттерн реализует интерфейс исходного компонента.
Таким образом у объектов расширяются возможности без использования одиночного наследования.
Что в свою очередь разрешает проблему усложнения структуры классов путем уменьшения числа создаваемых классов
по сравнению с результатами использования одиночного наследования.

2. *Невозможность расширить обязанности объекта с помощью наследования*

Во многих языках программирования есть ключевое слово, с помощью которого можно заблокировать наследование класса.

Применение паттерна **Декоратор (Decorator)** позволяет добавить функциональность классу,
определение которого может быть скрыто или иным образом недоступно для подклассов, то есть когда наследование невозможно.

3. *Динамическое добавление новых возможностей на лету, незаметно для кода, который их использует*

Применение паттерна **Декоратор (Decorator)** обеспечивает динамическое добавление объекту новых функциональных возможностей.
Объекты помещаются в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс,
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

Позволяет комбинировать классы в процессе выполнения программы. дважды применить один и тот же Декоратор.

## 1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Декоратор (Decorator)**:

* большая гибкость, чем у наследования
* добавление обязанности на лету
* добавление нескольких новых обязанностей сразу
* изменение функциональности не только применением самих Декораторов, но и различным порядком их вложенности

Минусы применения паттерна **Декоратор (Decorator)**:

* трудность конфигурирования многократно обёрнутых объектов
* обилие крошечных классов
* несколько мелких объектов вместо одного объекта на все случаи жизни

## 1.5. Применение паттерна в автотестах

### 1.5.1. Декоратор WebElement

#### До применения паттерна

Страница (Page Objects)

*Пример*

```java

```

Интерфейс **WebElement** не всегда удобно использовать.
Его невозможно расширить и добавить свои методы для работы с элементом.
Использовать свои методы можно только создавая классы-обвертки(CheckBox, Button и т.п.),
которые просто делегируют вызов методов настоящему **WebElement**.

#### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

### 4.1.5.2. Декоратор Page object

#### До применения паттерна



#### После применения паттерна



## 2. Паттерн Заместитель (Proxy)

***Заместитель (Proxy)*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заместители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

![Паттерн Заместитель (Proxy)](./_Files/1.%20Patterns/23.jpg "Паттерн Заместитель (Proxy)")

Паттерн **Заместитель (Proxy)** предлагает создать новый объект-заместитель, имеющий тот же интерфейс, что и оригинальный объект.
Ни интерфейс ни функциональность замещенного объекта, с точки зрения клиента, не изменяются.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр оригинального объекта и
переадресовывал бы ему всю реальную работу.

### 4.2.1. Структура паттерна

![Структура паттерна Заместитель (Proxy)](./_Files/1.%20Patterns/24.jpg "Структура паттерна Заместитель (Proxy)")

1. *Базовый объект (Subject)*

***Базовый объект (Subject)*** – общий интерфейс / абстрактный класс для всех замещаемых объектов и заместителей.

Конкретная реализация скрыта от **Заместителя (Proxy)** и он может работать практически со всеми **Реальными объектами (RealSubject)**,
поддерживающими данный интерфейс.

2. *Реальный объект (RealSubject)*

***Реальный объект (RealSubject)*** – конкретный класс с полезной бизнес логикой, реализующий **Базовый объект (Subject)**,
который будет замещен **Заместителем**.

3. *Заместитель (Proxy)*

***Заместитель (Proxy)*** - класс, реализующий **Базовый объект (Subject)**, который замещает **Конкретный объект (RealSubject)** и перехватывает обращения к нему.

**Заместитель (Proxy)** :

* выполняет дополнительные действия (инициализацию, логирование и т д.) до или после вызова вложенного в него **Конкретного объекта (RealSubject)**
* отвечает за создание и удаление **Конкретного объекта (RealSubject)**.

Паттерн не накладывает ограничения на вложения одного заместителя в другой.
Такой подход позволяет строить их различные конфигурации в процессе работы программы.

### 4.2.2. Шаги реализации паттерна

1. *Определение интерфейса, который бы сделал заместитель и оригинальный объект взаимозаменяемыми*

2. *Создание Заместителя*

Заместитель должен содержать ссылку на оригинальный объект. Чаще всего, оригинальный объект создаётся самим заместителем.
В редких случаях заместитель получает готовый оригинальный объект от клиента через конструктор.

3. *Реализация методов Заместителя в зависимости от его предназначения*

В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос оригинальному объекту.

4. *Создание Фабрики*

Фабрика будет решать, какой из объектов создавать — заместитель или оригинальный объект.

5 *Реализация ленивой инициализации оригинального объекта*

При первом обращении клиента к методам заместителя.

### 4.2.3. Применимость паттерна

1. *Ленивая инициализация (Виртуальный Прокси (Virtual Proxy))*

Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда,
когда он действительно понадобится.

2. *Защита доступа (Защищающий Прокси (Protection Proxy))*

Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа.
Например, если ваши объекты — это важная часть операционной системы,
а пользователи — сторонние программы (хорошие или вредоносные).

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. *Локальный запуск сервиса (Удаленный Прокси (Remote Proxy))*

Когда настоящий сервисный объект находится на удалённом сервере.
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. *Логирование запросов (Логирующий Прокси (Logging Proxy))*

Когда требуется хранить историю обращений к сервисному объекту.
Заместитель может сохранять историю обращения клиента к сервисному объекту.

5. *Кеширование объектов (Умная Ссылка (Smart Reference))*

Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.
Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными.
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект.
Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

### 4.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Заместитель (Proxy)**:

* контроль оригинального объекта незаметно для клиента
* возможность работы, даже если оригинальный объект ещё не создан
* возможность контроля жизненного цикла служебного объекта

Минусы применения паттерна **Заместитель (Proxy)**:

* усложнение кода программы из-за введения дополнительных классов
* увеличение времени отклика от сервиса

### 4.2.5. Применение паттерна в автотестах

#### 4.2.5.1. Создание заместителя для WebDriver в UI автотестах Selenium WebDriver

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

# 3. Паттерн Фасад (Facade)

***Фасад (Facade)*** — паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

![Паттерн Фасад (Facade)](./_Files/1.%20Patterns/25.jpg "Паттерн Фасад (Facade)")

**Фасад (Facade)** - простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь,
используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.
То есть содержит интерфейс, содержащий только методы для решения определённой задачи или
предоставляющий определённую абстракцию исходной системы.

## 3.1. Структура паттерна

![Структура паттерна Фасад (Facade)](./_Files/1.%20Patterns/26.jpg "Структура паттерна Фасад (Facade)")

1. *Подсистема (Subsystem)*

***Подсистема (Subsystem)*** - подсистема из множества разнообразных классов.

Нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее, чтобы заставить ее классы что-то делать.

2. *Фасад (Facade)*

***Фасад (Facade)*** - класс, который предоставляет быстрый доступ к определённой функциональности подсистемы.

Фасад выполняет:

* переадресацию запросов классам подсистемы

Классы подсистемы не знают о существовании Фасада и работают друг с другом напрямую.

* уменьшение числа параметров методов подстановкой заранее определенных значений

Часть исходных методов и свойств будут недоступны через Фасад, т.к. не играют роли для решения поставленной задачи

* создание новых методов, которые объединяют вызовы объектов подсистемы и/или добавляют свою логику

Фасад не является суммой всех методов объектов, входящих в систему.
Создание такой обобщенной версии приведет к появлению **божественного объекта**,
то есть интерфейса с огромным числом методов, без четко выраженной цели и порождающего большое количество зависимостей.
В итоге – прямо противоположный паттерну результат.

Дополнительный фасад можно ввести, чтобы не захламлять единственный фасад разнородной функциональностью.
Он может использоваться как клиентом, так и другими фасадами.

3. *Клиент (Client)*

***Клиент (Client)*** - класс, который использует фасад вместо прямой работы с объектами сложной подсистемы.

## 3.2. Шаги реализации паттерна

1. *Определение возможности создания более простого интерфейса, чем тот который предоставляется сложная подсистема*

Этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.

2. *Создание фасада, реализующего интерфейс подсистемы*

Фасад переадресовывает вызовы клиента нужным объектам подсистемы.

Фасад заботиться о том, чтобы правильно инициализировать объекты подсистемы

3. *Внедерение дополнительных фасадов*

## 3.3. Применимость паттерна

1. *Предоставление простого или урезанного интерфейса к сложной подсистеме*

Часто подсистемы усложняются по мере развития программы.
Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды,
но вместе с тем, применять подсистему без настройки становится труднее.
Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

2. *Разложение подсистемы на отдельные слои*

Фасады используются для определения точек входа на каждый уровень подсистемы.
Если подсистемы зависят друг от друга, то зависимость можно упростить,
разрешив подсистемам обмениваться информацией только через фасады.

## 3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Фасад (Facade)**:

* упрощает взаимодействие клиента с подсистемами
* изолирует клиентов от компонентов сложной подсистемы
* уменьшает зависимости клиентского кода от внутренней работы системы.

Минусы применения паттерна **Фасад (Facade)**:

* фасад рискует стать божественным объектом, привязанным ко всем классам программы

## 3.5. Применение в автотестах

### 3.5.1. Скрытие технических деталей прохождения UI теста

#### До применения паттерна

*Пример*

```java

```

#### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

# 4. Паттерн Легковес (Flyweight / Object Pool)

***Легковес (Flyweight / Object Pool)*** - паттерн, который позволяет вместить большее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой (внутреннее и внешнее),
вместо хранения одинаковых данных в каждом объекте.

![Паттерн Легковес (Flyweight / Object Pool)](./_Files/1.%20Patterns/27.jpg "Паттерн Легковес (Flyweight / Object Pool)")

***Внутреннее состояние*** - неизменяемые данные, которые хранятся в легковесном объекте и не используются за пределами объекта.
Внутреннее состояние не зависит от контекста, в котором используется объект-легковес.

***Внешнее состояние*** - изменяющиеся данные, которые не хранятся в легковесном объекте и используются за пределами объекта.
Внешнее состояние зависит от контекста. Клиенты несут ответственность за переход во внешнее состояние.

Паттерн **Легковес (Flyweight / Object Pool)** предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием,
а оно имеет не так много вариаций.

## 4.1. Структура паттерна

![Структура паттерна Легковес (Flyweight / Object Pool)](./_Files/1.%20Patterns/28.jpg "Структура паттерна Легковес (Flyweight / Object Pool)")

1. *Базовый легковес (Flyweight)*

***Базовый легковес (Flyweight)*** - интерфейс, общий для всех легковесов,
через который легковесы могут получать внешнее состояние или воздействовать на него.

2. *Конкретный легковес (ConcreteFlyweight)*

***Конкретный легковес (ConcreteFlyweight)*** - класс, который реализует **Базовый легковес (Flyweight)**
и добавляет хранилище для внутреннего состояния, если оно есть.

**Конкретный легковес (ConcreteFlyweight)** содержит состояние, которое повторялось во множестве первоначальных объектов.
Один и тот же легковес можно использовать в связке со множеством контекстов.

**Контекст**:

* содержит внешнюю часть состояния, уникальную для каждого объекта
* связан с одним из легковесов, хранящих внутреннюю часть состояния

3. *Фабрика легковесов (FlyweightFactory)*

***Фабрика легковесов (FlyweightFactory)*** - класс, который управляет созданием и повторным использованием легковесов.

Клиент должен запрашивать из фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
Фабрика легковесов получает запросы, в которых указано желаемое состояние легковеса.
Все созданные раннее легковесы хранятся в пуле. Если легковес с таким состоянием уже создан,
фабрика легковесов сразу его возвращает из пула, а если нет — создаёт новый объект, помещает его в пул и возвращает клиенту.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вычисляет или хранит контекст, то есть внешнее состояние легковесов.

Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.

## 4.2. Шаги реализации паттерна

1. *Разделение полей класса, который станет легковесом на две части: внутреннее и внешнее состояние*

2. *Создание фабрики, которая будет кешировать и повторно отдавать уже созданные объекты*

3. *Хранение или вычисление значения внешнего состояния (контекст) клиентом и передача его в методы объекта легковеса*

## 4.3. Применимость паттерна

1. *Большое количество однообразных объектов*

При использовании большого количества однообразных объектов происходит выделение
большого количества памяти для поддержки всех нужных объектов.
Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.

В зависимости от сложности структуры, хранящей разделяемые объекты, особенно если имеется большое количество легковесов,
то может увеличиваться время на поиск нужного легковеса.

## 4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Легковес (Flyweight / Object Pool)**:

* экономия оперативной памяти

Минусы применения паттерна **Легковес (Flyweight / Object Pool)**:

* расход процессорного времени на поиск/вычисление контекста
* усложнение кода программы из-за введения множества дополнительных классов

## 4.5. Применение паттерна в автотестах

### 4.5.1. Пул страниц

Не нужно ждать, пока откроется нужная страница, если все тесты начинаются с одной страницы.
Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать,
пока тест не обнаружит его в готовом к использованию состоянии.

#### До применения паттерна

*Пример*

```java

```

#### После применения паттерна

*Пример*

```java

```

### 4.5.2. Пул тестовых данных

#### До применения паттерна

*Пример*

```java

```

#### После применения паттерна

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

***

# 1. Паттерн Цепочка обязанностей (Chain of Invocations / Fluent)

***Цепочка обязанностей (Chain of Invocations / Fluent)*** - паттерн, который позволяет передавать запросы 
последовательно по цепочке обработчиков. Каждый последующий обработчик решает, 
может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

![Паттерн Цепочка обязанностей (Chain of Invocations / Fluent)](./_Files/1.%20Patterns/30.jpg "Цепочка обязанностей (Chain of Invocations / Fluent)")

Паттерн **Цепочка обязанностей (Chain of Invocations / Fluent)** предлагает связать объекты обработчиков в одну цепь. 
Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет 
не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, можно быть уверенным в том, что все объекты в цепи смогут его обработать. 
При этом длина цепочки не имеет никакого значения.

Обработчик необязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

## 1.1. Структура паттерна

![Структура паттерна Цепочка обязанностей (Chain of Invocations / Fluent)](./_Files/1.%20Patterns/31.jpg "Структура паттерна Цепочка обязанностей (Chain of Invocations / Fluent)")

1. *Обработчик (Handler)* 

***Обработчик (Handler)*** - интерфейс, определяющий метод обработки запросов, и иногда метод выставления следующего обработчика.

2. *Базовый Обработчик (BaseHandler)*

**Базовый Обработчик (BaseHandler)**- опциональный класс, который позволяет избавиться от 
дублирования одного и того же кода во всех конкретных обработчиках

Обычно **Базовый Обработчик (BaseHandler)** имеет поле для хранения ссылки на следующий обработчик в цепочке.
**Клиент (Client)** связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля.
Также здесь можно реализовать базовый метод обработки, 
который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.

3. *Конкретный Обработчик (ConcreteHandler)* 

***Конкретный Обработчик (ConcreteHandler)*** - класс, содержащие код обработки

При получении запроса каждый **Конкретный Обработчик (ConcreteHandler)** решает, может ли он обработать запрос, 
а также стоит ли передать его следующему объекту. 

В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми,
получив все нужные детали через параметры конструктора.

4. *Клиент (Client)* 

***Клиент (Client)*** - класс, который может либо сформировать цепочку обработчиков единожды, 
либо перестраивать её динамически, в зависимости от логики программы.

**Клиент (Client)*** может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, 
либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, 
опираясь на конфигурацию приложения или параметры окружения.

**Клиент (Client)** может посылать запросы любому обработчику в цепи, а не только первому. 
Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик 
не откажется передавать его дальше, либо когда будет достигнут конец цепи.

**Клиент (Client)** должен знать о динамической природе цепочки и быть готов к таким случаям:

* цепочка может состоять из единственного объекта.
* запросы могут не достигать конца цепи.
* запросы могут достигать конца, оставаясь необработанными.

Обычно, если вы хотите прервать цепочку методов, все, что вам нужно сделать, 
это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.

## 1.2. Шаги реализации паттерна

1. *Создание интерфейса Обработчик (Handler)*

2. *Создание абстрактного класса Базовый Обработчик (BaseHandler)*

3. *Создание классов Конкретный Обработчик (ConcreteHandler)*

## 1.3. Применимость паттерна

1. *Когда программа должна обрабатывать разнообразные запросы несколькими способами, 
но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся*

С помощью Цепочки обязанностей вы можете связать потенциальных обработчиков в одну цепь и 
при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

2. *Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке*

Цепочка обязанностей позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

3. *Когда набор объектов, способных обработать запрос, должен задаваться динамически*

В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

## 1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Цепочка обязанностей (Chain of Invocations / Fluent)**:

* уменьшение зависимости между клиентом и обработчиками
* реализация принципа единственной обязанности
* реализация принципа открытости/закрытости

Минусы применения паттерна **Цепочка обязанностей (Chain of Invocations / Fluent)**:

*  запрос может остаться никем не обработанным

## 1.5. Применение паттерна в автотестах

### 1.5.1. Цепочка вызовов методов объектов страниц

Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив **Fluent Invocations**, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

#### До применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage {
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
  
    // Конструктор
    public HomePage(WebDriver driver){
      this.driver = driver;
    }
  
    // Отображается элемент?
    public boolean isTextDisplyed() {
      return driver.findElement(tеxtBy).isDisplayed();
    }
  
    // Получение текста 
    public String getText() {
      return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

#### После применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage {
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
  
    // Конструктор
    public HomePage(WebDriver driver){
      this.driver = driver;
    }
  
    // Отображается элемент?
    public boolean isTextDisplyed() {
      return driver.findElement(tеxtBy).isDisplayed();
    }
  
    // Получение текста 
    public String getText() {
      return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
  @Test
  public void loginTest() {
    // Arrange
    String login = "login";
    String password = "password";
    String expected = "Стартовая страница";

    // Act
    HomePage homePage = getPageAfterLogin("login", "password")

    // Assert
    // Проверить что отображается текст "Стартовая страница"
    HomePageAssert homePageAssert = new HomePageAssert(homePage);
    homePageAssert.displayedTextAfterLogin();
    homePageAssert.textAfterLoginIs(expected);
  }

  public HomePage getPageAfterLogin(String email, String password) {
    // Страница "Sign In"
    SignInPage signInPage = new SignInPage(driver);
    // Вход с логином и паролем
    // Страница "Home"
    return signInPage.loginValidUser("login", "password");
  }
    ...
}
```

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)