Java_QA / 11. Паттерны

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Простой Java Объект (Plain Old Java Object (POJO))](#1-простой-java-объект-plain-old-java-object-pojo)
    * [1.1. Структура класса](#11-структура-класса)
    * [1.2. Шаги реализации](#12-шаги-реализации)
    * [1.3. Применимость](#13-применимость)
    * [1.4. Плюсы и минусы применения](#14-плюсы-и-минусы-применения)
        * [1.4.1. Плюсы применения паттерна](#141-плюсы-применения-паттерна)
        * [1.4.2. Минусы применения паттерна](#142-минусы-применения-паттерна)
    * [1.5. Применение в автотестах](#15-применение-в-автотестах)
        * [1.5.1. UI автотесты с POM + PE + AAA + Matchers + POJO](#151-ui-автотесты-с-pom--pe--aaa--matchers--pojo)
            * [1.5.1.1. До применения паттерна](#1511-до-применения-паттерна)
            * [1.5.1.2. После применения паттерна](#1512-после-применения-паттерна)
* [2. Java Боб (JavaBean)](#2-java-боб-javabean)
	* [2.1. Структура класса](#21-структура-класса)
	* [2.2. Шаги реализации](#22-шаги-реализации)
	* [2.3. Применимость](#23-применимость)
	* [2.4. Плюсы и минусы применения](#24-плюсы-и-минусы-применения)
		* [2.4.1. Плюсы применения паттерна](#241-плюсы-применения-паттерна)
		* [2.4.2. Минусы применения паттерна](#242-минусы-применения-паттерна)
	* [2.5. Применение в автотестах](#25-применение-в-автотестах)
		* [2.5.1. UI автотесты с POM + PE + AAA + Matchers + JB](#251-ui-автотесты-с-pom--pe--aaa--matchers--jb)
			* [2.5.1.1. До применения паттерна](#2511-до-применения-паттерна)
			* [2.5.1.2. После применения паттерна](#2512-после-применения-паттерна)
* [3. Объект Значение (Value Object (VO))](#3-объект-значение-value-object-vo)
	* [3.1. Структура класса](#31-структура-класса)
	* [3.2. Шаги реализации](#32-шаги-реализации)
	* [3.3. Применимость паттерна](#33-применимость-паттерна)
	* [3.4. Плюсы и минусы применения](#34-плюсы-и-минусы-применения)
		* [3.4.1. Плюсы применения паттерна](#341-плюсы-применения-паттерна)
		* [3.4.2. Минусы применения паттерна](#342-минусы-применения-паттерна)
	* [3.5. Применение в автотестах](#35-применение-в-автотестах)
		* [3.5.1. UI автотесты с POM + PE + AAA + Matchers + JB + VO](#351-ui-автотесты-с-pom--pe--aaa--matchers--jb--vo)
			* [3.5.1.1. До применения паттерна](#3511-до-применения-паттерна)
			* [3.5.1.2. После применения паттерна](#3512-после-применения-паттерна)
* [4. Паттерн Строитель (Builder)](#4-паттерн-строитель-builder)
    * [4.1. Структура паттерна](#41-структура-паттерна)
    * [4.2. Шаги реализации паттерна](#42-шаги-реализации-паттерна)
    * [4.3. Применимость паттерна](#43-применимость-паттерна)
    * [4.4. Плюсы и минусы применения паттерна](#44-плюсы-и-минусы-применения-паттерна)
        * [4.4.1. Плюсы применения паттерна](#441-плюсы-применения-паттерна)
        * [4.4.2. Минусы применения паттерна](#442-минусы-применения-паттерна)
    * [4.5. Применение паттерна в автотестах](#45-применение-паттерна-в-автотестах)
        * [4.5.1. UI автотесты с POM + PE + AAA + Matchers + JB + VO + Builder](#451-ui-автотесты-с-pom--pe--aaa--matchers--jb--vo--builder)
            * [4.5.1.1. До применения паттерна](#4511-до-применения-паттерна)
            * [4.5.1.2. После применения паттерна](#4512-после-применения-паттерна)
* [5. Паттерн Фасад (Facade)](#5-паттерн-фасад-facade)
	* [5.1. Структура паттерна](#51-структура-паттерна)
	* [5.2. Шаги реализации паттерна](#52-шаги-реализации-паттерна)
	* [5.3. Применимость паттерна](#53-применимость-паттерна)
	* [5.4. Плюсы и минусы применения паттерна](#54-плюсы-и-минусы-применения-паттерна)
		* [5.4.1. Плюсы применения паттерна](#541-плюсы-применения-паттерна)
		* [5.4.2. Минусы применения паттерна](#542-минусы-применения-паттерна)
	* [5.5. Применение паттерна в автотестах](#55-применение-в-автотестах)
		* [5.5.1. Скрытие технических деталей прохождения UI теста](#551-скрытие-технических-деталей-прохождения-ui-теста)
			* [5.5.1.1. До применения паттерна](#5511-до-применения-паттерна)
			* [5.5.1.2. После применения паттерна](#5512-после-применения-паттерна)
* [6. Паттерн Простая Фабрика (SimpleFactory)](#6-паттерн-простая-фабрика-simplefactory)
    * [6.1. Структура паттерна](#61-структура-паттерна)
    * [6.2. Шаги реализации паттерна](#62-шаги-реализации-паттерна)
    * [6.3. Применимость паттерна](#63-применимость-паттерна)
    * [6.4. Плюсы и минусы применения паттерна](#64-плюсы-и-минусы-применения-паттерна)
        * [6.4.1. Плюсы применения паттерна](#641-плюсы-применения-паттерна)
        * [6.4.2. Минусы применения паттерна](#642-минусы-применения-паттерна)
    * [6.5. Применение паттерна в автотестах](#65-применение-в-автотестах)
        * [6.5.1. Фабрика драйверов (WebDriverFactory)](#651-фабрика-драйверов-webdriverfactory)
            * [6.5.1.1. До применения паттерна](#6511-до-применения-паттерна)
            * [6.5.1.2. После применения паттерна](#6512-после-применения-паттерна)

***

# 1. Простой Java Объект (Plain Old Java Object (POJO))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Простой Java Объект (Plain Old Java Object (POJO))*** - простой **Java** класс без ссылок на какие-либо 
конкретные фреймворки, не унаследованный от какого-то класса и не реализующий никаких интерфейсов сверх тех, 
которые нужны для бизнес-модели.

То есть это такой класс, который не связан какими-либо особыми ограничениями, кроме тех, что налагаются спецификацией **Java**.

![Простой Java Объект (Plain Old Java Object (POJO))](./_Files/1.%20Lection/1.%20Plain%20Old%20Java%20Object/01.jpg "Простой Java Объект (Plain Old Java Object (POJO))")

Понятие **Простой Java Объект (Plain Old Java Object (POJO))** означает использование настолько простых классов 
насколько возможно для моделирования предметной области. Этот класс может использоваться в любом коде на **Java**, 
поскольку он не привязан к какой-либо структуре.

## 1.1. Структура класса

1. *Класс*

Класс **Простой Java Объект (Plain Old Java Object (POJO))**:

* **НЕ** должен расширять заранее заданные классы

Открытый класс, который расширяет **javax.servlet.http.HttpServlet**
**НЕ** является **Простым Java Объектом (Plain Old Java Object (POJO))**.

* **НЕ** должен реализовывать заранее заданные интерфейсы

Открытый класс, который реализует **javax.ejb.EntityBean**
**НЕ** является **Простым Java Объектом (Plain Old Java Object (POJO))**.

* **НЕ** должен содержать предварительно определенные аннотации

Открытый класс, который содержит аннотацию **@javax.persistence.Entity**
**НЕ** является **Простым Java Объектом (Plain Old Java Object (POJO))**.

2. *Поля класса*
   
Поля класса **Простой Java Объект (Plain Old Java Object (POJO))** могут иметь любые уровни доступа:

* **public** - общедоступные
* **private** - закрытые
* **default** - по умолчанию
* **protected** - защищенные

У класса **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для полей.

3. *Методы доступа класса*

Методы доступа класса **Простой Java Объект (Plain Old Java Object (POJO))** могут иметь любые уровни доступа:

* **public** - общедоступные
* **private** - закрытые
* **default** - по умолчанию
* **protected** - защищенные

*Сеттеры*

У класса **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для сеттеров.

*Геттеры*

У класса **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для геттеров.

4. *Конструктор класса*

В класс **Простой Java Объект (Plain Old Java Object (POJO))** нет необходимости добавлять специальный конструктор.
Есть конструктор по умолчанию.

5. *Переопределенные методы equals(), hashCode() и toString()*

Переопределение этих методов поможет при использовании класса **Простой Java Объект (Plain Old Java Object (POJO))** 
с различными классами коллекций **Java**.

*Пример*

```java
// Класс, который не расширяет классы, не реализует интерфейсы, не содержит аннотации  
public class EmployeePojo {
    // Поля класса с разными уровнями доступа
    public String firstName;
    public String lastName;
    private LocalDate startDate;

    // Конструктор класса с параметрами
    public EmployeePojo(String firstName, String lastName, LocalDate startDate) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.startDate = startDate;
    }

    // Методы класса
    public String name() {
        return this.firstName + " " + this.lastName;
    }

    public LocalDate getStart() {
        return this.startDate;
    }
}
```

## 1.2. Шаги реализации

1. *Создание класса, который не наследуется от какого-либо класса и не реализует какого-либо интерфейса*
2. *Создание полей класса*
3. *Создание методов доступа класса*
4. *Создание конструктора класса*
5. *Переопределение методов equals(), hashCode() и toString()*

## 1.3. Применимость

1. *Когда нет необходимости накладывать ограничения на поля класса*
  
Применение **Простого Java Объекта (Plain Old Java Object (POJO))**
не налагает каких либо ограничений на поля, и может дать полный доступ к ним.

## 1.4. Плюсы и минусы применения 

### 1.4.1. Плюсы применения паттерна

Плюсы применения **Простого Java Объекта (Plain Old Java Object (POJO))**:

* повышение читабельности
* возможность повторного использования
* упрощенное тестирование

### 1.4.2. Минусы применения паттерна

Минусы применения **Простого Java Объекта (Plain Old Java Object (POJO))**:

* отсутствие соглашения об именовании

Из-за отсутствия соглашений об именовании классы **Простой Java Объект (Plain Old Java Object (POJO))**: 

* могут быть трудными для понимания другими программистами
* могут работать некорректно при анализе с использованием **Reflection API**

## 1.5. Применение в автотестах

### 1.5.1. UI автотесты с POM + PE + AAA + Matchers + POJO

#### 1.5.1.1. До применения паттерна

1. *Базовывй класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

2. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
  
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        tbxLogin().setValue(login);
        tbxPassword().setValue(password);
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin(login, password)

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

#### 1.5.1.2. После применения паттерна

1. *Класс учетных данных - AccountPOJO*

*Пример*

```java
// Учетные данные
public class AccountPOJO {
    // Логин
    public String login;
    // Пароль
    public String password;

    // Конструктор
    public AccountPOJO(String login, String password) {
        this.login = login;
        this.password = password;
    }

    // Получение значения логина
    public String login() {
        return this.login;
    }

    // Получение значения пароля
    public String password() {
        return this.password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
  
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountPOJO accountPOJO) {
        tbxLogin().setValue(accountPOJO.login());
        tbxPassword().setValue(accountPOJO.password());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountPOJO accountPOJO = new AccountPOJO(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountPOJO);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountPOJO accountPOJO) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountPOJO);
    }
    ...
}
```

***

# 2. Java Боб (JavaBean)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Java Боб (JavaBean)*** - класс в **Java**, особый тип **Простого Java Объекта (Plain Old Java Object (POJO))** со строгим набором соглашений.

![Java Боб (JavaBean)](./_Files/1.%20Lection/2.%20JavaBean/01.jpg "Java Боб (JavaBean)")

Все классы **Java Боб (JavaBean)** являются классами **Простой Java Объект (Plain Old Java Object (POJO))**, 
но не все классы **Простой Java Объект (Plain Old Java Object (POJO))** можно назвать классами **Java Боб (JavaBean)**.

Чтобы исправить некоторые проблемы классов **Простой Java Объект (Plain Old Java Object (POJO))**, 
классы **Java Боб (JavaBean)** должны следовать некоторым стандартным правилам и соглашениям.

## 2.1. Структура класса

1. *Класс*

Класс **Java Боб (JavaBean)** должен быть сериализуемыми (то есть реализовывать интерфейс **java.io.Serializable**).
Реализация интерфейса **java.io.Serializable** позволяет хранить состояние в виде **JSON** или **XML** объектов.

2. *Поля класса*

Поля класса **Java Боб (JavaBean)** должны иметь уровни доступа **private** (закрытые).
Закрытость полей класса защищает их от случайного изменения.

3. *Методы доступа класса*

Методы доступа класса **Java Боб (JavaBean)** должны быть **public** (общедоступные).
Геттеры и сеттеры обеспечивают ограничение неконтролируемого доступа к полям класса.

*Сеттеры*

Соглашения:

* имена методов - *setX* (X - имя поля класса)
* уровень доступа - *public*
* тип возврата - *void*
* метод должен принимать параметр

*Геттеры*

Соглашения:

* имена методов 
  * в случае не логического возвращаемого значения - *getX* (X - имя поля класса) 
  * в случае логического возвращаемого значения - *isX* (X - имя поля класса) 
* уровень доступа - *public*
* тип возврата - любой, но не *void*
* метод 
  * в случае простого поля - не должен принимать параметр 
  * в случае поля коллекции - может принимать параметр индекс 

Префиксы в наименовании методов облегчают понимание назначения методов.

4. *Конструктор класса*

У класса **Java Боб (JavaBean)** должен быть конструктор без аргументов (конструктор по умолчанию).
Конструктор по умолчанию нужен для того, чтобы экземпляр класса можно было создать без предоставления аргументов.
Например, во время десериализации **JSON** объекта.

5. *Переопределенные методы equals(), hashCode() и toString()*

*Пример*

```java
// Класс, который реализует интерфейс Serializable
public class EmployeeBean implements Serializable {
    // Поля класса с уровнями доступа private
    private static final long serialVersionUID = -3760445487636086034L;
    private String firstName;
    private String lastName;
    private LocalDate startDate;

    // Конструктор класса без параметров
    public EmployeeBean() {
    }
    
    // Конструктор класса с параметрами
    public EmployeeBean(String firstName, String lastName, LocalDate startDate) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.startDate = startDate;
    }

    // Методы класса
    // Геттер 
    public String getFirstName() {
        return firstName;
    }
    
    // Сеттер
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}
```

## 2.2. Шаги реализации

1. *Создание класса, который реализует интерфейс java.io.Serializable*
2. *Создание закрытых полей класса*
3. *Создание общедоступных методов доступа класса*
4. *Создание конструктора класса без аргументов*
5. *Переопределение методов equals(), hashCode() и toString()*

## 2.3. Применимость

1. *Когда необходимо наличие стандартизированного класса*

Для работы некоторых библиотек (сериализации, рефлексии) нужны классы отвечающие требованиям **Java Боб (JavaBean)**.

## 2.4. Плюсы и минусы применения 

### 2.4.1. Плюсы применения паттерна

Плюсы применения **Java Боб (JavaBean)**:

* наличие соглашений по именованию, устраняющее минусы **Простого Java Объекта (Plain Old Java Object (POJO))**
* множество инструментов использующих спецификацию **JavaBeans**:
  * инструменты для создания на основе объектов **JavaBeans** данных определенного типа (**XML**, **JSON**, **CSV**, **DDL** и т д)
  * инструменты для чтения, управления, сопоставления объектов **JavaBeans** (**BeanUtils**, **Dozer**, **EZMorph** и т д)
  * фреймворки (MVC / ORM), которые работают с **JavaBeans** (**JPA**, **Hibernate**, **JSF**, **Spring** и т д)

### 2.4.2. Минусы применения паттерна

Минусы применения **Java Боб (JavaBean)**:

* обязательное наличие сеттеров и геттеров, даже если этого не требуется 
* все поля класса изменяемы из-за наличия обязательных методов установки (сеттеров)
* обязательное наличие конструктора класса по умолчанию

## 2.5. Применение в автотестах

### 2.5.1. UI автотесты с POM + PE + AAA + Matchers + JB

#### 2.5.1.1. До применения паттерна

1. *Класс учетных данных - AccountPOJO*

*Пример*

```java
// Учетные данные
public class AccountPOJO {
    // Логин
    public String login;
    // Пароль
    public String password;

    // Конструктор
    public AccountPOJO(String login, String password) {
        this.login = login;
        this.password = password;
    }

    // Получение значения логина
    public String login() {
        return this.login;
    }

    // Получение значения пароля
    public String password() {
        return this.password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }
    
    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountPOJO accountPOJO) {
        tbxLogin().setValue(accountPOJO.login());
        tbxPassword().setValue(accountPOJO.password());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountPOJO accountPOJO = new AccountPOJO(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountPOJO);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountPOJO accountPOJO) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountPOJO);
    }
    ...
}
```

#### 2.5.1.2. После применения паттерна

1. *Класс учетных данных - AccountJB*

*Пример*

```java
// Учетные данные
public class AccountJB implements Serializable {
    // Поля
    // Логин
    private String login;
    // Пароль
    private String password;
  
    // Конструктор
    public AccountJB(String login, String password) {
        this.login = login;
        this.password = password;
    }
  
    // Конструктор без параметров
    public AccountJB() {
  
    }
  
    // Геттеры и Сеттеры
    public String getLogin() {
        return this.login;
    }
  
    public void setLogin(String login) {
        this.login = login;
    }
  
    public String getPassword() {
        return this.password;
    }
  
    public void setPassword(String password) {
        this.password = password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountJB accountJB) {
        tbxLogin().setValue(accountJB.getLogin());
        tbxPassword().setValue(accountJB.getPassword());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountJB accountJB = new AccountJB(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountJB);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountJB accountJB) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountJB);
    }
    ...
}
```

***

# 3. Объект Значение (Value Object (VO))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Объект Значение (Value Object (VO))*** ⎼ класс в **Java**, 
который идентифицируется по уникальности значения полей класса (**структурная эквивалентность**).

![Объект Значение (Value Object (VO))](./_Files/1.%20Lection/3.%20Value%20Object/01.png "Объект Значение (Value Object (VO))")

***Ссылочная эквивалентность*** - равенство двух объектов в случае, если оба объекта ссылаются на один и тот же объект в куче.

![Ссылочная эквивалентность](./_Files/1.%20Lection/3.%20Value%20Object/02.png "Ссылочная эквивалентность")

***Структурная эквивалентность*** - равенство двух объектов в случае, если у обоих объектов все поля полностью эквивалентны.
То есть, если два экземпляра одного класса обладают одинаковым набором свойств (полей), то они равны.

![Структурная эквивалентность](./_Files/1.%20Lection/3.%20Value%20Object/03.png "Структурная эквивалентность")

## 3.1. Структура класса

1. *Класс*
   
Класс **Объект Значение (Value Object (VO))**:

* представляет логически целостные объекты, для которых нет готовых стандартных типов 

Примером класса **Объект Значение (Value Object (VO))** могут быть даты, время, деньги.

* НЕ обладает неотъемлемой идентичностью, то есть идентифицируется по уникальности значения полей класса (**структурная эквивалентность**), 
  а не уникальности значения идентификатора (**эквивалентность идентификаторов**)

Два объекта класса **Объект Значение (Value Object (VO))** считаются равными, если значения всех их полей равны.

* НЕ является самостоятельной сущностью, а представляет *кирпичики* для построения сущностей

Объект класса **Объект Значение (Value Object (VO))** не может существовать сам по себе, то есть они всегда должны принадлежать одной или нескольким сущностям.
Данные, которые представляет собой **Объект Значение (Value Object (VO))**, имеют значение только в контексте какой-либо сущности.

Объект класса **Объект Значение (Value Object (VO))** не должны иметь собственной таблицы в базе данных.

* обладает нулевым жизненным циклом

Объекты класса **Объект Значение (Value Object (VO))** с легкостью создаются и уничтожаются. 
Это следствие, логично вытекающее из того, что они взаимозаменяемы.
Важны не объекты, а важны их значения. Объект здесь служит лишь способом организации кода, 
но он никак не идентифицирует хранящиеся внутри него данные.

Например, если есть 1 рубль, то все равно та же ли это монета, что была вчера.
До тех пор, пока эта монета является монетой ценностью в 1 рубль, ее можно заменить другой, точно такой же.
Концепция денег в таком случае является **объектом значением**. То же самое можно сказать и про многое другое 
(адреса доставки, страна проживания, путь до файла, адрес страницы сайта, точки на плоскости).

2. *Поля класса*

Поля класса **Объект Значение (Value Object (VO))**:

* состоят из 
  * примитивных типов данных 
  * объектов класса **Объект Значение (Value Object (VO))**
* НЕ имеют поля идентификатор
* являются неизменяемыми

Если необходимо изменить объект, то создается новый объект на основе имеющегося, вместо того чтобы изменять существующий.

* проверяются на действительность при создании

Если одно из полей недействительно, то объект не должен создаваться и должна возникать ошибка или исключение.

Например, если есть класс Age (возраст), то не имеет смысла создавать экземпляр класс Age с отрицательным значением.
В **Java** можно выбросить исключение **IllegalArgumentException** или любое другое созданное исключение.

3. *Методы доступа класса*

*Сеттеры*

У класса **Объект Значение (Value Object (VO))** отсутствуют сеттеры.
Это следствие неизменяемости полей классов.

*Геттеры*

Геттеры класса **Объект Значение (Value Object (VO))** должны возвращать неизменяемые объекты или копии.

4. *Конструктор класса*

Так как объекты класса **Объект Значение (Value Object (VO))** неизменяемые, 
то их можно создать только одним способом - инициализацией в конструкторе.

5. *Переопределенные методы equals(), hashCode() и toString()*

Метод **equals()** должен сравнивать объекты по значениям их полей.

*Пример*

```java
class Money implements Serializable {
    int value;
    String currency;

    public Money(int value, String currency) {
        this.value = value;
        this.currency = currency;
    }

    int getValue() {
        return value;
    }

    String getCurrency() {
        return currency;
    }

    public boolean equals(Money m) {
        return value == m.value and currency == m.currency;
    }
}
```

## 3.2. Шаги реализации

1. *Создание класса, моделирующего объекты, которые идентифицируется по уникальности значения полей*
2. *Создание закрытых полей класса, представленных примитивными типами данных и/или объектами-значениями*
3. *Создание общедоступных методов доступа класса, состоящих только из геттеров*
4. *Создание конструктора класса*
5. *Переопределение методов equals(), hashCode() и toString()*

## 3.3. Применимость паттерна

1. *Когда есть объекты, равенство которых определяется по значениям полей*

Данные объекты делаются неизменяемыми, т.е. чтобы после создания объекта значения его полей не изменялись.
Такие объекты можно передавать в виде значения, а не в виде ссылки на объект.
Два объекта считаются равными, если равны значения их полей. 
Обычно изменение полей объекта подразумевает полную замену старого объекта новым.

## 3.4. Плюсы и минусы применения

### 3.4.1. Плюсы применения паттерна

Плюсы применения **Объект Значение (Value Object (VO))**:

* уменьшение примитивной одержимости

***Примитивная одержимость (Primitive Obsession)*** - использование примитивов для хранения данных или в качестве параметров. 

*Пример*

Использование **String** для хранения адреса электронной почты, **double** для веса или **float** для расстояния.
Обычно это происходит потому, что создание нового класса только для хранения этого атрибута кажется излишним.

```java
String email;
double weight;
float distance;
```

* безопасность типов

Неправильная единица измерения

*Пример*

Есть следующее поле:

```java
private float distance;
```

Возможно, это расстояние в дюймах, а может, в метрах. Конечно, всегда можно назвать это **distanceInMeters**.
Теперь допустим что нужно расстояние в дюймах где-то еще в коде. Нужно будет преобразовать это расстояние перед его использованием.
Где должен быть этот код преобразования? В служебном классе? В статическом методе?
Что, если удалить этот код преобразования перед использованием расстояния?
Код все равно будет компилироваться, но будет использоваться неправильная единица измерения!
Такая ошибка может быть серьезной и может стоить компании больших денег.
Можно снизить этот риск, используя вместо этого **объект значение** Distance.

В этом случае мы бы просто сохранили Distance и больше не заботились о том, в какой единице она была создана. 
Этот класс теперь также содержит всю логику преобразования, и можно легко получить расстояние в любой единице, благодаря геттерам.

Смешивание параметров

*Пример*

Например, следующий метод:

```java
void sendEmail (String email, String тема, String body);
```

Очень легко перепутать параметры и назвать это так:

```java
sendEmail ("Некоторая тема", "Некоторое содержание", "john@doe.com");
```

Это кажется глупой ошибкой, но это может произойти при невнимательности. К сожалению, компилятор здесь не поможет.
Что произойдет, если будет необходимо отправлять составной контент? 
Или если нужно отправить электронное письмо нескольким получателям? 
Тогда нужно будет перегружать метод для каждого нового случая.

Используя **объекты значения** вместо примитивов, можно было бы получить следующее:

```java
sendEmail (адрес электронной почты получателя, тема темы, содержимое содержимого);
```

Инвертировать параметры будет невозможно, так как компилятор обнаружит ошибки. 
Тем не менее все равно нужно перегрузить метод, если понадобиться иметь 
возможность отправлять электронное письмо нескольким получателям. 
Это можно исправить, проделав еще один шаг:

```java
sendEmail (электронная почта);
```

Этот способ читать намного проще, чем первый метод. У него также есть еще одно преимущество - гибкость.

* гибкость

Продолжая предыдущий пример, теперь, когда у есть класс электронной почты, можно изменить его, чтобы он мог обрабатывать 
несколько получателей или разные типы контента без необходимости возвращаться и снова изменять сигнатуру метода.

* самопроверка

**Объект значение** должен быть действительным и неизменяемым. 
Благодаря чему, можно перестать задаваться вопросом, нужно ли проверять параметр или нет.

Если повторно использовать пример **sendEmail**, нужно будет убедиться, что адрес электронной почты действителен. 
Где это делать? Возможно, в самом методе? Почему нет. Но что, если нужно использовать электронную почту в другом месте? 
А что, если кто-то уже подтвердил электронное письмо перед вызовом метода **sendEmail**? Повсюду бы дублировался проверочный код! 
Что, если кто-то тем временем решит изменить значение электронного письма? Затем нужно будет снова его проверить.

Нет разумного места, куда поместить код проверки, и нет гарантии, что параметр допустимый.
Однако с **объектом значения** гарантируется, что он действителен, иначе он просто не существовал бы. 
Код проверки, также находится там, где должен, внутри самого объекта. 
Только этот объект должен знать, действителен он или нет.

* уменьшение дублирования

Вместо того чтобы иметь одну и ту же группу атрибутов в отдельных классах, можно вместо этого создать общий **объект значения**. 
Одним из примеров этого может быть **объект значение** адреса, который может совместно использоваться сотрудниками и офисами, 
вместо дублирования полей адреса в каждом классе. Повторное использование **объектов значений** среди сущностей или 
других **объектов значений** - хороший способ уменьшить дублирование.

* улучшение читабельности

Используя **объекты значения**, не нужно гадать, что значат переменные на самом деле. 
Вместо **List<String>** может быть **List<PhoneNumber>**. Больше не нужно беспокоиться о внутренних представлениях, 
а вместо этого думать о концепциях предметной области. Код намного выразительнее.
Кроме того, **объекты значения** централизуют логику связанной предметной области, что упрощает поиск и изменение.

* улучшение производительности

**Объекты значения** неизменяемы и поэтому могут использоваться в распараллеленном коде без риска. 
Если многие объекты используют один и тот же **объект значение** с одним и тем же значением, 
можно использовать паттерн **Легковес (Flyweight)**, разделяя один и тот же экземпляр для всех объектов. 
Так как важны только атрибуты, а не то, какой экземпляр используется.

### 3.4.2. Минусы применения паттерна

Минусы применения паттерна **Объект Значение (Value Object (VO))**:

* дополнительные классы
* увеличение объема кода

## 3.5. Применение в автотестах

### 3.5.1. UI автотесты с POM + PE + AAA + Matchers + JB + VO

#### 3.5.1.1. До применения паттерна

1. *Класс учетных данных - AccountJB*

*Пример*

```java
// Учетные данные
public class AccountJB implements Serializable {
    // Поля
    // Логин
    private String login;
    // Пароль
    private String password;
  
    // Конструктор
    public AccountJB(String login, String password) {
        this.login = login;
        this.password = password;
    }
  
    // Конструктор без параметров
    public AccountJB() {
  
    }
  
    // Геттеры и Сеттеры
    public String getLogin() {
        return this.login;
    }
  
    public void setLogin(String login) {
        this.login = login;
    }
  
    public String getPassword() {
        return this.password;
    }
  
    public void setPassword(String password) {
        this.password = password;
    }
}
```

2. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

3. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }

    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(AccountJB accountJB) {
        tbxLogin().setValue(accountJB.getLogin());
        tbxPassword().setValue(accountJB.getPassword());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        AccountJB accountJB = new AccountJB(login, password);
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(accountJB);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(AccountJB accountJB) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(accountJB);
    }
    ...
}
```

#### 3.5.1.2. После применения паттерна

1. *Класс - Login*

*Пример*

```java
// Логин
public class Login implements Serializable {
    // Поле 
    private String login;
  
    // Конструктор
    public Login(String login) {
        if (!login.isBlank() && !login.isEmpty())
            this.login = login;
        else
            throw new IllegalArgumentException("Логин не может быть пустым!");
    }
  
    // Геттер
    public String getLogin() {
        return this.login;
    }
}
```

2. *Класс - Password*

*Пример*

```java
// Пароль
public class Password implements Serializable {
    // Поле
    private String password;
    
    // Конструктор
    public Password(String password) {
        if (!password.isBlank() && !password.isEmpty())
            this.password = password;
        else
            throw new IllegalArgumentException("Пароль не можеь быть пустым");
    }
    
    // Геттер
    public String getPassword() {
        return this.password;
    }
}
```

3. *Класс - FullName*

*Пример*

```java
// ФИО
public class FullName implements Serializable {
    // Поля
    private String fullName;
    private String firstName;
    private String secondName;
    private String lastName;
  
    // Конструктор
    public FullName(String fullName) {
        if (!fullName.isBlank() && !fullName.isEmpty()) {
            this.fullName = fullName;
            String[] names = fullName.split(" ");
            if (names.length == 3) {
                firstName = names[0];
                secondName = names[1];
                lastName = names[2];
            } 
            else
                throw new IllegalArgumentException("ФИО задано некорректно!");
        }
        else
          throw new IllegalArgumentException("ФИО не можеь быть пустым!");
    }
  
    // Геттеры
    public String getFullName() {
        return this.fullName;
    }
  
    public String getFirstName() {
        return this.firstName;
    }
  
    public String getSecondName() {
        return this.secondName;
    }
  
    public String getLastName() {
        return this.lastName;
    }
}
```

4. *Класс - MobilePhone*

*Пример*

```java
// Номер мобильного телефона
public class MobilePhone implements Serializable {
    // Поле
    private String mobilePhone;
  
    // Конструктор
    public MobilePhone(String mobilePhone) {
        if (!mobilePhone.isBlank() && !mobilePhone.isEmpty())
            this.mobilePhone = mobilePhone;
        else
            throw new IllegalArgumentException("Номер мобильного не можеь быть пустым");
    }
  
    // Геттер
    public String getMobilePhone() {
        return this.mobilePhone;
    }
}
```

5. *Класс учетных данных - Account*

*Пример*

```java
// Учетные данные
public class Account implements Serializable {
    // Поля
    private Login login;
    private Password password;
    private MobilePhone mobilePhone;
    private FullName fullName;
    private Date dateOfBirth;
  
    // Конструктор без параметров
    public Account() {
  
    }
  
    // Конструктор 
    public Account(Login login, Password password) {
        this.login = login;
        this.password = password;
    }
  
    // Геттеры и сеттеры
    public void setLogin(Login login) {
        this.login = login;
    }
  
    public Login getLogin() {
        return this.login;
    }
  
    public void setPassword(Password password) {
        this.password = password;
    }
  
    public Password getPassword() {
        return this.password;
    }
  
    public void setMobilePhone(MobilePhone mobilePhone) {
        this.mobilePhone = mobilePhone;
    }
  
    public MobilePhone getMobilePhone() {
        return this.mobilePhone;
    }
  
    public void setFullName(FullName fullName) {
        this.fullName = fullName;
    }
  
    public FullName getFullName() {
        return this.fullName;
    }
  
    public void setDateOfBirth(Date dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
    }
  
    public Date getDateOfBirth() {
         return this.dateOfBirth;
    }
}
```

6. *Базовый класс всех страниц (Page Object) - BasePage*

*Пример*

```java
// Базовый класс для всех объектов веб страниц
public class BasePage {
    // Драйвер браузера
    protected static WebDriver driver;

    // Конструктор базового класса
    public BasePage(WebDriver driver) {
        BasePage.driver = driver;
        // Инициализация ожидания - 10 секунд
        WaitFor.initWait(driver, Duration.ofSeconds(10), Duration.ofMillis(100));
        // Инициализация исполнителя JS скриптов
        JSExec.initJS(driver);
    }
}
```

7. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage extends BasePage {
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");
  
    // Конструктор
    public SignInPage(WebDriver driver){
        super(driver);
    }
    
    // Веб элементы
    public TextBox tbxLogin() {
        return new TextBox(driver, loginBy);
    }
  
    public TextBox tbxPassword() {
        return new TextBox(driver, passwordBy);
    }
  
    public Button btnSignIn() {
        return new Button(driver, signInBy);
    }
  
    // Конструктор с логином и паролем
    public HomePage loginValidUser(Account account) {
        tbxLogin().setValue(account.getLogin().getLogin());
        tbxPassword().setValue(account.getPassword().getPassword());
        btnSignIn().click();
        return new HomePage(driver);
    }
}
```

8. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login), 
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

***

# 4. Паттерн Строитель (Builder)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Строитель (Builder)*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

![Паттерн Строитель (Builder)](./_Files/1.%20Lection/4.%20Builder/01.jpg "Паттерн Строитель (Builder)")

Паттерн **Строитель (Builder)** предлагает:

* вынести конструирование объекта за пределы его собственного класса,
  поручив это дело отдельным объектам, называемым строителями.

* разбить процесс конструирования объекта на отдельные шаги

Чтобы создать объект, нужно поочерёдно вызывать методы строителя.
Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.
Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов.

## 4.1. Структура паттерна

![Структура паттерна Строитель (Builder)](./_Files/1.%20Lection/4.%20Builder/02.jpg "Паттерн Строитель (Builder)")

1. *Продукт (Product)*

***Продукт (Product)*** - класс создаваемого объекта.

Продукты, сделанные разными строителями, не обязаны иметь общий интерфейс.

2. *Базовый строитель (Builder)*

***Базовый строитель (Builder)*** - общий интерфейс / абстрактный класс, описывающий шаги конструирования продуктов,
общие для всех строителей

3. *Конкретный строитель (ConcreteBuilder)*

***Конкретный строитель (ConcreteBuilder)*** - класс, реализующий Базовый строитель

Конкретные строители могут производить разнородные объекты, не имеющие общего интерфейса.

4. *Директор (Director)*

***Директор (Director)*** - класс определяющий порядок вызова шагов строителей.

Отдельный класс директора не является строго обязательным.
Можно вызывать методы строителя и напрямую из клиентского кода.
Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов,
отличающихся порядком и наличием шагов конструирования.
В этом случае вы сможете объединить всю эту логику в одном классе.

5. *Клиент*

***Клиент*** - класс, который создает продукты с помощью строителей.

## 4.2. Шаги реализации паттерна

1. *Создание класса Продукт(Product)*
2. *Создание интерфейса Базовый строитель (Builder)*
3. *Создание классов Конкретный строитель (ConcreteBuilder)*
4. *Создание класса Директор (Director)*

## 4.3. Применимость паттерна

1. *Когда вы хотите избавиться от «телескопического конструктора»*

Допустим, у вас есть один конструктор с десятью опциональными параметрами.
Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров.
Всё, что они делают — это переадресуют вызов к базовому конструктору,
подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.

Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны.
А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и
с помощью современных IDE подсказок более интуитивно понятным.

2. *Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома*

Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов,
которые отличаются в деталях.

Интерфейс строителей определит все возможные этапы конструирования.
Каждому представлению будет соответствовать собственный класс-строитель.
А порядок этапов строительства будет задавать класс-директор.

3. *Когда вам нужно собирать сложные составные объекты*

Строитель конструирует объекты пошагово, а не за один проход.
Более того, шаги строительства можно выполнять рекурсивно.
А без этого не построить древовидную структуру, вроде Компоновщика.

Заметьте, что Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту,
пока тот не будет полностью готов. Это предохраняет клиентский код от получения незаконченных «битых» объектов.

## 4.4. Плюсы и минусы применения паттерна

### 4.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Строитель (Builder)**:

* позволяет создавать продукты пошагово
* позволяет использовать один и тот же код для создания различных продуктов
* изолирует сложный код сборки продукта от его основной бизнес-логики

### 4.4.2. Минусы применения паттерна

Минусы применения паттерна **Строитель (Builder)**:

* усложняет код программы из-за введения дополнительных классов
* клиент будет привязан к конкретным классам строителей,
  так как в интерфейсе директора может не быть метода получения результата

## 4.5. Применение паттерна в автотестах

### 4.5.1. UI автотесты с POM + PE + AAA + Matchers + JB + VO + Builder

#### 4.5.1.1. До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

#### 4.5.1.2. После применения паттерна

1. *Класс строитель - AccountBuilder*

```java
// Класс строитель
public class AccountBuilder {
    // Поля
    private Login login;
    private Password password;
    private MobilePhone mobilePhone;
    private FullName fullName;
    private Date dateOfBirth;

    // Конструктор
    public AccountBuilder(Login login, Password password) {
        this.login = login;
        this.password = password;
    }

    // Методы установки
    public AccountBuilder setMobilePhone(MobilePhone mobilePhone) {
        this.mobilePhone = mobilePhone;
        return this;
    }

    public AccountBuilder setFullName(FullName fullName) {
        this.fullName = fullName;
        return this;
    }

    public AccountBuilder setDateOfBirth(Date dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
        return this;
    }

    // Метод построения объекта
    public Account build() {
        Account account = new Account(this.login, this.password);
        account.setMobilePhone(this.mobilePhone);
        account.setFullName(this.fullName);
        account.setDateOfBirth(this.dateOfBirth);
        return account;
    }
}
```

2. *Класс с тестами - LoginTest*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        String mobilePhone = "89037568552";
        String fullName = "Diman The Red Devil";
        String dateOfBirth = "10-10-1980";
  
        AccountBuilder accountBuilder = new AccountBuilder(
                new Login(login),
                new Password(password))
                .setMobilePhone(new MobilePhone(mobilePhone))
                .setFullName(new FullName(fullName))
                .setDateOfBirth(new Date(dateOfBirth));
        Account account = accountBuilder.build();
  
        String expected = "Dashboard";
    
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

***

# 5. Паттерн Фасад (Facade)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Фасад (Facade)*** — паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

![Паттерн Фасад (Facade)](./_Files/1.%20Lection/5.%20Facade/01.jpg "Паттерн Фасад (Facade)")

**Фасад (Facade)** - простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь,
используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.
То есть содержит интерфейс, содержащий только методы для решения определённой задачи или
предоставляющий определённую абстракцию исходной системы.

## 5.1. Структура паттерна

![Структура паттерна Фасад (Facade)](./_Files/1.%20Lection/5.%20Facade/02.jpg "Структура паттерна Фасад (Facade)")

1. *Подсистема (Subsystem)*

***Подсистема (Subsystem)*** - подсистема из множества разнообразных классов.

Нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее, чтобы заставить ее классы что-то делать.

2. *Фасад (Facade)*

***Фасад (Facade)*** - класс, который предоставляет быстрый доступ к определённой функциональности подсистемы.

Фасад выполняет:

* переадресацию запросов классам подсистемы

Классы подсистемы не знают о существовании Фасада и работают друг с другом напрямую.

* уменьшение числа параметров методов подстановкой заранее определенных значений

Часть исходных методов и свойств будут недоступны через Фасад, т.к. не играют роли для решения поставленной задачи

* создание новых методов, которые объединяют вызовы объектов подсистемы и/или добавляют свою логику

Фасад не является суммой всех методов объектов, входящих в систему.
Создание такой обобщенной версии приведет к появлению **божественного объекта**,
то есть интерфейса с огромным числом методов, без четко выраженной цели и порождающего большое количество зависимостей.
В итоге – прямо противоположный паттерну результат.

Дополнительный фасад можно ввести, чтобы не захламлять единственный фасад разнородной функциональностью.
Он может использоваться как клиентом, так и другими фасадами.

3. *Клиент (Client)*

***Клиент (Client)*** - класс, который использует фасад вместо прямой работы с объектами сложной подсистемы.

## 5.2. Шаги реализации паттерна

1. *Определение возможности создания более простого интерфейса, чем тот который предоставляется сложная подсистема*

Этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.

2. *Создание фасада, реализующего интерфейс подсистемы*

Фасад переадресовывает вызовы клиента нужным объектам подсистемы.

Фасад заботиться о том, чтобы правильно инициализировать объекты подсистемы

3. *Внедерение дополнительных фасадов*

## 5.3. Применимость паттерна

1. *Предоставление простого или урезанного интерфейса к сложной подсистеме*

Часто подсистемы усложняются по мере развития программы.
Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды,
но вместе с тем, применять подсистему без настройки становится труднее.
Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

2. *Разложение подсистемы на отдельные слои*

Фасады используются для определения точек входа на каждый уровень подсистемы.
Если подсистемы зависят друг от друга, то зависимость можно упростить,
разрешив подсистемам обмениваться информацией только через фасады.

## 5.4. Плюсы и минусы применения паттерна

### 5.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Фасад (Facade)**:

* упрощает взаимодействие клиента с подсистемами
* изолирует клиентов от компонентов сложной подсистемы
* уменьшает зависимости клиентского кода от внутренней работы системы.

### 5.4.2. Минусы применения паттерна

Минусы применения паттерна **Фасад (Facade)**:

* фасад рискует стать божественным объектом, привязанным ко всем классам программы

## 5.5. Применение в автотестах

### 5.5.1. Скрытие технических деталей прохождения UI теста

#### 5.5.1.1. До применения паттерна

*Пример*

```java

```

#### 5.5.1.2. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

***

# 6. Паттерн Простая Фабрика (SimpleFactory)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Простая Фабрика (SimpleFactory)*** - паттерн, который создает экземпляр класса, скрывая детали по его созданию.

![Паттерн Простая Фабрика (Simple Factory)](./_Files/1.%20Lection/6.%20SimpleFactory/01.jpg "Паттерн Простая Фабрика (Factory)")

## 6.1. Структура паттерна

![Структура паттерна Простая Фабрика (Simple Factory)](./_Files/1.%20Lection/6.%20SimpleFactory/02.png "Структура паттерна Простая Фабрика (Simple Factory)")

1. *Базовый продукт (Product)*

***Базовый продукт (Product)*** - общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных продуктов (ConcreteProduct)**.

2. *Конкретный продукт (ConcreteProduct)* - конкретный класс со своей бизнес логикой, 
реализующий **Базовый продукт (Product)**, который будет создан **Простой фабрикой (SimpleFactory)**.

3. *Простая фабрика (SimpleFactory)*

***Простая фабрика (SimpleFactory)*** - класс, который содержит статический метод по созданию всех 
**Конкретных продуктов (ConcreteProduct)**.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вызывает статический метод **Простой фабрики (SimpleFactory)**, 
чтобы создать **Конкретный продукт (ConcreteProduct)**.

## 6.2. Шаги реализации паттерна

1. *Проверка наличия в задаче множества классов реализующих один интерфейс*

2. *Создание Базового продукта*

Базовый продукт описывает общие методы для всех продуктов.

3. *Создание Конкретных продуктов*

Конкретные продукты реализует свою логику.

4. *Создание Простой фабрики*

Простая фабрика создает продукты.

## 6.3. Применимость паттерна

1. *Когда нужно создавать однотипные объекты*
2. *Когда нужно вынести логику по созданию объектов*

## 6.4. Плюсы и минусы применения паттерна

### 6.4.1. Плюсы применения паттерна

Плюсы применения паттерна **Простая Фабрика (Factory)**:

* скрытие логики по созданию от клиента

### 6.4.2. Минусы применения паттерна

Минусы применения паттерна **Простая Фабрика (Factory)**:

* при добавлении новых типов конкретных продуктов метод по созданию может стать очень громоздким
* нет контроля за процессом создания объектов 

## 6.5. Применение паттерна в автотестах

### 6.5.1. Фабрика драйверов (WebDriverFactory)

#### 6.5.1.1. До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    // Драйвер браузера
    protected static WebDriver driver;
    // Логгер
    private Logger logger = LogManager.getLogger(WithoutPOJOTest.class);
  
    // Перед каждым тестом
    @BeforeEach
    public void setUp() {
        // Получаем параметр запуска тестов через Maven -Dbrowser
        String browser = System
                .getProperty("browser", "chrome")
                .toLowerCase();
        // Получаем экземпляр драйвера браузера
        switch(browser) {
            case "chrome":
                driver = new ChromeDriver();
            case "firefox":
                driver = new FirefoxDriver();
            case "edge":
                driver = new EdgeDriver();
        }
        logger.info("Драйвер стартовал!");
        driver.get("https://github.com/login");
    }
  
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
  
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

#### 6.5.1.2. После применения паттерна

1. *Перечисление наименований браузеров - BrowserName*

*Пример*

```java
// Имена браузеров
public enum BrowserName {
    CHROME("chrome"),   // Google Chrome
    FIREFOX("firefox"), // Mozilla Firefox
    EDGE("edge");       // Microsoft Edge

    private String browserName; // Имя браузера

    // Приватный конструктор
    private BrowserName(String browserName) {
        this.browserName = browserName;
    }

    // Переопределенный метод toString()
    @Override
    public String toString() {
        return String.valueOf(this.browserName);
    }

    // Возврат константы по строковому значению константы
    public static BrowserName fromString(String browserName) {
        if (browserName != null) {
            for(BrowserName b : BrowserName.values()) {
                if (browserName.equalsIgnoreCase(b.browserName)) {
                    return b;
                }
            }
        }
        return null;
    }

    // Получение имени браузера
    public String getBrowserName() {
        return this.browserName;
    }
}
```

2. *Класс создания драйвера браузера "Google Chrome" - ChromeBrowser*

*Пример*

```java
// Драйвера браузера "Google Chrome"
public class ChromeBrowser {
    // Получение экземпляра драйвера браузера "Google Chrome"
    public static WebDriver getDriver() {
        // Настройка файла драйвера
        WebDriverManager.chromedriver().setup();
    
        // Опции драйвера:
        ChromeOptions options = new ChromeOptions();
        // - поведение при появлении алертов "Игнорирование"
        options.setCapability(CapabilityType.UNEXPECTED_ALERT_BEHAVIOUR, UnexpectedAlertBehaviour.IGNORE);
        // - стратегия загрузки страницы "NORMAL"
        options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.NORMAL);
        // - режим "Инкогнито"
        options.addArguments("--incognito");
        // - режим "Полный экран"
        options.addArguments("--start-fullscreen");
    
        // Новый экземпляр драйвера
        return new ChromeDriver(options);
    }
}
```

3. *Класс создания драйвера браузера "Mozilla Firefox" - FirefoxBrowser*

*Пример*

```java
// Драйвера браузера "Mozilla Firefox"
public class FirefoxBrowser {
    // Получение экземпляра драйвера браузера "Mozilla Firefox"
    public static WebDriver getDriver() {
        // Настройка файла драйвера
        WebDriverManager.firefoxdriver().setup();
    
        // Опции драйвера:
        FirefoxOptions options = new FirefoxOptions();
        // - поведение при появлении алертов "Игнорирование"
        options.setCapability(CapabilityType.UNEXPECTED_ALERT_BEHAVIOUR, UnexpectedAlertBehaviour.IGNORE);
        // - стратегия загрузки страницы "NORMAL"
        options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.NORMAL);
        // - режим "Инкогнито"
        options.addArguments("-private");
        // - режим "Полный экран"
        options.addArguments("-kiosk");
    
        // Новый экземпляр драйвера
        return new FirefoxDriver(options);
    }
}
```

4. *Класс создания драйвера браузера "Microsoft Edge" - EdgeBrowser*

*Пример*

```java
// Драйвера браузера "Microsoft Edge"
public class EdgeBrowser {
    // Получение экземпляра драйвера браузера "Microsoft Edge"
    public static WebDriver getDriver() {
        // Настройка файла драйвера
        WebDriverManager.edgedriver().setup();
    
        // Опции драйвера:
        EdgeOptions options = new EdgeOptions();
        // - поведение при появлении алертов "Игнорирование"
        options.setCapability(CapabilityType.UNEXPECTED_ALERT_BEHAVIOUR, UnexpectedAlertBehaviour.IGNORE);
        // - стратегия загрузки страницы "NORMAL"
        options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.NORMAL);
        // - режим "Инкогнито"
        options.addArguments("--incognito");
        // - режим "Полный экран"
        options.addArguments("--start-fullscreen");
    
        // Новый экземпляр драйвера
        return new EdgeDriver(options);
    }
}
```

5. *Класс фабрика по созданию экземпляров драйвера браузера - WebDriverFactory*

*Пример*

```java
// Фабрика по созданию экземпляров драйвера браузера
public class WebDriverFactory {
    // Логгер
    private static Logger logger = LogManager.getLogger(WebDriverFactory.class);
  
    // Получение экземпляра драйвера по имени
    public static WebDriver getDriver(BrowserName name) {
        switch (name) {
            // Драйвер браузера Google Chrome
            case CHROME:
                logger.info("Драйвер браузера Google Chrome");
                return ChromeBrowser.getDriver();
            // Драйвер браузера Mozilla Firefox
            case FIREFOX:
                logger.info("Драйвер браузера Mozilla Firefox");
                return FirefoxBrowser.getDriver();
            // Драйвер браузера Microsoft Edge
            case EDGE:
                logger.info("Драйвер браузера Microsoft Edge");
                return EdgeBrowser.getDriver();
            // По умолчанию
            default:
                throw new RuntimeException("Некорректное наименование браузера");
        }
    }
}
```

6. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    // Драйвер браузера
    protected static WebDriver driver;
    // Логгер
    private Logger logger = LogManager.getLogger(LoginTest.class);
  
    // Перед каждым тестом
    @BeforeEach
    public void setUp() {
        // Получаем параметр запуска тестов через Maven -Dbrowser
        String browser = System
                .getProperty("browser", "chrome")
                .toLowerCase();
        // Получаем экземпляр драйвера браузера
        driver = WebDriverFactory.getDriver(browser);
        logger.info("Драйвер стартовал!");
        driver.get("https://github.com/login");
    }
  
    @Test
    public void loginTest() {
        // Arrange
        String login = "diman_the_red_devil@mail.ru";
        String password = "JAKARTA12345rex-";
        Account account = new Account(
                new Login(login),
                new Password(password)
        );
        account.setMobilePhone(new MobilePhone("89064067898"));
        account.setFullName(new FullName("Тестов Тест Тестович"));
        account.setDateOfBirth(new Date("01-01-2000"));
        String expected = "Dashboard";
  
        // Act
        HomePage homePage = getPageAfterLogin(account);
    
        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }
  
    public HomePage getPageAfterLogin(Account account) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(account);
    }
    ...
}
```

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)