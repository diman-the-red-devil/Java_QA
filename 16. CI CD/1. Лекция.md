Java_QA / 16. CI CD

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* []()
* []()
* []()
* []()

***

# 1. Жизненный цикл разработки ПО (Software Development LifeCycle (SDLC))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Жизненный цикл разработки ПО (Software Development LifeCycle (SDLC))*** - период времени, 
который начинается с момента принятия решения о необходимости создания программного продукта 
и заканчивается в момент его полного изъятия из эксплуатации.

Этапы **SDLC**:

1. **Идея** 
2. **Требования** отвечает на вопрос *Какие проблемы требуют решений?*
3. **Планирование** отвечает на вопрос *Что мы хотим сделать?*
4. **Проектирование** отвечает на вопрос *Как мы добьемся наших целей?*
5. **Разработка** регулирует процесс создания продукта
6. **Тестирование** регулирует обеспечение качественной работы продукта
7. **Развертывание** регулирует использование финального продукта
8. **Поддержка**
9. **Закрытие**

## 1.1. Этап 1. Идея

Разработка любой системы или ПО начинается с генерации идей для решения какой-то конкретной проблемы пользователя.

## 1.2. Этап 2. Требования

На этом этапе “идея” принимает более осмысленный и конкретный вид.

Это, пожалуй самый ответственный и важный из всех шагов к созданию успешной программной системы. 
Вся собранная информация используется для планирования базового проектного подхода.

Для определения начальных требований к продукту привлекаются эксперты из разных областей: 
заказчики, клиенты, специалисты разных отделов (продаж, разработки, аналитики, тестирования и т.п.), эксперты по схожим продуктам.

Как только базовый анализ требований будет выполнен, 
следующим шагом будет четкое определение и документирование требований к продукту, утверждение со стороны клиента. 
Если одной из целей первого этапа является понимание и анализ требований, 
то на этом этапе все цели должны быть прописаны, это защита обеих сторон.

Бизнес-аналитики (BA) прорабатывают полученную информацию, детализируют ее и преобразовывают в технические требования к системе. 
Эти требования называются Software Requirement Specification (SRS).

Кроме SRS на этом этапе:

Определяются требования к качеству (SQA, Software Quality Attributes)
Проводится анализ рисков (RA, Risk Analysis)
Создаются планы валидации и верификации (V&V Plans, Test Plans)
Определяются критерии приемки ПО (AC, Acceptance Criteria)

## 1.3. Этап 3. Планирование

## 1.4. Этап 4. Проектирование

SRS это ориентир для разработчиков, чтобы предложить лучшую архитектуру для продукта. 
Обычно предлагается несколько подходов к проектированию архитектуры продукта. 
Все предложенные подходы документируются в спецификации DDS (Design Document Specification) и выбирается наилучший подход к проектированию. 
Данный подход очень четко определяет все архитектурные модули продукта, а также его связь с внешними и сторонними модулями.

На этапе дизайна системы архитекторы ПО создают “скелет” проекта основываясь на требованиях. 
Они определяют используемые технологии, инструменты, рабочие процессы, взаимосвязи между разными частями проекта, структуры баз данных, потоки данных и т.п.

В итоге определяется спецификация по дизайну (Design Document Specification, DDS) с описанием что и как нужно делать с технической точки зрения.

DDS может состоять их двух частей — высокоуровневый дизайн (High-Level Design, HLD) и низкоуровневый дизайн (Low-Level Design, LLD).

## 1.5. Этап 5. Разработка

Весь программный код, новые модули и фичи разрабатываются на основании DDS. 
Чем лучше написана эта документация, тем быстрее будет идти имплементация. На этом этапе подключается команда разработчиков. 
Написанный код должен покрываться Unit-тестами, а взаимодействие новых фич с другими модулями тестироваться с помощью интеграционных тестов. 
Эти активности выполняются именно командой разработчиков, а не QA специалистами.

Разработчики получают требования (SRS), спецификацию по дизайну (DDS) и создают требуемое ПО.

Качество требований напрямую влияет на стоимость и продолжительность разработки. 
Чем хуже требования, тем больше ошибок нужно будет исправить, следовательно, увеличиваются незапланированные расходы.

## 1.6. Этап 6. Тестирование

Именно тестирование, в основном, затрагивает все этапы жизненного цикла. 
Дефекты продукта регистрируются, отслеживаются, исправляются и повторно тестируются. 
Это происходит до тех пор, пока продукт не достигнет стандартов качества, которые прописаны в SRS. 
На данном этапе в процесс разработки подключается команда мануальных тестировщиков или автоматизаторы.

По завершению этого этапа вы должны будете в состоянии обеспечить рабочее состояние продукта.

Тестировщики, основываясь на требованиях (SQA, SRS, DDS) и готовом продукте производят проверку качества ПО (Quality Control).

Если находятся отклонения от требований / ошибки — они оформляются в виде отчетов о дефектах, исправляются и перепроверяются.

Процесс продолжается до тех пор, пока качество продукта не будет доведено до приемлемого уровня.

## 1.7. Этап 7. Развертывание

После успешного тестирования готовый продукт передается заказчику.

Кроме передачи может производится настройка рабочих окружений, установка, конфигурация и запуск продукта.

## 1.8. Этап 8. Поддержка

Как только продукт протестирован, он выходит в релиз. 
Иногда внедрение происходит поэтапно, в соответствии с бизнес-стратегией. 
Продукт сначала может быть выпущен в ограниченном сегменте и протестирован в реальной бизнес-среде, это UAT-тестирование (User Acceptance Testing). 
Затем, основываясь на отзывах, продукт может быть выпущен как есть, или с предлагаемыми улучшениями. 
После того, как продукт выпущен на рынок его обслуживание выполняется для существующей клиентской базы, и на этом этапе подключаются Support-команды.

После запуска продукта он начинает развиваться, изменяться, дополняться новыми функциями.

Поддержку можно представить как повторяющуюся цепочку шагов 
“Определение новых требований” -> “Разработка” -> “Тестирование” -> “Развертывание”.

Эта часть жизненного цикла является самым длительным и важным этапом разработки ПО.

Без наличия процессов и стандартов разработки, рабочих процедур, порядка в документации, 
налаженной коммуникации и регрессионных тестов разработка очень быстро превращается в кошмар с микро-менеджментом, 
постоянно не закрывающимися задачами, кучей багов, огромным техническим долгом, развалом команды или проекта.

Именно на этом этапе умирает большинство стартапов.

## 1.9. Этап 9. Закрытие

Закрытие — последний этап жизни ПО. На нем происходит вывод продукта из эксплуатации, его замена на современные аналоги, либо новые версии.

Как пример, можно вспомнить браузер Internet Explorer (был замен на Edge) или Windows XP (заменена на Windows 7).

***

# 2. Модели разработки ПО 

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)


## Agile Development

***Agile Development*** - это общий термин для нескольких итеративных и дополнительных методологий разработки программного обеспечения. 
Наиболее популярные гибкие методологии включают Scrum, Kanban, Scaled Agile Framework® (SAFe®), Lean Development и Extreme Programming (XP).

Хотя каждая из гибких методологий уникальна в своем конкретном подходе, все они имеют общее видение и основные ценности (см. Agile Manifesto). 
Все они в основном включают в себя итерацию и непрерывную обратную связь, которую он обеспечивает для последовательной доработки и предоставления программной системы. 
Все они включают непрерывное планирование, непрерывное тестирование, непрерывную интеграцию и другие формы непрерывного развития как проекта, 
так и непосредственно программного обеспечения. Все они легкие, особенно по сравнению с традиционными процессами в стиле водопада, 
и по своей природе легко адаптируются. И что самое важное в гибких методах, так это то, что все они нацелены на то, 
чтобы дать людям возможность сотрудничать и быстро и эффективно принимать совместные решения.

В начале гибкие команды состояли в основном из разработчиков. 
Поскольку эти гибкие команды являлись более эффективными в производстве программного обеспечения, 
стало ясно, что обеспечение качества (QA) и разработка в качестве раздельных команд было неэффективным. 
В результате команды Agile стали включать в себя QA, чтобы увеличить скорость доставки программного обеспечения, 
и теперь Agile снова растет, чтобы охватить участников доставки и поддержки и расширить гибкость разработки ПО от идеи до доставки.

***

# 3. Проблемы

До попадания к пользователям программный продукт проходит несколько этапов. 
Аналитики собирают и анализируют требования заказчиков, формулируют постановку задач.
Разработчик пишет код. Затем отдельная команда QA тестирует программу в изолированной среде разработки, 
если код соответствует требованиям качества, передает его в следующую команду для дальнейшего развертывания.
Группы развертывания далее заливают приложение на боевой сервер.

Проблема этой парадигмы заключается в том, что когда команды работают отдельно:

Dev часто не знает о контрольно-пропускных пунктах QA и Ops, которые мешают программе работать должным образом.

QA и Ops, как правило, работают со множеством функций и не имеют большого представления о бизнес-целях и ценности программного обеспечения.

Каждая команда может иметь цели, противоречащие целям других команд, 
которые могут привести к неэффективности и дать возможность указывать пальцем на коллег из другого отдела, когда что-то идет не так.

## 3.1. Много действий при передаче на тестирование

Разработчик устанавливает у себя на машине все необходимое: язык программирования, 
на котором будет вестись разработка, например PHP 7.0, базу данных, MySQL 5.7 и веб-сервер, Apache. 
Какая операционная система и какие версии библиотек и зависимостей будут установлены на сервере, неизвестно.

После того как нужная функциональность приложения реализована, требуется ее протестировать.
Программист упаковывает в архив свой код, копию базы данных, 
информацию о требуемом ПО и инструкцию по установке всего необходимого для запуска и работы приложения. 
После этого он передает архив тестировщику.

QA-специалист устанавливает все необходимое на тестовый стенд, разворачивает приложение и принимается тестировать.
Если в процессе тестирования появляется новая версия разработки, то приходится повторять процедуру. 
Разработчику нужно снова создать архив, передать тестировщику; а тому, в свою очередь, снова развернуть приложение.

В результате таких многократно повторяющихся процедур ошибки наслаиваются, и QA- специалисту приходится дважды перепроверять одни и те же баги.

## 3.2. Несовместимость версий в тестовой среде и на сервере заказчика

После того как ручное тестирование прошло удачно и решено переносить приложение на боевой сервер, 
системный администратор подготавливает новый или уже существующий сервер. Программист заливает туда приложение, и тут начинаются проблемы.

Версия языка программирования может отличаться от той, на которой велась разработка. 
Могут различаться версии базы данных. И даже сама система управления базами данных может быть другой. 
И это не говоря о том, что пути до файлов и каталогов в коде самого приложения различаются, 
так как приложение на боевом сервере находится совершенно в другом месте, нежели на машине разработчика.

В итоге при использовании на продакшне другого веб-сервера приходится настраивать приложение заново. 
А это дополнительное время.

***

# 4. DevOps

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***DevOps*** – подход, методология и даже культура и философия процесса разработки.

***DevOps*** – набор практик, нацеленных на активное взаимодействие специалистов по разработке 
со специалистами по информационно-технологическому обслуживанию и взаимную интеграцию их рабочих процессов друг в друга. 

**DevOps** помогает разработчикам, тестировщикам и системным администраторам работать быстрее и эффективнее за счёт автоматизации и бесшовности.

Термин **DevOps** был популяризован серией встреч «DevOps Days», прошедших в 2009 году в Бельгии. 
Одной из наиболее важных теоретических работ по DevOps считается книга Патрика Дюбуа, Джина Ким, Джеза Хамбл и Джона Уиллис «Руководство по DevOps. 
Как добиться гибкости, надежности и безопасности мирового уровня в технологических компаниях», 
впервые опубликованная на английском языке в 2016 году. 
К этому основателей нескольких софтверных компаний и независимых ИТ-консультантов подтолкнул накопленный опыт работы в крупных проектах.

Однако само понятие **DevOps** зародилось в начале 2000-х годов, 
когда в ИТ-мире больших корпораций возникла проблема рассогласования рабочих процессов, 
при которой нормальная работа программного продукта нарушена из-за функционального и организационного разделения тех, 
кто пишет код, и тех, кто выполняет его развертывание и поддержку. 
У разработчиков и специалистов по эксплуатации продукта часто бывают разные и даже противоречащие друг другу цели, 
руководители подразделений и ключевые показатели эффективности. 
Рабочие места разнопрофильных участников жизненного цикла ПО зачастую располагаются в разных локациях. 
Такая разрозненность и нарушение коммуникации внутри компании приводит к удлинению сроков решения задач, 
сверхурочной работе, сорванным релизам и недовольству клиентов.

Концепция **DevOps** предлагает решать эту проблему с помощью приложения принципов **Agile** не только к разработке и тестированию, 
но и к процессам эксплуатации ПО, т.е. к развертыванию и поддержке. Таким образом, популярность **DevOps** возникла, 
в том числе благодаря распространению Agile-практик, 
ориентированных на ускорение процессов поставки готового продукта и увеличение количества выпускаемых версий. 
Кроме того, дополнительным драйвером развития девопс стала **микросервисная архитектура**, 
когда система состоит из набора отдельных слабосвязанных модулей, 
реализация каждого из которых находится в зоне ответственности одного человека, который разрабатывает, тестирует и развертывает ПО. 
Благодаря небольшому размеру каждого модуля (сервиса), его архитектура может создаваться путем непрерывного рефакторинга, 
что уменьшает трудоемкость предварительного проектирования и позволяет постоянно выпускать новые релизы программного продукта.

ИТОГ

**DevOps** позиционируется как Agile-подход для устранения организационных и 
временных барьеров между командами разработчиков и других участников жизненного цикла ПО (тестировщиками, администраторами, техподдержкой), 
чтобы они могли быстрее и надежнее собирать, тестировать и выпускать релизы программных продуктов.

Подход помогает снизить ошибки при передаче проекта от разработчиков к тестировщикам и сисадминам и наладить между ними взаимодействие. 
В основе лежит идея, что разработка, тестирование и эксплуатация цифровых продуктов — это единый, бесшовный и циклический процесс.

Сама по себе тема DevOps довольно объемная. Это автоматизация процессов подготовки инфраструктуры как для разработки, 
так и для тестирования приложения, а также для его эксплуатации. Сюда же входят автоматизация деплоя и мониторинг.

Наиболее ярко DevOps раскрывается при разработке приложения с применением микросервисной архитектуры.

## 4.1. Цели

* Улучшение частоты развертывания
* Сокращение времени для выхода на рынок
* Снижение частоты отказов новых релизов
* Сокращение времени выполнения исправлений
* Уменьшение количества времени на восстановления при сбое новой версии или других случаях отключения текущей системы

## 4.2. Задачи

* Согласование процессов разработки и поставки ПО с эксплуатацией
* Автоматизация процессов разработки, тестирования и развертывания
* Непрерывное тестирование качества приложений
* Управление ИТ-инфраструктурой как кодом
* Управление изменениями
* Непрерывный мониторинг производительности приложений и состояния инфраструктуры

ИТОГ

Таким образом, DevOps нацелен на предсказуемость, эффективность, безопасность и ремонтопригодность операционных процессов, 
а также регулярную поставку надежно работающего продукта, его обновлений и обслуживания.

## 4.3. Процессы

**DevOps**, как и другие Agile-практики, ориентирован на командную работу, 
где рассматриваются все аспекты жизненного цикла ПО, от программного кода до эксплуатации продукта конечным пользователем:

* Code (Код) – разработка и анализ, контроль версий и слияния кода;
* Build (Сборка) – непрерывная интеграция различных сборок;
* Test (Тест) – непрерывное тестирование, обеспечивающее обратную связь по бизнес-рискам;
* Operate (Работа с пакетами) – репозиторий артефактов, предварительная установка приложения;
* Release (Выпуск) – управление изменениями, официальное утверждение выпуска, автоматизация выпуска;
* Deploy (Развертывание конфигурации) – управление инфраструктурой как кодом;
* Monitor (Мониторинг) – мониторинг производительности приложений, опыт работы с конечным пользователем.

## 4.4. Кому и для чего применять

**Разработчикам** 

Позволит сконцентрироваться на коде приложения и не задумываться об инфраструктуре, которая будет на продакшне.

**Тестировщикам** 

Предоставит больше простора в тестировании приложения на разных конфигурациях систем и с разным набором библиотек.

**Системным администраторам** 

Снимет с них работы по развертыванию и мониторингу приложения.

**Бизнесу в цифровой среде** 

Поможет быстрее адаптировать продукт под запросы рынка, выпускать новые версии и улучшать пользовательский опыт клиентов.

## 4.5. Инструментарий DevOps

* Управление версиями: Subversion, Git
* Виртуализация и контейнеризация: Docker, Kubernetes
* Управление конфигурацией серверов: Ansible, Chef, Puppet
* Непрерывная интеграция и доставка (CI/CD): GitLab, Jenkins, TeamCity, Drone
* Автоматизация сборки: Ant, Maven, Gradle
* Автоматизация тестирования: JUnit, Selenium, Cucumber
* Сбор данных для мониторинга: Prometheus, Telegraf, LogStash
* Отображение собранных данных: Grafana, Kibana, Zabbix
* Мониторинг ошибок: Sentry, Rollbar.

***

# 5. CI CD

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Непрерывная интеграция, доставка и развертывание (CI/CD или CI/CDL/CDP)*** — одна из практик **DevOps**, 
подразумевающая набор принципов предназначенных для повышения удобства, частоты и 
надежности развертывания изменений программного обеспечения или продукта.
Другими словами, это технологии, воплощающие принципы DevOps.

**CI/CD** относится к **Agile**-практикам и позволяет разработчикам уделять внимание реализации бизнес-требований, качеству кода и безопасности продукта.

Основная идея - создание автоматизированного конвейера поставки продукта заказчику/потребителю за счёт автоматизации процессов.

* чекина изменений в репозиторий
* статического анализа кода: на уязвимости, на соответствие требованиям/стандартам
* компиляции и формирования билда (сборки)
* всех необходимых тестов (unit, smoke, acceptance, regression, integration, end-to-end)
* заведения в СУП issue в случае ошибок
* обратной связи об успехе/неудаче в виде отчётов о билде и уведомлений по выбранным каналам
* слияния изменений с основной веткой в случае "зелёных" тестов
* деплоя на dev/test/staging/prod

Зачем это нужно?

Раньше разработчики одной команды могли в течение долгого времени работать изолированно и
объединяли свои изменения с основной частью проекта только по завершении собственной работы.
Это делало слияние кода сложной и трудоемкой задачей,
к тому же ошибки накапливались и не исправлялись в течение долгого времени.
Такие факторы затрудняли быструю доставку обновлений пользователям.

## 5.1. Непрерывная интеграция (Continuous integration (СI))

***Непрерывная интеграция (Continuous integration (СI))*** – практика разработки программного обеспечения,
состоящая из следующих этапов:

1. публикация изменений программного кода в центральном репозитории (Git)

После того как разработчик сделал определенный функционал, он отправляет код в репозиторий.
Для этого изменения из ветки фичи сливаются в ветку dev | master

2. компиляция и сборка новой версии ПО (Maven, Gradle)

Проект компилируется и собирается. 

3. прогон модульных, интеграционных тестов (JUnit)

Выполняется запуск юнит тестов.

4. подсчет покрытия кода тестами (JaCoCo)

Выполняется подсчет покрытия кода тестами.

5. статический анализ кода (SonarQube)

Выполняется проверка на говнокод.

6. обратная связь об успехе/неудаче в виде отчетов и уведомлений (Allure Reports, Report Portal, Slack)

Если какой-либо из этапов завершился неудачно, разработчик получит оповещение.

Польза:

*Более продуктивная разработка*

Непрерывная интеграция повышает производительность вашей команды 
за счет освобождения разработчиков от ручной работы и стимуляции подходов, 
которые помогают уменьшить количество ошибок и дефектов в версиях ПО для конечных пользователей.

*Быстрое обнаружение и устранение ошибок*

За счет более частого и всестороннего тестирования ваша команда сможет выявлять 
и устранять ошибки заблаговременно, до того, как они перерастут в серьезные проблемы.

*Быстрая доставка обновлений*

Непрерывная интеграция дает возможность вашей команде быстрее и чаще доставлять обновления конечным пользователям.

## 5.2. Непрерывная доставка (Continuous Delivery (CDL))

***Непрерывная доставка (Continuous Delivery (CDL))*** – практика разработки программного обеспечения,
состоящая из следующих этапов:

1. этапы CI
2. поставка готовой сборки новой версии ПО на стенды (Ansible, Docker, Kubernetes)

Для подготовки серверов используются инструменты наподобие **Ansible**.
Они позволяют быстро настроить окружение, в котором приложение будет работать в автоматическом режиме. 
На это тратится несколько минут, а не несколько часов.

Для единообразия окружения используем инструмент **Docker**.

Если процесс сборки и юнит тестирования прошел успешно, приложение разворачивается на стендах:

* стенд для проведения функционального тестирования
* стенд для проведения нагрузочного тестирования
* стенд для проведения приемочного тестирования

3. прогон разных автотестов (Selenium WD, REST Assured)

Специалист по QA проводит ручное тестирование либо тестирование с применением инструментов вроде Selenium —
для автоматизации действий веб-браузера в случае веб-приложения.

4. обратная связь об успехе/неудаче в виде отчетов и уведомлений (Allure Reports, Report Portal, Slack)

Даже если во время ручного тестирования возникли какие-либо ошибки, разработчик быстро вносит правки и выкатывает обновление. 
Даже если нужно повторять процедуру, это происходит быстро.

После успешного тестирования принимается решение о релизе, после чего достаточно нажать одну кнопку, чтобы выпустить новый релиз в продакшн.
DevOps-инженер также проводит работы по так называемому незаметному деплою, когда конечные пользователи даже не подозревают о том, что вышла новая версия.

Польза:

*Автоматизация процесса выпуска ПО*

Непрерывная доставка позволяет вашей команде автоматически выполнять сборку, 
тестировать и подготавливать изменения кода к запуску в рабочей среде, 
что обеспечивает более эффективную и быструю доставку ПО.

*Более продуктивная разработка*

Применение практики непрерывной доставки повышает производительность вашей команды 
за счет освобождения разработчиков от ручной работы и стимуляции подходов, 
которые помогают уменьшить количество ошибок и дефектов в развертываниях для конечных пользователей.

*Быстрое обнаружение и устранение ошибок*

За счет более частого и полного тестирования ваша команда сможет выявлять и устранять ошибки заранее, 
до того, как они перерастут в серьезные проблемы. 
Непрерывная доставка позволяет упростить дополнительное тестирование вашего кода за счет автоматизации всего процесса.

*Быстрая доставка обновлений*

Непрерывная доставка дает вашей команде возможность доставлять обновления конечным пользователям быстрее и чаще. 
При правильном внедрении непрерывной доставки у вас всегда будет готовый к развертыванию собранный экземпляр ПО, 
прошедший стандартизированную процедуру тестирования.  

Непрерывная доставка является одним из основополагающих принципов разработки современных приложений, 
поскольку расширяет практику непрерывной интеграции за счет того, что все изменения кода после стадии сборки развертываются в тестовой и/или в рабочей среде. 
При правильном внедрении у разработчиков всегда будет готовый к развертыванию собранный экземпляр ПО, прошедший стандартизированную процедуру тестирования.

## 5.3. Непрерывное развертывание (Continuous Deployment (CDP))

***Непрерывное развертывание (Continuous Deployment (CDP))***– практика разработки программного обеспечения,
состоящая из следующих этапов:

* этапы CDL
* развёртывание изменений в Пром

Отличие непрерывной доставки от непрерывного развертывания заключается в том, 
что при непрерывной доставке для развертывания обновлений в рабочей среде требуется подтверждение вручную. 
При непрерывном развертывании это происходит автоматически без специального подтверждения.

***

## 5.4. Профиты

Итого

При работе с CI/CD мы имеем:

* *Сокращение действий для деплоя до одного клика.*
* *Снижение рисков появления потенциальных ошибок.*
* *Автоматизация модульных и регрессионных тестов.*
* *Щепетильный контроль качества кода.*
* *Контейнеризация приложений и исключение различий среды разработки со средой выполнения.*
* *Возможность моментального отката версии приложения при возникновении критических ситуаций.*
* *Общее сокращение времени разработки на 10-20%.*

***

# 6. Автотесты в CI CD

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Задача непрерывной интеграции и развертывания (CI/CD) — 
позволить командам разработчиков часто выпускать пользователям работающее ПО, 
таким образом принося им пользу и узнавая, как продукт используется в реальном мире. 
Чтобы не отставать от конкурентов, многие компании начали использовать практику DevOps.

Однако давление бизнеса с целью ускорить доставку не должно негативно сказываться на качестве производимого продукта. 
Пользователи могут ратовать за новые возможности, однако они ожидают, 
что ПО продолжит функционировать и останется стабильным. 
Именно поэтому надежное тщательное тестирование, которое позволило бы вам быть уверенными в новых сборках, — 
необходимая часть практики непрерывной интеграции и доставки.

Тесты дают нам уверенность в качестве нашего ПО и давно стали частью процесса разработки. 
При каскадной разработке ручное тестирование (или стадия QA) выполнялось уже после того, 
как код был написан и интегрирован, с целью проверить, соответствует ли поведение приложения спецификациям или нет.

Такой линейный подход замедляет процедуру релиза. Работает ли новый код, разработчик узнает с большой задержкой, 
когда поверх этого кода уже появится много всего другого. 
Процесс CI/CD, напротив, использует гибкий подход с короткими итеративными циклами, 
обеспечивающими быструю обратную связь и позволяющими часто выпускать небольшие обновления. 
Ключевой составляющей этих коротких итеративных циклов являются тесты — 
автоматическая проверка того, работает ли новый код и не ломает ли он ничего вокруг.

Непрерывная интеграция предполагает регулярные коммиты изменений в основную ветку (master), 
которые запускают сборку и тестирование приложения. 
Чтобы получить максимум пользы от CI, члены команды должны делать коммиты хотя бы раз в день. 
Однако даже если у вас не так много разработчиков, чтобы тестировать эти изменения вручную, 
вам понадобится внушительное количество тестировщиков, 
которые будут вынуждены постоянно выполнять одну и ту же работу. 
Именно поэтому появляется автоматизированное тестирование.

Автоматизация идеально подходит в случае повторяющихся задач. 
Она обеспечивает большую консистентность, чем ручное тестирование, 
так как люди всегда рискуют упустить детали или же допустить различия при повторном выполнении одних и тех же шагов.

Мало того, что автоматизированные тесты быстрее ручных, — их также можно запускать параллельно. 
При наличии необходимой инфраструктуры вы можете выполнить масштабирование и впоследствии экономить время. 
Написание автоматизированных тестов требует времени, 
однако возможность делать регулярные коммиты и гораздо чаще выпускать продукт действительно стоит того.

Автоматизированное тестирование освободит вас от ряда скучных повторяющихся задач, 
но это не значит, что вам больше не нужны будут тестировщики. 
Помимо выявления и приоритизации тест-кейсов, тестировщики также участвуют в написании автоматизированных тестов, 
зачастую совместно с разработчиками. 
Кроме того, тестировщикам остаются те тесты, которые невозможно автоматизировать (мы еще вернемся к этому).

Непрерывная интеграция и непрерывная поставка нуждаются в непрерывном тестировании, 
поскольку конечная цель — разработка качественных приложений. 
Непрерывное тестирование часто реализуется в виде набора различных автоматизированных тестов 
(регрессионных, производительности и других), которые выполняются в CI/CD-конвейере.

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)