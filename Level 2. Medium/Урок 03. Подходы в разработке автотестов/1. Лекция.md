Java_QA / Level 2. Medium - Продвинутые темы / Урок 03. Подходы в разработке автотестов

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

Любой современный софт, включая веб-ориентированные приложения, тестируется на наличие ошибок. 
Скорость идентификации этих ошибок зависит не только от инструментов, 
количества тестировщиков и их опыта, но и от выбранного подхода.

# 1. Подходы в разработке ПО

Существуют следующие подходы в разработке ПО:

1. Разработка через тестирование (Test Driven Development (TDD))
2. 

## 1.1. Разработка через тестирование (Test Driven Development (TDD))

***Разработка через тестирование (Test Driven Development (TDD))*** - подход в разработке ПО, 
предполагающий сначала написание тестов основанных на требованиях к ПО, с помощью которых ПО многократно проверяется, 
а потом уже программный код, достаточный для выполнения этих тестов.

**Разработка через тестирование (Test Driven Development (TDD))** — по сути, практика написания точных спецификаций, 
которые могут быть автоматически проверены до написания кода.

**Тесты** — это лучшие спецификации, потому что они не лгут. 
Они не скажут вам после двух недель мучения с кодом «я имел в виду совершенно не это». 
Тесты, если они правильно написаны, либо успешно выполняются, либо терпят неудачу.
Тесты недвусмысленно указывают, что именно должно происходить при определенных обстоятельствах.

[Кент Бек](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D0%BA,_%D0%9A%D0%B5%D0%BD%D1%82) -
[Кент Бек - Экстремальное программирование. Разработка через тестирование](https://www.litres.ru/kent-bek/ekstremalnoe-programmirovanie-razrabotka-cherez-testirovanie/)

### 1.1.1. Описание

**Разработка через тестирование (Test Driven Development (TDD))** основывается на повторении коротких циклов разработки.

Каждый цикл состоит из этапов:

1. *Написание кода теста*

На этом этапе занимаются написанием кода теста, покрывающий желаемое поведение системы и 
проверяющий корректность работы ещё ненаписанного кода.

Добавление каждой новой функциональности (**feature**) в программу начинается с написания теста.
Тест содержит проверки условий, которые могут либо выполняться, либо нет.
Прохождение теста подтверждает поведение, предполагаемое программистом.

На практике тесты покрывают критические и нетривиальные участки кода. Это может быть:

* код, подверженный частым изменениям
* код, от работы которого зависит работоспособность большого количества другого кода
* код с большим количеством зависимостей

2. *Запуск тестов - новые тесты не проходят (Red)* - 

На этом этапе проверяют, что новые написанные тесты не проходят.

Новый тест не будет проходить, поскольку соответствующий код ещё не написан.

3. *Написание кода ПО*

На этом этапе пишется новый код, который реализует желаемое поведение системы и позволит пройти написанный тест. 

Этот код не обязательно должен быть идеален. 
Допустимо, чтобы он проходил тест каким-то неэлегантным способом. 
Это приемлемо, поскольку последующие этапы улучшат и отполируют его.
Важно писать код, предназначенный именно для прохождения теста. 
Не следует добавлять лишней и, соответственно, не тестируемой функциональности.

4. *Запуск теста - новые тесты проходит (Green)*

На этом этапе проверяют, что новые написанные тесты проходят.

Если все тесты проходят, программист может быть уверен, что код удовлетворяет всем тестируемым требованиям (старым и новым).

Если все тесты не проходят, то написание кода продолжается (этап 2).

5. *Рефакторинг (Refactoring)*

Требуемая функциональность уже достигнута. На этом этапе может быть проведен рефакторинг кода.

***Рефакторинг*** — процесс изменения внутренней структуры программы, 
не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы, 
устранить дублирование кода, облегчить внесение изменений в ближайшем будущем.

Основные проблемы требующие рефакторинга:

* дублирование кода 
* длинный метод 
* большой класс 
* длинный список параметров 
* «жадные» функции (метод, который чрезмерно обращается к данным другого объекта) 
* избыточные временные переменные 
* классы данных 
* несгруппированные данные 
* и т.д

Рефакторинг написанного кода проводится с постоянной проверкой прохождения тестов.

6. *Повторение цикла*

Описанный цикл повторяется снова и снова, реализуя всё новую и новую функциональность.
Шаги следует делать небольшими, от 1 до 10 изменений между запусками тестов. 
Если новый код не удовлетворяет новым тестам или старые тесты перестают проходить, 
программист должен вернуться к отладке.

![TDD](_Files/1.%20TDD,%20BDD,%20ETC/01.png "TDD")

Названия цветов относятся к пользовательскому интерфейсу популярного автоматического запуска теста **JUnit**, 
где красная полоса указывает на то, что тест не пройден, а зеленая полоса указывает на то, что тест прошел успешно.

### 1.1.2. Плюсы 

1. *Раннее обнаружение багов*

Потенциальные критические баги могут быть найдены еще на начальном этапе разработки ПО.

2. *Хорошее покрытие функционала ПО тестами*

Разработка через тестирование сосредотачивается на тестировании отдельно взятых модулей.
Всё, что программа должна делать, проверяется тестами.

3. *Упрощение программной реализации*
   
Можно быть абсолютно уверенным, в том, что не пишется никакого ненужного кода, 
поскольку нужно будет писать код только для прохождения тестов.

4. *Сокращение времени на разработку и отладку ПО*

В то время как общее количество строк кода увеличивается (из-за тестов), 
частое тестирование исключает ошибки в процессе и выявляет существующие намного раньше, 
предотвращая возникновение проблем в дальнейшем.

5. *Повышение стабильности работы ПО*

Все основные функциональные возможности программы покрыты тестами и их работоспособность постоянно проверяется.

6. *Улучшение сопровождаемости ПО*

Разработчики могут не бояться вносить изменения в код, 
если что-то пойдёт не так, то об этом сообщат результаты автоматического тестирования.

7. *Использование тестов в качестве документации к коду ПО*

Хороший код расскажет о том, как он работает, лучше любой документации. 
Документация и комментарии в коде могут устаревать. 
Это может сбивать с толку разработчиков, изучающих код. 
А так как документация, в отличие от тестов, не может сказать, что она устарела, 
такие ситуации, когда документация не соответствует действительности — не редкость.

### 1.1.3. Минусы

1. *Наличие задач, которые невозможно (по крайней мере, на текущий момент) решить только при помощи тестов*

В частности, TDD не позволяет механически продемонстрировать адекватность разработанного кода 
в области безопасности данных и взаимодействия между процессами.

2. *Сложность применения в тех случаях, когда для тестирования необходимо прохождение функциональных тестов*

Примерами может быть: разработка интерфейсов пользователя, программ, работающих с базами данных, 
а также того, что зависит от специфической конфигурации сети.

3. *Увеличение времени на разработку и поддержку тестов*

Хотя время, затрачиваемое на предварительную генерацию тестов, экономится позднее в жизненном цикле разработки. 
Тем не менее, для подготовки и написания тестов требуется значительное время. 
Его многие разработчики предпочитают потратить на написание нового кода или рефакторинг существующего.

4. *Возможное падение контроля качества*

Большое количество используемых тестов может создать ложное ощущение надежности, 
приводящее к меньшему количеству действий по контролю качества.
В то же время тесты написанные с ошибками неизбежно приведут к ошибкам в разрабатываемом ПО.

## 1.2. Разработка через поведение (Behaviour Driven Development (BDD))

***Разработка через поведение (Behaviour Driven Development (BDD))*** - подход в разработке ПО, 
предполагающий написание тестовых сценариев (обычно выражающих поведение программного продукта и 
ожидаемые результаты в терминах, понятных неспециалисту) на понятном предметно-ориентированном языке, 
основу которого представляют конструкции из естественного языка.

Благодаря чему достигается совмещение в процессе разработки чисто технических интересов и интересов бизнеса, 
позволяя тем самым управляющему персоналу и программистам говорить на одном языке.
Это даёт возможность ускорить процесс получения обратной связи, убрав традиционные барьеры.
То есть описание пользовательских сценариев происходит на естественном языке — грубо говоря, на языке бизнеса.

[Три амиго](https://habr.com/ru/company/tinkoff/blog/449424/)

Три точки зрения (называемые триадой), необходимые, для четкого определения поведения решения:

1. *Клиентоориентированные заинтересованные лица* 

Понимают потребности клиентов и бизнеса, их пожелания и насколько они осуществимы.

2. *Заинтересованные лица, ориентированные на разработку* 

Понимают возможности решения и технологическую осуществимость.

3. *Заинтересованные лица, ориентированные на тестирование*

Видят исключения, граничные случаи и ограничительные условия для нового поведения системы.

![Три амиго](_Files/1.%20TDD,%20BDD,%20ETC/02.png "Три амиго")

Вместе эта группа достигает согласованности в том, что именно нужно создавать, чтобы уменьшить количество ошибок и переделок и ускорить поток ценностей.

**Разработка через поведение (Behaviour Driven Development (BDD))** - по сути является разновидностью (расширением) TDD
в том смысле, что перед тем как написать какой-либо тест, необходимо сначала описать желаемый результат от 
добавляемой функциональности на предметно-ориентированном языке и только после того как это будет проделано, 
конструкции этого языка переводятся специалистами или специальным программным обеспечением в описание теста.

[Ден Норт](https://dannorth.net/)
[Ден Норт - Introducing BDD](https://dannorth.net/introducing-bdd/)
[Ден Норт - Введение в программирование через поведение (BDD)](https://habr.com/ru/post/216923/)

### 1.2.1. Описание

**Разработка через поведение (Behaviour Driven Development (BDD))** ориентирована на поведение сущности,
которую тестируют, в то время как в TDD основной фокус идёт непосредственно на сам код.

Тесты для некоторой единицы программного обеспечения должны быть описаны с точки зрения желаемого поведения. 
Под желаемым поведением здесь понимается такое, которое имеет ценность для бизнеса. 
Описание желаемого поведения даётся с помощью спецификации поведения (Behavioral Specification).

Спецификация поведения строится в полуформальной форме. 
В настоящее время в практике BDD устоялась следующая структура:

1. *Заголовок (Title)* - в сослагательной форме должно быть дано описание бизнес-цели
2. *Описание (Narrative)* - в краткой и свободной форме должны быть раскрыты следующие вопросы:

* кто является заинтересованным лицом данной истории?
* что входит в состав данной истории?
* какую ценность данная история предоставляет для бизнеса?

3. *Сценарии (Scenarios)* в одной спецификации может быть один и более сценариев, каждый из которых раскрывает 
одну из ситуаций поведения пользователя, тем самым конкретизируя описание спецификации

Каждый сценарий обычно строится по одной и той же схеме:

* начальные условия (**Givens**)
* событие, инициирующее начало сценария (**Whens**)
* ожидаемый результат(ы) (**Thens**)

![BDD](_Files/1.%20TDD,%20BDD,%20ETC/03.png "BDD")

BDD не предоставляет каких-либо формальных правил, но настаивает на том, чтобы использовался 
ограниченный стандартный набор фраз, который включал бы все элементы спецификации поведения. 
В 2007 году **Дэном Нортом** был предложен шаблон для спецификации, 
который получил популярность и впоследствии стал известен как язык **Gherkin**.

Полуформальный формат спецификации поведения требует использования ограниченного набора предложений, 
о которых управляющий персонал и разработчики должны предварительно договориться. 
Исходя из этого, фреймворки для поддержки BDD строятся по следующим принципам:

1. Парсер может разбить спецификацию по её формальным частям, например по ключевым словам языка Gherkin. 
На выходе мы получаем набор предложений, каждое из которых начинается с ключевого слова.
2. Каждое предложение может выражать один шаг теста.
3. Некоторые части предложения могут являться входными параметрами, которые можно захватить, 
а остальные части могут никак не использоваться и служить только для понимания действия человеком. 
Обычно для такого захвата используется процессор регулярных выражений. 
Захваченные параметры могут быть конвертированы и отправлены на вход конкретной исполняющей функции.
На этом принципе строятся такие фреймворки как **JBehave** и **RBehave**, которые основаны на языке **Gherkin**. 
Некоторые фреймворки строятся по аналогии, например **CBehave** и **Cucumber**.

Этапы:

1. *Определение функциональности с точки зрения бизнеса*

Задание на понятном нам языке, что хочет бизнес увидеть от функциональности разрабатываемого ПО.

*Пример*

```text
Функция: Показать имя авторизованного пользователя

Войдя в систему как пользователь "Username"
Я хочу видеть в заголовке страницы текст "Здравствуйте, Username!"
```

2. *Написание сценария по шагам*

Сценарий с использованием специальной нотации (**Gherkin**). 

*Пример*

```text
Сценарий: Показать приветствие авторизованному пользователю
Дано: Я вошел в систему как пользователь "Username"
Когда: Я посетил страницу
Тогда: В заголовке страницы отображается текст "Здравствуйте, Username!"
```

3. *Реализация определения шагов*

Написание кода по взаимодействию с системой, на который мапятся шаги сценария.
Таким образом BDD фреймворк (**Cucumber**) сможет интерпретировать каждый шаг, 
вычленить с помощью регулярных выражений параметры и запустить соответствующие тесты.

*Пример*

```text
Дано("Я вошел в систему как пользователь \"{string}\"")
public void ...
```

4. *Запуск тестов - новые тесты не проходят*

5. *Написание кода ПО*

6. *Запуск тестов - новые тесты проходят*

7. *Рефакторинг (Refactoring)*

8. *Повторение цикла*

![BDD](_Files/1.%20TDD,%20BDD,%20ETC/04.png "BDD")

### 1.2.2. Плюсы

1. *Вовлечение всех заинтересованных лиц в написание сценариев*

Использование понятного языка для написания сценариев способствует тому, 
что сценарии могут читать и писать Product Owner, аналитики или другие заинтересованные лица.
Так в написании сценариев участвуют все (представители бизнеса, аналитики, разработчики и тестировщики), 
то формируется общее понимание ожидаемого поведения разрабатываемой системы.

2. *Независимость тестовых сценариев от реализации*

Так как сами сценарии пишутся на естественном языке и не зависят от реализации шагов сценария, 
то миграция на другой язык программирования сильно упрощается - нужно просто переписать шаги. 
Также упрощается поддержка тестовых сценариев в случае изменения реализации системы - нужно просто отредактировать шаги.
Сценарии могут измениться только в случае изменения требований.

3. *Поощрение автоматизации тестирования*

BDD подход изначально был направлен на внедрение автоматизации - пишем сценарии и сразу автотесты к ним.

4. *Снижение количества потенциальных дефектов*

Фокусировка на поведении системы с точки зрения пользователей позволяет проводить приемочное автотматизированное тестирование, 
В случае, если система не будет удовлетворять спецификациям, то автотесты не пройдут.

7. *Всегда актуальная структурированная документация*

BDD подход совместно с инженерными практиками позволит отказаться от legacy-документации, 
содержащей неактуальную информацию, и получать новую документацию налету, 
хранить ее вместе с проектом, что приблизило бы аналитиков и тестировщиков к коду.

### 1.2.3. Минусы

1. *Долго и дорого по сравнению с другими методами*

BDD неудобен хотя бы тем, что требует привлечения специалистов тестирования уже на этапе проработки требований, 
а это удлиняет цикл разработки. Выходом из этой ситуации может оказаться выбор подходящего 
BDD фреймворка и правильно выстроенных процессов разработки.

Поддержка сценариев и тестов также требует времени и усилий, которые в некоторых проектах могут считаться накладными.

2. *Бесполезность в случае неучастия всех заинтересованных сторон*

В случае, если в написании сценариев BDD участвует только тестировщик, 
то это только дополнительные затраты времени на разработку и поддержку сценариев.

3. *Необходимость внедрения с самого старта проекта*

BDD не имеет пользы, если внедрение началось в середине процесса разработки. 
Это только заставит выполнить дополнительную работы для уже готовых частей проекта. 
Модернизация сценариев и тестов для устаревшего кода практически невозможна и не имеет смысла.

## 1.3. TDD VS BDD

| Критерий        | TDD                         | BDD                           |
|-----------------|-----------------------------|-------------------------------|
| Фокус           | Код, Реализация             | Поведение системы, Требования |
| Стартовая точка | Тест кейс                   | Пользовательская история      |
| Участники       | Разработчики, тестировщики  | Все + бизнес                  |
| Документация    | Раздельная                  | Спеки=Тест кейсы=Автотесты    |
| Язык            | Язык программирования       | Общеупотребительный язык      |
| Тестирование    | Модульное                   | Интеграционное Е2Е Системное  |
| Автотесты       | Отдельным этапом            | На всех этапах                |

При этом оба подхода отлично дополняют друг друга.

![BDD](_Files/1.%20TDD,%20BDD,%20ETC/05.png "BDD")

## 1.4. Прочие X Driven Development

1. *Разработка на основе типов (Type Driven Development (TDD))* - 
типы данных и сигнатуры типов являются спецификацией программы

2. *Предметно-ориентированное проектирование (Domain Driven Design (DDD))* -
создание программных абстракций, которые называются моделями предметных областей

3. *Разработка на основе функциональности (Features Driven Development (FDD))* -
функциональность (свойства) разрабатываемого программного обеспечения

4. *Разработка на основе моделей (Model Driven Development (MDD))* -
основная бизнес-логика содержится в диаграммах и 
не сковывает рамками выбора языка программирования и инструментов разработки

5. 

***

# 2. Подходы в разработке тестов

## 2.1. Тестирование, управляемое данными (Data Driven Testing (DDT))

***Тестирование, управляемое данными (Data Driven Testing (DDT))*** - подход, при котором тестовые данные хранятся отдельно от тест-кейсов, 
(в файле либо в базе данных). Такое разделение логически упрощает тесты.

Часто покрываемая система, или метод являются очень сложными, и тогда невозможно ввести явно эталонные значения, 
здесь можно говорить об эталонных выходных состояниях. Бывает, нужно применить смекалку, чтобы понять, 
что же будет входным описанием, а что будет выходным. 

Чтобы проверка приложения была успешна, потребуются разные комбинации данных.

### Описание

При использовании подхода **Тестирование, управляемое данными (Data Driven Testing (DDT))** 
тест умеет принимать набор входных параметров, и эталонный результат или эталонное состояние, 
с которым он должен сравнить результат, полученный в ходе прогонки входных параметров.

Для реализации подхода **Тестирование, управляемое данными (Data Driven Testing (DDT))** 
необходимо наличие хранилища данных - файлы **.xls**, **.csv**, **.xml**, **.json** либо база данных. 

Этапы:

1. *Извлечение части тестовых данных из хранилища*

Чтение файлов, запрос к БД.

2. *Использование данных тестовым сценарием*

Ввод данных в форму на UI, подстановка данных в методы или передача данных в запросы API.

3. *Проверка и сохранение результатов для последующего анализа*

Получение результатов на UI, от API или методов.
Проверка и сравнение с эталонными значениями.

4. *Продолжение тестирования со следующим набором входных данных*

![DDT](_Files/1.%20TDD,%20BDD,%20ETC/06.jpg "DDT")

### Плюсы

1. *Раздельное хранение кода тестов и тестовых данных*

Возможность ввода входных значений и эталонного результата в виде, удобном для всех ролей на проекте – 
начиная от мануального тестировщика и заканчивая менеджером (тест менеджером) проекта.
Это может быть Excel файл либо CSV файл.

Подготовка эталонных тестовых данных любым членом команды.

2. *Прогон тестов в нескольких средах с большими наборами данных*

### Минусы

1. *Качество теста зависит от навыков автоматизации команды разработчиков*

Если в приложении сложная логика, которая проверяется на наборе комбинаций входных параметров, 
то от тех кто подготавливает тестовые наборы, требуется высокая квалификация в области применения техник тест дизайна.

2. *Затраты на подготовку данных*

Подготовка данных может занять некоторое время.

3. *Затраты на проверку*

Проверка данных - трудоемкая задача при тестировании большого количества данных.

3. *Больше документации*

В основном связано с управлением скриптами, инфраструктурой тестирования и результатами тестирования.

## 2.2. Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))

***Тестирование, управляемое ключевыми словами (Keyword Driven Testing (KDT))*** - подход, основанный на 
использовании ключевых слов, описывающих набор действий, нужных для выполнения конкретного шага тестового сценария.

### 2.2.1. Описание

При таком подходе в первую очередь определяется набор ключевых слов,
а только после этого ассоциируется функция либо действие, связанное с данным ключевым словом.
Например, каждые шаги теста, такие как щелчок мышью, нажатие клавиши,
открытие либо закрытие браузера описываются определёнными ключевыми словами («открыть» — openbrowser, «нажать» — click и т. п.).

Этапы разработки KDT-тестов:
1. Определяем ключевые слова.
2. Реализуем ключевые слова как исполняемые файлы.
3. Создаём тест-кейсы.
4. Создаём скрипты.
5. Выполняем автоматизированные сценарии.
6. 
### 2.2.2. Плюсы

1. функциональные тестировщики могут планировать автоматизацию тестирования до того, как приложение будет готово;
2. тесты можно разработать без знаний программирования;
3. подход не зависит от выбранного языка программирования.

### 2.2.3. Минусы

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)