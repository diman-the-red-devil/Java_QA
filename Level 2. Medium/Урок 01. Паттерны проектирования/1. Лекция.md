Java_QA / Level 2. Medium - Продвинутые темы / Урок 01. Паттерны проектирования

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

***Шаблон проектирования или паттерн*** в разработке программного обеспечения — 
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Обычно паттерн не является законченным образцом, который может быть прямо преобразован в код. 
Это лишь пример решения задачи, который можно использовать в различных ситуациях. 
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, 
без определения того, какие конечные классы или объекты приложения будут использоваться.

**Паттерны** - это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. 
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

***

# 2. Зачем нужны паттерны в тестах?

Проблем в автоматизации и разработке множество, и сталкиваясь с этими проблемами, люди формулировали паттерны. 
Изначально классические паттерны были сформулированы давным-давно четверкой, которая выпустила книгу **Design Patterns**.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире. 
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, пополняясь новыми паттернами.
Сегодня просматривается тенденция появления подобных паттернов в других областях, в которых накопилась проблематика.

Основными драйверами практически всех паттернов в автоматизации тестирования являются **факторы**: 

* *надежность*
* *понятность*
* *гибкость*
* *поддерживаемость*
* *стабильность*
* *другие факторы, которые важны в тестах*

Большая часть этих факторов находится под влиянием разделения концепции.
В любом тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три **компонента**: 

* *тестовая логика*
* *тестовые данные*
* *техническая часть* (отвечающая за непосредственное взаимодействие с приложением - вызов функций, клики на экран и т. п.)

Если эти **компоненты** хорошо разделены, тесты начинают хорошо попадать в выше упомянутые **факторы**, 
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

Все паттерны можно поделить на группы:

* *паттерны данных*
* *технические паттерны*
* *структурные паттерны*  
* *бизнес паттерны*

***

# 3. Паттерны данных

***Паттерны данных*** - паттерны, которые разделяют данные и логику тестирования.

а также уменьшить дублирование кода в тестах.
Это должно сделать их более понятными и простыми в обслуживании для всех, кто с ними работает.

## 3.1. Паттерн Value Object

***Value Object*** - паттерн, представляющий 

### 3.1.1. Проблема

Необходимо передавать в метод в качестве параметра множество примитивных значений за раз.  

сделать ваш код более читабельным 
значительно сократить количество повторяемых конструкций

### 3.1.2. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried, List<String> accomplishments) {
    enter(firstName, into("name"));
    enter(lastName, into("lastName"));
    enter(age, into("age"));
    enterMaritalStatus(isMarried);
    accomplishments.forEach(this::addAccomplishment);
}
```

### 3.1.3. После применения паттерна

*Пример*

```java
public void createUser(User user) {
    enter(user.firstName, into("name"));
    enter(user.lastName, into("lastName"));
    enter(user.age, into("age"));
    enterMaritalStatus(user.isMarried);
    user.accomplishments.forEach(this::addAccomplishment);
}
```

https://www.tutorialspoint.com/design_pattern/transfer_object_pattern.htm
https://habr.com/ru/post/268371/
https://martinfowler.com/eaaCatalog/dataTransferObject.html
http://design-pattern.ru/patterns/data-transfer-object.html
https://habr.com/ru/post/513072/
https://www.javaguides.net/2018/08/data-transfer-object-design-pattern-in-java.html
https://medium.com/swlh/value-objects-to-the-rescue-28c563ad97c6

***

## 3.2. Паттерн Builder

***Builder*** - паттерн,

### 3.2.1. Проблема

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и с помощью современных IDE подсказок более интуитивно понятным.

### 3.2.2. До применения паттерна

*Пример*

```java

```

### 3.2.3. После применения паттерна



*Пример*

```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

Вначале создается специальный объект ServerBuilder, после чего его можно настроить до создания фактического объекта Server.
При этом только метод сборки возвращает фактический объект Server, другие возвращают исходный ServerBuilder для дальнейшей настройки.

Под капотом это выглядело бы примерно так:

*Пример*

```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}

```

В приведенном выше примере все параметры имеют значения по умолчанию при создании ServerBuilder,
Это означает, что пользователь может создать объект Server без необходимости ничего настраивать.
Это также можно изменить, если мы хотим, чтобы у нашего объекта были обязательные настраиваемые поля.
В этом случае я выбрасываю исключение, говоря, что объект не полностью настроен.

https://habr.com/ru/company/otus/blog/552412/
https://refactoring.guru/ru/design-patterns/builder/java/example
https://www.softwaretestinghelp.com/design-patterns-in-java/#Builder_Pattern_In_Java

## 3.3. Паттерн Assert Object/Matchers

***Assert Object/Matchers*** - паттерн,

### 3.3.1. Проблема

### 3.3.2. До применения паттерна

*Пример*

```java
@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
List<Response> responses = server.getResponses();
assertEquals(1, responses.size());
Response response = responses.get(0);
assertEquals(ResponseCode.ERROR_403, response.getCode());
}
```

### 3.3.3. После применения паттерна

Большинство людей слышали о следующем паттерне, но я видел лишь несколько человек, которые действительно его использовали.
Его имя - «Утвердить объект» или просто Matcher.
Обычно его можно использовать всякий раз, когда нам нужно сделать утверждения, специфичные для предметной области, для некоторого объекта. Давайте посмотрим на пример ниже:

*Пример*

```java


@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
assertThat(server).hadSingleResponseWithCode(
ResponseCode.ERROR_403);
}

public static ServerAssert assertThat(Server server) {
return new ServerAssert(server);
}

public class ServerAssert {
private final Server server;
public ServerAssert(Server server) {
this.server = server;
}

public void hadSingleResponseWithCode(ResponseCode
responseCode) {
List<Response> responses = server.getResponses();
assertEquals(1, responses.size());
Response response = responses.get(0);
assertEquals(responseCode, response.getCode());
}
}

```

В исходном примере мы не видим очевидной логики проверок в тесте.
Пользователю может быть непонятно, что именно будет проверяться.
Сначала мы проверяем, что сервер возвращает только один ответ, а затем проверяем, что ответ содержит код ошибки 403.
Мы должны разделить эти проверки на два отдельных утверждения, потому что в противном случае было бы трудно понять, что пошло не так.
Но для того, кто не знаком с нашей предметной областью, все равно будет сложно понять такой тест.

Шаблон соответствия помогает нам создавать утверждения в виде многоразовых конструкций, что сокращает общее дублирование кода.
Например, если нам нужно убедиться, что сервер возвращает один ответ, но с кодом ответа 200.

Кроме того, этот подход создает логику предметной области в наших тестах.
Вот почему я предпочитаю реализовать его так, как показано выше, когда мы создаем группу утверждений и объединяем их в отдельный класс (например, ServerAssert),
который отвечает за все возможные проверки объекта Server.
Затем все, что нам нужно сделать, это создать статический метод assertThat, принимающий объект Server и возвращающий вместо него ServerAssert.
Он выглядит великолепно и его можно читать намного проще, чем раньше, а код утверждения внизу остается прежним.

Другой вариант создания сопоставителей - создание статических методов для каждого из них.
Существует несколько библиотек, которые уже содержат множество готовых к использованию сопоставителей и предоставляют простой в использовании API для создания ваших собственных.
Самые популярные из них - Hamcrest и AssertJ.
Если вы не использовали их раньше, я предлагаю хотя бы обратить на них внимание и подумать о том, чтобы встроить их в свой фреймворк.
Опять же, у них не будет сопоставителей для вашего домена, но они могут значительно упростить их создание.

https://www.mikulskibartosz.name/assert-object-pattern/

***

## 3.4. Паттерн Data Registry

***Data Registry*** - паттерн,

### 3.4.1. Проблема

### 3.4.2. До применения паттерна

*Пример*

```java

```

### 3.4.3. После применения паттерна

Интересен следующий паттерн. Основной подход заключается в следующем: мы хотим, чтобы наши тесты были независимыми и
попробуем разделить наши тестовые данные по ним, но в результате мы получим полную противоположность.
Например, в тесте A используются user1, user2 и user3, и они жестко запрограммированы как тестовые данные.
Это может быть проблемой, поскольку нам нужны полностью независимые тесты, верно?
Но мы заставляем другой тест знать, что user1, user2 и user3 уже заняты тестом A.
Другая проблема заключается в том, что разработчик, не знакомый с этим, может использовать этих пользователей в других тестах, и это может вызвать проблемы.

Реестр данных позволяет нам генерировать уникальные данные и избегать дублирования.
В приведенном ниже примере я использую самый простой из возможных подходов:
при каждом вызове getUser статический потокобезопасный счетчик будет увеличиваться на 1,
гарантируя, что каждый раз создается уникальный пользователь.

*Пример*

```java
public static class UserRegistry {
    private static AtomicInteger COUNTER = new AtomicInteger(0);
    
    public static getUser() {
        int index = COUNTER.incrementAndGet();
        return new User("User_" + index, index);
    }
}

```

В вашем случае логика шаблона может быть намного сложнее, например. реестр может брать пользователя из базы данных, файла, предопределенного набора данных и т. д.
Но результат будет таким же: ваши тесты будут по-настоящему независимыми, поскольку каждый раз, когда они используют UserRegistry, они получают эксклюзивного пользователя, избегая проблем с перехватом тестов.

***

## 3.5. Паттерн Object Pool/Flyweight

***Object Pool/Flyweight*** - паттерн,

### 3.5.1. Проблема

### 3.5.2. До применения паттерна

*Пример*

```java

```

### 3.5.3. После применения паттерна

Следующий паттерн используют еще меньше разработчиков.
Легковес - это классический паттерн из книги GoF, который решает проблему сохранения и работы с тяжелыми с точки зрения ресурсов объектами или набором объектов.
Вместо того, чтобы создавать их каждый раз, когда они нам нужны, мы берем их, используем и возвращаем в так называемый пул для использования в будущем.

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

Используя этот паттерн, мы могли бы реализовать много интересного, например, пул браузеров.
Я слышал тихие жалобы от разных людей, что веб-тесты занимают безумно много времени,
потому что они требуют запуска браузера, загрузки первой страницы, импорта профилей пользователей и т. д.
Но необязательно создавать браузер в реальном тесте, вместо этого мы могли бы использовать фоновый пул, который настроен на сохранение необходимого количества «горячих» браузеров.
Закончив работу с браузером, мы просто возвращаем его в пул и очищаем его данные.
И это может быть сделано в фоновом режиме, параллельно с фактическими тестовыми потоками.
И только после того, как браузер снова будет готов к использованию, его можно будет вернуть на следующий тест в качестве нового экземпляра.

Тем не менее, эта конфигурация пула и настройки браузера могут быть исключены из теста,
значительно минимизируя затрачиваемое на это время и ресурсы.

Другой пример - использование страницы. Вам не нужно ждать, пока откроется нужная страница,
если все тесты начинаются с одной страницы. Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать, пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных. Вместо того, чтобы работать с реальной базой данных,
мы можем запустить необходимое количество контейнеров базы данных на разных портах (это можно сделать с помощью Docker или другого инструмента виртуализации)
и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. Д.

https://habr.com/ru/post/88393/
https://refactoring.guru/design-patterns/flyweight
https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-2/2.2-flyweight.html
https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern

## 3.6. Паттерн Data Provider

***Data Provider*** - паттерн,

### 3.6.1. Проблема

### 3.6.2. До применения паттерна

*Пример*

```java

```

### 3.6.3. После применения паттерна

Поставщик данных - один из наиболее широко используемых шаблонов данных среди инженеров-тестировщиков.
Если вы хотите реализовать тесты на основе данных и хотите запустить одну и 
ту же логику тестирования для нескольких наборов данных,
вы можете загружать данные из внешних источников (таких как Excel или таблица CVS), 
удаленных служб или жестко закодировать их на месте.

*Пример*

```java
@DataProvider
private static Object[][] testDataProvider() {
    try {
        return ReadExcelSheet.getTableArray("src/main/resources/TestData.xls");
    } catch (Exception e) {
        return null;
    }
}
```

Это можно сделать так, как я показал выше, 
путем чтения из источника и возврата нетипизированных данных (простой массив массивов или строк).
Но современный подход заключался бы в использовании шаблона Value Object, 
о котором мы говорили ранее, и предоставлении данных в терминах сущностей.

*Пример*

```java
@DataProvider
private static Iterator<Object[]> devices() {
    return asList(
        new Object[] { new Device("iPhone X", Platform.IOS, "11.2") },
        new Object[] { new Device("iPhone 7 Plus", Platform.IOS, "10.3") },
        new Object[] { new Device("Google Pixel 2", Platform.ANDROID, "8.0") }  
    ).iterator();
}

@Test(dataProvider = "devices")
public void pageShouldBeOpenedOnDevice(Device device) {
    startDevice(device);
    // some test steps
}
```

Вам нужно пометить свой метод аннотацией dataProvider или сделать его параметризованным с помощью JUnit и 
заставить его возвращать набор данных для использования в тесте. Остальное (синтаксический анализ и итерация) 
будет выполняться фреймворком, все, что вам нужно сделать, - это использовать данные, как в обычном тесте.

Важно, чтобы мы использовали оба шаблона (поставщик данных и объект значения) в одном подходе, 
поскольку это помогло нам избежать передачи нескольких параметров методу и сделать код более чистым и читаемым.

Мне нравится использовать шаблоны данных в своей автоматизации, 
они помогают мне поддерживать работоспособность кода и максимально оптимизировать управление ресурсами. 
Если вас интересуют другие шаблоны, которые могут помочь вам в написании чистых и надежных тестов, 
ознакомьтесь с другими моими сообщениями:

https://www.devbridge.com/articles/top-design-pattern-test-automation-frameworks/
https://antony-s-smirnov.medium.com/how-to-use-the-data-provider-pattern-in-the-project-ea12430d9275

***

# 4. Технические паттерны

The main goal of Technical Patterns is to encapsulate technical details from test logic, providing extra low-level control over them.

## 4.1. Паттерн Decorator

***Decorator*** - паттерн,

### 4.1.1. Проблема

### 4.1.2. До применения паттерна

*Пример*

```java

```

### 4.1.3. После применения паттерна

Decorator is a very well-known pattern, since it was mentioned in the GoF list and discussed in many other programming books and articles. 
The example of this one is simple. Let’s imagine you’re working with any driver implementation (e.g. WebDriver) and are willing to add an extra functionality to it, like logging or caching. But in the same time you don’t wanna reveal that additional functionality to your actual tests, leaving test logic the same as it was before. That’s where you want to use Decorator.

Decorator helps to implement so called “Cabbage principle”, when you are able to wrap one driver implementation into another, in the way cabbage leaves are formed. Your tests won’t be aware of that extra layer since they work with the same interface as before.

For instance, you want to log every click on some element in your tests. All you need to do is to decorate your initial WebDriver object, by wrapping it into the EventFiringWebDriver and registering new listener, while your tests don’t have to be changed at all:

*Пример*

```java
new EventFiringWebDriver(driver)
    .register(new AbstractWebDriverEventListener() {
        @Override 
        public void afterClickOn(WebElement element, WebDriver driver) {
            LOG.log(Level.INFO, "Click on element " + element.getTagName());
        }
    }
);
```

## 4.2. Паттерн Proxy

***Proxy*** - паттерн,

### 4.2.1. Проблема

### 4.2.2. До применения паттерна

*Пример*

```java

```

### 4.2.3. После применения паттерна

*Пример*

```java

```

Proxy is the pattern that allows to intervene into the process running between you and another user, introducing new logic in-between without affecting either of the sides.

This pattern might be useful when you, for example, want to add logging, to enable or to disable something, to have control over some additional recourses etc. The most popular method of using it in tests is to set up the HTTP proxy. It allows to dynamically enable and disable host blacklists, excluding or stubbing the third-party sites like Facebook or Twitter in your tests. Sometimes it’s the only way you can check some exceptional scenarios for the external services like those ones.

https://habr.com/ru/company/jugru/blog/338836/

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)