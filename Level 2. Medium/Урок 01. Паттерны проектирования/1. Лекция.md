Java_QA / Level 2. Medium - Продвинутые темы / Урок 01. Паттерны проектирования

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

***Шаблон проектирования или паттерн*** в разработке программного обеспечения — 
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Обычно паттерн не является законченным образцом, который может быть прямо преобразован в код. 
Это лишь пример решения задачи, который можно использовать в различных ситуациях. 
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, 
без определения того, какие конечные классы или объекты приложения будут использоваться.

**Паттерны** - это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. 
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

***

# 2. Зачем нужны паттерны в тестах?

Проблем в автоматизации и разработке множество, и сталкиваясь с этими проблемами, люди формулировали паттерны. 
Изначально классические паттерны были сформулированы давным-давно четверкой, которая выпустила книгу **Design Patterns**.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире. 
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, пополняясь новыми паттернами.
Сегодня просматривается тенденция появления подобных паттернов в других областях, в которых накопилась проблематика.

Основными драйверами практически всех паттернов в автоматизации тестирования являются **факторы**: 

* *надежность*
* *понятность*
* *гибкость*
* *поддерживаемость*
* *стабильность*
* *другие факторы, которые важны в тестах*

Большая часть этих факторов находится под влиянием разделения концепции.
В любом тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три **компонента**: 

* *тестовая логика*
* *тестовые данные*
* *техническая часть* (отвечающая за непосредственное взаимодействие с приложением - вызов функций, клики на экран и т. п.)

Если эти **компоненты** хорошо разделены, тесты начинают хорошо попадать в выше упомянутые **факторы**, 
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

Все паттерны можно поделить на группы:

* *порождающие паттерны*
* *структурные паттерны*
* *паттерны данных*
* *технические паттерны*
* *бизнес паттерны*

***

# 3. Порождающие паттерны

https://www.baeldung.com/java-creational-design-patterns

## 3.1. Паттерн Data Transfer Object

***Data Transfer Object*** - паттерн, представляющий собой класс, содержащий данные без какой-либо логики для работы с ним.
По сути это простой класс.

### 3.1.1. Проблема

Необходимо передавать в метод в качестве параметра множество примитивных значений за раз.

### 3.1.2. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age));
    isMarried.check(isMarried);
}
```

### 3.1.3. После применения паттерна

#### Реализация

*Пример*

```java
class User {
    String firstName;
    String lastName;
    int age;
    boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

#### Применение

*Пример*

```java
public void createUser(User user) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age));
    isMarried.check(isMarried);
}
```

## 3.2. Паттерн Singleton

***Singleton*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

### 3.2.1. Проблема

### 3.2.2. До применения паттерна

*Пример*

```java

```

### 3.2.3. После применения паттерна

#### Реализация

*Пример*

```java

```

#### Применение

*Пример*

```java

```

https://refactoring.guru/ru/design-patterns/singleton
http://design-pattern.ru/patterns/singleton.html
https://www.tutorialspoint.com/design_pattern/singleton_pattern.htm
https://java-design-patterns.com/patterns/singleton/
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja
https://metanit.com/sharp/patterns/2.3.php

## 3.3. Паттерн Factory Method

***Factory Method*** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

### 3.3.1. Проблема

### 3.3.2. До применения паттерна

*Пример*

```java

```

### 3.3.3. После применения паттерна

#### Реализация

*Пример*

```java

```

#### Применение

*Пример*

```java

```

https://refactoring.guru/ru/design-patterns/factory-method
http://design-pattern.ru/patterns/factory-method.html
https://javadevcentral.com/factory-method
https://www.tutorialspoint.com/design_pattern/factory_pattern.htm
https://java-design-patterns.com/patterns/factory/
https://javanerd.ru/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4/
https://www.journaldev.com/1392/factory-design-pattern-in-java
https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://metanit.com/sharp/patterns/2.1.php

## 3.4. Паттерн Abstract Factory

***Abstract Factory*** — паттерн, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.

### 3.4.1. Проблема

### 3.4.2. До применения паттерна

*Пример*

```java

```

### 3.4.3. После применения паттерна

#### Реализация

*Пример*

```java

```

#### Применение

*Пример*

```java

```

https://refactoring.guru/ru/design-patterns/abstract-factory
http://design-pattern.ru/patterns/abstract-factory.html
https://javadevcentral.com/abstract-factory-pattern
https://www.tutorialspoint.com/design_pattern/abstract_factory_pattern.htm
https://java-design-patterns.com/patterns/abstract-factory/
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b0%d0%b1%d1%81%d1%82%d1%80%d0%b0%d0%ba%d1%82%d0%bd%d0%b0%d1%8f-%d1%84%d0%b0%d0%b1%d1%80%d0%b8%d0%ba%d0%b0/
https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java
https://javarush.ru/groups/posts/2379-patternih-proektirovanija-abstractfactory
https://metanit.com/sharp/patterns/2.2.php

## 3.5. Паттерн Builder

***Builder*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

### 3.5.1. Проблема

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и с помощью современных IDE подсказок более интуитивно понятным.

### 3.5.2. До применения паттерна

*Пример*

```java

```

### 3.5.3. После применения паттерна

#### Реализация

*Пример*

```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

    public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}
```

#### Применение

*Пример*

```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

https://refactoring.guru/ru/design-patterns/builder
http://design-pattern.ru/patterns/builder.html
https://javadevcentral.com/builder-design-pattern
https://www.tutorialspoint.com/design_pattern/builder_pattern.htm
https://java-design-patterns.com/patterns/builder/
https://www.journaldev.com/1425/builder-design-pattern-in-java
https://metanit.com/sharp/patterns/2.5.php
https://habr.com/ru/company/otus/blog/552412/

https://www.softwaretestinghelp.com/design-patterns-in-java/#Builder_Pattern_In_Java

***

# 4. Структурные паттерны

The main goal of Technical Patterns is to encapsulate technical details from test logic, providing extra low-level control over them.

## 4.1. Паттерн Decorator

***Decorator*** - паттерн, который позволяет динамически добавлять объектам новую функциональность, 
оборачивая их в полезные «обёртки»

### 4.1.1. Проблема

Декоратор - очень известный шаблон, поскольку он упоминался в списке GoF и
обсуждался во многих других книгах и статьях по программированию.
Пример этого прост. Представим, что вы работаете с какой-либо реализацией драйвера
(например, WebDriver) и хотите добавить к ней дополнительные функции, такие как ведение журнала или кеширование.
Но в то же время вы не хотите раскрывать эту дополнительную функциональность в ваших реальных тестах,
оставляя логику тестирования такой же, как и раньше. Вот где вы хотите использовать Decorator.

Декоратор помогает реализовать так называемый «принцип капусты»,
когда вы можете обернуть одну реализацию драйвера в другую, как образуются капустные листья.
Ваши тесты не будут знать об этом дополнительном слое, поскольку они работают с тем же интерфейсом, что и раньше.

Например, вы хотите регистрировать каждый щелчок по какому-либо элементу в ваших тестах.
Все, что вам нужно сделать, это украсить ваш исходный объект WebDriver,
заключив его в EventFiringWebDriver и зарегистрировав нового слушателя, при этом ваши тесты вообще не нужно менять:

### 4.1.2. До применения паттерна

*Пример*

```java

```

### 4.1.3. После применения паттерна

#### Реализация

*Пример*

```java
new EventFiringWebDriver(driver)
    .register(new AbstractWebDriverEventListener() {
        @Override 
        public void afterClickOn(WebElement element, WebDriver driver) {
            LOG.log(Level.INFO, "Click on element " + element.getTagName());
        }
    }
);
```

#### Применение

https://refactoring.guru/ru/design-patterns/decorator
http://design-pattern.ru/patterns/abstract-factory.html
https://javadevcentral.com/decorator-design-pattern
https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm
https://java-design-patterns.com/patterns/decorator/
https://www.journaldev.com/1540/decorator-design-pattern-in-java-example
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b4%d0%b5%d0%ba%d0%be%d1%80%d0%b0%d1%82%d0%be%d1%80/
https://javarush.ru/groups/posts/3426-pattern-dekorator-decorator
https://metanit.com/sharp/patterns/4.1.php

## 4.2. Паттерн Proxy

***Proxy*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. 
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Прокси - это шаблон, который позволяет вмешиваться в процесс, происходящий между вами и другим пользователем,
вводя новую логику между ними, не затрагивая ни одну из сторон.

### 4.2.1. Проблема

Этот шаблон может быть полезен, когда вы, например, хотите добавить ведение журнала, включить или отключить что-то,
иметь контроль над некоторыми дополнительными ресурсами и т. Д.
Самый популярный метод использования его в тестах - это настройка HTTP-прокси.
Это позволяет динамически включать и отключать черные списки хостов,
исключая или заглушая сторонние сайты, такие как Facebook или Twitter, в ваших тестах.
Иногда это единственный способ проверить некоторые исключительные сценарии для внешних служб, подобных этим.

### 4.2.2. До применения паттерна

*Пример*

```java

```

### 4.2.3. После применения паттерна

#### Реализация

*Пример*

```java

```

#### Применение

https://refactoring.guru/ru/design-patterns/proxy
https://javadevcentral.com/proxy-design-pattern
https://javadevcentral.com/proxy-pattern-vs-decorator-pattern
https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm
https://java-design-patterns.com/patterns/proxy/
https://www.journaldev.com/1572/proxy-design-pattern
https://habr.com/ru/company/jugru/blog/338836/
https://javarush.ru/groups/posts/2368-pattern-proektirovanija-proxy
https://metanit.com/sharp/patterns/4.5.php

## 4.3. Паттерн Object Pool/Flyweight

***Object Pool/Flyweight*** - паттерн, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. 
Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

### 4.3.1. Проблема

Используя этот паттерн, мы могли бы реализовать много интересного, например, пул браузеров.
Я слышал тихие жалобы от разных людей, что веб-тесты занимают безумно много времени,
потому что они требуют запуска браузера, загрузки первой страницы, импорта профилей пользователей и т. д.
Но необязательно создавать браузер в реальном тесте, вместо этого мы могли бы использовать фоновый пул, который настроен на сохранение необходимого количества «горячих» браузеров.
Закончив работу с браузером, мы просто возвращаем его в пул и очищаем его данные.
И это может быть сделано в фоновом режиме, параллельно с фактическими тестовыми потоками.
И только после того, как браузер снова будет готов к использованию, его можно будет вернуть на следующий тест в качестве нового экземпляра.

Тем не менее, эта конфигурация пула и настройки браузера могут быть исключены из теста,
значительно минимизируя затрачиваемое на это время и ресурсы.

Другой пример - использование страницы. Вам не нужно ждать, пока откроется нужная страница,
если все тесты начинаются с одной страницы. Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать, пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных. Вместо того, чтобы работать с реальной базой данных,
мы можем запустить необходимое количество контейнеров базы данных на разных портах (это можно сделать с помощью Docker или другого инструмента виртуализации)
и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. Д.

### 4.3.2. До применения паттерна

*Пример*

```java

```

### 4.3.3. После применения паттерна

Следующий паттерн используют еще меньше разработчиков.
Легковес - это классический паттерн из книги GoF, который решает проблему сохранения и работы с тяжелыми с точки зрения ресурсов объектами или набором объектов.
Вместо того, чтобы создавать их каждый раз, когда они нам нужны, мы берем их, используем и возвращаем в так называемый пул для использования в будущем.

#### Реализация

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

#### Применение

https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern
https://www.tutorialspoint.com/design_pattern/flyweight_pattern.htm
https://java-design-patterns.com/patterns/flyweight/
https://www.journaldev.com/1562/flyweight-design-pattern-java
https://habr.com/ru/post/88393/
https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-2/2.2-flyweight.html
https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern
https://metanit.com/sharp/patterns/4.7.php

***

# 5. Паттерны данных

***Паттерны данных*** - паттерны, которые разделяют данные и логику тестирования.

а также уменьшить дублирование кода в тестах.
Это должно сделать их более понятными и простыми в обслуживании для всех, кто с ними работает.

## 5.3. Паттерн Assert Object/Matchers

***Assert Object/Matchers*** - паттерн,

### 5.3.1. Проблема

### 5.3.2. До применения паттерна

*Пример*

```java
@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
List<Response> responses = server.getResponses();
assertEquals(1, responses.size());
Response response = responses.get(0);
assertEquals(ResponseCode.ERROR_403, response.getCode());
}
```

### 5.3.3. После применения паттерна

Большинство людей слышали о следующем паттерне, но я видел лишь несколько человек, которые действительно его использовали.
Его имя - «Утвердить объект» или просто Matcher.
Обычно его можно использовать всякий раз, когда нам нужно сделать утверждения, специфичные для предметной области, для некоторого объекта. Давайте посмотрим на пример ниже:

#### Реализация

*Пример*

```java


@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
assertThat(server).hadSingleResponseWithCode(
ResponseCode.ERROR_403);
}

public static ServerAssert assertThat(Server server) {
    return new ServerAssert(server);
}

public class ServerAssert {
    private final Server server;
    public ServerAssert(Server server) {
        this.server = server;
    }
    
    public void hadSingleResponseWithCode(ResponseCode responseCode) {
        List<Response> responses = server.getResponses();
        assertEquals(1, responses.size());
        Response response = responses.get(0);
        assertEquals(responseCode, response.getCode());
    }
}
```

#### Применение

В исходном примере мы не видим очевидной логики проверок в тесте.
Пользователю может быть непонятно, что именно будет проверяться.
Сначала мы проверяем, что сервер возвращает только один ответ, а затем проверяем, что ответ содержит код ошибки 403.
Мы должны разделить эти проверки на два отдельных утверждения, потому что в противном случае было бы трудно понять, что пошло не так.
Но для того, кто не знаком с нашей предметной областью, все равно будет сложно понять такой тест.

Шаблон соответствия помогает нам создавать утверждения в виде многоразовых конструкций, что сокращает общее дублирование кода.
Например, если нам нужно убедиться, что сервер возвращает один ответ, но с кодом ответа 200.

Кроме того, этот подход создает логику предметной области в наших тестах.
Вот почему я предпочитаю реализовать его так, как показано выше, когда мы создаем группу утверждений и объединяем их в отдельный класс (например, ServerAssert),
который отвечает за все возможные проверки объекта Server.
Затем все, что нам нужно сделать, это создать статический метод assertThat, принимающий объект Server и возвращающий вместо него ServerAssert.
Он выглядит великолепно и его можно читать намного проще, чем раньше, а код утверждения внизу остается прежним.

Другой вариант создания сопоставителей - создание статических методов для каждого из них.
Существует несколько библиотек, которые уже содержат множество готовых к использованию сопоставителей и предоставляют простой в использовании API для создания ваших собственных.
Самые популярные из них - Hamcrest и AssertJ.
Если вы не использовали их раньше, я предлагаю хотя бы обратить на них внимание и подумать о том, чтобы встроить их в свой фреймворк.
Опять же, у них не будет сопоставителей для вашего домена, но они могут значительно упростить их создание.

https://www.mikulskibartosz.name/assert-object-pattern/

## 5.4. Паттерн Data Registry

***Data Registry*** - паттерн,

### 5.4.1. Проблема

### 5.4.2. До применения паттерна

*Пример*

```java

```

### 5.4.3. После применения паттерна

Интересен следующий паттерн. Основной подход заключается в следующем: мы хотим, чтобы наши тесты были независимыми и
попробуем разделить наши тестовые данные по ним, но в результате мы получим полную противоположность.
Например, в тесте A используются user1, user2 и user3, и они жестко запрограммированы как тестовые данные.
Это может быть проблемой, поскольку нам нужны полностью независимые тесты, верно?
Но мы заставляем другой тест знать, что user1, user2 и user3 уже заняты тестом A.
Другая проблема заключается в том, что разработчик, не знакомый с этим, может использовать этих пользователей в других тестах, и это может вызвать проблемы.

Реестр данных позволяет нам генерировать уникальные данные и избегать дублирования.
В приведенном ниже примере я использую самый простой из возможных подходов:
при каждом вызове getUser статический потокобезопасный счетчик будет увеличиваться на 1,
гарантируя, что каждый раз создается уникальный пользователь.

#### Реализация

*Пример*

```java
public static class UserRegistry {
    private static AtomicInteger COUNTER = new AtomicInteger(0);
    
    public static getUser() {
        int index = COUNTER.incrementAndGet();
        return new User("User_" + index, index);
    }
}

```

#### Применение

В вашем случае логика шаблона может быть намного сложнее, например. реестр может брать пользователя из базы данных, файла, предопределенного набора данных и т. д.
Но результат будет таким же: ваши тесты будут по-настоящему независимыми, поскольку каждый раз, когда они используют UserRegistry, они получают эксклюзивного пользователя, избегая проблем с перехватом тестов.

## 5.6. Паттерн Data Provider

***Data Provider*** - паттерн,

### 5.6.1. Проблема

### 5.6.2. До применения паттерна

*Пример*

```java

```

### 5.6.3. После применения паттерна

Поставщик данных - один из наиболее широко используемых шаблонов данных среди инженеров-тестировщиков.
Если вы хотите реализовать тесты на основе данных и хотите запустить одну и
ту же логику тестирования для нескольких наборов данных,
вы можете загружать данные из внешних источников (таких как Excel или таблица CVS),
удаленных служб или жестко закодировать их на месте.

#### Реализация

*Пример*

```java
@DataProvider
private static Object[][] testDataProvider() {
    try {
        return ReadExcelSheet.getTableArray("src/main/resources/TestData.xls");
    } catch (Exception e) {
        return null;
    }
}
```

Это можно сделать так, как я показал выше,
путем чтения из источника и возврата нетипизированных данных (простой массив массивов или строк).
Но современный подход заключался бы в использовании шаблона Value Object,
о котором мы говорили ранее, и предоставлении данных в терминах сущностей.

#### Применение

*Пример*

```java
@DataProvider
private static Iterator<Object[]> devices() {
    return asList(
        new Object[] { new Device("iPhone X", Platform.IOS, "11.2") },
        new Object[] { new Device("iPhone 7 Plus", Platform.IOS, "10.3") },
        new Object[] { new Device("Google Pixel 2", Platform.ANDROID, "8.0") }  
    ).iterator();
}

@Test(dataProvider = "devices")
public void pageShouldBeOpenedOnDevice(Device device) {
    startDevice(device);
    // some test steps
}
```

Вам нужно пометить свой метод аннотацией dataProvider или сделать его параметризованным с помощью JUnit и
заставить его возвращать набор данных для использования в тесте. Остальное (синтаксический анализ и итерация)
будет выполняться фреймворком, все, что вам нужно сделать, - это использовать данные, как в обычном тесте.

Важно, чтобы мы использовали оба шаблона (поставщик данных и объект значения) в одном подходе,
поскольку это помогло нам избежать передачи нескольких параметров методу и сделать код более чистым и читаемым.

Мне нравится использовать шаблоны данных в своей автоматизации,
они помогают мне поддерживать работоспособность кода и максимально оптимизировать управление ресурсами.
Если вас интересуют другие шаблоны, которые могут помочь вам в написании чистых и надежных тестов,
ознакомьтесь с другими моими сообщениями:

https://www.devbridge.com/articles/top-design-pattern-test-automation-frameworks/
https://antony-s-smirnov.medium.com/how-to-use-the-data-provider-pattern-in-the-project-ea12430d9275

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)