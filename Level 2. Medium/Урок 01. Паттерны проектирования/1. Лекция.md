Java_QA / Level 2. Medium - Продвинутые темы / Урок 01. Паттерны проектирования

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

Why do we need patterns in our testsPermalink
The main reasons for leveraging design patterns in test automation is increasing of stability, maintainability, flexibility, reliability and clarity. All of them are important but different aspect can be reached by using different patterns.

Most of them could be assigned to some group by the problem it helps to solve:

Structural patterns
Data patterns
Technical patterns
Business involvement patterns
In the first part I’ll cover structural patterns, the next articles will cover others.

# Structural Patterns
The main goal of structural patterns is to structure test code to simplify maintenance, avoid duplication and increase clarity. By doing that we will make it easier for other test engineers, not familiar with other code base, to understand and to start working with the tests right away.

## Page Object

The first pattern we’ll take a look at is Page Object. Probably it’s the most famous one among test engineers. The main problem it solves is the separation of technical details (e.g. user interface elements on the page/screen) and actual test logic of UI test.

Secondly, it helps to reduce code duplication. We would like to reuse our code in different test scripts and Page Object may help us to do that. Sometimes when I add new tests to my projects I don’t have to write any extra class or function except of the test script. Because they were already written with Page Object!

And finally Page Object makes tests more readable and understandable. It shows which page is user on right now and prevents test from doing actions not related to current page.

Of course, Page Object is not a panacea. If I had small amount of tests in my project (i.e. less than 20) and did not plan to extend those, I would consider not to use it. Just because the effort to create page objects would not pay off. Each pattern may generate a great value for you project but they should not be your goal in favor of project needs.

## Fluent / Chain of InvocationsPermalink

The second pattern we were going to talk about is Chain of Invocations. It’s usually being used along with Page Object, so most of you might be familiar with it too. The problem it resolves is helping test developer to determine if she can use the object or she should switch to other one. For example, user is on the login page and he’s pressing some button. By writing code in old fashion we wouldn’t be sure if he’s still on the login page or already on the home page.

And now just imagine if you had 50 similar methods in your test. You cannot be sure if you can invoke them right away, or they depend on some order, or even they can not be invoked after one of them was executed. For example, can I click on hint dialog if I haven’t entered any character into input field? Probably not, because at the very moment, it doesn’t exist yet!

```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();

  assertThat(homePage.isSignedIn(user));  
}
```

## Strategy

Strategy pattern is used whenever we want to have more than one implementations of the same action/sequence of actions, which is done differently. Depending on the context we could choose the implementation.

The easiest example is user registration. You might want to have two different implementations of this particular action. The first one would be the actual flow of transitions through the pages for successful user registration. The other one would be short API call which is invoked when new user is needed for the test.

interface UserRegistrationStrategy {
User register();
}

class WebUserRegistrationStrategy
implements UserRegistrationStrategy {
@Override
public User register() {
String username = UserRegistry.getUsername();
String password = PasswordGenerator.generatePassword();
SignInPage.open()
.pressSignUpButton()
.enterUsername(username)
.enterPassword(password)
.clickRegisterButton();
return new User(username, password);   
}
}

class ApiUserRegistrationStrategy
implements UserRegistrationStrategy {
@Override
public User register() {
User user = new User(UserRegistry.getNewUsername(), PasswordGenerator.generatePassword());
put("api/user").withBody(user.toJson());
return user;   
}
}

## AAA

"Настрой – действуй – проверь" – отличный способ структуризации тест-кейсов. Он задает порядок операций.

"Настрой" данные и цели. Эти шаги должны подготовить тест-кейс. Требует ли он объектов или особых настроек? Нужно ли подготовить базу данных? Нужен ли логин в веб-приложение? Разберитесь с этими операциями в начале теста.
"Действуй" согласно целевому поведению. Эти шаги покрывают основную задачу теста. Это может быть вызов функции или метода, вызов RESTAPI или взаимодействие с веб-страницей. Действия должны быть сфокусированы на целевом поведении.
"Проверь" ожидаемые результаты. Эти шаги должны получать какую-то разновидность ответа. Они убеждаются в правильности или ложности этого ответа. Иногда эти проверки просты – например, сверка числовых или строковых значений. В других случаях они требуют проверки множества аспектов системы. Проверка определяет, упал тест или прошел.
Шаг "Настрой" создает переменную с именем "negative".
Шаг "Действуй" вызывает функцию "abc" с использованием переменной "negative" и хранит возвращенное значение в переменной с именем "answer".
Шаг "Проверь" убеждается, что "answer" – положительное число.
Шаг "Настрой" формирует URL конечной точки для поиска "PythonProgramming". Обратите внимание на основной URL и параметры запроса.
Шаг "Действуй" вызывает API, используя URLи "requests", а затем интерпретирует тело ответа из JSON в словарь Python.
Шаг "Проверь" убеждается, что код HTTP-ответа – 200, что означает "ОК" или "успешно", и что слово "Python" появляется где-то в абстрактном тексте ответа.
В BDD паттерн "Настрой –Действуй – Проверь" называется иначе – Если – Когда – Тогда. Язык Gherkin использует шаги Если – Когда – Тогда для описания поведенческих сценариев. По сути это та же самая формула, что и в "Настрой – Действуй – Проверь"

# Паттерны данных – Data Patterns

## Value Object

## Builder

## Assert Object/Matchers

## Data Registry

## Object Pool/Flyweight

## Data Provider

# Technical Patterns

## Decorator

## Proxy



***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)