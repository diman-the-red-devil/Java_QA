Java_QA / Level 2. Medium - Продвинутые темы / Урок 01. Паттерны проектирования

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

***Шаблон проектирования или паттерн*** в разработке программного обеспечения — 
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код. 
Это лишь пример решения задачи, который можно использовать в различных ситуациях. 
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, 
без определения того, какие конечные классы или объекты приложения будут использоваться.

Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. 
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

https://habr.com/ru/company/jugru/blog/338836/
https://habr.com/ru/post/210288/
https://tproger.ru/translations/design-patterns-simple-words-1/
https://refactoring.guru/ru/design-patterns/catalog

Зачем нужны шаблоны в тестах?
Основными причинами использования шаблонов проектирования в автоматизации тестирования являются увеличение
стабильности, ремонтопригодность, гибкость, надежность и наглядность.
Все они важны, но разные аспекты могут быть достигнуты с помощью разных шаблонов.

Проблем в автоматизации проектирования и разработке множество, и сталкиваясь с этими проблемами, люди формулировали паттерны. 
Изначально классические паттерны были сформулированы давным-давно четверкой, которая выпустила книгу Design Patterns.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире. 
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, пополняясь новыми паттернами.

Сегодня просматривается тенденция появления подобных паттернов в других областях, в которых накопилась проблематика.

Основными драйверами практически всех паттернов в автоматизации тестирования являются факторы на слайде выше: 
надежность, понятность, гибкость, поддерживаемость, стабильность и другие подобные факторы, которые вам важны в ваших тестах.

Большая часть этих факторов находится под влиянием разделения концепции: 
в любом вашем тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три компонента: 
тестовая логика, тестовые данные и application driver, или technical details, technical parts – часть, 
отвечающая за непосредственное взаимодействие с вашим приложением, вашим кодом (вызов функций, клики на экран и т. п.).

Если эти части хорошо разделены, ваши тесты начинают хорошо попадать в выше упомянутые факторы, 
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

Все паттерны можно поделить на группы:

* структурные паттерны
* паттерны данных
* технические паттерны
* бизнес паттерны

***

# 2. Структурные паттерны

Первая группа – это cтруктурные паттерны, основная задача которых сводится к структурированию кода наших тестов — чтобы упростить поддержку, 
избежать дубликатов и проблем с запутанностью. 
Таким образом, тестовым инженерам, работающим с теми же проблемами, будет проще понять их и изменить, и проще поддерживать.

## 2.1. Паттерн Page Object

The first pattern we’ll take a look at is Page Object. Probably it’s the most famous one among test engineers. 
The main problem it solves is the separation of technical details (e.g. user interface elements on the page/screen) 
and actual test logic of UI test.

Secondly, it helps to reduce code duplication. 
We would like to reuse our code in different test scripts and Page Object may help us to do that. 
Sometimes when I add new tests to my projects I don’t have to write any extra class or function except of the test script. 
Because they were already written with Page Object!

And finally Page Object makes tests more readable and understandable. 
It shows which page is user on right now and prevents test from doing actions not related to current page.

Of course, Page Object is not a panacea. 
If I had small amount of tests in my project (i.e. less than 20) and did not plan to extend those, 
I would consider not to use it. Just because the effort to create page objects would not pay off. 
Each pattern may generate a great value for you project but they should not be your goal in favor of project needs.

## 2.2. Паттерн Page Factory

Page Factory is an extension to Page Object pattern. It helps to encapsulate page’s attributes and methods even more by providing FindBy annotations.

```java
public class LoginPage extends BasePage {
    private static final By USERNAME_FIELD = By.id("usernameField");
    private static final By PASSWORD_FIELD = By.id("passwordField");
    private static final By LOGIN_BUTTON = By.id("loginButton");
    
    public LoginPage(WebDriver driver) {
        super(driver);
    }
    
    public HomePage loginAs(User user) {
        driver.findElement(USERNAME_FIELD).sendKeys(user.username);
        driver.findElement(PASSWORD_FIELD).sendKeys(user.password);
        driver.findElement(LOGIN_BUTTON).click();
        return new HomePage(driver);
    }
}

public class LoginPage extends BasePage {
    @FindBy
    private WebElement usernameField;
    @FindBy
    private WebElement passwordField;
    @FindBy
    private WebElement loginButton;
    
    public LoginPage(WebDriver driver) {
        super(driver);
        PageFactory.initElements(driver, this);
    }
    
    public HomePage loginAs(User user) {
        usernameField.sendKeys(user.username);
        passwordField.sendKeys(user.password);
        loginButton.click();
        return new HomePage(driver);
    }
}

```

Pay attentions to PageFactory#initElements invocation. 
This static helper initializes all fields with FindBy annotations on the page, which will be found on it on each call. 
The main advantage is the fact that now we work directly with fields, buttons, windows etc. 
and do not worry about low level driver’s interactions exactly the same way our app users do.

Composition of Page Elements

Any web, desktop or mobile application consists of repeatable elements, and logic of their usage should be implemented again and again in our tests. 
For instance, every menu has list of links, every table has rows and columns, every form has input fields. 
In real life when we work with those elements we do not separate those components from the main element consisting them.

Thanks to Composition we could implement some elements once and reuse them every time we need them. 
Thus it helps to avoid code duplication by composing different web elements into widgets (high-level elements), like tables, menus, forms. 
This significantly reduces costs of extending and scaling of test automation framework when, for example new Page Objects needs to be created.

Loadable Component

This pattern is used by most of the developers who works with user interface tests. 
The thing is, when test makes the transition from one page to another, it doesn’t know if the targeted page was loaded completely. 
Obviously, either regular sleep or not waiting at all is not a solution here. So how do we solve this problem? Usually test engineers create explicit wait in constructor of the page class or in its ancestor and override if it’s needed.

```java
public class HomePage extends BasPage {
@FindBy(id = "someId")
private WebElement element;

public HomePage(WebDriver driver) {
super(driver);
PageFactory.initElements(driver, this);
waitForElement(element);
}
}

```

Again, there is not strict rule how to do this wait. 
Personally I like to move this waiting to BasePage and override abstract method for waiting particular element. 
How to do that in your case, completely up to you. 
But before implementing such complicated logic you need to be sure that your app page transition could cause you some problem. 
Otherwise just usual implicit wait might be enough. 
If you’re interested in implementation of explicit waits in your UI mobile tests and do not know where to start, 
I recommend to read my post about explicit waits in Android or iOS.

## 2.3. Паттерн Fluent / Chain of Invocations

The second pattern we were going to talk about is Chain of Invocations. 
It’s usually being used along with Page Object, so most of you might be familiar with it too. 
The problem it resolves is helping test developer to determine if she can use the object or she should switch to other one. 
For example, user is on the login page and he’s pressing some button. 
By writing code in old fashion we wouldn’t be sure if he’s still on the login page or already on the home page.

And now just imagine if you had 50 similar methods in your test. 
You cannot be sure if you can invoke them right away, or they depend on some order, 
or even they can not be invoked after one of them was executed. 
For example, can I click on hint dialog if I haven’t entered any character into input field? 
Probably not, because at the very moment, it doesn’t exist yet!

```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();

  assertThat(homePage.isSignedIn(user));  
}
```

This pattern is important in case you’re trying to scale your test automation framework. 
Large amount of pages, elements and methods available for usage may create a confusion, 
especially for someone not really familiar with your domain. 
But by implementing Fluent Invocations modern IDE will give you a hint every time you’ll 
try to invoke some method on the object by autocompletion feature.

Usually if you want to interrupt method chain, 
all you have to do is to assign the return value (e.g. string, number etc.) to some variable. 
This way you’d show that this is the end of the sequence of invocations. 
At this point developer should stop and think about next method to be invoked in test script before doing that.

Chain of Invocations is easy to implement. 
All you have to do is to return the value in every method of Page Object. This might be this, some value or any other object, 
for example next Page Object after method invocation (transition to other page).

This pattern doesn’t help to reduce code a lot (that’s not its mission thought), 
but it allows you to not repeat yourself by putting the object again and again before invoking its methods. 
Also IMO it makes code a little bit prettier.

## 2.4. Паттерн Strategy

Strategy pattern is used whenever we want to have more than one implementations of the same action/sequence of actions, 
which is done differently. Depending on the context we could choose the implementation.

The easiest example is user registration. You might want to have two different implementations of this particular action. 
The first one would be the actual flow of transitions through the pages for successful user registration. 
The other one would be short API call which is invoked when new user is needed for the test.

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

You may not want to invoke “long” registration every time in your tests. 
But sometimes you’ll need it, for example when you validate actual registration through the web. 
And vice versa, we want new user creation for test needs to be fast and reliable. That’s why REST registration would be suitable here.

Strategy helps making our test automation framework more flexible and easier in maintenance by using separation of concepts. 
Again you need to be careful and not implement it in situations when you can do fine without it.

## 2.5. Паттерн AAA

***Настрой – действуй – проверь*** – отличный способ структуризации тест-кейсов. Он задает порядок операций.

The Pattern
Arrange-Act-Assert is a great way to structure test cases. It prescribes an order of operations:

Arrange inputs and targets. Arrange steps should set up the test case. Does the test require any objects or special settings? Does it need to prep a database? Does it need to log into a web app? Handle all of these operations at the start of the test.
Act on the target behavior. Act steps should cover the main thing to be tested. This could be calling a function or method, calling a REST API, or interacting with a web page. Keep actions focused on the target behavior.
Assert expected outcomes. Act steps should elicit some sort of response. Assert steps verify the goodness or badness of that response. Sometimes, assertions are as simple as checking numeric or string values. Other times, they may require checking multiple facets of a system. Assertions will ultimately determine if the test passes or fails.


"Настрой" данные и цели. 
Эти шаги должны подготовить тест-кейс. Требует ли он объектов или особых настроек? Нужно ли подготовить базу данных? Нужен ли логин в веб-приложение? Разберитесь с этими операциями в начале теста.
"Действуй" согласно целевому поведению. 
Эти шаги покрывают основную задачу теста. Это может быть вызов функции или метода, вызов RESTAPI или взаимодействие с веб-страницей. Действия должны быть сфокусированы на целевом поведении.
"Проверь" ожидаемые результаты. 
Эти шаги должны получать какую-то разновидность ответа. Они убеждаются в правильности или ложности этого ответа. Иногда эти проверки просты – например, сверка числовых или строковых значений. В других случаях они требуют проверки множества аспектов системы. Проверка определяет, упал тест или прошел.
Шаг "Настрой" создает переменную с именем "negative".
Шаг "Действуй" вызывает функцию "abc" с использованием переменной "negative" и хранит возвращенное значение в переменной с именем "answer".
Шаг "Проверь" убеждается, что "answer" – положительное число.
Шаг "Настрой" формирует URL конечной точки для поиска "PythonProgramming". Обратите внимание на основной URL и параметры запроса.
Шаг "Действуй" вызывает API, используя URLи "requests", а затем интерпретирует тело ответа из JSON в словарь Python.
Шаг "Проверь" убеждается, что код HTTP-ответа – 200, что означает "ОК" или "успешно", и что слово "Python" появляется где-то в абстрактном тексте ответа.
В BDD паттерн "Настрой –Действуй – Проверь" называется иначе – Если – Когда – Тогда. Язык Gherkin использует шаги Если – Когда – Тогда для описания поведенческих сценариев. По сути это та же самая формула, что и в "Настрой – Действуй – Проверь"

https://alexilyenko.github.io/patterns-1/

https://habr.com/ru/company/jugru/blog/338836/

https://www.devbridge.com/articles/top-design-pattern-test-automation-frameworks/

https://www.software-testing.ru/library/testing/test-analysis/3496-arrange-act-assert-a-pattern-for-writing-good-tests

https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/

***

# 3. Паттерны данных

The main goal of data patterns is to split data and test logic as well as to reduce boilerplate and code duplication in our tests. 
It should make them more understandable and easier in maintenance for anyone who works with them.

## 3.1. Паттерн Value Object

We will start from the easiest pattern in this group - Value Object. 
I think most of us used it once in a while, but unfortunately I’ve seen lots of the projects, 
where this best practice is neglected by developers. 
That’s really sad because from design perspective Value Object can make your code more readable and significantly reduce amount of repeatable constructions.

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried, List<String> accomplishments) {
    enter(firstName, into("name"));
    enter(lastName, into("lastName"));
    enter(age, into("age"));
    enterMaritalStatus(isMarried);
    accomplishments.forEach(this::addAccomplishment);
}

public void createUser(User user) {
    enter(user.firstName, into("name"));
    enter(user.lastName, into("lastName"));
    enter(user.age, into("age"));
    enterMaritalStatus(user.isMarried);
    user.accomplishments.forEach(this::addAccomplishment);
}
```

## 3.2. Паттерн Builder

Let’s imaging we have extremely complex object and it can be configured in many different ways. 
The first option which comes to mind is to create as many types of constructors as we have parameter variations in 
this object and every time we meet new one we’d need to create new constructor for that. 
As a result we’ll get crazy amount of constructors which will definitely confuse the end-user of the framework. 
Builder pattern is used to make the process of building such objects easier and with the help of modern IDE hints more intuitive.

Here is the example of Builder pattern usage:


```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

At the beginning the special ServerBuilder object is created and after that it can be configured before actual Server object is built. 
That said only build method returns the actual Server object, other ones return the original ServerBuilder for further configuration.

Under the hood it would look something like this:


```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}

```

In the example above all the parameters have default values when ServerBuilder is created, 
which means user can create Server object without having to set up anything. 
This might be changed as well if we want our object to have mandatory configurable fields. 
In that case I’d throw exception saying that object is not fully configured.

## 3.3. Паттерн Assert Object/Matchers

Majority of the people heard about the next pattern but I’ve seen only few actually using it. 
Its name is “Assert Object” or simply Matcher. 
Usually it might be used whenever we need to do domain specific assertions on some object. Let’s take a look at the example below:

```java
@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
List<Response> responses = server.getResponses();
assertEquals(1, responses.size());
Response response = responses.get(0);
assertEquals(ResponseCode.ERROR_403, response.getCode());
}

@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
assertThat(server).hadSingleResponseWithCode(
ResponseCode.ERROR_403);
}

public static ServerAssert assertThat(Server server) {
return new ServerAssert(server);
}

public class ServerAssert {
private final Server server;
public ServerAssert(Server server) {
this.server = server;
}

public void hadSingleResponseWithCode(ResponseCode
responseCode) {
List<Response> responses = server.getResponses();
assertEquals(1, responses.size());
Response response = responses.get(0);
assertEquals(responseCode, response.getCode());
}
}

```

In the original example we do not see obvious logic of the checks in the test. 
It might be not clear to the user what exactly is going to be verified. 
At first we’re validating that server returns only one response and then that the response has 403 error code. 
We have to split these checks to two separate assertions because otherwise it would be difficult to understand what went wrong. 
But for someone not familiar with our domain it would be still difficult to understand test like that.

Matcher pattern helps us to create asserts as reusable constructions, which reduce overall code duplication. 
For instance, if we need to verify that server returns one response, but with 200 response code.

Besides that this approach creates domain logic in our tests. 
That’s why I prefer to implement it the way shown above, when we create group of asserts and put them together in separate class (e.g. ServerAssert), 
which is responsible for all possible checks on the Server object. 
Then all we need to do is to create static method assertThat accepting Server object and returning ServerAssert instead. 
It looks great and can be read much easier than before and the assertion code underneath stays the same.

Another option for creating matchers is to build static methods for each of them. 
There are multiple libraries out there which already have a lot of ready-to-use matchers bundled in and provide easy-to-use API for creating your own ones. 
The most popular of them are Hamcrest and AssertJ. 
If you haven’t used them before I suggest at least to pay attention to those ones and think about building them into your framework. 
Again, they won’t have your domain specific Matchers, but they might significantly simplify creating ones.

## 3.4. Паттерн Data Registry

The next pattern is interesting one. The main approach is as follows: we want our tests to be independent and 
try to split our test data across them, but as a result we get completely opposite. 
For example, test A uses user1, user2 and user3 and they are hardcoded as a test data. 
This might be the problem since we want completely independent tests, right? 
But we force other test to be aware that user1, user2 and user3 are already occupied by test A.
Another concern is that developer not familiar with this could use those users in other tests and this may cause the issues.

Data registry allows us to generate unique data and avoid duplications. 
In the example below I’m using the simplest approach possible: 
on every getUser invocation static thread-safe counter will be incremented by 1, 
guaranteeing that each time unique user is created.

```java
public static class UserRegistry {
    private static AtomicInteger COUNTER = new AtomicInteger(0);
    
    public static getUser() {
        int index = COUNTER.incrementAndGet();
        return new User("User_" + index, index);
    }
}

```

In your case the pattern logic might be much more complex, e.g. the registry could take the user from database, file, predefined data set etc. 
But the outcome will be the same: your tests will be truly independent, since each time they use UserRegistry they get exclusive user avoiding test interception issues.

## 3.5. Паттерн Object Pool/Flyweight

The next pattern is used by even less developers. 
Flyweight is the classic pattern from GoF book, which solves the problem of retaining and operating with the heavy in terms of resources objects or set of objects. 
Instead of creating them every time we need them, we take them, use them and return them to so called Pool for future uses.

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

Using this pattern we could implement lots of interesting things, for instance, browser pool. 
I heard quiet a few complains from different people that web-tests take crazy amounts of time, 
because they require to start browser, load first page, import user profiles etc. 
But it’s not necessarily to create browser in the actual test, instead we could use Background Pool, which set up to retain needed amount of “hot” browsers. 
After we’re done with the browser we just return it to the pool and clear its data. 
And this might be done in background, in parallel with the actual test threads. 
And only after browser is ready to be used again it can be given back to the next test as a fresh instance.

That said, this pool configuration and browser set up parts might be taken out outside of the test, 
significantly minimizing the time and resources spent on it.

The other example is the page usage. You don’t have to wait until the needed page is opened, 
if all of the tests start from the same page. You could have the Page Pool as well and request it from there. 
This means it’s gonna be opened in one of the browser instances in background beforehand and will be waiting for the test to pick it up in ready-to-use state.

Another well-known option for using this approach would be Database Pool. Instead of working with the real database, 
we could start the needed number of database containers on the different ports (it can be done with Docker or other virtualization tool) 
and “kill” it after we do not need it anymore. 
That way we’d always have clean database without the need of tearing it down, cleaning it up, collection and uploading the data etc.

## 3.6. Паттерн Data Provider

Data Provider is one of the most widely used data patterns among test engineers. 
If you want to implement Data-Driven tests and are willing to run the same test logic on multiple sets of data, 
you could load the data from outer sources (like Excel or CVS table), remote services or hardcode them in-place.

```java
@DataProvider
private static Object[][] testDataProvider() {
    try {
        return ReadExcelSheet.getTableArray("src/main/resources/TestData.xls");
    } catch (Exception e) {
        return null;
    }
}
```
        
This could be done in the way I showed above by reading from source and returning untyped data (simple array of arrays or strings). 
But modern approach would be to utilize Value Object pattern, we were talking about previously, and provide data in terms of entities.

```java
@DataProvider
private static Iterator<Object[]> devices() {
    return asList(
        new Object[] { new Device("iPhone X", Platform.IOS, "11.2") },
        new Object[] { new Device("iPhone 7 Plus", Platform.IOS, "10.3") },
        new Object[] { new Device("Google Pixel 2", Platform.ANDROID, "8.0") }  
    ).iterator();
}

@Test(dataProvider = "devices")
public void pageShouldBeOpenedOnDevice(Device device) {
    startDevice(device);
    // some test steps
}
```

You need to mark your method with the annotation dataProvider or make it parametrized with the help of JUnit and make it return the data set for using it in the test. The rest (parsing and iterating) will be done by the framework, all you have to do is to use data as you would use in regular test.

It’s important that we used both patterns (Data Provider and Value Object) in one approach, since it helped us to avoid the passing of multiple parameters to method and to make code cleaner and more readable.

I love using Data Patterns in my automation, they help me to keep my code healthy and handle resources in the most optimized way possible. In case, you’re interested in other patterns which might help you in writing clean and robust tests, check out my other posts:

https://www.devbridge.com/articles/top-design-pattern-test-automation-frameworks/

***

# 4. Технические паттерны

The main goal of Technical Patterns is to encapsulate technical details from test logic, providing extra low-level control over them.

## 4.1. Паттерн Decorator

Decorator is a very well-known pattern, since it was mentioned in the GoF list and discussed in many other programming books and articles. 
The example of this one is simple. Let’s imagine you’re working with any driver implementation (e.g. WebDriver) and are willing to add an extra functionality to it, like logging or caching. But in the same time you don’t wanna reveal that additional functionality to your actual tests, leaving test logic the same as it was before. That’s where you want to use Decorator.

Decorator helps to implement so called “Cabbage principle”, when you are able to wrap one driver implementation into another, in the way cabbage leaves are formed. Your tests won’t be aware of that extra layer since they work with the same interface as before.

For instance, you want to log every click on some element in your tests. All you need to do is to decorate your initial WebDriver object, by wrapping it into the EventFiringWebDriver and registering new listener, while your tests don’t have to be changed at all:

```java
new EventFiringWebDriver(driver)
    .register(new AbstractWebDriverEventListener() {
        @Override 
        public void afterClickOn(WebElement element, WebDriver driver) {
            LOG.log(Level.INFO, "Click on element " + element.getTagName());
        }
    }
);
```

## 4.2. Паттерн Proxy

Proxy is the pattern that allows to intervene into the process running between you and another user, introducing new logic in-between without affecting either of the sides.

This pattern might be useful when you, for example, want to add logging, to enable or to disable something, to have control over some additional recourses etc. The most popular method of using it in tests is to set up the HTTP proxy. It allows to dynamically enable and disable host blacklists, excluding or stubbing the third-party sites like Facebook or Twitter in your tests. Sometimes it’s the only way you can check some exceptional scenarios for the external services like those ones.

https://habr.com/ru/company/jugru/blog/338836/

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)