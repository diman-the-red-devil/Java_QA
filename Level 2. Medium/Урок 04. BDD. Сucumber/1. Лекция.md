Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Cucumber

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

Первоначально **Cucumber** был разработан **Ruby**-сообществом,
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**).

**Cucumber** использует легко читаемый предметно-ориентированный язык для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему, понимать и писать их может любой участник проекта.

**Cucumber** заполняет разрыв между разработчиками и заинтересованными сторонами (бизнес).
Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых примеров.
Тестовые примеры могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.).
Эти тестовые примеры мапятся с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, который можно использовать в связке со многими другими популярными инструментами:

* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов

***

# 2. Структура проекта Cucumber

Проект **Cucumber** состоит из следующих частей:

1. описание сценариев (поведения системы) по шагам - текстовые файлы с расширением **.feature**
2. реализация шагов сценариев на языке программирования - файлы с исходным кодом **.java**
3. теги - метки для организации запуска сценариев
4. хуки - методы выполняемые до и после для запуска сценариев
5. раннер для запуска сценариев - специальный класс **Java**
6. прочие файлы

## 2.1. Описание сценариев (Features)

***Описание сценариев (Features)*** – текстовые файлы с расширением **.feature**, которые содержат текст исполняемых спецификаций на языке **Gherkin**.

**Описание сценариев (Features)** представляет собой текст на естественном языке в свободной форме с использованием ключевых слов **Gherkin**.

*Пример*

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

  @success
  Сценарий: Успешное снятие денег со счета
    Дано на счете пользователя имеется 120000 рублей
    Когда пользователь снимает со счета 20000 рублей
    Тогда на счете пользователя имеется 100000 рублей

  @fail
  Сценарий: Снятие денег со счета - недостаточно денег
    Дано на счете пользователя имеется 100 рублей
    Когда пользователь снимает со счета 120 рублей
    Тогда появляется предупреждение "На счете недостаточно денег"
```

Особенности:

1. Каждый файл **.feature** должен содержать описание только одной фичи

Описание фичи начинается с ключевого слова **Функция (Function)** и поэтому каждый файл содержит только одно ключевое слово.

2. Каждый файл **.feature** может содержать от 0 и более сценариев

3. Текст сценариев должен начинаться с **# language: ru**, если используется русский язык

Эта строка указывает **Cucumber**, что в сценарии используется русский язык (по умолчанию используется английский язык).
Если её не указать, фреймворк, встретив в сценарии русский текст, выбросит исключение **LexingError** и тест не запустится.

4. Каждый сценарий должен иметь следующую структуру:

* получение начального состояние системы
* выполнение действий по изменению состояния системы
* получение и проверка нового состояние системы

## 2.2. Реализация шагов сценариев (Step Defs)

***Реализация шагов сценариев (Step Defs)*** - файлы с расширением **.java**,
содержащие код для взаимодействия с разрабатываемой системой,
на который мапятся шаги в описании сценариев.

**Cucumber** не знает как взаимодействовать с системой в рамках
исполнения шагов сценариев написанных на **Gherkin** в файлах **.feature**.

**Реализация шагов сценариев (Step Defs)** связывает шаги описанные в тексте на **Gherkin** в файлах **.feature**
с кодом по взаимодействию с системой на **Java**, чтобы сценарии могли исполниться.

**Реализация шагов сценариев (Step Defs)** представляет собой текст с записанным выражением-паттерном
(регулярным выражением или выражением Cucumber), который содержится в специальной аннотации 
у каждого метода реализующего определенный шаг.

Сам код на **Java** может тестировать:

* Web UI (**Selenium WebDriver**)
* REST API (**REST Assured**)
* SOAP
* БД
  и т д.

*Пример*

```java

```

Аннотации для **Реализации шагов сценариев (Step Defs)**:

| Аннотация | Описание  |
|-----------|-----------|
| @Given    |           |
| @When     |           |
| @Then     |           |

При выполнении тестов **Cucumber** для каждого шага **.feature** на **Gherkin** 
ищет его реализацию в коде на **Java**, посредством сравнения с выражением-паттерном в аннотации.
Таким образом, шаги в файлах **.feature** на **Gherkin** можно рассматривать как вызов методов **Java**.

Особенности:

1. Каждая **Реализация шагов сценариев (Step Defs)** должна совпадать по количеству аргументов с шагами описанными в **.feature**
2. Каждая **Реализация шагов сценариев (Step Defs)** должна иметь уникальный паттерн описанный в аннотации

Если задать два разных метода с одним и тем же паттерном, то при выполнении тестов возникнет исключение **DuplicateStepException**.
Такое же исключение можно словить, если задать два разных метода с одним и тем же паттерном в разных файлах **.java** в одном пакете **Java**.

3. Каждая **Реализация шагов сценариев (Step Defs)** может быть повторно использована в различных файлах **.feature**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

4. Каждая **Реализация шагов сценариев (Step Defs)** может быть использована в одном файле **.feature**
   совместно с другими реализациями шагов из разных файлов **.java**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

## 2.3. Теги (Tags)

***Теги (Tags)*** - метки для организации запуска сценариев.

**Теги (Tags)** представляют собой строки начинающиеся с символа **@** и располагающиеся перед строками с ключевыми словами.

**Тегами (Tags)** в файле **.feature** можно пометить:

* фичи (**Функции (Feature)**)
* сценарии (**Сценарии (Scenario)** и **Структуры сценариев (Scenario Outline)**)
* примеры (**Примеры (Examples)**)

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

С помощью тегов можно задать классификацию и группировку сценариев,
а также организацию запуска сценариев, независимо от их расположения в файлах и папках проекта.

Например, можно задать теги **@smoke**, **@regression**, чтобы поделить тестовые сценарии на регрессионные и смоук,
и при запуске указывать теги, чтобы выполнить только определенные сценарии.

*Пример*

```java
tags = {"~@Ignore"}
tags = {"@UpdateProfile"}
```

Особенности:

1. Можно использовать множество тегов для пометки

*Пример*

```gherkin
@important @maintenance @db @auth
```

2. Теги наследуется

Любой тег из **Функции (Feature)** будет наследоваться в **Сценарии (Scenario)**,
**Структуры сценариев (Scenario Outline)** или **Примеры (Examples)**.


## 2.4. Хуки (Hooks)

***Хуки (Hooks)*** - методы выполняемые до и после для запуска сценариев.

**Хуки (Hooks)** представляют собой методы помеченные специальными аннотациями.

*Пример*

```java
import cucumber.api.java.After;
import cucumber.api.java.Before;

public class Hooks {
    @Before
    public void prepareData() {
        //подготовить данные
    }
    
    @After
    public void clearData() {
        //очистить данные
    }
}
```

Аннотации для **Хуков (Hooks)**:

| Аннотация             | Описание                    |    |
|-----------------------|-----------------------------|----|
| @Before               | Перед каждым сценарием      |    |
| @After                | После каждого сценария      |    |
| @Around               | До и после сценария         |    |
| @BeforeStep           | Перед каждым шагом          |    |
| @AfterStep            | После каждого шага          |    |
| @AfterConfiguration   | После конфигурации Cucumber |    |

Особенности:

1. Класс с **Хуками (Hooks)** должен находиться в пакете, указанном в опциях фреймворка

2. **Хукам (Hooks)** можно задать порядок, в котором они будут выполняться

Для этого необходимо в аннотации указать параметр **order**. По умолчанию значение order равно 10000.

Для **@Before** чем меньше это значение, тем раньше выполнится метод

*Пример*

```java
// первым выполнится метод connectToServer()
@Before(order = 10)
    public void connectToServer() {
    // подключиться к серверу
}
// затем prepareData()
@Before(order = 20)
    public void prepareData() {
    // подготовить данные
}
```

Для **@After** отрабатывает в обратном порядке.

3. **Хукам (Hooks) @Before, @After, @Around** можно задать теги, чтобы задать фильтрацию сценариев, для которых будут применяться хуки.

В параметре **value** нужно указать тэги сценариев, для которых будут отрабатывать **Хуки (Hooks)**.
Список тегов сценариев в одной строке обрабатывается как **ИЛИ**, а отдельные аргументы обрабатываются как **И**.
Символ **~** означает «за исключением».

*Пример*

```java
// метод connectToServer() будет выполнен для всех сценариев с тэгом correct
@Before(value = "@correct", order = 30)
public void connectToServer() {
    //сделай что-нибудь
}
        
// метод prepareData() будет выполнен для всех сценариев за исключением сценариев с тэгом fail
@Before(value = "~@fail", order = 20)
public void prepareData() {
    //сделай что-нибудь
}
```

4. **Хукам (Hooks)** можно передать в качестве параметра объект класса **Scenario**

Если в определении **Хука (Hooks)** в аргументе указать объект класса **Scenario**,
то в данном методе можно будет узнать много полезной информации о запущенном сценарии.

*Пример*

Метод **getScenarioInfo(Scenario scenario)**

```java
@After
public void getScenarioInfo(Scenario scenario) {
    System.out.println(scenario.getId());
    System.out.println(scenario.getName());
    System.out.println(scenario.getStatus());
    System.out.println(scenario.isFailed());
    System.out.println(scenario.getSourceTagNames());
}
```

Для сценария

```gherkin
# language: ru
@all
Функция: Аутентификация банковской карты
  
    Банкомат должен спросить у пользователя PIN-код банковской карты
    Банкомат должен выдать предупреждение если пользователь ввел неправильный PIN-код
    Аутентификация успешна если пользователь ввел правильный PIN-код

    Предыстория:
    Допустим пользователь вставляет в банкомат банковскую карту
    И банкомат выдает сообщение о необходимости ввода PIN-кода

    @correct
    Сценарий: Успешная аутентификация
    Если пользователь вводит корректный PIN-код
    То банкомат отображает меню и количество доступных денег на счету
```

Выведет в консоль следующее

```text
аутентификация-банковской-карты;успешная-аутентификация
Успешная аутентификация
passed
false
[@correct, @all]
```

5. Необходимо помнить про нюансы работы с **Хуками (Hooks)**

* тестовый фреймворк может также добавить выполнение кода до и после выполнения каждого метода
* сценарии в **Cucumber** выполняются независимо друг от друга
* шаги описанные в **Предыстории (Background)** выполняются перед каждым сценарием

## 2.5. Раннер (Runner)

***Раннер (Runner)*** - класс для запуска сценариев.

**Раннер (Runner)** представляет собой специальный класс **Java** с аннотацией **@RunWith(Cucumber.class)**.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
        plugin = {"pretty", "html:target/htmlreport", "json:report.json", "junit:report.xml"},
        monochrome = true, 
//      name = "^Успешное|Успешная.*"
)
public class RunnerTest {
    
}

```

В классе-раннере через аннотацию **@CucumberOptions** задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
tags = "@all, @dev, @int, @regress",
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
tags = "@positive, ~@negative",
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — to specify different formatting options for the output reports

* *monochrome* — to receive clean and readable output in your console

## 2.6. Прочие файлы

PageObjects, ConfigFiles e t c

***

# 3. Запуск (Run)

## 3.1. Процесс запуска

При запуске теста **Cucumber** выполняет следующее:

1. Проходит по cценарию шаг за шагом
2. Взяв шаг, он отделяет ключевое слово от описания шага
3. Пытается найти в **Java** классах пакета указанного в опции glue аннотацию с регулярным выражением,
подходящим описанию в шаге
4. Найдя совпадение, фреймворк вызывает метод с найденной аннотацией
5. Если несколько регулярных выражений удовлетворяют описанию шага, фреймворк выбрасывает ошибку

Схема:

|                      |                |                      |               |            | 
|----------------------|----------------|----------------------|---------------|------------|
| **Steps in Gherkin** | *matched with* | **Step Definitions** | *manipulates* | **System** |

## 3.2. Отчеты (Reports)

После прогона тестовых сценариев **Cucumber** формирует отчет по результатам запуска.
Для построения отчетов **Cucumber** использует специальные плагины **Formatter Plugins**. 


JSON
HTML
JUnit


## 3.3. Интерфейс командной строки Cucumber (Cucumber CLI)

Фреймворк **Cucumber** поставляется с встроенным интерфейсом командной строки (CLI).

Команды:

* *--help* - справка

```shell
cucumber --help
```

* -r, --require LIBRARY|DIR        Require files before executing the features.
* --i18n LANG                      List keywords for in a particular language.

Run with "--i18n help" to see all languages.

* -f, --format FORMAT              How to format features (Default: pretty).
* -o, --out [FILE|DIR]             Write output to a file/directory instead of

Cucumber command line can be used to quickly run defined tests. 
It also supports running a subset of scenarios by filtering tags.

$ cucumber --tags @tag-name

The above command helps in executing only those scenarios that have the specified @tag-name.
Arguments can be provided as a logical OR or AND operation of tags. Apart from tags, scenarios can be filtered on scenario names.

$ cucumber --name logout

The above command will run only those scenarios that contain the word 'logout'.

It is also useful to be able to know what went wrong when a test fails. 
Cucumber makes it easy to catch bugs in the code with the --backtrace option.

Cucumber can also be configured to ignore certain scenarios that have not been completed by marking them with the Work In Progress tag @wip. 
When Cucumber is passed the --wip argument, Cucumber ignores scenarios with the @wip tag.

***

# 3. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и
использует отступы для задания структуры. Каждая строка представляет собой выражение -
шаг (**step**) и заканчивается переносом строки.

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на множество языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Список зарезервированных символов:

* *#* – обозначает комментарии
* *@* – тэгирует сценарии или функционал
* *|* – разделяет данные в табличном формате
* *"""* – обрамляет многострочные данные

## 3.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания поведения/функции системы и набора связанных с ней тестовых сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  # подробное описание
  # сценарии
```

Каждая **Функция (Feature)** описывается в отдельном файле с расширением **.feature**.
Любой документ **.feature** начинается с этого ключевого слова и краткого описания.
Каждая функция обычно состоит из списка сценариев (**Сценарий (Scenario)**, **Структура сценария (Scenario Outline)**).

На следующей строке после ключевого слова и наименования функции может идти **Подробное описание (Descriptions)**.
В **Подробное описание (Description)** можно добавить **Пользовательскую историю (User Story)**.

Наименование функции и подробное описание не имеют какого либо значения для **Cucumber**.

*Пример*

```Gherkin
Feature: Withdraw Money from ATM

  A user with an account at a bank would like to withdraw money from an ATM.
  Provided he has a valid account and debit or credit card, he should be allowed to make the transaction. 
  The ATM will tend the requested amount of money, return his card, and subtract amount of the withdrawal from the user's account.

  Scenario: Scenario 1
    Given preconditions
    When actions
    Then results

  Scenario: Scenario 2
  ...
```

## 3.2. Подробное описание (Descriptions)

***Подробное описание (Descriptions)*** - более подробное описание фичи.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

    Подробное описание
    На нескольких строках

    # сценарии
```

**Подробное описание (Descriptions)** представляет собой текст, который располагается на следующих строках
после строки с ключевым словом и размечается отступами. Количество строк никак не ограничено и
**Подробное описание (Descriptions)** продолжается до первого встреченного ключевого слова.
Эти строки будут проигнорированы **Cucumber** при выполнении тестов, но будут использованы при формировании отчетов.
Можно сказать, что **Подробное описание (Descriptions)** похоже на комментарий.

**Подробное описание (Descriptions)** можно добавлять после:

* *Примера (Example)* или *Сценария (Scenario)*
* *Предыстории (Background)*
* *Структуры сценария (Scenario Outline)*

*Пример*

```gherkin

```

## 3.3. Сценарий (Scenario)

***Сценарий (Scenario)*** - ключевое слово, предназначенное для описания конкретного тестового сценария.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
  # шаги сценария
```

**Сценарий (Scenario)** представляет собой одну из ключевых структур в языке **Gherkin**.
Каждый сценарий состоит из набора **Шагов (Steps)** - **Дано (Given)**, **Когда (When)** и **Тогда (Then)**.
Также **Сценарии (Scenario)** могут содержать **Предысторию (Background)** или
иметь множество примеров в виде **Структуры сценария (Scenario Outline)**.

**Сценарий (Scenario)** описывает поведение системы и является ее спецификацией.

*Пример*

```gherkin
#language: ru
Сценарий: Вася создает новую запись
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Лекарства"
То мне должен быть ответ "Ваша запись успешно добавлена."

Сценарий: Вася не может добавлять запись в справочник лечений
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Виды лечений"
То мне должен быть ответ "У вас нет прав доступа!"
```

## 3.4. Шаги (Steps)

***Шаги (Steps)*** - строительные блоки тестовых сценариев.

**Шаги (Steps)** представляют собой строки текста начинающиеся с одного из ключевых слов:

* *Дано (Given)* - данные
* *Когда (When)* - действия
* *То (Then)* - результаты
* *Но (But)*
* *И (And)*

Шаги **Но (But)** и **И (And)** существуют исключительно для удобства чтения и
по своим функциям повторяют ключевое слово, с которого начиналась предыдущая строка.

*Пример*

```gherkin
Scenario: A user attempts to withdraw more money than they have in their account
Given John has a valid Credit or Debit card
And his account balance is $20
When he inserts his card
And withdraws $40
Then the ATM displays an error
And returns his card
But his balance remains $20
```

Шаги должны быть параметризованными, чтобы их можно было повторно использовать.

### 3.4.1. Дано (Given)

***Дано (Given)*** - ключевое слово, предназначенное для описания предусловий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    # шаги сценария
```

Шаг ***Дано (Given)*** приводит систему в желаемое состояние перед тем
как пользователь (или внешняя система) начнет взаимодействие с системой.
Также можно рассматривать их как предусловия.

*Пример*

```gherkin
#language: ru
Дано нет пользователей в базе
Дано база данных пустая
```

### 3.4.2. Когда (When)

***Когда (When)*** - ключевое слово, предназначенное для описания событий или действий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    # шаги сценария
```

Шаг **Когда (When)** изменяет состояние системы путем взаимодействия с системой пользователя (или внешней системы).
Настоятельно рекомендуется использовать только один шаг **Когда (When)** для каждого сценария.

*Пример*

```gherkin
#language: ru
Пример: взаимодействие со страницей
Когда я открыл форму добавления учреждения
Когда я ввел "Институт радости" в поле "Наименование"
Когда я выбрал в поле "Тип" значение "Институт"
Когда я нажал на кнопку "Сохранить"
```

### 3.4.3. Тогда (Then)

***Тогда (Then)*** - ключевое слово, предназначенное для описания ожидаемых результатов.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

Шаг ***Тогда (Then)*** проверяет результирующее состояние системы после выполнения действий.
Проверки результатов должны быть связаны с явной пользой, которая указаны в описании функции.
Также необходимо помнить, что должен проверяться вывод системы (отчеты, интерфейс, сообщения), а не что-то глубоко закопанное в систему.

*Пример*

```gherkin
#language: ru

```

### 3.4.4. И (And), Но (But), * (Asterisk)

Если **Сценарии (Scenario)** есть несколько шагов **Дано (Given)**, **Когда (When)**, или **Тогда (Then)**, то можно писать их так:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
    Дано что-то первое
    Дано что-то второе
    Дано и что-то ещё
    Когда я открою свои глаза
    То я увижу что-то
    То чего-то я не увижу
```  

Или можно использовать шаги **И (And)** и **Но (But)**, превращая **Сценарии (Scenario)** в нечто более читаемое:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
И что-то второе
И и что-то ещё
Когда я открою свои глаза
То я увижу что-то
Но чего-то я не увижу
```

***И (And)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Когда Действие
    И Действие
    Тогда Результат
    И Результат
    # шаги сценария
```

***Но (But)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Но Предусловие
    Когда Действие
    И Действие
    Но Действие
    Тогда Результат
    И Результат
    Но Результат
    # шаги сценария
```

***\* (Asterisk)*** - символ, заменяющий любое ключевое слово обозначающее **Шаг (Step)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    * Предусловие
    * Предусловие
    Когда Действие
    * Действие
    * Действие
    Тогда Результат
    * Результат
    * Результат
    # шаги сценария
```

**\* (Asterisk)** используется для улучшения восприятия текста сценария.

*Пример*

```gherkin
#language: ru

```

## 3.5. Предыстория (Background)

***Предыстория (Background)*** - ключевое слово, предназначенное для добавления определенного
контекста ко всем **Сценариям (Scenario)** в пределах **Функции (Feature)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  
  Подробное описание
  На нескольких строках

  Предыстория: 
    Дано Предусловие
    
  Сценарий: Наименование сценария 1
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария

  Сценарий: Наименование сценария 2
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

В каждой **Функции (Feature)** может быть всего одна **Предыстория (Background)**
и располагается она до первого **Сценария (Scenario)** описанного в **Функции (Feature)**.

Если нужно добавить еще одну **Предыстория (Background)**,
то нужно подумать над разбиением **Функции (Feature)** на части.
Либо же настроить **Хуки (Hooks)** на определенные **Теги (Tags)**,
которыми будут помечены нужные **Сценарии (Scenario)**.

**Предыстория (Background)** по сути, представляет собой **Сценарий (Scenario)** без имени,
состоящий из **Шагов (Steps)**, которые повторно выполняются в каждом **Сценарии (Scenario)** какой-либо **Функции (Feature)**.

Основное отличие в запуске: **Предыстория (Background)** запускается перед каждым **Сценарием (Scenario)**,
но после выполнения любого **Хука (Hooks)** помеченного аннотацией **@Before**.

*Пример*

```gherkin
# language: ru
Функция: поддержка многих справочников

    Предыстория:
        Дано есть пользователь с именем "Вася"
        И есть справочник "Лекарства"
        И у пользователя "Вася" есть право на запись в  "Лекарство"
        И есть справочник "Виды лечений"

    Сценарий: Вася создает новую запись
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Лекарства"
        То мне должен быть ответ "Ваша запись успешно добавлена."

    Сценарий: Вася не может добавлять запись в справочник лечений
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Виды лечений"
        То мне должен быть ответ "У вас нет прав доступа!"
```      

## 3.6. Структура сценария (Scenario outline)

***Структура сценария (Scenario outline)*** - ключевое слово, предназначенное для многократного параметризованного выполнения сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  Структура сценария: Наименование сценария
    Дано Предусловие <параметр1>
    Когда Действие <параметр2>
    Тогда Результат <параметр3>

    Примеры:
      | параметр1 | параметр2 | параметр3 |
      | значение1 | значение1 | значение3 |
      | значение2 | значение2 | значение3 |
```

В некоторых случаях может потребоваться протестировать один и тот же сценарий несколько раз,
чтобы выполнить тестовые сценарии с применением техник **Эквивалентного разделения** и **Анализа граничных значений**.

*Пример*

```gherkin
#language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
```

**Структура сценария (Scenario outline)** позволяет более кратко описывать подобные наборы сценариев с помощью заглушек (\< \>).

***Примеры (Examples)*** - ключевое слово, предназначенное для определения значений параметров 
в виде таблицы значений, которые будут подставляться вместо заглушек.

Шаги указанные в **Структуре сценария (Scenario outline)** не выполняются напрямую,
а используются для подстановки в места, обозначенные символами (\< \>) значений из таблицы **Примеров (Examples)**.
Каждая строка таблицы **Примеров (Examples)** будет обрабатываться как отдельный сценарий,
а значения из строки будут подставляться в сценарий вместо заглушек.
Названия колонок должно совпадать с названием заглушек.
Количество строк может быть сколь угодном.

*Пример*

```gherkin
#language: ru
Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

***

# 4. Выражения (Expressions)

***Выражения (Expressions)*** - текст, содержащийся в аннотациях шагов, записанный с применением регулярного выражения или выражения **Cucumber**.

## 4.1. Регулярные выражения (Regular Expression)

***Регулярные выражения (Regular Expressions)*** — используемый в компьютерных программах, работающих с текстом, 
формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов 
(**Символ подстановки (Wildcard Characters)**). 

Для поиска используется строка-образец (**Шаблон (Pattern)**), состоящая из символов и метасимволов и задающая правило поиска. 
Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.

В аннотациях **Шагов (Steps)** то, что в регулярных выражениях записано в скобках передается в метод в виде аргумента.
Фреймворк **Cucumber** самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

*Пример*

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
public void they_have_their_receipt() {
    //code
}
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки)

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки)

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент.

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

## 4.2. Выражения Cucumber (Cucumber Expressions)

***Выражения Cucumber (Cucumber Expressions)*** - специальный формат записи выражений, используемый фреймворком **Cucumber** 
по функциональности похожий на **Регулярные выражения (Regular Expressions)**, но более удобный для восприятия.

По умолчанию фреймворк **Cucumber** воспринимает выражения как **Выражения Cucumber (Cucumber Expressions)**.
Чтобы фреймворк воспринимал их как **Регулярные выражения (Regular Expressions)**, то само выражение должно обрамляться: 
* или символами начала **^** и конца **$** (так называемые **Якоря (Anchors)**)
* или символами **/** в начале и в конце выражения

*Пример*

```java

```

### 4.2.1. Параметры

***Параметры*** - 

Синтаксис:

```java
Текст {параметр}
```

В **Выражения Cucumber (Cucumber Expressions)** можно передавать параметры в методы, на которые мапятся шаги.
***Параметры*** обрамляются в фигурные скобки, с указанием внутри типа.

Типы параметров в **Выражениях Cucumber (Cucumber Expressions)**:

* __{byte}__ - тип **byte / Byte** в Java

Соответствует **127**, **-128**.

* __{short}__ - тип **short / Short** в Java

Соответствует **32_767**, **-32_768**.

* __{int}__ - тип **int / Integer** в Java

Соответствует **2_147_483_647**, **-2_147_483_648**.

* __{long}__ - тип **long / Long** в Java

Соответствует **9_223_372_036_854_775_807**, **–9_223_372_036_854_775_808**.

* __{float}__ - тип **float / Float** в Java

Соответствует **3.6**, **-1.30**.

* __{double}__ - тип **double / Double** в Java

Соответствует **3.6**, **-1.30**.

* __{biginteger}__ - тип **BigInteger** в Java

Соответствует **9_223_372_036_854_775_807**, **–9_223_372_036_854_775_808**.

* __{bigdecimal}__ - тип **BigDecimal** в Java

Соответствует **71.1234567890**, **-10.1234567890**.

* __{word}__ - тип **String** в Java (без пробелов)

Соответствует **banana**, но не **banana split**.

* __{string}__ - тип **String** в Java (с пробелами, но все в кавычках)

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.
В метод будет передан только текст расположенный между парными кавычками.

* __{}__ - анонимный тип

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.

Параметр анонимного типа будет преобразован в тип параметра шага с помощью **Преобразователей объектов (Object Mapper)**.
**Cucumber** имеет встроенные **Преобразователи объектов (Object Mapper)**, которые могут обрабатывать большинство основных типов.
Помимо **Enum**, он поддерживает преобразование в **BigInteger**, **BigDecimal**, **Boolean**, **Byte**, **Short**, **Integer**, **Long**, **Float**, **Double** и **String**.
Для автоматического преобразования в другие типы рекомендуется использовать соответствующие **Преобразователи объектов (Object Mapper)**.

## 4.2.2. Параметры кастомных типов (Custom Parameter Types)

***Параметры кастомных типов*** - классы, помеченные специальной аннотацией, для создания собственных типов данных.

Синтаксис:

```java
@ParameterType("значение1|значение2")   // Регулярное выражение
...
```

**Выражения Cucumber (Cucumber Expressions)** можно расширить, чтобы они автоматически преобразовывали выходные параметры в кастомные типы.

*Пример*

```java
I have a {color} ball
```


```java
@ParameterType("red|blue|yellow") 
public Color color(String color) { // Тип и имя кастомного параметра
    return new Color(color);       
}
```

Список аргументов:

* *name* - имя, по которому тип параметра будет распознаваться
* *regexp* - регулярное выражение, с помощью которого будет сопоставляться параметр

Может включать группы захвата.

* *type* - тип значения возвращаемый методом
* *transformer* - метод, преобразующий совпадение из регулярного выражения

Должен иметь арность 1, если в регулярном выражении нет групп захвата.  
В ином случае арность должна соответствовать количеству групп захвата в регулярном выражении.

* *useForSnippets* - использование типа параметра для создания заглушек для неопределенных шагов

Если регулярное выражение часто совпадает с текстом, который не будет использоваться в качестве аргументов, 
то нужно отключить его использование для создания заглушек неопределенных шагов установив значение в **false**.
По умолчанию **true**.  

* *preferForRegexpMatch* - приоритет соответствия регулярному выражению

Если есть определения шагов, в которых используются регулярные выражения, и нужно, 
чтобы этот тип параметра имел приоритет над другими типами во время сопоставления, то нужно установить значение в **true**.
По умолчанию - **false**. 

## 4.2.3. Опциональный текст (Optional text)

***Опциональный текст (Optional text)*** - необязательный фрагмент текста, который может присутствовать в **Выражении Cucumber (Cucumber Expressions)**.

Синтаксис:

```java
Текст(необязательный текст)
```

**Опциональный текст (Optional text)** обрамляется в круглые скобки.
В регулярных выражениях круглые скобки обозначают группу захвата, 
но в **Выражении Cucumber (Cucumber Expressions)** они означают необязательный текст.

*Пример*

Грамматически неправильно говорить 1 огурцы, поэтому мы должны сделать множественное число необязательным.

```java
I have {int} cucumber(s) in my belly
```        

```java
I have 1 cucumber in my belly
```        

```java
I have 42 cucumbers in my belly
```

### 4.2.4. Альтернативный текст (Alternative text)

***Альтернативный текст (Alternative text)*** обязательный фрагмент текста, который может иметь значение на выбор из заданных вариантов. 

Синтаксис:

```java
Текст/альтернативный текст
```

**Альтернативный текст (Alternative text)** задается перечислением через слеш, без пробелов.
**Альтернативный текст (Alternative text)** работает только тогда, когда между альтернативными частями нет пробелов.

*Пример*

```java
I have {int} cucumber(s) in my belly/stomach
```

```java
I have 42 cucumbers in my belly
I have 42 cucumbers in my stomach
```


### 4.2.5. Экранирование (Escaping)

***Escape последовательности (Escape Sequence)*** - сочетание символов, состоящее из обратной косой черты *\\*,
за которой следует символ.

**Escape последовательности (Escape Sequence)** используется экранирования символов **\**, **(**, **{** или 
для представления знака новой строки, одиночной кавычки или некоторых других символов в символьной константе.

**Escape последовательности (Escape Sequence)** рассматривается как один символ и, следовательно, 
является допустимой символьной константой.

Если нужно будет использовать **()** или **{}**, можно экранировать символ **(** или **{** с помощью обратной косой черты.

*Пример*

```java
I have {int} \{what} cucumber(s) in my belly \(amazing!)
```

```gherkin
I have 1 {what} cucumber in my belly (amazing!)
I have 42 {what} cucumbers in my belly (amazing!)
```

Если нужно будет использовать **\\**, можно экранировать символ **\\** с помощью обратной косой черты.

*Пример*

```java
I have {int} \\{what} cucumber(s) in my belly \\(amazing!)
```

```gherkin
I have 1 \{what} cucumber in my belly \(amazing!)
I have 42 \{what} cucumbers in my belly \(amazing!)
```

В настоящее время нет возможности экранировать символ /.
Он всегда будет интерпретироваться как **Альтернативный текст (Alternative text)**.

***

# 5. Передача данных в шаги

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций.
Для подобной задачи в **Cucumber** есть несколько решений.

## 5.1. Данные перечисленные через запятую

Данные, перечисленные через запятую, **Cucumber** может обернуть в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

Для замены разделителя, можно воспользоваться аннотацией **@Delimiter**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл и Редактировать и О программе
```

```java
@Дано("^в меню доступны пункты (.+)$")
public void вМенюДоступныПункты(@Delimiter(" и ") List<String> arg) {
    // что-то сделать
}
```

## 5.2. Данные в виде таблицы с одной колонкой

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## 5.3. Данные в виде таблицы с двумя колонками

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в **Map**,
где данные из первой колонки – это ключи, а из второй – значения.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```

## 5.4. Данные в виде таблицы с множеством колонок (Data Tables)

***Таблицы данных (Data Tables)*** - конструкция для передачи списков данных в методы.

Синтаксис:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

[DataTable](https://github.com/cucumber/cucumber-jvm/tree/main/datatable)

***DataTable*** – класс, который эмулирует табличное представление данных. 

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    // что-то сделать
}
```

Для доступа к данным в **DataTable* имеется большое количество методов.

### 5.4.1. Преобразование таблицы в список ассоциативных массивов

```java
public <K,V> List<Map<K,V>> asMaps(Class<K> keyType,Class<V> valueType)
```

Конвертирует таблицу в список ассоциативных массивов. 
Первая строка таблицы используется для именования ключей, остальные как значения.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Название      | Доступен | Количество подменю |
| Файл          | true     | 5                  |
| Редактировать | false    | 8                  |
| О программе   | true     | 2                  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<Map<String, String>> table = arg.asMaps(String.class, String.class);
    System.out.println(table.get(0).get("Название"));
    System.out.println(table.get(1).get("Название"));
    System.out.println(table.get(2).get("Название"));
}
```

Данный пример выведет на консоль:

```text
Файл
Редактировать
О программе
```


### 5.4.2. Преобразование таблицы в список списков

```java
public <T> List<List<T>> asLists(Class<T> itemType)
```

Метод преобразует таблицу в список списков.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<List<String>> table = arg.asLists(String.class);
    
    System.out.print(table.get(0).get(0) + " ");
    System.out.print(table.get(0).get(1) + " ");
    System.out.println(table.get(0).get(2) + " ");
    
    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

На консоль будет выведено:

```text
Файл true 5
Редактировать false 8
```

### 5.4.3. Преобразование таблицы в список списков строк

```java
public List<List<String>> cells(int firstRow)
```

Этот метод делает то же, что и предыдущий метод, за исключением того, 
что нельзя определить какого типа данные находятся в таблице, всегда возвращает список строк – List. 
В качестве аргумента метод принимает номер первой строки:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<List<String>> table = arg.cells(1);
    
    System.out.print(table.get(0).get(0) + " ");
    System.out.print(table.get(0).get(1) + " ");
    System.out.println(table.get(0).get(2) + " ");
    
    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

Метод выведет на консоль:

```text
Редактировать false 8
О программе true 2
```

### 5.4.4. Экранирование (Table Cell Escaping)

Экранирование:

* **\n** - перевод на новую строку
* **\|** - вертикальная черта
* **\\** - обратный слэш

## 5.4. Использование классов 

Фреймворк **Cucumber** может создать объекты из табличных данных, переданных из сценария. 

Существует два способа это сделать.

### 5.4.1. Наименование полей класса в первой строке

Фреймворк **Cucumber** создает связанный список объектов из таблицы с тремя колонками. 
В первой строке таблицы должны быть указаны наименования полей класса, создаваемого объекта. 
Если какое-то поле не указать, оно не будет инициализировано.


*Пример*

```java
public class Menu {
    private String title;
    private boolean isAvailable;
    private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

```gherkin
# language: ru
Дано в меню доступны пункты
| title         | isAvailable | subMenuCount |
| Файл          | true        | 5            |
| Редактировать | false       | 8            |
| О программе   | true        | 2            |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<Menu> arg) {
    for (int i = 0; i < arg.size(); i++) {
        System.out.print(arg.get(i).getTitle() + " ");
        System.out.print(Boolean.toString(arg.get(i).getAvailable()) + " ");
        System.out.println(Integer.toString(arg.get(i).getSubMenuCount()));
    }
}
```

Вывод в консоль:

```text
Файл true 5
Редактировать false 8
О программе true 2
```

### 5.4.2. Наименование полей класса в первом столбце 

Фреймворк **Cucumber** создает связанный список объектов, но, в данном случае, 
наименования полей записывается в первой колонке таблицы.


*Пример*

```java
public class Menu {
    private String title;
    private boolean isAvailable;
    private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

```gherkin
# language: ru
Дано в меню доступны пункты
| title        | Файл | Редактировать | О программе |
| isAvailable  | true | false         | true        |
| subMenuCount | 5    | 8             | 2           |
```

А в аргументе описания шага используем аннотацию **@Transpose**.

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(@Transpose List<Menu> arg) {
    // что-то сделать
}
```

## 5.5. Докстринг (Doc Strings)

***Докстринг (Doc Strings)*** - текст экранированный тремя двойными кавычками.

Синтаксис:

```gherkin
# language: ru

"""
Текст
"""
```
Для передачи многострочных данных в аргумент метода, их необходимо экранировать тремя двойными кавычками.

```gherkin
# language: ru
Тогда отображается форма с текстом

"""
На ваш номер телефона был выслан одноразовый пароль.
Для подтверждения платежа необходимо ввести полученный
одноразовый пароль.
"""
```

В реализации шага нет необходимости находить **Докстринг (Doc Strings)** с помощью шаблона.
Он будет автоматически передан в качестве последнего аргумента в определении шага.
Данные в метод приходят в виде объекта класса **String**:

```java
@Тогда("^отображается форма с текстом$")
public void отображаетсяФормаСТекстом(String expectedText) {
// что-то сделать
}
```

***

# 6. Преобразование данных

Фреймворк самостоятельно приводит данные из сценария к типу данных, указанному в аргументе метода. 
Если это невозможно, то выбрасывает исключение ConversionException. 
Это справедливо и для классов Date и Calendar. 

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04.05.2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Все прекрасно сработало, **Cucumber** преобразовал *04.05.2017* 
в объект класса **Date** со значением *Thu May 04 00:00:00 EET 2017*.

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Дойдя до этого шага, **Cucumber** выбросил исключение:

```text
cucumber.deps.com.thoughtworks.xstream.converters.ConversionException: Couldn't convert "04-05-2017" to an instance of: [class java.util.Date]

```

Почему первый пример сработал, а второй нет?

Дело в том, что в **Cucumber** встроена поддержка форматов дат чувствительных к текущей локали. 
Если необходимо записать дату в формате, отличающемся от формата текущей локали, нужно использовать аннотацию **Format**:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (@Format("dd-MM-yyyy") Date arg) {
// что-то сделать
}
```

***

# 6. Плюсы и минусы

Плюсы:

1. Использование понятного всем языка

Сценарии **Gherkin**, определяющие поведение системы, описываются в простой форме и
могут быть понятны всем участникам проекта (заказчикам, аналитикам, разработчикам, тестировщикам).

2. Проектная документация + автотесты

Значительная часть функциональных спецификаций может быть написана в виде пользовательских историй на **Gherkin**.
Файлы, содержащие в себе спецификации, одновременно являются и исполняемыми автотестами.

3. Эффективный инструмент для автоматизации тестирования

* разделение тест-кейсов и кода тестов
* тестовая документация и программный код автотестов хранятся в одном проекте и неотделимы друг от друга
* сценарии тестирования **Gherkin** напрямую связывают приемочные тесты с автоматизированными тестами
* наличие словаря доступных шагов допускает вариативность сценариев и позволяет тестировщикам составлять новые автотесты, 
не обращаясь к программному коду.

Минусы:

1. Обязательное наличие высокой степени деловой активности и сотрудничества между всеми заинтересованными лицами 
(представители бизнеса, аналитики, разработчики, тестировщики)

2. Может работать не во всех сценариях

3. Плохо написанные тесты могут легко увеличить расходы на обслуживание тестов.

***

# 7. Лучшие практики

[Если вы чувствуете необходимость добавить что-то еще, обычно это знак того, что вам следует разбить сценарий на несколько сценариев.
Постарайтесь придумать примеры, которые не предполагают никаких предположений о технологиях или пользовательском интерфейсе.
Представьте себе 1922 год, когда не было компьютеров.
Детали реализации должны быть скрыты в определениях шагов.]

[Your BDD scenarios should change only when the requirement changes, not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).]

Tips for using Background
Don’t use Background to set up complicated states, unless that state is actually something the client needs to know.
For example, if the user and site names don’t matter to the client, use a higher-level step such as Given I am logged in as a site owner.
Keep your Background section short.
The client needs to actually remember this stuff when reading the scenarios. If the Background is more than 4 lines long, consider moving some of the irrelevant details into higher-level steps.
Make your Background section vivid.
Use colourful names, and try to tell a story. The human brain keeps track of stories much better than it keeps track of names like "User A", "User B", "Site 1", and so on.
Keep your scenarios short, and don’t have too many.
If the Background section has scrolled off the screen, the reader no longer has a full overview of what’s happening. Think about using higher-level steps, or splitting the *.feature file.

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)