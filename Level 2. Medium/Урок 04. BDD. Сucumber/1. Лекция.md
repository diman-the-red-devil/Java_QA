Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Интерфейс командной строки Cucumber (Cucumber Command-Line Interface Runner (Cucumber CLI Runner))

Фреймворк **Cucumber** поставляется с встроенным интерфейсом командной строки (**Cucumber CLI Runner**).

***Интерфейс командной строки Cucumber (Cucumber Command-Line Interface Runner (Cucumber CLI Runner))*** -
исполняемый класс **Java**, который можно запустить из командной строки (**io.cucumber.core.cli.Main**).

Формат команды:

```text
java io.cucumber.core.cli.Main [options] [ [DIR|DIR URI] | [ [FILE|FILE URI][:LINE]* ] | @[FILE|FILE URI] ]+
```

## 1.1. Опции командной строки Cucumber

1. Количество параллельных потоков при запуске сценариев

```shell
java io.cucumber.core.cli.Main --threads COUNT
```

Параметры:

* *COUNT* - число параллельных потоков

По умолчанию (если опция не указана): сценарии запускаются в один поток.

2. Пакет **Java** с кодом шагов, хуков и т д.

```shell
java io.cucumber.core.cli.Main --glue PATH
java io.cucumber.core.cli.Main -g PATH
```

Параметры:

* *PATH* - полный путь пакета **Java** 

По умолчанию (если опция не указана): **Cucumber** будет искать код шагов, хуков и т д в **classpath**.

3. Подключение плагинов

```shell
java io.cucumber.core.cli.Main --plugin PLUGIN[:[PATH|[URI [OPTIONS]]]
java io.cucumber.core.cli.Main -p PLUGIN[:[PATH|[URI [OPTIONS]]]
```

Параметры:

* *PLUGIN* - наименование/тип плагина

   * встроенные плагины форматов: 
*html*, *json*, *pretty*,
*junit*, *testng*, *teamcity*,
*progress*, *rerun*,*timeline*,
*message*, *usage*.

   * встроенные плагины описания:
*summary*, *null_summary*, *unused*

В **PLUGIN** можно указать полностью определенное имя класса, чтобы подключать сторонние плагины.

 * *URI*- ссылка на ресурс (http:// или https://) 

На данный адрес будет отправлен вывод как запрос PUT.
Это можно изменить, предоставив дополнительные параметры.

* *OPTIONS* - поддержка команд **cUrls** *-X* и *-H*

По умолчанию (если опция не указана): сценарии запускаются без плагина.

4. Фильтрация сценариев по тегам

```shell
java io.cucumber.core.cli.Main --tags TAG_EXPRESSION
java io.cucumber.core.cli.Main -t TAG_EXPRESSION
```

Параметры:

* *TAG_EXPRESSION* - список тегов для проверки на соответствие

По умолчанию (если опция не указана): сценарии запускаются без фильтрации по тегам.

5. Фильтрация сценариев по наименованию                       

```shell
java io.cucumber.core.cli.Main --name REGEXP
java io.cucumber.core.cli.Main -n REGEXP
```

Параметры:

* *REGEXP* - регулярное выражение для проверки на соответствие
  
По умолчанию (если опция не указана): сценарии запускаются без фильтрации по наименованию.

6. Невыполнение / выполнение кода сценариев

```shell
java io.cucumber.core.cli.Main --dry-run
java io.cucumber.core.cli.Main --no-dry-run
java io.cucumber.core.cli.Main -d true 
java io.cucumber.core.cli.Main -d false 
```

По умолчанию (если опция не указана): сценарии запускаются без пропуска выполнения кода.

7. Черно-белый / цветной вывод терминала

```shell
java io.cucumber.core.cli.Main --monochrome
java io.cucumber.core.cli.Main --no-monochrome
java io.cucumber.core.cli.Main -m true 
java io.cucumber.core.cli.Main -m false 
```

По умолчанию (если опция не указана): сценарии запускаются с цветным выводом терминала.

8. Соглашение об наименовании для сгенерированных методов 

```shell
java io.cucumber.core.cli.Main --snippets STYLE
```
Параметры:

* *STYLE* - стиль именования методов

  * *underscore* - сгенерированные методы будут именоваться в **змеином** стиле (подчеркивание)

  * *camelcase* - сгенерированные методы будут именоваться в **верблюжьем** стиле (заглавные буквы)

По умолчанию (если опция не указана): сгенерированные методы будут именоваться в "змеином" стиле (подчеркивание).

9. Версия

```shell
java io.cucumber.core.cli.Main --version
java io.cucumber.core.cli.Main -v
```

10. Справка

```shell
java io.cucumber.core.cli.Main --help
java io.cucumber.core.cli.Main -h
```

11. Список ключевых слов для определенного языка

```shell
java io.cucumber.core.cli.Main --i18n LANG
```

Параметры:

* *LANG* - язык сценариев

  * *help* - вывод списка всех языков

12. Пропуск сценариев с тегом @wip (**Работа в процессе (Work In Progress**)

```shell
java io.cucumber.core.cli.Main --wip
java io.cucumber.core.cli.Main -w
```

По умолчанию (если опция не указана): сценарии запускаются без пропуска.

13. Порядок выполнения сценариев

```shell
java io.cucumber.core.cli.Main --order ORDER
```

Параметры:

* *ORDER* - порядок выполнения сценариев

  * *reverse* - в обратном порядке

  * *random* - рандомно

По умолчанию (если опция не указана): сценарии запускаются по порядку.

14. Количество выполняемых сценариев

```shell
java io.cucumber.core.cli.Main --count COUNT
```

Параметры:

* *COUNT* - число выполняемых сценариев

По умолчанию (если опция не указана): сценарии запускаются без ограничений по количеству.

## 1.2. Путь к фичам

Если путь к **.feature** файлам не указан, **Cucumber** просканирует корневую папку и все подпапки.

* *\<path\>* - путь к папке с **.feature** файлами

Загрузка **.feature** файлов из папки **\<path\>** и всех подпапок.

*Пример*

```shell
src/tests/resources/features
```

* *\<path\>/\<name\>.feature* - путь к конкретному **.feature** файлу

Загрузка **.feature** файла с именем **\<name\>** из папки **\<path\>**.

*Пример*

```shell
src/tests/resources/features/Smartphones.feature
```

* *classpath:\<path\>/\<name\>.feature* - путь к конкретному **.feature** файлу с указанием **classpath**         

Загрузка **.feature** файла с именем **\<name\>** из папки **\<path\>** относительно **classpath**.

*Пример*

```shell
classpath:src/tests/resources/features/Smartphones.feature
```

* *\<path\>/\<name\>.feature:3:9* - путь к конкретному **.feature** файлу с указанием строки сценария

Загрузка **.feature** файла с именем **\<name\>** из папки **\<path\>** с указанием строк с 3 по 9 сценария.

*Пример*

```shell
src/tests/resources/features/Smartphones.feature:3:9
```

* *@\<path\>/\<file\>*

Загрузка **.feature** файла с именем **\<file\>** из папки **\<path\>** **\<path\>/\<file\>** 
from the file system and parse feature paths generated by the rerun formatter.

*Пример*

```shell
java io.cucumber.core.cli.Main ./src/tests/resources/features
```

--backtrace.

***

# 2. Опции запуска

Напрямую работать с CLI нет никакой необходимости.

**Cucumber** предоставляет несколько параметров, которые можно передать в командной строке.

Properties, Environment variables, System Options
Cucumber will in order of precedence parse properties from system properties, environment variables, @CucumberOptions and the cucumber.properties file. Note that the CLI arguments take precedence over all.

## 2.1. cucumber.properties

List configuration options
You can list the options available for the Cucumber version you are using.

Pass the --help option to print out all the available configuration options:

java io.cucumber.core.cli.Main --help
You can also use tags to specify what to run.

Cucumber will in order of precedence parse properties from system properties, environment variables and the cucumber.properties file.
Note that options provided by @CucumberOptions take precedence over the properties file and CLI arguments take precedence over all.
Note that the cucumber-junit-platform-engine is provided with properties by the Junit Platform rather then Cucumber. See junit-platform-engine Configuration Options for more information.

For example, if you are using Maven and want to run a subset of scenarios tagged with @smoke:

mvn test -Dcucumber.filter.tags="@smoke"
Supported properties are:

cucumber.ansi-colors.disabled=  # true or false. default: false                     
cucumber.execution.dry-run=     # true or false. default: false
cucumber.execution.limit=       # number of scenarios to execute (CLI only).  
cucumber.execution.order=       # lexical, reverse, random or random:[seed] (CLI only). default: lexical
cucumber.execution.strict=      # true or false. default: true.
cucumber.execution.wip=         # true or false. default: false.
cucumber.features=              # comma separated paths to feature files. example: path/to/example.feature, path/to/other.feature  
cucumber.filter.name=           # regex. example: .*Hello.*
cucumber.filter.tags=           # tag expression. example: @smoke and not @slow
cucumber.glue=                  # comma separated package names. example: com.example.glue  
cucumber.plugin=                # comma separated plugin strings. example: pretty, json:path/to/report.json
cucumber.object-factory=        # object factory class name. example: com.example.MyObjectFactory
cucumber.snippet-type=          # underscore or camelcase. default: underscore

## 2.2. junit.properties

Supported properties are:

cucumber.ansi-colors.disabled=  # true or false. default: false

cucumber.execution.dry-run=     # true or false. default: false

cucumber.execution.limit=       # number of scenarios to execute (CLI only).

cucumber.execution.order=       # lexical, reverse, random or random:[seed] (CLI only). default: lexical

cucumber.execution.wip=         # true or false. default: false.
# Fails if there any passing scenarios
# CLI only.

cucumber.features=              # command separated paths to feature files.
# example: path/to/example.feature, path/to/other.feature

cucumber.filter.name=           # a regular expression
# only scenarios with matching names are executed.
# example: ^Hello (World|Cucumber)$

cucumber.filter.tags=           # a cucumber tag expression.
# only scenarios with matching tags are executed.
# example: @Cucumber and not (@Gherkin or @Zucchini)

cucumber.glue=                  # comma separated package names.
# example: com.example.glue

cucumber.plugin=                # comma separated plugin strings.
# example: pretty, json:path/to/report.json

cucumber.object-factory=        # object factory class name.
# example: com.example.MyObjectFactory

cucumber.publish.enabled        # true or false. default: false
# enable publishing of test results

cucumber.publish.quiet          # true or false. default: false
# supress publish banner after test exeuction

cucumber.publish.token          # any string value.
# publish authenticated test results

cucumber.publish.url            # a valid url
# location to publish test reports to

cucumber.snippet-type=          # underscore or camelcase.
# default: underscore
Each property also has an UPPER_CASE and snake_case variant. For example cucumber.ansi-colors.disabled would also be understood as CUCUMBER_ANSI_COLORS_DISABLED and cucumber_ansi_colors_disabled.

***

# 3. Формирование отчетов (Reports)

CUCUMBER_PUBLISH_TOKEN=f435057b-3712-422d-8d35-398dd74f1a8f
После прогона тестовых сценариев **Cucumber** формирует отчет по результатам запуска.
В отчетах содержится информация о запуске - успешные и неуспешные сценарии / шаги / фичи и т д.
Для построения отчетов **Cucumber** использует специальные **Плагины отчетов (Reporter Plugins)**.

Существует множество различных **Плагины отчетов (Reporter Plugins)**:
некоторые из них встроены в сам фреймворк, другие устанавливаются отдельно.

## 3.1. Встроенные плагины отчетов (Built-in Reporter Plugins)

В **Cucumber** встроена возможность локальной генерации отчетов с помощью встроенных **Плагины отчетов (Reporter Plugins)**.
Встроенные **Плагины отчетов (Reporter Plugins)** еще называются **Форматтеры (Formatters)**.

Существуют следующие встроенные **Плагины отчетов (Reporter Plugins)**:

* message
* progress
* pretty
* html
* json (deprecated)
* rerun
* junit
* testng

## 3.2. Кастомные Форматтеры (Custom formatters)

В **Cucumber** есть возможность создания своего кастомного форматтера,
путем имплементации или расширения стандартного форматтера или использования сторонних форматтеров.

Чтобы указать свой форматтер, достаточно просто добавить флаг **--format**.

```shell
cucumber --format CustomFormatter
```

## 3.3. Cucumber Reports Service

The easiest way to get started with reporting is to use the Cucumber Reports service.

Watch this video for a quick introduction or read the introductory blog post for more details.

Publishing to the Cucumber Reports service is currently supported in:

Cucumber-JVM 6.7.0 and above
Cucumber-Ruby 5.1.1 and above
Cucumber-JS 7.0.0 and above

https://reports.cucumber.io/report-collections/506c4074-5727-4444-bda7-4052d68033ac

***

# 4. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и
использует отступы для задания структуры. Каждая строка представляет собой выражение -
шаг (**step**) и заканчивается переносом строки.

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на множество языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Список зарезервированных символов:

* *#* – обозначает комментарии
* *@* – тэгирует сценарии или функционал
* *|* – разделяет данные в табличном формате
* *"""* – обрамляет многострочные данные

## 3.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания поведения/функции системы и набора связанных с ней тестовых сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  # подробное описание
  # сценарии
```

Каждая **Функция (Feature)** описывается в отдельном файле с расширением **.feature**.
Любой документ **.feature** начинается с этого ключевого слова и краткого описания.
Каждая функция обычно состоит из списка сценариев (**Сценарий (Scenario)**, **Структура сценария (Scenario Outline)**).

На следующей строке после ключевого слова и наименования функции может идти **Подробное описание (Descriptions)**.
В **Подробное описание (Description)** можно добавить **Пользовательскую историю (User Story)**.

Наименование функции и подробное описание не имеют какого либо значения для **Cucumber**.

*Пример*

```Gherkin
Feature: Withdraw Money from ATM

  A user with an account at a bank would like to withdraw money from an ATM.
  Provided he has a valid account and debit or credit card, he should be allowed to make the transaction. 
  The ATM will tend the requested amount of money, return his card, and subtract amount of the withdrawal from the user's account.

  Scenario: Scenario 1
    Given preconditions
    When actions
    Then results

  Scenario: Scenario 2
  ...
```

## 3.2. Подробное описание (Descriptions)

***Подробное описание (Descriptions)*** - более подробное описание фичи.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

    Подробное описание
    На нескольких строках

    # сценарии
```

**Подробное описание (Descriptions)** представляет собой текст, который располагается на следующих строках
после строки с ключевым словом и размечается отступами. Количество строк никак не ограничено и
**Подробное описание (Descriptions)** продолжается до первого встреченного ключевого слова.
Эти строки будут проигнорированы **Cucumber** при выполнении тестов, но будут использованы при формировании отчетов.
Можно сказать, что **Подробное описание (Descriptions)** похоже на комментарий.

**Подробное описание (Descriptions)** можно добавлять после:

* *Примера (Example)* или *Сценария (Scenario)*
* *Предыстории (Background)*
* *Структуры сценария (Scenario Outline)*

*Пример*

```gherkin

```

## 3.3. Сценарий (Scenario)

***Сценарий (Scenario)*** - ключевое слово, предназначенное для описания конкретного тестового сценария.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
  # шаги сценария
```

**Сценарий (Scenario)** представляет собой одну из ключевых структур в языке **Gherkin**.
Каждый сценарий состоит из набора **Шагов (Steps)** - **Дано (Given)**, **Когда (When)** и **Тогда (Then)**.
Также **Сценарии (Scenario)** могут содержать **Предысторию (Background)** или
иметь множество примеров в виде **Структуры сценария (Scenario Outline)**.

**Сценарий (Scenario)** описывает поведение системы и является ее спецификацией.

*Пример*

```gherkin
#language: ru
Сценарий: Вася создает новую запись
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Лекарства"
То мне должен быть ответ "Ваша запись успешно добавлена."

Сценарий: Вася не может добавлять запись в справочник лечений
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Виды лечений"
То мне должен быть ответ "У вас нет прав доступа!"
```

## 3.4. Шаги (Steps)

***Шаги (Steps)*** - строительные блоки тестовых сценариев.

**Шаги (Steps)** представляют собой строки текста начинающиеся с одного из ключевых слов:

* *Дано (Given)* - данные
* *Когда (When)* - действия
* *То (Then)* - результаты
* *Но (But)*
* *И (And)*

Шаги **Но (But)** и **И (And)** существуют исключительно для удобства чтения и
по своим функциям повторяют ключевое слово, с которого начиналась предыдущая строка.

*Пример*

```gherkin
Scenario: A user attempts to withdraw more money than they have in their account
Given John has a valid Credit or Debit card
And his account balance is $20
When he inserts his card
And withdraws $40
Then the ATM displays an error
And returns his card
But his balance remains $20
```

Шаги должны быть параметризованными, чтобы их можно было повторно использовать.

### 3.4.1. Дано (Given)

***Дано (Given)*** - ключевое слово, предназначенное для описания предусловий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    # шаги сценария
```

Шаг ***Дано (Given)*** приводит систему в желаемое состояние перед тем
как пользователь (или внешняя система) начнет взаимодействие с системой.
Также можно рассматривать их как предусловия.

*Пример*

```gherkin
#language: ru
Дано нет пользователей в базе
Дано база данных пустая
```

### 3.4.2. Когда (When)

***Когда (When)*** - ключевое слово, предназначенное для описания событий или действий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    # шаги сценария
```

Шаг **Когда (When)** изменяет состояние системы путем взаимодействия с системой пользователя (или внешней системы).
Настоятельно рекомендуется использовать только один шаг **Когда (When)** для каждого сценария.

*Пример*

```gherkin
#language: ru
Пример: взаимодействие со страницей
Когда я открыл форму добавления учреждения
Когда я ввел "Институт радости" в поле "Наименование"
Когда я выбрал в поле "Тип" значение "Институт"
Когда я нажал на кнопку "Сохранить"
```

### 3.4.3. Тогда (Then)

***Тогда (Then)*** - ключевое слово, предназначенное для описания ожидаемых результатов.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

Шаг ***Тогда (Then)*** проверяет результирующее состояние системы после выполнения действий.
Проверки результатов должны быть связаны с явной пользой, которая указаны в описании функции.
Также необходимо помнить, что должен проверяться вывод системы (отчеты, интерфейс, сообщения), а не что-то глубоко закопанное в систему.

*Пример*

```gherkin
#language: ru

```

### 3.4.4. И (And), Но (But), * (Asterisk)

Если **Сценарии (Scenario)** есть несколько шагов **Дано (Given)**, **Когда (When)**, или **Тогда (Then)**, то можно писать их так:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
    Дано что-то первое
    Дано что-то второе
    Дано и что-то ещё
    Когда я открою свои глаза
    То я увижу что-то
    То чего-то я не увижу
```  

Или можно использовать шаги **И (And)** и **Но (But)**, превращая **Сценарии (Scenario)** в нечто более читаемое:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
И что-то второе
И и что-то ещё
Когда я открою свои глаза
То я увижу что-то
Но чего-то я не увижу
```

***И (And)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Когда Действие
    И Действие
    Тогда Результат
    И Результат
    # шаги сценария
```

***Но (But)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Но Предусловие
    Когда Действие
    И Действие
    Но Действие
    Тогда Результат
    И Результат
    Но Результат
    # шаги сценария
```

***\* (Asterisk)*** - символ, заменяющий любое ключевое слово обозначающее **Шаг (Step)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    * Предусловие
    * Предусловие
    Когда Действие
    * Действие
    * Действие
    Тогда Результат
    * Результат
    * Результат
    # шаги сценария
```

**\* (Asterisk)** используется для улучшения восприятия текста сценария.

*Пример*

```gherkin
#language: ru

```

## 3.5. Предыстория (Background)

***Предыстория (Background)*** - ключевое слово, предназначенное для добавления определенного
контекста ко всем **Сценариям (Scenario)** в пределах **Функции (Feature)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  
  Подробное описание
  На нескольких строках

  Предыстория: 
    Дано Предусловие
    
  Сценарий: Наименование сценария 1
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария

  Сценарий: Наименование сценария 2
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

В каждой **Функции (Feature)** может быть всего одна **Предыстория (Background)**
и располагается она до первого **Сценария (Scenario)** описанного в **Функции (Feature)**.

Если нужно добавить еще одну **Предыстория (Background)**,
то нужно подумать над разбиением **Функции (Feature)** на части.
Либо же настроить **Хуки (Hooks)** на определенные **Теги (Tags)**,
которыми будут помечены нужные **Сценарии (Scenario)**.

**Предыстория (Background)** по сути, представляет собой **Сценарий (Scenario)** без имени,
состоящий из **Шагов (Steps)**, которые повторно выполняются в каждом **Сценарии (Scenario)** какой-либо **Функции (Feature)**.

Основное отличие в запуске: **Предыстория (Background)** запускается перед каждым **Сценарием (Scenario)**,
но после выполнения любого **Хука (Hooks)** помеченного аннотацией **@Before**.

*Пример*

```gherkin
# language: ru
Функция: поддержка многих справочников

    Предыстория:
        Дано есть пользователь с именем "Вася"
        И есть справочник "Лекарства"
        И у пользователя "Вася" есть право на запись в  "Лекарство"
        И есть справочник "Виды лечений"

    Сценарий: Вася создает новую запись
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Лекарства"
        То мне должен быть ответ "Ваша запись успешно добавлена."

    Сценарий: Вася не может добавлять запись в справочник лечений
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Виды лечений"
        То мне должен быть ответ "У вас нет прав доступа!"
```      

## 3.6. Структура сценария (Scenario outline)

***Структура сценария (Scenario outline)*** - ключевое слово, предназначенное для многократного параметризованного выполнения сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  Структура сценария: Наименование сценария
    Дано Предусловие <параметр1>
    Когда Действие <параметр2>
    Тогда Результат <параметр3>

    Примеры:
      | параметр1 | параметр2 | параметр3 |
      | значение1 | значение1 | значение3 |
      | значение2 | значение2 | значение3 |
```

В некоторых случаях может потребоваться протестировать один и тот же сценарий несколько раз,
чтобы выполнить тестовые сценарии с применением техник **Эквивалентного разделения** и **Анализа граничных значений**.

*Пример*

```gherkin
#language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
```

**Структура сценария (Scenario outline)** позволяет более кратко описывать подобные наборы сценариев с помощью заглушек (\< \>).

***Примеры (Examples)*** - ключевое слово, предназначенное для определения значений параметров 
в виде таблицы значений, которые будут подставляться вместо заглушек.

Шаги указанные в **Структуре сценария (Scenario outline)** не выполняются напрямую,
а используются для подстановки в места, обозначенные символами (\< \>) значений из таблицы **Примеров (Examples)**.
Каждая строка таблицы **Примеров (Examples)** будет обрабатываться как отдельный сценарий,
а значения из строки будут подставляться в сценарий вместо заглушек.
Названия колонок должно совпадать с названием заглушек.
Количество строк может быть сколь угодном.

*Пример*

```gherkin
#language: ru
Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

***

# 4. Выражения (Expressions)

***Выражения (Expressions)*** - текст, содержащийся в аннотациях шагов, записанный с применением регулярного выражения или выражения **Cucumber**.

## 4.1. Регулярные выражения (Regular Expression)

***Регулярные выражения (Regular Expressions)*** — используемый в компьютерных программах, работающих с текстом, 
формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов 
(**Символ подстановки (Wildcard Characters)**). 

Для поиска используется строка-образец (**Шаблон (Pattern)**), состоящая из символов и метасимволов и задающая правило поиска. 
Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.

В аннотациях **Шагов (Steps)** то, что в регулярных выражениях записано в скобках передается в метод в виде аргумента.
Фреймворк **Cucumber** самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

*Пример*

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
public void they_have_their_receipt() {
    //code
}
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки)

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки)

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент.

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

## 4.2. Выражения Cucumber (Cucumber Expressions)

***Выражения Cucumber (Cucumber Expressions)*** - специальный формат записи выражений, используемый фреймворком **Cucumber** 
по функциональности похожий на **Регулярные выражения (Regular Expressions)**, но более удобный для восприятия.

По умолчанию фреймворк **Cucumber** воспринимает выражения как **Выражения Cucumber (Cucumber Expressions)**.
Чтобы фреймворк воспринимал их как **Регулярные выражения (Regular Expressions)**, то само выражение должно обрамляться: 
* или символами начала **^** и конца **$** (так называемые **Якоря (Anchors)**)
* или символами **/** в начале и в конце выражения

*Пример*

```java

```

### 4.2.1. Параметры

***Параметры*** - 

Синтаксис:

```java
Текст {параметр}
```

В **Выражения Cucumber (Cucumber Expressions)** можно передавать параметры в методы, на которые мапятся шаги.
***Параметры*** обрамляются в фигурные скобки, с указанием внутри типа.

Типы параметров в **Выражениях Cucumber (Cucumber Expressions)**:

* __{byte}__ - тип **byte / Byte** в Java

Соответствует **127**, **-128**.

* __{short}__ - тип **short / Short** в Java

Соответствует **32_767**, **-32_768**.

* __{int}__ - тип **int / Integer** в Java

Соответствует **2_147_483_647**, **-2_147_483_648**.

* __{long}__ - тип **long / Long** в Java

Соответствует **9_223_372_036_854_775_807**, **–9_223_372_036_854_775_808**.

* __{float}__ - тип **float / Float** в Java

Соответствует **3.6**, **-1.30**.

* __{double}__ - тип **double / Double** в Java

Соответствует **3.6**, **-1.30**.

* __{biginteger}__ - тип **BigInteger** в Java

Соответствует **9_223_372_036_854_775_807**, **–9_223_372_036_854_775_808**.

* __{bigdecimal}__ - тип **BigDecimal** в Java

Соответствует **71.1234567890**, **-10.1234567890**.

* __{word}__ - тип **String** в Java (без пробелов)

Соответствует **banana**, но не **banana split**.

* __{string}__ - тип **String** в Java (с пробелами, но все в кавычках)

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.
В метод будет передан только текст расположенный между парными кавычками.

* __{}__ - анонимный тип

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.

Параметр анонимного типа будет преобразован в тип параметра шага с помощью **Преобразователей объектов (Object Mapper)**.
**Cucumber** имеет встроенные **Преобразователи объектов (Object Mapper)**, которые могут обрабатывать большинство основных типов.
Помимо **Enum**, он поддерживает преобразование в **BigInteger**, **BigDecimal**, **Boolean**, **Byte**, **Short**, **Integer**, **Long**, **Float**, **Double** и **String**.
Для автоматического преобразования в другие типы рекомендуется использовать соответствующие **Преобразователи объектов (Object Mapper)**.

## 4.2.2. Параметры кастомных типов (Custom Parameter Types)

***Параметры кастомных типов*** - классы, помеченные специальной аннотацией, для создания собственных типов данных.

Синтаксис:

```java
@ParameterType("значение1|значение2")   // Регулярное выражение
...
```

**Выражения Cucumber (Cucumber Expressions)** можно расширить, чтобы они автоматически преобразовывали выходные параметры в кастомные типы.

*Пример*

```java
I have a {color} ball
```


```java
@ParameterType("red|blue|yellow") 
public Color color(String color) { // Тип и имя кастомного параметра
    return new Color(color);       
}
```

Список аргументов:

* *name* - имя, по которому тип параметра будет распознаваться
* *regexp* - регулярное выражение, с помощью которого будет сопоставляться параметр

Может включать группы захвата.

* *type* - тип значения возвращаемый методом
* *transformer* - метод, преобразующий совпадение из регулярного выражения

Должен иметь арность 1, если в регулярном выражении нет групп захвата.  
В ином случае арность должна соответствовать количеству групп захвата в регулярном выражении.

* *useForSnippets* - использование типа параметра для создания заглушек для неопределенных шагов

Если регулярное выражение часто совпадает с текстом, который не будет использоваться в качестве аргументов, 
то нужно отключить его использование для создания заглушек неопределенных шагов установив значение в **false**.
По умолчанию **true**.  

* *preferForRegexpMatch* - приоритет соответствия регулярному выражению

Если есть определения шагов, в которых используются регулярные выражения, и нужно, 
чтобы этот тип параметра имел приоритет над другими типами во время сопоставления, то нужно установить значение в **true**.
По умолчанию - **false**. 

## 4.2.3. Опциональный текст (Optional text)

***Опциональный текст (Optional text)*** - необязательный фрагмент текста, который может присутствовать в **Выражении Cucumber (Cucumber Expressions)**.

Синтаксис:

```java
Текст(необязательный текст)
```

**Опциональный текст (Optional text)** обрамляется в круглые скобки.
В регулярных выражениях круглые скобки обозначают группу захвата, 
но в **Выражении Cucumber (Cucumber Expressions)** они означают необязательный текст.

*Пример*

Грамматически неправильно говорить 1 огурцы, поэтому мы должны сделать множественное число необязательным.

```java
I have {int} cucumber(s) in my belly
```        

```java
I have 1 cucumber in my belly
```        

```java
I have 42 cucumbers in my belly
```

### 4.2.4. Альтернативный текст (Alternative text)

***Альтернативный текст (Alternative text)*** обязательный фрагмент текста, который может иметь значение на выбор из заданных вариантов. 

Синтаксис:

```java
Текст/альтернативный текст
```

**Альтернативный текст (Alternative text)** задается перечислением через слеш, без пробелов.
**Альтернативный текст (Alternative text)** работает только тогда, когда между альтернативными частями нет пробелов.

*Пример*

```java
I have {int} cucumber(s) in my belly/stomach
```

```java
I have 42 cucumbers in my belly
I have 42 cucumbers in my stomach
```


### 4.2.5. Экранирование (Escaping)

***Escape последовательности (Escape Sequence)*** - сочетание символов, состоящее из обратной косой черты *\\*,
за которой следует символ.

**Escape последовательности (Escape Sequence)** используется экранирования символов **\**, **(**, **{** или 
для представления знака новой строки, одиночной кавычки или некоторых других символов в символьной константе.

**Escape последовательности (Escape Sequence)** рассматривается как один символ и, следовательно, 
является допустимой символьной константой.

Если нужно будет использовать **()** или **{}**, можно экранировать символ **(** или **{** с помощью обратной косой черты.

*Пример*

```java
I have {int} \{what} cucumber(s) in my belly \(amazing!)
```

```gherkin
I have 1 {what} cucumber in my belly (amazing!)
I have 42 {what} cucumbers in my belly (amazing!)
```

Если нужно будет использовать **\\**, можно экранировать символ **\\** с помощью обратной косой черты.

*Пример*

```java
I have {int} \\{what} cucumber(s) in my belly \\(amazing!)
```

```gherkin
I have 1 \{what} cucumber in my belly \(amazing!)
I have 42 \{what} cucumbers in my belly \(amazing!)
```

В настоящее время нет возможности экранировать символ /.
Он всегда будет интерпретироваться как **Альтернативный текст (Alternative text)**.

***

# 5. Передача данных в шаги

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций.
Для подобной задачи в **Cucumber** есть несколько решений.

## 5.1. Данные перечисленные через запятую

Данные, перечисленные через запятую, **Cucumber** может обернуть в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

Для замены разделителя, можно воспользоваться аннотацией **@Delimiter**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл и Редактировать и О программе
```

```java
@Дано("^в меню доступны пункты (.+)$")
public void вМенюДоступныПункты(@Delimiter(" и ") List<String> arg) {
    // что-то сделать
}
```

## 5.2. Данные в виде таблицы с одной колонкой

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## 5.3. Данные в виде таблицы с двумя колонками

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в **Map**,
где данные из первой колонки – это ключи, а из второй – значения.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```

## 5.4. Данные в виде таблицы с множеством колонок (Data Tables)

***Таблицы данных (Data Tables)*** - конструкция для передачи списков данных в методы.

Синтаксис:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

[DataTable](https://github.com/cucumber/cucumber-jvm/tree/main/datatable)

***DataTable*** – класс, который эмулирует табличное представление данных. 

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    // что-то сделать
}
```

Для доступа к данным в **DataTable* имеется большое количество методов.

### 5.4.1. Преобразование таблицы в список ассоциативных массивов

```java
public <K,V> List<Map<K,V>> asMaps(Class<K> keyType,Class<V> valueType)
```

Конвертирует таблицу в список ассоциативных массивов. 
Первая строка таблицы используется для именования ключей, остальные как значения.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Название      | Доступен | Количество подменю |
| Файл          | true     | 5                  |
| Редактировать | false    | 8                  |
| О программе   | true     | 2                  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<Map<String, String>> table = arg.asMaps(String.class, String.class);
    System.out.println(table.get(0).get("Название"));
    System.out.println(table.get(1).get("Название"));
    System.out.println(table.get(2).get("Название"));
}
```

Данный пример выведет на консоль:

```text
Файл
Редактировать
О программе
```


### 5.4.2. Преобразование таблицы в список списков

```java
public <T> List<List<T>> asLists(Class<T> itemType)
```

Метод преобразует таблицу в список списков.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<List<String>> table = arg.asLists(String.class);
    
    System.out.print(table.get(0).get(0) + " ");
    System.out.print(table.get(0).get(1) + " ");
    System.out.println(table.get(0).get(2) + " ");
    
    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

На консоль будет выведено:

```text
Файл true 5
Редактировать false 8
```

### 5.4.3. Преобразование таблицы в список списков строк

```java
public List<List<String>> cells(int firstRow)
```

Этот метод делает то же, что и предыдущий метод, за исключением того, 
что нельзя определить какого типа данные находятся в таблице, всегда возвращает список строк – List. 
В качестве аргумента метод принимает номер первой строки:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    List<List<String>> table = arg.cells(1);
    
    System.out.print(table.get(0).get(0) + " ");
    System.out.print(table.get(0).get(1) + " ");
    System.out.println(table.get(0).get(2) + " ");
    
    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

Метод выведет на консоль:

```text
Редактировать false 8
О программе true 2
```

### 5.4.4. Экранирование (Table Cell Escaping)

Экранирование:

* **\n** - перевод на новую строку
* **\|** - вертикальная черта
* **\\** - обратный слэш

## 5.4. Использование классов 

Фреймворк **Cucumber** может создать объекты из табличных данных, переданных из сценария. 

Существует два способа это сделать.

### 5.4.1. Наименование полей класса в первой строке

Фреймворк **Cucumber** создает связанный список объектов из таблицы с тремя колонками. 
В первой строке таблицы должны быть указаны наименования полей класса, создаваемого объекта. 
Если какое-то поле не указать, оно не будет инициализировано.


*Пример*

```java
public class Menu {
    private String title;
    private boolean isAvailable;
    private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

```gherkin
# language: ru
Дано в меню доступны пункты
| title         | isAvailable | subMenuCount |
| Файл          | true        | 5            |
| Редактировать | false       | 8            |
| О программе   | true        | 2            |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<Menu> arg) {
    for (int i = 0; i < arg.size(); i++) {
        System.out.print(arg.get(i).getTitle() + " ");
        System.out.print(Boolean.toString(arg.get(i).getAvailable()) + " ");
        System.out.println(Integer.toString(arg.get(i).getSubMenuCount()));
    }
}
```

Вывод в консоль:

```text
Файл true 5
Редактировать false 8
О программе true 2
```

### 5.4.2. Наименование полей класса в первом столбце 

Фреймворк **Cucumber** создает связанный список объектов, но, в данном случае, 
наименования полей записывается в первой колонке таблицы.


*Пример*

```java
public class Menu {
    private String title;
    private boolean isAvailable;
    private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

```gherkin
# language: ru
Дано в меню доступны пункты
| title        | Файл | Редактировать | О программе |
| isAvailable  | true | false         | true        |
| subMenuCount | 5    | 8             | 2           |
```

А в аргументе описания шага используем аннотацию **@Transpose**.

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(@Transpose List<Menu> arg) {
    // что-то сделать
}
```

## 5.5. Докстринг (Doc Strings)

***Докстринг (Doc Strings)*** - текст экранированный тремя двойными кавычками.

Синтаксис:

```gherkin
# language: ru

"""
Текст
"""
```
Для передачи многострочных данных в аргумент метода, их необходимо экранировать тремя двойными кавычками.

```gherkin
# language: ru
Тогда отображается форма с текстом

"""
На ваш номер телефона был выслан одноразовый пароль.
Для подтверждения платежа необходимо ввести полученный
одноразовый пароль.
"""
```

В реализации шага нет необходимости находить **Докстринг (Doc Strings)** с помощью шаблона.
Он будет автоматически передан в качестве последнего аргумента в определении шага.
Данные в метод приходят в виде объекта класса **String**:

```java
@Тогда("^отображается форма с текстом$")
public void отображаетсяФормаСТекстом(String expectedText) {
// что-то сделать
}
```

***

# 6. Преобразование данных

Фреймворк самостоятельно приводит данные из сценария к типу данных, указанному в аргументе метода. 
Если это невозможно, то выбрасывает исключение ConversionException. 
Это справедливо и для классов Date и Calendar. 

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04.05.2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Все прекрасно сработало, **Cucumber** преобразовал *04.05.2017* 
в объект класса **Date** со значением *Thu May 04 00:00:00 EET 2017*.

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Дойдя до этого шага, **Cucumber** выбросил исключение:

```text
cucumber.deps.com.thoughtworks.xstream.converters.ConversionException: Couldn't convert "04-05-2017" to an instance of: [class java.util.Date]

```

Почему первый пример сработал, а второй нет?

Дело в том, что в **Cucumber** встроена поддержка форматов дат чувствительных к текущей локали. 
Если необходимо записать дату в формате, отличающемся от формата текущей локали, нужно использовать аннотацию **Format**:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (@Format("dd-MM-yyyy") Date arg) {
// что-то сделать
}
```

***


***

# 7. Лучшие практики

Think twice before you use Before

Whatever happens in a Before hook is invisible to people who only read the features. You should consider using a background as a more explicit alternative, especially if the setup should be readable by non-technical people. Only use a Before hook for low-level logic such as starting a browser or deleting data from a database.


[Если вы чувствуете необходимость добавить что-то еще, обычно это знак того, что вам следует разбить сценарий на несколько сценариев.
Постарайтесь придумать примеры, которые не предполагают никаких предположений о технологиях или пользовательском интерфейсе.
Представьте себе 1922 год, когда не было компьютеров.
Детали реализации должны быть скрыты в определениях шагов.]

[Your BDD scenarios should change only when the requirement changes, not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).]

Tips for using Background
Don’t use Background to set up complicated states, unless that state is actually something the client needs to know.
For example, if the user and site names don’t matter to the client, use a higher-level step such as Given I am logged in as a site owner.
Keep your Background section short.
The client needs to actually remember this stuff when reading the scenarios. If the Background is more than 4 lines long, consider moving some of the irrelevant details into higher-level steps.
Make your Background section vivid.
Use colourful names, and try to tell a story. The human brain keeps track of stories much better than it keeps track of names like "User A", "User B", "Site 1", and so on.
Keep your scenarios short, and don’t have too many.
If the Background section has scrolled off the screen, the reader no longer has a full overview of what’s happening. Think about using higher-level steps, or splitting the *.feature file.

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)