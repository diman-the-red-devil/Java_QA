Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Cucumber

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

Первоначально **Cucumber** был разработан **Ruby**-сообществом, 
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**). 

**Cucumber** использует легко читаемый предметно-ориентированный язык для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему, понимать и писать их может любой участник проекта.

**Cucumber** заполняет разрыв между разработчиками и заинтересованными сторонами (бизнес). 
Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых примеров. 
Тестовые примеры могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.). 
Эти тестовые примеры мапятся с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, который можно использовать в связке со многими другими популярными инструментами:

* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов

***

# 2. Структура проекта Cucumber

Проект **Cucumber** состоит из следующих частей:

1. описание сценариев (поведения системы) по шагам - текстовые файлы с расширением **.feature** 

2. реализация шагов сценариев на языке программирования - файлы с исходным кодом **.java**

3. прочие файлы

4. раннер для запуска сценариев - специальный класс

# Features

Feature file – Contains code written in Gherkin (plain English text)
These files contain executable specifications written in a domain-specific language (DSL) 
called Gherkin which is a business-readable, plain-text, English-like language with simple grammar.
A .feature file is supposed to describe a single feature of the system, or a particular aspect of a feature. 
It's just a way to provide a high-level description of a software feature, and to group related scenarios.

The feature describes (part of) a feature of your application, and the scenarios describe different ways users can use this feature.
Тест записывается в файл с расширением *.feature и может содержать как один, так и более сценариев.

Your BDD scenarios should change only when the requirement changes, 
not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).

# Step Defs

Cucumber doesn’t know how to execute your scenarios out-of-the-box. It needs Step Definitions to translate plain text Gherkin steps into actions that will interact with the system. 
When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.
When Cucumber matches a Step against a pattern in a Step Definition, it passes the value of all the capture groups to the Step Definition’s arguments.

Step definition file – Contains the actual code written by the developer
Step definitions connect Gherkin steps to programming code.
A step definition carries out the action that should be performed by the step.
So step definitions hard-wire the specification to the implementation.

    Steps    │                 │     Step     │                 │           │
│ in Gherkin ├──matched with──>│ Definitions  ├───manipulates──>│  System

Step definitions can be written in many programming languages.

To run the scenarios in the feature file, a step definition file with a function for each Given, When, Then is required.

```java
@RunWith(Cucumber.class)
public class MyStepDefinitions {

    @Given("^the customer has purchased a kettle for €10$")
    public void the_customer_has_purchased_a_kettle_for_10() {
        //code
    }

    @When("^the sales assistant processes the refund$")
    public void the_sales_assistant_processes_the_refund() {
        //code
    }

    @Then("^the stock inventory for kettles is incremented by 1$")
    public void the_stock_inventory_for_kettles_is_incremented_by_1() {
        //code
    }

    @And("^they have their receipt$")
    public void they_have_their_receipt() {
        //code
    }

    @And("^the customer's card is credited with €10$")
    public void the_customers_card_is_credited_with_10() {
        //code
    }

}
```

# Hooks

This is a cool option in Cucumber. But you need prior knowledge to understand Hooks. Cucumber hooks are more like utility functions which help to perform some activity before/after/during execution. With that, you must remember that not only Cucumber, but also the test runner also performs hook functions. According to the priority of each hook type, one can implement their activities in them appropriately.
Also note that each Cucumber Scenario executes independently, and Background steps mentioned in the feature file run before executing each Scenario.

# Tags

Tags are a great way made for Cucumber power users to organize their features and scenarios. In the above example, by changing tags = {“~@Ignore”} line to tags = {“@UpdateProfile”}, one can choose run only the features and scenarios tagged with @UpdateProfile tag. A Scenario or feature can have as many tags as you like. Just separate them with spaces: @important @maintenance @db @auth
Any tag that exists on a Feature will be inherited by Scenario, Scenario Outline or Examples. Therefore, in the above example, all the scenarios in the Update Profile feature must run. By mentioning a tag before a Scenario (as same as above Feature case), one can choose to run a subset of scenarios with that tag.

You can tag your scenarios. Tagging a scenario helps you to run only the scenarios that belong to a certain tag.
You can have multiple tags for a single scenario
You can run multiple tags together

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

# Run

To run the feature files, an empty class is created with @RunWith(Cucumber.class) annotation. All the configurations are put in the @CucumberOptions.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
//        name = "^Успешное|Успешная.*"
)
public class RunnerTest {
}

```

В классе-раннере задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
tags = "@all, @dev, @int, @regress",
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
tags = "@positive, ~@negative",
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — to specify different formatting options for the output reports

* *monochrome* true — to receive clean and readable output in your console

# Reports



# 3. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для 
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и 
использует отступы для задания структуры. Каждая строка представляет собой выражение - 
шаг (**step**) и заканчивается переносом строки. 

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на много языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Обратите внимание на структуру сценария:

1. Получить начальное состояние системы;
2. Что-то сделать;
3. Получить новое состояние системы.

Помните паттерн AAA))

Список зарезервированных символов:

* \# – обозначает комментарии
* @ – тэгирует сценарии или функционал
* | – разделяет данные в табличном формате
* """ – обрамляет многострочные данные

  Why Gherkin?
  Describe use cases for a software system in one way, easy to read and understand.
  Allows business analysts, managers, developers and other third-parties involved to understand the requirements of the project and the life-cycle.
  Makes it easy to create simple documentation of the code that’s being written.
  Provides scripts for test automation.
* 
Pros / Cons of Gherkin
Pros
Help determine the right customer requirements: because the document is based on natural language direction, any object can understand, so when reading this document, customers can easily know if the programmer is going in the right direction they want it.
The code writing style is easy to maintain and implement
An effective tool for testing

Advantages of Gherkin
Gherkin is simple enough for non-programmers to understand
Programmers can use it as a very solid base to start their tests
It makes User Stories easier to digest
Gherkin script can easily understand by business executives and developers
Gherkin Testing targets the business requirements
A significant proportion of the functional specifications is written as user stories
You don’t need to be expert to understand the small Gherkin command set
Gherkin Test cases link acceptance tests directly to automated tests
Style of writing tests cases are easier to reuse code in other tests

Cons
It requires a high degree of business engagement and cooperation
May not work well in all scenarios
Poorly written tests can easily increase test maintenance costs

Disadvantages of Gherkin
It requires a high level of business engagement and collaborations
May not work well in all scenarios
Poorly written tests can easily increase test-maintenance cost


## 2.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания фичи и набора связанных с ней тестовых сценариев. 

Любой документ начинается с этого ключевого слова и последующего краткого описания. 

*Пример*

```Gherkin
Функция: Заказ товара
```



## 2.2. Подробное описание (Descriptions)

Можно добавить более подробное описание на следующих строках.
Эти строки будут проигнорированы ***Cucumber*** при выполнении тестов, но будут использованы при формировании отчетов.

*Пример*

```gherkin

```

A Feature usually consists of a list of Scenarios. Can write whatever you want until the beginning of the first Scenario (when the new line begins with the word “Scenario:”)

Tags can be used to group features and scenarios together, regardless of the file and directory structure. Each scenario consists of a list of steps, steps starting with keywords such as (Given, When, Then, But or And). Additionally, the feature may include a scenario outline and background

# #

## Scenario
Each feature file may have multiple scenarios, and each scenario starts with a script.
Scenarios are added to the feature file, to define examples of the expected behaviour. These scenarios can be used to test the feature. Start a scenario with the Scenario keyword and add a brief description of the scenario. To define the scenario, you have to define all of its steps.
Scenario or Example: This is a concrete example that illustrates a business rule. It consists of a list of steps.

Each step starts with Given, When, Then, And, or But.

## Given: 

Preconditions, use to describe the original context. Introduce into the system a state to start interacting with the system. Given’s goal is to put the system into a known state before use (or the external system) to start interacting with the system (in the When step).

If you have worked with a use case, Givens is a prerequisite.
the initial context of the system - the scene of the scenario.
Use this keyword to bring the system to a familiar state before the user starts interacting with the system. However, you can skip writing user interactions in the given steps if given in the “Precondition” step.

## When: 

describe the main action events the user performed. The use of the keyword “then” is to see the result after the action in the when “step”. However, you can only verify notable changes.
an event, or an action. This can be a person interacting with the system, or it can be an event triggered by another system.
The purpose of “When” is to describe events, the main action that a user uses.

## Then: 

Expected output. “Then” was used to observe the result. Observations must be related to business values / benefits in “Feature” description. Observations must check the output of the system (a report, user interface, messages, etc.)

an expected outcome, or result.
The use of the keyword ‘then’ is to see the result after the action in the “When” step. However, you can only verify notable changes.

## And, But: 

Used when there are many “Given”, “When”, “Then”
If you have successive Given’s, When’s, or Then’s, you could use And or But based on the context.

## Scenario outline

Scenario Outline: to run the same Scenario multiple times, with different combinations of values.
Examples: A Scenario Outline must contain Examples section containing all the different values to run the Scenario Outline with.


## Background

Background: add some context to the scenarios in the feature.
The “Background” keyword helps you add some context to the script. It may contain several script steps, but the only difference is that it should be run before each script.
It can contain some steps of the scenario, but the only difference is that it should be run before each scenario.

# Passing Data

## Regular Expression

Regular Expressions could be used when multiple scenarios are similar but they work with different data.
Say, for example, for Feature 'Process refund', you have a scenario where customer has their bank statement claiming they purchases a kettle for €10 from the store. In this case you would like to reuse the following function and not create a fresh one for 'bank statement'

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
    public void they_have_their_receipt() {
        //code
    }
```

## Datatables

When you have multiple parameters to pass to the function

Feature File:

```gherkin
Feature: Process refunds
Scenario: Customer has their receipt
Given the customer has purchased a kettle for €10
And they have their receipt
When the sales assistant processes the refund
And user fills the process refund form
| John | Smith | US | 987654321 |
Then the stock inventory for kettles is incremented by 1
And the customer's card is credited with €10

```

The function in Step Definition would look like this:

```java
@And("^user fills the process refund form$")
public void user_fills_the_process_refund_form(DataTable data) {
//To access the values
List<List<String>> obj = data.raw();
System.out.println(obj.get(0).get(0)); // 1st row, 1st column
System.out.println(obj.get(0).get(1)); // 1st row, 2nd column
System.out.println(obj.get(0).get(2)); // 1st row, 3rd column
System.out.println(obj.get(0).get(3)); // 1st row, 4th column       
}
```

## Scenario Outline & Example keyword


```gherkin
Feature: Process refunds
  Scenario Outline: Customer has their receipt
    Given the customer has purchased something
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for <product> is incremented by <quantity>
      And the customer's card is credited with €<price>

    Examples: 
      | product | quantity | price | 
      | kettle  | 1        | 10    | 
      | cup     | 6        | 50    | 
      | mug     | 2        | 30    | 
      | glass   | 12       | 40    |
```

```java
@Then("^the stock inventory for (.+) is incremented by (.+)$")
    public void the_stock_inventory_for_is_incremented_by(String product, String quantity) {
        System.out.println(product);
        System.out.println(quantity);
    }

    @And("^the customer's card is credited with €(.+)$")
    public void the_customers_card_is_credited_with_(String price) {
        System.out.println(price);
    }
```

***

# Best practices of using Gherkin

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)