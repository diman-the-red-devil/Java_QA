Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Cucumber

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

Первоначально **Cucumber** был разработан **Ruby**-сообществом, 
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**). 

**Cucumber** использует легко читаемый предметно-ориентированный язык для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему, понимать и писать их может любой участник проекта.

**Cucumber** заполняет разрыв между разработчиками и заинтересованными сторонами (бизнес). 
Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых примеров. 
Тестовые примеры могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.). 
Эти тестовые примеры мапятся с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, который можно использовать в связке со многими другими популярными инструментами:

* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов

***

# 2. Структура проекта Cucumber

Проект **Cucumber** состоит из следующих частей:

1. описание сценариев (поведения системы) по шагам - текстовые файлы с расширением **.feature** 

2. реализация шагов сценариев на языке программирования - файлы с исходным кодом **.java**

3. прочие файлы

4. раннер для запуска сценариев - специальный класс

# Описание сценариев (Features)

***Описание сценариев (Features)*** – файлы с расширением **.feature**, которые содержат текст исполняемых спецификаций на языке **Gherkin**.

Файл **.feature** должен содержать описание только одной фичи.

A .feature file is supposed to describe a single feature of the system, or a particular aspect of a feature. 
It's just a way to provide a high-level description of a software feature, and to group related scenarios.

*Пример*

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

  @success
  Сценарий: Успешное снятие денег со счета
    Дано на счете пользователя имеется 120000 рублей
    Когда пользователь снимает со счета 20000 рублей
    Тогда на счете пользователя имеется 100000 рублей

  @fail
  Сценарий: Снятие денег со счета - недостаточно денег
    Дано на счете пользователя имеется 100 рублей
    Когда пользователь снимает со счета 120 рублей
    Тогда появляется предупреждение "На счете недостаточно денег"
```

Обратите внимание на структуру сценария:

1. Получить начальное состояние системы;
2. Что-то сделать;
3. Получить новое состояние системы.

Сценарий начинается со строки # language: ru. 
Эта строчка указывает Cucumber, что в сценарии используется русский язык. 
Если её не указать, фреймворк, встретив в сценарии русский текст, выбросит исключение LexingError и тест не запустится. 
По умолчанию используется английский язык.

Your BDD scenarios should change only when the requirement changes, not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).

# Реализация шагов сценариев (Step Defs)

***Реализация шагов сценариев (Step Defs)*** - файлы с расширением **.java**, 
содержащие код для взаимодействия с разрабатываемой системой, на который мапятся шаги в описании сценариев. 

**Cucumber** не знает как исполнять сценарии написанные на **Gherkin**.
Для их запуска нужна **Реализация шагов сценариев (Step Defs)**, чтобы замапить шаги описанные в тексте на **Gherkin**
в действия по взаимодействию с системой. 

**Реализация шагов сценариев (Step Defs)** может быть написана на разных языках программирования (**Java**, **Ruby**, **C#**, **Python**, **JS**).

    Steps    │                 │     Step     │                 │           │
│ in Gherkin ├──matched with──>│ Definitions  ├───manipulates──>│  System


*Пример*

```java

```

# Хуки (Hooks)

This is a cool option in Cucumber. But you need prior knowledge to understand Hooks. Cucumber hooks are more like utility functions which help to perform some activity before/after/during execution. With that, you must remember that not only Cucumber, but also the test runner also performs hook functions. According to the priority of each hook type, one can implement their activities in them appropriately.
Also note that each Cucumber Scenario executes independently, and Background steps mentioned in the feature file run before executing each Scenario.

# Теги (Tags)

Tags are a great way made for Cucumber power users to organize their features and scenarios. In the above example, by changing tags = {“~@Ignore”} line to tags = {“@UpdateProfile”}, one can choose run only the features and scenarios tagged with @UpdateProfile tag. A Scenario or feature can have as many tags as you like. Just separate them with spaces: @important @maintenance @db @auth
Any tag that exists on a Feature will be inherited by Scenario, Scenario Outline or Examples. Therefore, in the above example, all the scenarios in the Update Profile feature must run. By mentioning a tag before a Scenario (as same as above Feature case), one can choose to run a subset of scenarios with that tag.

You can tag your scenarios. Tagging a scenario helps you to run only the scenarios that belong to a certain tag.
You can have multiple tags for a single scenario
You can run multiple tags together

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

# Запуск (Run)

## Раннер

Для запуска сценариев нужно создать класс с аннотацией **@RunWith(Cucumber.class)**. 

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
//        name = "^Успешное|Успешная.*"
)
public class RunnerTest {
}

```

В классе-раннере через аннотацию **@CucumberOptions** задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
tags = "@all, @dev, @int, @regress",
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
tags = "@positive, ~@negative",
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — to specify different formatting options for the output reports

* *monochrome* true — to receive clean and readable output in your console

## Процесс запуска

При запуске теста Cucumber проходит по сценарию шаг за шагом. Взяв шаг, он отделяет ключевое слово от описания шага и пытается найти в Java-классах пакета указанного в опции glue аннотацию с регулярным выражением, подходящим описанию. Найдя совпадение, фреймворк вызывает метод с найденной аннотацией. Если несколько регулярных выражений удовлетворяют описанию шага, фреймворк выбрасывает ошибку.
When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.
When Cucumber matches a Step against a pattern in a Step Definition, it passes the value of all the capture groups to the Step Definition’s arguments.

# Reports


***

# 3. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для 
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и 
использует отступы для задания структуры. Каждая строка представляет собой выражение - 
шаг (**step**) и заканчивается переносом строки. 

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на много языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Обратите внимание на структуру сценария:

1. Получить начальное состояние системы;
2. Что-то сделать;
3. Получить новое состояние системы.

Помните паттерн AAA))

Список зарезервированных символов:

* \# – обозначает комментарии
* @ – тэгирует сценарии или функционал
* | – разделяет данные в табличном формате
* """ – обрамляет многострочные данные

  Why Gherkin?
  Describe use cases for a software system in one way, easy to read and understand.
  Allows business analysts, managers, developers and other third-parties involved to understand the requirements of the project and the life-cycle.
  Makes it easy to create simple documentation of the code that’s being written.
  Provides scripts for test automation.
* 
Pros / Cons of Gherkin
Pros
Help determine the right customer requirements: because the document is based on natural language direction, any object can understand, so when reading this document, customers can easily know if the programmer is going in the right direction they want it.
The code writing style is easy to maintain and implement
An effective tool for testing

Advantages of Gherkin
Gherkin is simple enough for non-programmers to understand
Programmers can use it as a very solid base to start their tests
It makes User Stories easier to digest
Gherkin script can easily understand by business executives and developers
Gherkin Testing targets the business requirements
A significant proportion of the functional specifications is written as user stories
You don’t need to be expert to understand the small Gherkin command set
Gherkin Test cases link acceptance tests directly to automated tests
Style of writing tests cases are easier to reuse code in other tests

Cons
It requires a high degree of business engagement and cooperation
May not work well in all scenarios
Poorly written tests can easily increase test maintenance costs

Disadvantages of Gherkin
It requires a high level of business engagement and collaborations
May not work well in all scenarios
Poorly written tests can easily increase test-maintenance cost


## 2.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания фичи и набора связанных с ней тестовых сценариев. 

Любой документ начинается с этого ключевого слова и последующего краткого описания. 

*Пример*

```Gherkin
Функция: Заказ товара
```



## 2.2. Подробное описание (Descriptions)

Можно добавить более подробное описание на следующих строках.
Эти строки будут проигнорированы ***Cucumber*** при выполнении тестов, но будут использованы при формировании отчетов.

*Пример*

```gherkin

```

A Feature usually consists of a list of Scenarios. Can write whatever you want until the beginning of the first Scenario (when the new line begins with the word “Scenario:”)

Tags can be used to group features and scenarios together, regardless of the file and directory structure. Each scenario consists of a list of steps, steps starting with keywords such as (Given, When, Then, But or And). Additionally, the feature may include a scenario outline and background

# #

## Scenario
Each feature file may have multiple scenarios, and each scenario starts with a script.
Scenarios are added to the feature file, to define examples of the expected behaviour. These scenarios can be used to test the feature. Start a scenario with the Scenario keyword and add a brief description of the scenario. To define the scenario, you have to define all of its steps.
Scenario or Example: This is a concrete example that illustrates a business rule. It consists of a list of steps.

Each step starts with Given, When, Then, And, or But.

## Given: 

Preconditions, use to describe the original context. Introduce into the system a state to start interacting with the system. Given’s goal is to put the system into a known state before use (or the external system) to start interacting with the system (in the When step).

If you have worked with a use case, Givens is a prerequisite.
the initial context of the system - the scene of the scenario.
Use this keyword to bring the system to a familiar state before the user starts interacting with the system. However, you can skip writing user interactions in the given steps if given in the “Precondition” step.

## When: 

describe the main action events the user performed. The use of the keyword “then” is to see the result after the action in the when “step”. However, you can only verify notable changes.
an event, or an action. This can be a person interacting with the system, or it can be an event triggered by another system.
The purpose of “When” is to describe events, the main action that a user uses.

## Then: 

Expected output. “Then” was used to observe the result. Observations must be related to business values / benefits in “Feature” description. Observations must check the output of the system (a report, user interface, messages, etc.)

an expected outcome, or result.
The use of the keyword ‘then’ is to see the result after the action in the “When” step. However, you can only verify notable changes.

## And, But: 

Used when there are many “Given”, “When”, “Then”
If you have successive Given’s, When’s, or Then’s, you could use And or But based on the context.

## Scenario outline

Scenario Outline: to run the same Scenario multiple times, with different combinations of values.
Examples: A Scenario Outline must contain Examples section containing all the different values to run the Scenario Outline with.


## Background

Background: add some context to the scenarios in the feature.
The “Background” keyword helps you add some context to the script. It may contain several script steps, but the only difference is that it should be run before each script.
It can contain some steps of the scenario, but the only difference is that it should be run before each scenario.

# Passing Data

## Регулярные выражения (Regular Expression)

То, что в регулярных выражениях записано в скобках передается в метод в виде аргумента. Фреймворк самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

Regular Expressions could be used when multiple scenarios are similar but they work with different data.
Say, for example, for Feature 'Process refund', you have a scenario where customer has their bank statement claiming they purchases a kettle for €10 from the store. In this case you would like to reuse the following function and not create a fresh one for 'bank statement'

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
    public void they_have_their_receipt() {
        //code
    }
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки) 

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)
  
*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки) 

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные 

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент. 

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

#

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций. 
Для подобной задачи в Cucumber есть несколько решений

## Данные перечисленные через запятую (ArrayList)

Фреймворк **Cucumber** по умолчанию оборачивает данные, перечисленные через запятую, в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

Для замены разделителя, можно воспользоваться аннотацией **@Delimiter**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл и Редактировать и О программе
```

```java
@Дано("^в меню доступны пункты (.+)$")
public void вМенюДоступныПункты(@Delimiter(" и ") List<String> arg) {
    // что-то сделать
}
```

## Данные в виде таблицы с одной колонкой (ArrayList)

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** также может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## Данные в виде таблицы с двумя колонками (Map)

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в ассоциативный массив, 
где данные из первой колонки – это ключ, а из второй – данные

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```


## Таблицы данных (Datatables)

When you have multiple parameters to pass to the function

Feature File:

```gherkin
Feature: Process refunds
Scenario: Customer has their receipt
Given the customer has purchased a kettle for €10
And they have their receipt
When the sales assistant processes the refund
And user fills the process refund form
| John | Smith | US | 987654321 |
Then the stock inventory for kettles is incremented by 1
And the customer's card is credited with €10

```

The function in Step Definition would look like this:

```java
@And("^user fills the process refund form$")
public void user_fills_the_process_refund_form(DataTable data) {
//To access the values
List<List<String>> obj = data.raw();
System.out.println(obj.get(0).get(0)); // 1st row, 1st column
System.out.println(obj.get(0).get(1)); // 1st row, 2nd column
System.out.println(obj.get(0).get(2)); // 1st row, 3rd column
System.out.println(obj.get(0).get(3)); // 1st row, 4th column       
}
```

## Scenario Outline & Example keyword


```gherkin
Feature: Process refunds
  Scenario Outline: Customer has their receipt
    Given the customer has purchased something
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for <product> is incremented by <quantity>
      And the customer's card is credited with €<price>

    Examples: 
      | product | quantity | price | 
      | kettle  | 1        | 10    | 
      | cup     | 6        | 50    | 
      | mug     | 2        | 30    | 
      | glass   | 12       | 40    |
```

```java
@Then("^the stock inventory for (.+) is incremented by (.+)$")
    public void the_stock_inventory_for_is_incremented_by(String product, String quantity) {
        System.out.println(product);
        System.out.println(quantity);
    }

    @And("^the customer's card is credited with €(.+)$")
    public void the_customers_card_is_credited_with_(String price) {
        System.out.println(price);
    }
```

***

# Best practices of using Gherkin

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)