Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Cucumber

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

Первоначально **Cucumber** был разработан **Ruby**-сообществом, 
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**). 

**Cucumber** использует легко читаемый предметно-ориентированный язык для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему, понимать и писать их может любой участник проекта.

**Cucumber** заполняет разрыв между разработчиками и заинтересованными сторонами (бизнес). 
Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых примеров. 
Тестовые примеры могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.). 
Эти тестовые примеры мапятся с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, который можно использовать в связке со многими другими популярными инструментами:

* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов

***

# 2. Структура проекта Cucumber

Проект **Cucumber** состоит из следующих частей:

1. описание сценариев (поведения системы) по шагам - текстовые файлы с расширением **.feature** 
2. реализация шагов сценариев на языке программирования - файлы с исходным кодом **.java**
3. теги - метки для организации запуска сценариев
4. хуки - методы выполняемые до и после для запуска сценариев
5. раннер для запуска сценариев - специальный класс **Java**
6. прочие файлы

## 2.1. Описание сценариев (Features)

***Описание сценариев (Features)*** – текстовые файлы с расширением **.feature**, которые содержат текст исполняемых спецификаций на языке **Gherkin**.

**Описание сценариев (Features)** представляет собой текст на естественном языке в свободной форме с использованием ключевых слов **Gherkin**.

*Пример*

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

    @success
    Сценарий: Успешное снятие денег со счета
      Дано на счете пользователя имеется 120000 рублей
      Когда пользователь снимает со счета 20000 рублей
      Тогда на счете пользователя имеется 100000 рублей
  
    @fail
    Сценарий: Снятие денег со счета - недостаточно денег
      Дано на счете пользователя имеется 100 рублей
      Когда пользователь снимает со счета 120 рублей
      Тогда появляется предупреждение "На счете недостаточно денег"
```

Особенности:

1. Каждый файл **.feature** должен содержать описание только одной фичи 

Описание фичи начинается с ключевого слова **Функция (Function)** и поэтому каждый файл содержит только одно ключевое слово.

2. Каждый файл **.feature** может содержать от 0 и более сценариев

3. Текст сценариев должен начинаться с **# language: ru**, если используется русский язык

Эта строка указывает **Cucumber**, что в сценарии используется русский язык (по умолчанию используется английский язык).
Если её не указать, фреймворк, встретив в сценарии русский текст, выбросит исключение **LexingError** и тест не запустится.

4. Каждый сценарий должен иметь следующую структуру:

* получение начального состояние системы 
* выполнение действий по изменению состояния системы
* получение и проверка нового состояние системы

[Your BDD scenarios should change only when the requirement changes, not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).]

## 2.2. Реализация шагов сценариев (Step Defs)

***Реализация шагов сценариев (Step Defs)*** - файлы с расширением **.java**,
содержащие код для взаимодействия с разрабатываемой системой, 
на который мапятся шаги в описании сценариев.

**Cucumber** не знает как взаимодействовать с системой в рамках 
исполнения шагов сценариев написанных на **Gherkin** в файлах **.feature**.

**Реализация шагов сценариев (Step Defs)** связывает шаги описанные в тексте на **Gherkin** в файлах **.feature** 
с кодом по взаимодействию с системой на **Java**, чтобы сценарии могли исполниться.

Реализация каждого шага представляет собой текст с регулярным выражением,
который содержится в специальной аннотации у каждого метода реализующего определенный шаг.

Сам код на **Java** может тестировать:

* Web UI (**Selenium WebDriver**)
* REST API (**REST Assured**)
* SOAP
* БД 
и т д.

*Пример*

```java

```

Аннотации для **Реализации шагов сценариев (Step Defs)**:

|    |    |    |
|----|----|----|
|    |    |    |
|    |    |    |
|    |    |    |

При выполнении тестов **Cucumber** для каждого шага **.feature** на **Gherkin** ищет его реализацию в коде на **Java**, посредством сравнения с паттерном в аннотации.
Таким образом, шаги в файлах **.feature** на **Gherkin** можно рассматривать как вызов методов **Java**.

Особенности:

1. Каждая **Реализация шагов сценариев (Step Defs)** должна совпадать по количеству аргументов с шагами описанными в **.feature**
2. Каждая **Реализация шагов сценариев (Step Defs)** должна иметь уникальный паттерн описанный в аннотации

Если задать два разных метода с одним и тем же паттерном, то при выполнении тестов возникнет исключение **DuplicateStepException**.
Такое же исключение можно словить, если задать два разных метода с одним и тем же паттерном в разных файлах **.java** в одном пакете **Java**.

3. Каждая **Реализация шагов сценариев (Step Defs)** может быть повторно использована в различных файлах **.feature**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

4. Каждая **Реализация шагов сценариев (Step Defs)** может быть использована в одном файле **.feature** 
совместно с другими реализациями шагов из разных файлов **.java** 

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

## 2.3. Теги (Tags)

***Теги (Tags)*** - метки для организации запуска сценариев.

**Теги (Tags)** представляют собой строки начинающиеся с символа **@** и располагающиеся перед строками с ключевыми словами.

**Тегами (Tags)** в файле **.feature** можно пометить:

* фичи (**Функции (Feature)**)
* сценарии (**Сценарии (Scenario)** и **Структуры сценариев (Scenario Outline)**)
* примеры (**Примеры (Examples)**)

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

С помощью тегов можно задать классификацию и группировку сценариев, 
а также организацию запуска сценариев, независимо от их расположения в файлах и папках проекта.

Например, можно задать теги **@smoke**, **@regression**, чтобы поделить тестовые сценарии на регрессионные и смоук,
и при запуске указывать теги, чтобы выполнить только определенные сценарии.

*Пример*

```java
tags = {“~@Ignore”}
        tags = {“@UpdateProfile”}
```

Особенности:

1. Можно использовать множество тегов для пометки

*Пример*

```gherkin
@important @maintenance @db @auth
```
   
2. Теги наследуется

Любой тег из **Функции (Feature)** будет наследоваться в **Сценарии (Scenario)**, 
**Структуры сценариев (Scenario Outline)** или **Примеры (Examples)**.


## 2.4. Хуки (Hooks)

***Хуки (Hooks)*** - методы выполняемые до и после для запуска сценариев.

**Хуки (Hooks)** представляют собой методы помеченные специальными аннотациями.

*Пример*

```java
import cucumber.api.java.After;
import cucumber.api.java.Before;

public class Hooks {
    @Before
    public void prepareData() {
        //подготовить данные
    }
    
    @After
    public void clearData() {
        //очистить данные
    }
}
```

Аннотации для **Хуков (Hooks)**:

|    |    |    |
|----|----|----|
| Before   | перед каждым сценарием   |    |
| After   | после   |    |
| Around   | Assumes control and runs around a scenario   |    |
| BeforeStep   |    |    |
| AfterStep   |    |    |
| AfterConfiguration   | Runs after Cucumber configuration and is passed an instance of the configuration   |    |

Особенности:

1. Класс с **Хуками (Hooks)** должен находиться в пакете, указанном в опциях фреймворка

2. **Хукам (Hooks)** можно задать порядок, в котором они будут выполняться

Для этого необходимо в аннотации указать параметр **order**. По умолчанию значение order равно 10000.

Для **@Before** чем меньше это значение, тем раньше выполнится метод

*Пример*

```java
// первым выполнится метод connectToServer()
@Before(order = 10)
    public void connectToServer() {
    // подключиться к серверу
}
// затем prepareData()
@Before(order = 20)
    public void prepareData() {
    // подготовить данные
}
```

Для **@After** отрабатывает в обратном порядке.   

3. **Хукам (Hooks) @Before, @After, @Around** можно задать теги, чтобы задать фильтрацию сценариев, для которых будут применяться хуки.

В параметре **value** нужно указать тэги сценариев, для которых будут отрабатывать **Хуки (Hooks)**.
Список тегов сценариев в одной строке обрабатывается как **ИЛИ**, а отдельные аргументы обрабатываются как **И**.
Символ **~** означает «за исключением». 

*Пример*

```java
// метод connectToServer() будет выполнен для всех сценариев с тэгом correct
@Before(value = "@correct", order = 30)
public void connectToServer() {
    //сделай что-нибудь
}
        
// метод prepareData() будет выполнен для всех сценариев за исключением сценариев с тэгом fail
@Before(value = "~@fail", order = 20)
public void prepareData() {
    //сделай что-нибудь
}
```

4. **Хукам (Hooks)** можно передать в качестве параметра объект класса **Scenario**

Если в определении **Хука (Hooks)** в аргументе указать объект класса **Scenario**, 
то в данном методе можно будет узнать много полезной информации о запущенном сценарии.

*Пример*

Метод **getScenarioInfo(Scenario scenario)**

```java
@After
public void getScenarioInfo(Scenario scenario) {
    System.out.println(scenario.getId());
    System.out.println(scenario.getName());
    System.out.println(scenario.getStatus());
    System.out.println(scenario.isFailed());
    System.out.println(scenario.getSourceTagNames());
}
```

Для сценария

```gherkin
# language: ru
@all
Функция: Аутентификация банковской карты
  
    Банкомат должен спросить у пользователя PIN-код банковской карты
    Банкомат должен выдать предупреждение если пользователь ввел неправильный PIN-код
    Аутентификация успешна если пользователь ввел правильный PIN-код

    Предыстория:
    Допустим пользователь вставляет в банкомат банковскую карту
    И банкомат выдает сообщение о необходимости ввода PIN-кода

    @correct
    Сценарий: Успешная аутентификация
    Если пользователь вводит корректный PIN-код
    То банкомат отображает меню и количество доступных денег на счету
```

Выведет в консоль следующее

```text
аутентификация-банковской-карты;успешная-аутентификация
Успешная аутентификация
passed
false
[@correct, @all]
```

5. Необходимо помнить про нюансы работы с **Хуками (Hooks)**

* тестовый фреймворк может также добавить выполнение кода до и после выполнения каждого метода
* сценарии в **Cucumber** выполняются независимо друг от друга
* шаги описанные в **Предыстории (Background)** выполняются перед каждым сценарием

## 2.5. Раннер (Runner)

***Раннер (Runner)*** - класс для запуска сценариев. 

**Раннер (Runner)** представляет собой специальный класс **Java** с аннотацией **@RunWith(Cucumber.class)**.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
        plugin = {"pretty", "html:target/htmlreport", "json:report.json", "junit:report.xml"},
        monochrome = true, 
//      name = "^Успешное|Успешная.*"
)
public class RunnerTest {
    
}

```

В классе-раннере через аннотацию **@CucumberOptions** задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
tags = "@all, @dev, @int, @regress",
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
tags = "@positive, ~@negative",
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — to specify different formatting options for the output reports

* *monochrome* — to receive clean and readable output in your console

## 2.6. Прочие файлы

PageObjects, ConfigFiles e t c

***

# 3. Запуск (Run)

## Процесс запуска

При запуске теста **Cucumber** проходит по сценарию шаг за шагом. 
Взяв шаг, он отделяет ключевое слово от описания шага и 
пытается найти в **Java** классах пакета указанного в опции glue аннотацию с регулярным выражением, 
подходящим описанию. Найдя совпадение, фреймворк вызывает метод с найденной аннотацией. 
Если несколько регулярных выражений удовлетворяют описанию шага, фреймворк выбрасывает ошибку.

When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.
When Cucumber matches a Step against a pattern in a Step Definition, it passes the value of all the capture groups to the Step Definition’s arguments.
The pattern is used to link the step definition to all the matching Steps and Cucumber will execute the code written inside Step Definition when it sees a Gherkin Step.


    Steps    │                 │     Step     │                 │           │
│ in Gherkin ├──matched with──>│ Definitions  ├───manipulates──>│  System

## Reports

Cucumber uses Formatter Plugins to provide output. Several common formats are provided by default, including

JSON
HTML
JUnit

Available formats are not standardized across different Cucumber implementations, so offerings may differ.
Cucumber also supports rich output formats like images and videos.

## Cucumber command-line

Cucumber comes with a built-in command line interface that covers a comprehensive list of instructions. 
Like most command line tools, cucumber provides the --help option that provides a summary of arguments the command accepts.

$ cucumber --help
-r, --require LIBRARY|DIR        Require files before executing the features.
--i18n LANG                      List keywords for in a particular language.
Run with "--i18n help" to see all languages.
-f, --format FORMAT              How to format features (Default: pretty).
-o, --out [FILE|DIR]             Write output to a file/directory instead of
...
Cucumber command line can be used to quickly run defined tests. It also supports running a subset of scenarios by filtering tags.

$ cucumber --tags @tag-name
The above command helps in executing only those scenarios that have the specified @tag-name.[30] Arguments can be provided as a logical OR or AND operation of tags. Apart from tags, scenarios can be filtered on scenario names.[30]

$ cucumber --name logout
The above command will run only those scenarios that contain the word 'logout'.

It is also useful to be able to know what went wrong when a test fails. Cucumber makes it easy to catch bugs in the code with the --backtrace option.[30]

Cucumber can also be configured to ignore certain scenarios that have not been completed by marking them with the Work In Progress tag @wip. When Cucumber is passed the --wip argument, Cucumber ignores scenarios with the @wip tag.

***

# 3. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для 
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и 
использует отступы для задания структуры. Каждая строка представляет собой выражение - 
шаг (**step**) и заканчивается переносом строки. 

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на множество языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Список зарезервированных символов:

* *#* – обозначает комментарии
* *@* – тэгирует сценарии или функционал
* *|* – разделяет данные в табличном формате
* *"""* – обрамляет многострочные данные

## 3.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания поведения/функции системы и набора связанных с ней тестовых сценариев. 

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  # подробное описание
  # сценарии
```

**Функция (Feature)** описывается в отдельном файле с расширением **.feature**.
Любой документ **.feature** начинается с этого ключевого слова и краткого описания.
Каждая функция обычно состоит из списка сценариев (**Сценарий (Scenario)**, **Структура сценария (Scenario Outline)**).

На следующей строке после ключевого слова и наименования функции может идти **Подробное описание (Descriptions)**.

Наименование функции и подробное описание не имеют какого либо значения для **Cucumber**.

*Пример*

```Gherkin
Feature: Withdraw Money from ATM

  A user with an account at a bank would like to withdraw money from an ATM.

  Provided he has a valid account and debit or credit card, he should be allowed to make the transaction. The ATM will tend the requested amount of money, return his card, and subtract amount of the withdrawal from the user's account.

  Scenario: Scenario 1
    Given preconditions
    When actions
    Then results

  Scenario: Scenario 2
  ...
```

## 3.2. Подробное описание (Descriptions)

***Подробное описание (Descriptions)*** - более подробное описание фичи.
 
Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

    Подробное описание
    На нескольких строках

    # сценарии
```

**Подробное описание (Descriptions)** представляет собой текст, который располагается на следующих строках 
после строки с ключевым словом и размечается отступами. Количество строк никак не ограничено и 
**Подробное описание (Descriptions)** продолжается до первого встреченного ключевого слова.
Эти строки будут проигнорированы **Cucumber** при выполнении тестов, но будут использованы при формировании отчетов.

**Подробное описание (Descriptions)** можно добавлять после:

* *Примера (Example)* или *Сценария (Scenario)*
* *Предыстории (Background)* 
* *Структуры сценария (Scenario Outline)*

*Пример*

```gherkin

```

## 3.3. Сценарий (Scenario)

***Сценарий (Scenario)*** - ключевое слово, предназначенное для описания конкретного тестового сценария.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
  # шаги сценария
```

**Сценарий (Scenario)** представляет собой одну из ключевых структур в языке **Gherkin**.
Каждый сценарий состоит из набора **Шагов (Steps)**.
Также **Сценарии (Scenario)** могут содержать **Предысторию (Background)** или 
иметь множество примеров в виде **Структуры сценария (Scenario Outline)**.

**Сценарий (Scenario)** описывает поведение системы и является ее спецификацией.

*Пример*

```gherkin
#language: ru
Сценарий: Вася создает новую запись
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Лекарства"
То мне должен быть ответ "Ваша запись успешно добавлена."

Сценарий: Вася не может добавлять запись в справочник лечений
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Виды лечений"
То мне должен быть ответ "У вас нет прав доступа!"
```

## 3.4. Шаги (Steps)

***Шаги (Steps)*** - строительные блоки тестовых сценариев.

**Шаги (Steps)** представляют собой строки текста начинающиеся с одного из ключевых слов:

* *Дано (Given)* - данные
* *Когда (When)* - действия
* *То (Then)* - результаты
* *Но (But)*
* *И (And)* 

Шаги **Но (But)** и **И (And)** существуют исключительно для удобства чтения и 
по своим функциям повторяют ключевое слово, с которого начиналась предыдущая строка.

*Пример*

```gherkin
Scenario: A user attempts to withdraw more money than they have in their account
Given John has a valid Credit or Debit card
And his account balance is $20
When he inserts his card
And withdraws $40
Then the ATM displays an error
And returns his card
But his balance remains $20
```

### 3.4.1. Дано (Given)

***Дано (Given)*** - ключевое слово, предназначенное для описания предусловий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    # шаги сценария
```

Шаг ***Дано (Given)*** приводит систему в известное состояние перед тем 
как пользователь (или внешняя система) начнет взаимодействие с системой. 
Также можно рассматривать их как предусловия.

*Пример*

```gherkin
#language: ru
Дано нет пользователей в базе
Дано база данных пустая
```

### 3.4.2. Когда (When)

***Когда (When)*** - ключевое слово, предназначенное для описания событий или действий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    # шаги сценария
```

Шаг **Когда (When)** изменяет состояние системы путем взаимодействия с системой пользователя (или внешней системы).
Настоятельно рекомендуется использовать только один шаг **Когда (When)** для каждого сценария. 
[Если вы чувствуете необходимость добавить что-то еще, обычно это знак того, что вам следует разбить сценарий на несколько сценариев.
Постарайтесь придумать примеры, которые не предполагают никаких предположений о технологиях или пользовательском интерфейсе. 
Представьте себе 1922 год, когда не было компьютеров.
Детали реализации должны быть скрыты в определениях шагов.]

*Пример*

```gherkin
#language: ru
Пример: взаимодействие со страницей
Когда я открыл форму добавления учреждения
Когда я ввел "Институт радости" в поле "Наименование"
Когда я выбрал в поле "Тип" значение "Институт"
Когда я нажал на кнопку "Сохранить"
```

### 3.4.3. Тогда / То (Then)

***Тогда / То (Then)*** - ключевое слово, предназначенное для описания ожидаемых результатов.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

Шаг ***Тогда / То (Then)*** проверяет результирующее состояние системы после выполнения действий. 
Проверки результатов должны быть связаны с явной пользой, которая указаны в описании функции. 
Также необходимо помнить, что должен проверяться вывод системы (отчеты, интерфейс, сообщения), а не что-то глубоко закопанное в систему.

*Пример*

```gherkin
#language: ru

```

### 3.4.4. И (And), Но (But), * (Asterisk)

Если **Сценарии (Scenario)** есть несколько шагов **Дано (Given)**, **Когда (When)**, или **Тогда (Then)**, то можно писать их так:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
    Дано что-то первое
    Дано что-то второе
    Дано и что-то ещё
    Когда я открою свои глаза
    То я увижу что-то
    То чего-то я не увижу
```  

Или можно использовать шаги **И (And)** и **Но (But)**, превращая **Сценарии (Scenario)** в нечто более читаемое:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
И что-то второе
И и что-то ещё
Когда я открою свои глаза
То я увижу что-то
Но чего-то я не увижу
```

***И (And)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Когда Действие
    И Действие
    Тогда Результат
    И Результат
    # шаги сценария
```

***Но (But)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Но Предусловие
    Когда Действие
    И Действие
    Но Действие
    Тогда Результат
    И Результат
    Но Результат
    # шаги сценария
```

***\* (Asterisk)*** - символ, заменяющий любое ключевое слово обозначающее **Шаг (Step)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    * Предусловие
    * Предусловие
    Когда Действие
    * Действие
    * Действие
    Тогда Результат
    * Результат
    * Результат
    # шаги сценария
```

**\* (Asterisk)** используется для улучшения восприятия текста сценария.

*Пример*

```gherkin
#language: ru

```

## 3.5. Предыстория (Background)

***Предыстория (Background)*** - ключевое слово, предназначенное для добавления определенного 
контекста ко всем **Сценариям (Scenario)** в пределах **Функции (Feature)**. 

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  
  Подробное описание
  На нескольких строках

  Предыстория: 
    Дано Предусловие
    
  Сценарий: Наименование сценария 1
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария

  Сценарий: Наименование сценария 2
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

В каждой **Функции (Feature)** может быть всего одна **Предыстория (Background)** 
и располагается она до первого **Сценария (Scenario)** описанного в **Функции (Feature)**.

Если нужно добавить еще одну **Предыстория (Background)**, 
то нужно подумать над разбиением **Функции (Feature)** на части.
Либо же настроить **Хуки (Hooks)** на определенные **Теги (Tags)**,
которыми будут помечены нужные **Сценарии (Scenario)**.

**Предыстория (Background)** по сути, представляет собой **Сценарий (Scenario)** без имени,
состоящий из **Шагов (Steps)**, которые повторно выполняются в каждом **Сценарии (Scenario)** какой-либо **Функции (Feature)**.

Основное отличие в запуске: **Предыстория (Background)** запускается перед каждым **Сценарием (Scenario)**, 
но после выполнения любого **Хука (Hooks)** помеченного аннотацией **@Before**.

*Пример*

```gherkin
# language: ru
Функция: поддержка многих справочников

    Предыстория:
        Дано есть пользователь с именем "Вася"
        И есть справочник "Лекарства"
        И у пользователя "Вася" есть право на запись в  "Лекарство"
        И есть справочник "Виды лечений"

    Сценарий: Вася создает новую запись
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Лекарства"
        То мне должен быть ответ "Ваша запись успешно добавлена."

    Сценарий: Вася не может добавлять запись в справочник лечений
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Виды лечений"
        То мне должен быть ответ "У вас нет прав доступа!"
```      

## 3.6. Scenario outline

In some cases, one might want to test multiple scenarios at once to perform Equivalence partitioning and Boundary-value analysis. A Scenario Outline provides a technique to specify multiple examples to test against a template scenario by using placeholders.[24] For example,

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
```

*Пример*

```gherkin
Scenario Outline: A user withdraws money from an ATM
Given <Name> has a valid Credit or Debit card
And their account balance is <OriginalBalance>
When they insert their card
And withdraw <WithdrawalAmount>
Then the ATM should return <WithdrawalAmount>
And their account balance is <NewBalance>

    Examples:
      | Name   | OriginalBalance | WithdrawalAmount | NewBalance |
      | Eric   | 100             | 45               | 55         |
      | Gaurav | 100             | 40               | 60         |
      | Ed     | 1000            | 200              | 800        |
```

At runtime the scenario is run against each row in the table. Column values are substituted for each of the named placeholders in the scenario.

Достаточно часто приходится писать множество мелких сценариев, которые различаются буквально парой переменных. Эти повторения могут быстро надоесть:

*Пример*

```gherkin
#language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
Структуры сценариев позволяют нам более кратко описывать подобные наборы сценариев с помощью шаблонов:

Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

Шаги указанные в структуре сценария не выполняются напрямую, но используются для подстановки в них значений из таблицы примеров. Каждая строчка таблицы будет обрабатываться как отдельный сценарий с указанными значениями вместо заглушек “было”, “удалено” и “стало”.
Scenario Outline: to run the same Scenario multiple times, with different combinations of values.
Examples: A Scenario Outline must contain Examples section containing all the different values to run the Scenario Outline with.


# Passing Data

## Регулярные выражения (Regular Expression)

То, что в регулярных выражениях записано в скобках передается в метод в виде аргумента. Фреймворк самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

Regular Expressions could be used when multiple scenarios are similar but they work with different data.
Say, for example, for Feature 'Process refund', you have a scenario where customer has their bank statement claiming they purchases a kettle for €10 from the store. In this case you would like to reuse the following function and not create a fresh one for 'bank statement'

*Пример*

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
    public void they_have_their_receipt() {
        //code
    }
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки) 

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)
  
*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки) 

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные 

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент. 

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

#

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций. 
Для подобной задачи в Cucumber есть несколько решений

## Данные перечисленные через запятую (ArrayList)

Фреймворк **Cucumber** по умолчанию оборачивает данные, перечисленные через запятую, в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

Для замены разделителя, можно воспользоваться аннотацией **@Delimiter**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл и Редактировать и О программе
```

```java
@Дано("^в меню доступны пункты (.+)$")
public void вМенюДоступныПункты(@Delimiter(" и ") List<String> arg) {
    // что-то сделать
}
```

## Данные в виде таблицы с одной колонкой (ArrayList)

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** также может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## Данные в виде таблицы с двумя колонками (Map)

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в ассоциативный массив, 
где данные из первой колонки – это ключ, а из второй – данные

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```

## Таблицы данных (Datatables)

When you have multiple parameters to pass to the function

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

The function in Step Definition would look like this:


```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    // что-то сделать
}
```

***DataTable*** – это класс, который эмулирует табличное представление данных. Для доступа к данным в нем имеется большое количество методов.

```java
public <K,V> List<Map<K,V>> asMaps(Class<K> keyType,Class<V> valueType)
```

Конвертирует таблицу в список ассоциативных массивов. Первая строка таблицы используется для именования ключей, остальные как значения:

```gherkin
# language: ru
Дано в меню доступны пункты
| Название      | Доступен | Количество подменю |
| Файл          | true     | 5                  |
| Редактировать | false    | 8                  |
| О программе   | true     | 2                  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<Map<String, String>> table = arg.asMaps(String.class, String.class);
System.out.println(table.get(0).get("Название"));
System.out.println(table.get(1).get("Название"));
System.out.println(table.get(2).get("Название"));
}
```

Данный пример выведет на консоль:

Файл
Редактировать
О программе

```java
public <T> List<List<T>> asLists(Class<T> itemType)
```

Метод преобразует таблицу в список списков:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<List<String>> table = arg.asLists(String.class);
System.out.print(table.get(0).get(0) + " ");
System.out.print(table.get(0).get(1) + " ");
System.out.println(table.get(0).get(2) + " ");

    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

На консоль будет выведено:

Файл true 5
Редактировать false 8

```java
public List<List<String>> cells(int firstRow)
```

Этот метод делает то же, что и предыдущий метод, за исключением того, что нельзя определить какого типа данные находятся в таблице, всегда возвращает список строк – List. В качестве аргумента метод принимает номер первой строки:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<List<String>> table = arg.cells(1);
System.out.print(table.get(0).get(0) + " ");
System.out.print(table.get(0).get(1) + " ");
System.out.println(table.get(0).get(2) + " ");

    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

Метод выведет на консоль:

Редактировать false 8
О программе true 2

## Использование классов

Class
Cucumber может создать объекты из табличных данных, переданных из сценария. Существует два способа это сделать.

Создадим для примера класс Menu:

```java
public class Menu {
private String title;
private boolean isAvailable;
private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

Для первого способа шаг в сценарии запишем в следующем виде:

```gherkin
# language: ru
Дано в меню доступны пункты
| title         | isAvailable | subMenuCount |
| Файл          | true        | 5            |
| Редактировать | false       | 8            |
| О программе   | true        | 2            |
```

Реализация:

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<Menu> arg) {
for (int i = 0; i < arg.size(); i++) {
System.out.print(arg.get(i).getTitle() + " ");
System.out.print(Boolean.toString(arg.get(i).getAvailable()) + " ");
System.out.println(Integer.toString(arg.get(i).getSubMenuCount()));
}
}
```

Вывод в консоль:

Файл true 5
Редактировать false 8
О программе true 2

Фреймворк создает связанный список объектов из таблицы с тремя колонками. В первой строке таблицы должны быть указаны наименования полей класса, создаваемого объекта. Если какое-то поле не указать, оно не будет инициализировано.

Для второго способа приведем шаг сценария к следующему виду:

```gherkin
# language: ru
Дано в меню доступны пункты
| title        | Файл | Редактировать | О программе |
| isAvailable  | true | false         | true        |
| subMenuCount | 5    | 8             | 2           |
```

А в аргументе описания шага используем аннотацию @Transpose.

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(@Transpose List<Menu> arg) {
// что-то сделать
}
```

Cucumber, как и в предыдущем примере, создаст связанный список объектов, но, в данном случае, наименования полей записывается в первой колонке таблицы.

## Многострочный текст

Для передачи многострочных данных в аргумент метода, их необходимо экранировать тремя двойными кавычками:
```gherkin
# language: ru
Тогда отображается форма с текстом

"""
На ваш номер телефона был выслан одноразовый пароль.
Для подтверждения платежа необходимо ввести полученный
одноразовый пароль.
"""
```

Данные в метод приходят в виде объекта класса String:

```java
@Тогда("^отображается форма с текстом$")
public void отображаетсяФормаСТекстом(String expectedText) {
// что-то сделать
}
```

## Преобразование данных

Фреймворк самостоятельно приводит данные из сценария к типу данных, указанному в аргументе метода. Если это невозможно, то выбрасывает исключение ConversionException. Это справедливо и для классов Date и Calendar. Рассмотрим пример:

```gherkin
# language: ru
Дано дата создания документа 04.05.2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Все прекрасно сработало, Cucumber преобразовал 04.05.2017 в объект класса Date со значением «Thu May 04 00:00:00 EET 2017».

Рассмотрим еще один пример:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Дойдя до этого шага, Cucumber выбросил исключение:

cucumber.deps.com.thoughtworks.xstream.converters.ConversionException: Couldn't convert "04-05-2017" to an instance of: [class java.util.Date]

Почему первый пример сработал, а второй нет?

Дело в том, что в Cucumber встроена поддержка форматов дат чувствительных к текущей локали. Если необходимо записать дату в формате, отличающемся от формата текущей локали, нужно использовать аннотацию Format:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```


```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (@Format("dd-MM-yyyy") Date arg) {
// что-то сделать
}
```

## Scenario Outline & Example keyword

Достаточно часто приходится писать множество мелких сценариев, которые различаются буквально парой переменных. Эти повторения могут быстро надоесть:

```gherkin
# language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
Структуры сценариев позволяют нам более кратко описывать подобные наборы сценариев с помощью шаблонов:

Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

Шаги указанные в структуре сценария не выполняются напрямую, но используются для подстановки в них значений из таблицы примеров. Каждая строчка таблицы будет обрабатываться как отдельный сценарий с указанными значениями вместо заглушек “было”, “удалено” и “стало”.


Бывают случаи, когда необходимо запустить тест несколько раз с различным набором данных, в таких случая на помощь приходит конструкция «Структура сценария»:

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

@success
Структура сценария: Успешное снятие денег со счета
Дано на счете пользователя имеется <изначально> рублей
Когда пользователь снимает со счета <снято> рублей
Тогда на счете пользователя имеется <осталось> рублей

    Примеры:
      | изначально | снято | осталось |
      | 10000      | 1     | 9999     |
      | 9999       | 9999  | 0        |
```

Суть данной конструкции заключается в том, что в места, обозначенные символами <>, вставляются данные из таблицы Примеры. Тест будет запускаться поочередно для каждой строки из данной таблицы. Названия колонок должно совпадать с названием мест вставки данных.

```gherkin
Feature: Process refunds
  Scenario Outline: Customer has their receipt
    Given the customer has purchased something
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for <product> is incremented by <quantity>
      And the customer's card is credited with €<price>

    Examples: 
      | product | quantity | price | 
      | kettle  | 1        | 10    | 
      | cup     | 6        | 50    | 
      | mug     | 2        | 30    | 
      | glass   | 12       | 40    |
```

```java
@Then("^the stock inventory for (.+) is incremented by (.+)$")
    public void the_stock_inventory_for_is_incremented_by(String product, String quantity) {
        System.out.println(product);
        System.out.println(quantity);
    }

    @And("^the customer's card is credited with €(.+)$")
    public void the_customers_card_is_credited_with_(String price) {
        System.out.println(price);
    }
```

***

# 4. Плюсы и минусы

Why Gherkin?
Describe use cases for a software system in one way, easy to read and understand.
Allows business analysts, managers, developers and other third-parties involved to understand the requirements of the project and the life-cycle.
Makes it easy to create simple documentation of the code that’s being written.
Provides scripts for test automation.

Плюсы:

1. Использование естественного языка в свободной форме

Сценарии **Gherkin**, определяющие поведение системы, описываются в простой форме и
могут быть понятны всем участникам проекта (заказчикам, аналитикам, разработчикам, тестировщикам).
Не нужно быть экспертом, чтобы понять небольшой набор команд **Gherkin**.

2. Живая проектная документация

Значительная часть функциональных спецификаций написана в виде пользовательских историй.
Gherkin Testing нацелен на бизнес-требования

3. Эффективный инструмент для тестирования

Разделение тест-кейсов и кода тестов
Файлы, содержащие в себе спецификации, одновременно являются и исполняемыми автотестами.
Тестовая документация и программный код автотестов хранятся в одном проекте и неотделимы друг от друга.
Сценарии тестирования Gherkin напрямую связывают приемочные тесты с автоматизированными тестами
Наличие словаря доступных шагов допускает вариативность сценариев и
позволяет тестировщикам составлять новые автотесты, не обращаясь к программному коду.

Минусы:

1. Обязательное наличие высокой степени деловой активности и сотрудничества
2. Может работать не во всех сценариях
3. Плохо написанные тесты могут легко увеличить расходы на обслуживание тестов

***

# 5. Best practices of using Gherkin

Tips for using Background
Don’t use Background to set up complicated states, unless that state is actually something the client needs to know.
For example, if the user and site names don’t matter to the client, use a higher-level step such as Given I am logged in as a site owner.
Keep your Background section short.
The client needs to actually remember this stuff when reading the scenarios. If the Background is more than 4 lines long, consider moving some of the irrelevant details into higher-level steps.
Make your Background section vivid.
Use colourful names, and try to tell a story. The human brain keeps track of stories much better than it keeps track of names like "User A", "User B", "Site 1", and so on.
Keep your scenarios short, and don’t have too many.
If the Background section has scrolled off the screen, the reader no longer has a full overview of what’s happening. Think about using higher-level steps, or splitting the *.feature file.

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)