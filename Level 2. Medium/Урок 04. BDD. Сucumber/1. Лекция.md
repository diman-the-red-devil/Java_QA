Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Cucumber

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

Первоначально **Cucumber** был разработан **Ruby**-сообществом, 
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**). 

**Cucumber** использует легко читаемый предметно-ориентированный язык для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему, понимать и писать их может любой участник проекта.

**Cucumber** заполняет разрыв между разработчиками и заинтересованными сторонами (бизнес). 
Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых примеров. 
Тестовые примеры могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.). 
Эти тестовые примеры мапятся с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, который можно использовать в связке со многими другими популярными инструментами:

* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов

***

# 2. Структура проекта Cucumber

Проект **Cucumber** состоит из следующих частей:

1. описание сценариев (поведения системы) по шагам - текстовые файлы с расширением **.feature** 

2. реализация шагов сценариев на языке программирования - файлы с исходным кодом **.java**

3. прочие файлы

4. раннер для запуска сценариев - специальный класс

# Описание сценариев (Features)

***Описание сценариев (Features)*** – файлы с расширением **.feature**, которые содержат текст исполняемых спецификаций на языке **Gherkin**.

Файл **.feature** должен содержать описание только одной фичи.

A .feature file is supposed to describe a single feature of the system, or a particular aspect of a feature. 
It's just a way to provide a high-level description of a software feature, and to group related scenarios.

*Пример*

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

  @success
  Сценарий: Успешное снятие денег со счета
    Дано на счете пользователя имеется 120000 рублей
    Когда пользователь снимает со счета 20000 рублей
    Тогда на счете пользователя имеется 100000 рублей

  @fail
  Сценарий: Снятие денег со счета - недостаточно денег
    Дано на счете пользователя имеется 100 рублей
    Когда пользователь снимает со счета 120 рублей
    Тогда появляется предупреждение "На счете недостаточно денег"
```

Обратите внимание на структуру сценария:

1. Получить начальное состояние системы;
2. Что-то сделать;
3. Получить новое состояние системы.

Сценарий начинается со строки # language: ru. 
Эта строчка указывает Cucumber, что в сценарии используется русский язык. 
Если её не указать, фреймворк, встретив в сценарии русский текст, выбросит исключение LexingError и тест не запустится. 
По умолчанию используется английский язык.

Your BDD scenarios should change only when the requirement changes, not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).

# Реализация шагов сценариев (Step Defs)

A Step Definition is a small piece of code with a (regex) pattern attached to it. The pattern is used to link the step definition to all the matching Steps and Cucumber will execute the code written inside Step Definition when it sees a Gherkin Step.

***Реализация шагов сценариев (Step Defs)*** - файлы с расширением **.java**, 
содержащие код для взаимодействия с разрабатываемой системой, на который мапятся шаги в описании сценариев. 

**Cucumber** не знает как исполнять сценарии написанные на **Gherkin**.
Для их запуска нужна **Реализация шагов сценариев (Step Defs)**, чтобы замапить шаги описанные в тексте на **Gherkin**
в действия по взаимодействию с системой. 

**Реализация шагов сценариев (Step Defs)** может быть написана на разных языках программирования (**Java**, **Ruby**, **C#**, **Python**, **JS**).

    Steps    │                 │     Step     │                 │           │
│ in Gherkin ├──matched with──>│ Definitions  ├───manipulates──>│  System


*Пример*

```java

```

Steps in Gherkin's .feature files can be considered a method invocation.[26][22] Before Cucumber can execute a step it must be told, via a step definition, how that step should be performed.

Definitions are written in Ruby and conventionally filed under features/step_definitions/*_steps.rb.[22] Definitions start with the same keywords as their invocation (including Gherkin's full language support).[22] Each definition takes two arguments[22]

Either a regular expression or string with $variables
A block containing ruby code to execute
Example using regular expressions
*Пример*

```java
Given /(.*) has a valid Credit or Debit card/ do |name|
# Ruby code
end
```        
Example using strings and $variables. Note that at runtime the string is converted into a regular expression, and any $variable is converted to match (.*).[22]
*Пример*

```java
Given "$name has a valid Credit or Debit card" do |name|
# Ruby code
end
```

The number of argument in the method signature also must match with the no of placeholders in Feature File’s Step.
If we specify two differently named methods with same regex pattern then, at runtime, error will occur (DuplicateStepException)
Single Feature File can be implemented by multiple Step Files as the Step Methods can be distributed among those Step Files; only restriction is that all those Step Files are to be in the specified package.
Matching Step Methods are searched across the specified package, Hence even if we specify two differently named methods with same regex pattern in two different Step Files in same package, then also at runtime error will occur (DuplicateStepException).
Step Methods are reusable. Means to say, for same Steps written in different Step Scenarios or even different Feature Files (generally Given steps can be like that) we need to write only one Step Method.
# Хуки (Hooks)

These are the blocks of the code that runs before or after each scenario. So that we can define these, anywhere in our project. For Example, Step Definition.

As per the definition, these are just two annotation @After and @Before. In the console, we can see the blocks getting executed and giving clear output. We can also execute the hooks for specific Tags.

Hooks are Cucumber's way of allowing for setup to be performed prior to tests being run and teardown to be run afterwards. They are defined as executable Ruby blocks, similar to JUnit methods marked with @Before, @After annotations. Conventionally they are placed under support/, and are applied globally.[22] Three basic types of hooks exist[22]

Before - Runs before a scenario
After - Runs after a scenario
Around - Assumes control and runs around a scenario
Additional hooks include[22]

BeforeStep
AfterStep
AfterConfiguration - Runs after Cucumber configuration and is passed an instance of the configuration
Before, After, and Around hooks optionally take a list of tags filtering scenarios that they apply to. A list of tags in the same string is treated as OR, while individual arguments are treated as AND; tags can be optionally negated by being preceded with ~.[22]

Example of a tagged before hook

Before('@ATM') do |scenario|
# Ruby code
end
Hooks are often used to maintain database state, typically by cleaning up prior to running a scenario. It is also possible to start and roll back a transaction using Before and After hooks, and many Cucumber extensions provide an @txn tag for such a purpose.[24]

Cucumber поддерживает хуки (hooks) – методы, запускаемые до или после сценария. Для их обозначения используется аннотация Before и After. Класс с хуками должен находиться в пакете, указанном в опциях фреймворка. Пример класса с хуками:

*Пример*

```java
import cucumber.api.java.After;
import cucumber.api.java.Before;

public class Hooks {
@Before
public void prepareData() {
//подготовить данные
}

    @After
    public void clearData() {
        //очистить данные
    }
}
```

Метод c аннотацией Before будет запускаться перед каждым сценарием, After – после.

Порядок выполнения

Хукам можно задать порядок, в котором они будут выполняться. Для этого необходимо в аннотации указать параметр order. По умолчанию значение order равно 10000.

Для Before чем меньше это значение, тем раньше выполнится метод:

*Пример*

```java
@Before(order = 10)
public void connectToServer() {
//подключиться к серверу
}

@Before(order = 20)
public void prepareData() {
//подготовить данные
}
```

В данном примере первым выполнится метод connectToServer(), затем prepareData().

After отрабатывает в обратном порядке.

В параметре value можно указать тэги сценариев, для которых будут отрабатывать хуки. Символ ~ означает «за исключением». Пример:

*Пример*

```java
@Before(value = "@correct", order = 30)
public void connectToServer() {
//сделай что-нибудь
}

@Before(value = "~@fail", order = 20)
public void prepareData() {
//сделай что-нибудь
}
```

Scenario class

Если в определении метода-хука в аргументе указать объект класса Scenario, то в данном методе можно будет узнать много полезной информации о запущенном сценарии, например:

*Пример*

```java
@After
public void getScenarioInfo(Scenario scenario) {
System.out.println(scenario.getId());
System.out.println(scenario.getName());
System.out.println(scenario.getStatus());
System.out.println(scenario.isFailed());
System.out.println(scenario.getSourceTagNames());
}
```

Для сценария:

*Пример*

```gherkin
# language: ru
@all
Функция: Аутентификация банковской карты
Банкомат должен спросить у пользователя PIN-код банковской карты
Банкомат должен выдать предупреждение если пользователь ввел неправильный PIN-код
Аутентификация успешна если пользователь ввел правильный PIN-код

Предыстория:
Допустим пользователь вставляет в банкомат банковскую карту
И банкомат выдает сообщение о необходимости ввода PIN-кода

@correct
Сценарий: Успешная аутентификация
Если пользователь вводит корректный PIN-код
То банкомат отображает меню и количество доступных денег на счету
```

Выведет в консоль:

```text
аутентификация-банковской-карты;успешная-аутентификация
Успешная аутентификация
passed
false
[@correct, @all]
```

Метод connectToServer будет выполнен для всех сценариев с тэгом correct, метод prepareData для всех сценариев за исключением сценариев с тэгом fail.

This is a cool option in Cucumber. But you need prior knowledge to understand Hooks. Cucumber hooks are more like utility functions which help to perform some activity before/after/during execution. With that, you must remember that not only Cucumber, but also the test runner also performs hook functions. According to the priority of each hook type, one can implement their activities in them appropriately.
Also note that each Cucumber Scenario executes independently, and Background steps mentioned in the feature file run before executing each Scenario.

# Теги (Tags)

These are normally used over the feature file to classify the scenarios over the feature files as per their given tag name. We can have multiple tags for a given scenario in the feature file.

Tags are user-defined and we can give any name to it such as @Smoke, @Regression, etc.

Gherkin's Feature structure forces organisation. However, in cases where this default organisation is inconvenient or insufficient, Gherkin provides Tags. Tags are @-prefixed strings and can be placed before[24]

Feature
Scenario
Scenario Outline
Examples
An element can have multiple tags and inherits from parent elements

Tags are a great way made for Cucumber power users to organize their features and scenarios. In the above example, by changing tags = {“~@Ignore”} line to tags = {“@UpdateProfile”}, one can choose run only the features and scenarios tagged with @UpdateProfile tag. A Scenario or feature can have as many tags as you like. Just separate them with spaces: @important @maintenance @db @auth
Any tag that exists on a Feature will be inherited by Scenario, Scenario Outline or Examples. Therefore, in the above example, all the scenarios in the Update Profile feature must run. By mentioning a tag before a Scenario (as same as above Feature case), one can choose to run a subset of scenarios with that tag.

You can tag your scenarios. Tagging a scenario helps you to run only the scenarios that belong to a certain tag.
You can have multiple tags for a single scenario
You can run multiple tags together

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

# Запуск (Run)

## Раннер

Для запуска сценариев нужно создать класс с аннотацией **@RunWith(Cucumber.class)**. 

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
        plugin = {"pretty", "html:target/htmlreport", "json:report.json", "junit:report.xml"},//     plugin — to specify different formatting options for the output reports
        monochrome = true, // monochrome = true — to receive clean and readable output in your console
//        name = "^Успешное|Успешная.*"
)
public class RunnerTest {
}

```

В классе-раннере через аннотацию **@CucumberOptions** задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
tags = "@all, @dev, @int, @regress",
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
tags = "@positive, ~@negative",
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — to specify different formatting options for the output reports

* *monochrome* true — to receive clean and readable output in your console

## Процесс запуска

При запуске теста Cucumber проходит по сценарию шаг за шагом. Взяв шаг, он отделяет ключевое слово от описания шага и пытается найти в Java-классах пакета указанного в опции glue аннотацию с регулярным выражением, подходящим описанию. Найдя совпадение, фреймворк вызывает метод с найденной аннотацией. Если несколько регулярных выражений удовлетворяют описанию шага, фреймворк выбрасывает ошибку.
When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.
When Cucumber matches a Step against a pattern in a Step Definition, it passes the value of all the capture groups to the Step Definition’s arguments.

# Reports

Cucumber uses Formatter Plugins to provide output. Several common formats are provided by default, including[24]

JSON
HTML
JUnit
Available formats are not standardized across different Cucumber implementations, so offerings may differ.[24] Cucumber also supports rich output formats like images and videos.

# Cucumber command-line

Cucumber comes with a built-in command line interface that covers a comprehensive list of instructions. Like most command line tools, cucumber provides the --help option that provides a summary of arguments the command accepts.[30]

$ cucumber --help
-r, --require LIBRARY|DIR        Require files before executing the features.
--i18n LANG                      List keywords for in a particular language.
Run with "--i18n help" to see all languages.
-f, --format FORMAT              How to format features (Default: pretty).
-o, --out [FILE|DIR]             Write output to a file/directory instead of
...
Cucumber command line can be used to quickly run defined tests. It also supports running a subset of scenarios by filtering tags.

$ cucumber --tags @tag-name
The above command helps in executing only those scenarios that have the specified @tag-name.[30] Arguments can be provided as a logical OR or AND operation of tags. Apart from tags, scenarios can be filtered on scenario names.[30]

$ cucumber --name logout
The above command will run only those scenarios that contain the word 'logout'.

It is also useful to be able to know what went wrong when a test fails. Cucumber makes it easy to catch bugs in the code with the --backtrace option.[30]

Cucumber can also be configured to ignore certain scenarios that have not been completed by marking them with the Work In Progress tag @wip. When Cucumber is passed the --wip argument, Cucumber ignores scenarios with the @wip tag.


***

# 3. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для 
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и 
использует отступы для задания структуры. Каждая строка представляет собой выражение - 
шаг (**step**) и заканчивается переносом строки. 

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на много языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Обратите внимание на структуру сценария:

1. Получить начальное состояние системы;
2. Что-то сделать;
3. Получить новое состояние системы.

Помните паттерн AAA))

Список зарезервированных символов:

* \# – обозначает комментарии
* @ – тэгирует сценарии или функционал
* | – разделяет данные в табличном формате
* """ – обрамляет многострочные данные

  Why Gherkin?
  Describe use cases for a software system in one way, easy to read and understand.
  Allows business analysts, managers, developers and other third-parties involved to understand the requirements of the project and the life-cycle.
  Makes it easy to create simple documentation of the code that’s being written.
  Provides scripts for test automation.
* 
Pros / Cons of Gherkin
Pros
Help determine the right customer requirements: because the document is based on natural language direction, any object can understand, so when reading this document, customers can easily know if the programmer is going in the right direction they want it.
The code writing style is easy to maintain and implement
An effective tool for testing

Advantages of Gherkin
Gherkin is simple enough for non-programmers to understand
Programmers can use it as a very solid base to start their tests
It makes User Stories easier to digest
Gherkin script can easily understand by business executives and developers
Gherkin Testing targets the business requirements
A significant proportion of the functional specifications is written as user stories
You don’t need to be expert to understand the small Gherkin command set
Gherkin Test cases link acceptance tests directly to automated tests
Style of writing tests cases are easier to reuse code in other tests

Cons
It requires a high degree of business engagement and cooperation
May not work well in all scenarios
Poorly written tests can easily increase test maintenance costs

Disadvantages of Gherkin
It requires a high level of business engagement and collaborations
May not work well in all scenarios
Poorly written tests can easily increase test-maintenance cost


## 2.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания фичи и набора связанных с ней тестовых сценариев. 

Каждая функция описывается в отдельном файле с расширением .feature.

Любой документ начинается с этого ключевого слова и последующего краткого описания. за которой могут идти три строчки с описанием, размеченные отступами. 
Каждая функция обычно состоит из списка сценариев.

A feature is a Use Case that describes a specific function of the software being tested. There are three parts to a Feature[24]

The Feature: keyword
The Feature name (on the same line as the keyword)
An optional description on the following lines
Example Feature definition

*Пример*

```Gherkin
Feature: Withdraw Money from ATM

  A user with an account at a bank would like to withdraw money from an ATM.

  Provided he has a valid account and debit or credit card, he should be allowed to make the transaction. The ATM will tend the requested amount of money, return his card, and subtract amount of the withdrawal from the user's account.

  Scenario: Scenario 1
    Given preconditions
    When actions
    Then results

  Scenario: Scenario 2
  ...
```


## 2.2. Подробное описание (Descriptions)

Можно добавить более подробное описание на следующих строках.
Эти строки будут проигнорированы ***Cucumber*** при выполнении тестов, но будут использованы при формировании отчетов.

*Пример*

```gherkin

```

A Feature usually consists of a list of Scenarios. Can write whatever you want until the beginning of the first Scenario (when the new line begins with the word “Scenario:”)

Tags can be used to group features and scenarios together, regardless of the file and directory structure. Each scenario consists of a list of steps, steps starting with keywords such as (Given, When, Then, But or And). Additionally, the feature may include a scenario outline and background

# #

## Scenario

Each Feature is made of a collection of scenarios. A single scenario is a flow of events through the Feature being described and maps 1:1 with an executable test case for the system.
*Пример*

```gherkin
Scenario: Eric wants to withdraw money from his bank account at an ATM
Given Eric has a valid Credit or Debit card
And his account balance is $100
When he inserts his card
And withdraws $45
Then the ATM should return $45
And his account balance is $55
```

Сценарий представляет собой одну из ключевых структур в языке Gherkin. Каждый сценарий начинается с ключевого слова “Сценарий:”, и может содержать в себе название сценария. Описание функционала может содержать в себе один или больше сценариев, и каждый сценарий состоит из одного или более шага.

Каждый из следующих сценариев содержит три шага:

*Пример*

```gherkin
#language: ru
Сценарий: Вася создает новую запись
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Лекарства"
То мне должен быть ответ "Ваша запись успешно добавлена."

Сценарий: Вася не может добавлять запись в справочник лечений
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Виды лечений"
То мне должен быть ответ "У вас нет прав доступа!"
```

Каждый сценарий состоит из списка шагов, каждый из которых должен начинаться с одного из ключевых слов:

Дано
Когда
То
Но
И
Шаги “Но” и “И” существуют исключительно для удобства чтения и по своим функциям повторяют ключевое слово, с которого начиналась предыдущая строчка.

Вдобавок к сценариям, описание функционала может также содержать структуры сценариев и предыстории.

Each feature file may have multiple scenarios, and each scenario starts with a script.
Scenarios are added to the feature file, to define examples of the expected behaviour. These scenarios can be used to test the feature. Start a scenario with the Scenario keyword and add a brief description of the scenario. To define the scenario, you have to define all of its steps.
Scenario or Example: This is a concrete example that illustrates a business rule. It consists of a list of steps.

## Шаги

The crux of a Scenario is defined by a sequence of Steps outlining the preconditions and flow of events that will take place. The first word of a step is a keyword, typically one of[24]

Given - Describes the preconditions and initial state before the start of a test and allows for any pre-test setup that may occur
When - Describes actions taken by a user during a test
Then - Describes the outcome resulting from actions taken in the When clause
Occasionally, the combination of Given-When-Then uses other keywords to define conjunctions

And - Logical and
But - Logically the same as And, but used in the negative form[

Функции состоят из шагов, также известных как Данные, Действия и Результаты.
Each step starts with Given, When, Then, And, or But.
*Пример*

```gherkin
Scenario: A user attempts to withdraw more money than they have in their account
Given John has a valid Credit or Debit card
And his account balance is $20
When he inserts his card
And withdraws $40
Then the ATM displays an error
And returns his card
But his balance remains $20
```

## Given: 

Данные (Givens)
Назначение шагов Дано состоит в приведение системы в известное состояние перед тем как пользователь (или внешняя система) начнет взаимодействие с системой (в шагах Когда). Также можно рассматривать их как предусловия.

Пример: создавать объекты сущностей или настраивать БД
*Пример*

```gherkin
#language: ru
Дано нет пользователей в базе
Дано база данных пустая
```

Пример: вход пользователя в систему (исключение к правилу “никаких взаимодействий в шаге Дано”)

*Пример*

```gherkin
#language: ru
Дано я вошел в систему как "Вася"
```

Preconditions, use to describe the original context. Introduce into the system a state to start interacting with the system. Given’s goal is to put the system into a known state before use (or the external system) to start interacting with the system (in the When step).

If you have worked with a use case, Givens is a prerequisite.
the initial context of the system - the scene of the scenario.
Use this keyword to bring the system to a familiar state before the user starts interacting with the system. However, you can skip writing user interactions in the given steps if given in the “Precondition” step.

## When: 

*Пример*

```gherkin
#language: ru
Действия (Whens)
Назначение шагов Когда состоит в описании ключевого действия, совершаемого пользователем.

Пример: взаимодействие со страницей

Когда я открыл форму добавления учреждения
Когда я ввел "Институт радости" в поле "Наименование"
Когда я выбрал в поле "Тип" значение "Институт"
Когда я нажал на кнопку "Сохранить"
```

describe the main action events the user performed. The use of the keyword “then” is to see the result after the action in the when “step”. However, you can only verify notable changes.
an event, or an action. This can be a person interacting with the system, or it can be an event triggered by another system.
The purpose of “When” is to describe events, the main action that a user uses.

## Then: 
Результаты (Thens)
Назначение шагов То состоит в наблюдении результатов выполнения действий. Наблюдения должны быть связаны с явной пользой, которая указаны в описании функции. Также необходимо помнить, что должен проверяться вывод системы (отчеты, интерфейс, сообщения), а не что-то глубоко закопанное в систему.

Expected output. “Then” was used to observe the result. Observations must be related to business values / benefits in “Feature” description. Observations must check the output of the system (a report, user interface, messages, etc.)

an expected outcome, or result.
The use of the keyword ‘then’ is to see the result after the action in the “When” step. However, you can only verify notable changes.

## And, But: 

Предлоги (And, But)
Если у вас есть несколько шагов Дано, Когда, или То то вы можете писать так:
*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
Дано что-то второе
Дано и что-то ещё
Когда я открою свои глаза
То я увижу что-то
То чего-то я не увижу
```  
  
...или можете использовать шаги И и Но, превращая свой сценарий в нечто более читаемое:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
И что-то второе
И и что-то ещё
Когда я открою свои глаза
То я увижу что-то
Но чего-то я не увижу
```

Used when there are many “Given”, “When”, “Then”
If you have successive Given’s, When’s, or Then’s, you could use And or But based on the context.

## Scenario outline

In some cases, one might want to test multiple scenarios at once to perform Equivalence partitioning and Boundary-value analysis. A Scenario Outline provides a technique to specify multiple examples to test against a template scenario by using placeholders.[24] For example,

*Пример*

```gherkin
Scenario Outline: A user withdraws money from an ATM
Given <Name> has a valid Credit or Debit card
And their account balance is <OriginalBalance>
When they insert their card
And withdraw <WithdrawalAmount>
Then the ATM should return <WithdrawalAmount>
And their account balance is <NewBalance>

    Examples:
      | Name   | OriginalBalance | WithdrawalAmount | NewBalance |
      | Eric   | 100             | 45               | 55         |
      | Gaurav | 100             | 40               | 60         |
      | Ed     | 1000            | 200              | 800        |
```

At runtime the scenario is run against each row in the table. Column values are substituted for each of the named placeholders in the scenario.

Достаточно часто приходится писать множество мелких сценариев, которые различаются буквально парой переменных. Эти повторения могут быстро надоесть:

*Пример*

```gherkin
#language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
Структуры сценариев позволяют нам более кратко описывать подобные наборы сценариев с помощью шаблонов:

Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

Шаги указанные в структуре сценария не выполняются напрямую, но используются для подстановки в них значений из таблицы примеров. Каждая строчка таблицы будет обрабатываться как отдельный сценарий с указанными значениями вместо заглушек “было”, “удалено” и “стало”.
Scenario Outline: to run the same Scenario multiple times, with different combinations of values.
Examples: A Scenario Outline must contain Examples section containing all the different values to run the Scenario Outline with.


## Background

Предыстории позволяют вам добавить определенный контекст ко всем сценариям в пределах функции. По сути, предыстория - сценарий без имени, состоящий из шагов. Основное отличие в запуске: предыстория запускается перед каждым сценарием:

*Пример*

```gherkin
# language: ru
Функция: поддержка многих справочников

    Предыстория:
        Дано есть пользователь с именем "Вася"
        И есть справочник "Лекарства"
        И у пользователя "Вася" есть право на запись в  "Лекарство"
        И есть справочник "Виды лечений"

    Сценарий: Вася создает новую запись
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Лекарства"
        То мне должен быть ответ "Ваша запись успешно добавлена."

    Сценарий: Вася не может добавлять запись в справочник лечений
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Виды лечений"
        То мне должен быть ответ "У вас нет прав доступа!"
```      
      
Background: add some context to the scenarios in the feature.
The “Background” keyword helps you add some context to the script. It may contain several script steps, but the only difference is that it should be run before each script.
It can contain some steps of the scenario, but the only difference is that it should be run before each scenario.
These are steps or series of steps that are common to all the scenarios in the feature file.

It allows us to add some context to the scenarios for a feature where it is defined. It runs before every scenario for a feature in which it is defined.

# Passing Data

## Регулярные выражения (Regular Expression)

То, что в регулярных выражениях записано в скобках передается в метод в виде аргумента. Фреймворк самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

Regular Expressions could be used when multiple scenarios are similar but they work with different data.
Say, for example, for Feature 'Process refund', you have a scenario where customer has their bank statement claiming they purchases a kettle for €10 from the store. In this case you would like to reuse the following function and not create a fresh one for 'bank statement'

*Пример*

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
    public void they_have_their_receipt() {
        //code
    }
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки) 

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)
  
*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки) 

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные 

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент. 

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

#

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций. 
Для подобной задачи в Cucumber есть несколько решений

## Данные перечисленные через запятую (ArrayList)

Фреймворк **Cucumber** по умолчанию оборачивает данные, перечисленные через запятую, в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

Для замены разделителя, можно воспользоваться аннотацией **@Delimiter**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл и Редактировать и О программе
```

```java
@Дано("^в меню доступны пункты (.+)$")
public void вМенюДоступныПункты(@Delimiter(" и ") List<String> arg) {
    // что-то сделать
}
```

## Данные в виде таблицы с одной колонкой (ArrayList)

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** также может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## Данные в виде таблицы с двумя колонками (Map)

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в ассоциативный массив, 
где данные из первой колонки – это ключ, а из второй – данные

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```

## Таблицы данных (Datatables)

When you have multiple parameters to pass to the function

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

The function in Step Definition would look like this:


```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    // что-то сделать
}
```

***DataTable*** – это класс, который эмулирует табличное представление данных. Для доступа к данным в нем имеется большое количество методов.

```java
public <K,V> List<Map<K,V>> asMaps(Class<K> keyType,Class<V> valueType)
```

Конвертирует таблицу в список ассоциативных массивов. Первая строка таблицы используется для именования ключей, остальные как значения:

```gherkin
# language: ru
Дано в меню доступны пункты
| Название      | Доступен | Количество подменю |
| Файл          | true     | 5                  |
| Редактировать | false    | 8                  |
| О программе   | true     | 2                  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<Map<String, String>> table = arg.asMaps(String.class, String.class);
System.out.println(table.get(0).get("Название"));
System.out.println(table.get(1).get("Название"));
System.out.println(table.get(2).get("Название"));
}
```

Данный пример выведет на консоль:

Файл
Редактировать
О программе

```java
public <T> List<List<T>> asLists(Class<T> itemType)
```

Метод преобразует таблицу в список списков:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<List<String>> table = arg.asLists(String.class);
System.out.print(table.get(0).get(0) + " ");
System.out.print(table.get(0).get(1) + " ");
System.out.println(table.get(0).get(2) + " ");

    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

На консоль будет выведено:

Файл true 5
Редактировать false 8

```java
public List<List<String>> cells(int firstRow)
```

Этот метод делает то же, что и предыдущий метод, за исключением того, что нельзя определить какого типа данные находятся в таблице, всегда возвращает список строк – List. В качестве аргумента метод принимает номер первой строки:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<List<String>> table = arg.cells(1);
System.out.print(table.get(0).get(0) + " ");
System.out.print(table.get(0).get(1) + " ");
System.out.println(table.get(0).get(2) + " ");

    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

Метод выведет на консоль:

Редактировать false 8
О программе true 2

## Использование классов

Class
Cucumber может создать объекты из табличных данных, переданных из сценария. Существует два способа это сделать.

Создадим для примера класс Menu:

```java
public class Menu {
private String title;
private boolean isAvailable;
private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

Для первого способа шаг в сценарии запишем в следующем виде:

```gherkin
# language: ru
Дано в меню доступны пункты
| title         | isAvailable | subMenuCount |
| Файл          | true        | 5            |
| Редактировать | false       | 8            |
| О программе   | true        | 2            |
```

Реализация:

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<Menu> arg) {
for (int i = 0; i < arg.size(); i++) {
System.out.print(arg.get(i).getTitle() + " ");
System.out.print(Boolean.toString(arg.get(i).getAvailable()) + " ");
System.out.println(Integer.toString(arg.get(i).getSubMenuCount()));
}
}
```

Вывод в консоль:

Файл true 5
Редактировать false 8
О программе true 2

Фреймворк создает связанный список объектов из таблицы с тремя колонками. В первой строке таблицы должны быть указаны наименования полей класса, создаваемого объекта. Если какое-то поле не указать, оно не будет инициализировано.

Для второго способа приведем шаг сценария к следующему виду:

```gherkin
# language: ru
Дано в меню доступны пункты
| title        | Файл | Редактировать | О программе |
| isAvailable  | true | false         | true        |
| subMenuCount | 5    | 8             | 2           |
```

А в аргументе описания шага используем аннотацию @Transpose.

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(@Transpose List<Menu> arg) {
// что-то сделать
}
```

Cucumber, как и в предыдущем примере, создаст связанный список объектов, но, в данном случае, наименования полей записывается в первой колонке таблицы.

## Многострочный текст

Для передачи многострочных данных в аргумент метода, их необходимо экранировать тремя двойными кавычками:
```gherkin
# language: ru
Тогда отображается форма с текстом

"""
На ваш номер телефона был выслан одноразовый пароль.
Для подтверждения платежа необходимо ввести полученный
одноразовый пароль.
"""
```

Данные в метод приходят в виде объекта класса String:

```java
@Тогда("^отображается форма с текстом$")
public void отображаетсяФормаСТекстом(String expectedText) {
// что-то сделать
}
```

## Преобразование данных

Фреймворк самостоятельно приводит данные из сценария к типу данных, указанному в аргументе метода. Если это невозможно, то выбрасывает исключение ConversionException. Это справедливо и для классов Date и Calendar. Рассмотрим пример:

```gherkin
# language: ru
Дано дата создания документа 04.05.2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Все прекрасно сработало, Cucumber преобразовал 04.05.2017 в объект класса Date со значением «Thu May 04 00:00:00 EET 2017».

Рассмотрим еще один пример:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Дойдя до этого шага, Cucumber выбросил исключение:

cucumber.deps.com.thoughtworks.xstream.converters.ConversionException: Couldn't convert "04-05-2017" to an instance of: [class java.util.Date]

Почему первый пример сработал, а второй нет?

Дело в том, что в Cucumber встроена поддержка форматов дат чувствительных к текущей локали. Если необходимо записать дату в формате, отличающемся от формата текущей локали, нужно использовать аннотацию Format:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```


```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (@Format("dd-MM-yyyy") Date arg) {
// что-то сделать
}
```

## Scenario Outline & Example keyword

Достаточно часто приходится писать множество мелких сценариев, которые различаются буквально парой переменных. Эти повторения могут быстро надоесть:

```gherkin
# language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
Структуры сценариев позволяют нам более кратко описывать подобные наборы сценариев с помощью шаблонов:

Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

Шаги указанные в структуре сценария не выполняются напрямую, но используются для подстановки в них значений из таблицы примеров. Каждая строчка таблицы будет обрабатываться как отдельный сценарий с указанными значениями вместо заглушек “было”, “удалено” и “стало”.


Бывают случаи, когда необходимо запустить тест несколько раз с различным набором данных, в таких случая на помощь приходит конструкция «Структура сценария»:

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

@success
Структура сценария: Успешное снятие денег со счета
Дано на счете пользователя имеется <изначально> рублей
Когда пользователь снимает со счета <снято> рублей
Тогда на счете пользователя имеется <осталось> рублей

    Примеры:
      | изначально | снято | осталось |
      | 10000      | 1     | 9999     |
      | 9999       | 9999  | 0        |
```

Суть данной конструкции заключается в том, что в места, обозначенные символами <>, вставляются данные из таблицы Примеры. Тест будет запускаться поочередно для каждой строки из данной таблицы. Названия колонок должно совпадать с названием мест вставки данных.

```gherkin
Feature: Process refunds
  Scenario Outline: Customer has their receipt
    Given the customer has purchased something
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for <product> is incremented by <quantity>
      And the customer's card is credited with €<price>

    Examples: 
      | product | quantity | price | 
      | kettle  | 1        | 10    | 
      | cup     | 6        | 50    | 
      | mug     | 2        | 30    | 
      | glass   | 12       | 40    |
```

```java
@Then("^the stock inventory for (.+) is incremented by (.+)$")
    public void the_stock_inventory_for_is_incremented_by(String product, String quantity) {
        System.out.println(product);
        System.out.println(quantity);
    }

    @And("^the customer's card is credited with €(.+)$")
    public void the_customers_card_is_credited_with_(String price) {
        System.out.println(price);
    }
```

***

# Best practices of using Gherkin

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)