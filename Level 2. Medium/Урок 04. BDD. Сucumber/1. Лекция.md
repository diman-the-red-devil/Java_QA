Java_QA / Level 2. Medium - Продвинутые темы / Урок 04. BDD. Сucumber

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Cucumber

***Cucumber*** - фреймворк автоматизации тестирования, поддерживающий **BDD (Behavior-Driven Development)** подход.

Первоначально **Cucumber** был разработан **Ruby**-сообществом,
но со временем был адаптирован и для других популярных языков программирования (**Java**, **JS**).

**Cucumber** использует легко читаемый предметно-ориентированный язык для описания поведения приложения, который называется **Gherkin**.
Тестовые сценарии пишутся на простом нетехническом языке, благодаря чему, понимать и писать их может любой участник проекта.

**Cucumber** заполняет разрыв между разработчиками и заинтересованными сторонами (бизнес).
Используя **Cucumber**, все заинтересованные стороны могут быть вовлечены в написание тестовых примеров.
Тестовые примеры могут быть написаны на общем понятном для всех языке (например, на английском, французском и т. Д.).
Эти тестовые примеры мапятся с реальным тестовым кодом.

**Cucumber** — очень мощный и гибкий фреймворк, который можно использовать в связке со многими другими популярными инструментами:

* **Selenium WebDriver** – фреймворк для управления браузером (веб UI тесты)
* **Rest Assured** - фреймворк для API тестов
* **Yandex.Allure** – библиотека для создания удобных отчетов

***

# 2. Структура проекта Cucumber

Проект **Cucumber** состоит из следующих частей:

1. описание сценариев (поведения системы) по шагам - текстовые файлы с расширением **.feature**
2. реализация шагов сценариев на языке программирования - файлы с исходным кодом **.java**
3. теги - метки для организации запуска сценариев
4. хуки - методы выполняемые до и после для запуска сценариев
5. раннер для запуска сценариев - специальный класс **Java**
6. прочие файлы

## 2.1. Описание сценариев (Features)

***Описание сценариев (Features)*** – текстовые файлы с расширением **.feature**, которые содержат текст исполняемых спецификаций на языке **Gherkin**.

**Описание сценариев (Features)** представляет собой текст на естественном языке в свободной форме с использованием ключевых слов **Gherkin**.

*Пример*

```gherkin
# language: ru
@withdrawal
Функция: Снятие денег со счета

  @success
  Сценарий: Успешное снятие денег со счета
    Дано на счете пользователя имеется 120000 рублей
    Когда пользователь снимает со счета 20000 рублей
    Тогда на счете пользователя имеется 100000 рублей

  @fail
  Сценарий: Снятие денег со счета - недостаточно денег
    Дано на счете пользователя имеется 100 рублей
    Когда пользователь снимает со счета 120 рублей
    Тогда появляется предупреждение "На счете недостаточно денег"
```

Особенности:

1. Каждый файл **.feature** должен содержать описание только одной фичи

Описание фичи начинается с ключевого слова **Функция (Function)** и поэтому каждый файл содержит только одно ключевое слово.

2. Каждый файл **.feature** может содержать от 0 и более сценариев

3. Текст сценариев должен начинаться с **# language: ru**, если используется русский язык

Эта строка указывает **Cucumber**, что в сценарии используется русский язык (по умолчанию используется английский язык).
Если её не указать, фреймворк, встретив в сценарии русский текст, выбросит исключение **LexingError** и тест не запустится.

4. Каждый сценарий должен иметь следующую структуру:

* получение начального состояние системы
* выполнение действий по изменению состояния системы
* получение и проверка нового состояние системы

[Your BDD scenarios should change only when the requirement changes, not when the implementation changes (i.e. your BDD scenarios must drive the implementation, not the other way around).]

## 2.2. Реализация шагов сценариев (Step Defs)

***Реализация шагов сценариев (Step Defs)*** - файлы с расширением **.java**,
содержащие код для взаимодействия с разрабатываемой системой,
на который мапятся шаги в описании сценариев.

**Cucumber** не знает как взаимодействовать с системой в рамках
исполнения шагов сценариев написанных на **Gherkin** в файлах **.feature**.

**Реализация шагов сценариев (Step Defs)** связывает шаги описанные в тексте на **Gherkin** в файлах **.feature**
с кодом по взаимодействию с системой на **Java**, чтобы сценарии могли исполниться.

**Реализация шагов сценариев (Step Defs)** представляет собой текст с записанным выражением-паттерном
(регулярным выражением или выражением Cucumber), который содержится в специальной аннотации 
у каждого метода реализующего определенный шаг.

Сам код на **Java** может тестировать:

* Web UI (**Selenium WebDriver**)
* REST API (**REST Assured**)
* SOAP
* БД
  и т д.

*Пример*

```java

```

Аннотации для **Реализации шагов сценариев (Step Defs)**:

| Шаг   | Аннотация |    |
|-------|-----------|----|
| Given | @Given    |    |
| When  | @When     |    |
| Then  | @Then     |    |

При выполнении тестов **Cucumber** для каждого шага **.feature** на **Gherkin** 
ищет его реализацию в коде на **Java**, посредством сравнения с выражением-паттерном в аннотации.
Таким образом, шаги в файлах **.feature** на **Gherkin** можно рассматривать как вызов методов **Java**.

Особенности:

1. Каждая **Реализация шагов сценариев (Step Defs)** должна совпадать по количеству аргументов с шагами описанными в **.feature**
2. Каждая **Реализация шагов сценариев (Step Defs)** должна иметь уникальный паттерн описанный в аннотации

Если задать два разных метода с одним и тем же паттерном, то при выполнении тестов возникнет исключение **DuplicateStepException**.
Такое же исключение можно словить, если задать два разных метода с одним и тем же паттерном в разных файлах **.java** в одном пакете **Java**.

3. Каждая **Реализация шагов сценариев (Step Defs)** может быть повторно использована в различных файлах **.feature**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

4. Каждая **Реализация шагов сценариев (Step Defs)** может быть использована в одном файле **.feature**
   совместно с другими реализациями шагов из разных файлов **.java**

Единственное ограничение - все шаги должны быть в одном пакете **Java**.

## 2.3. Теги (Tags)

***Теги (Tags)*** - метки для организации запуска сценариев.

**Теги (Tags)** представляют собой строки начинающиеся с символа **@** и располагающиеся перед строками с ключевыми словами.

**Тегами (Tags)** в файле **.feature** можно пометить:

* фичи (**Функции (Feature)**)
* сценарии (**Сценарии (Scenario)** и **Структуры сценариев (Scenario Outline)**)
* примеры (**Примеры (Examples)**)

*Пример*

```gherkin
Feature: Process refunds
  @RegressionTest
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their receipt
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

С помощью тегов можно задать классификацию и группировку сценариев,
а также организацию запуска сценариев, независимо от их расположения в файлах и папках проекта.

Например, можно задать теги **@smoke**, **@regression**, чтобы поделить тестовые сценарии на регрессионные и смоук,
и при запуске указывать теги, чтобы выполнить только определенные сценарии.

*Пример*

```java
tags = {“~@Ignore”}
        tags = {“@UpdateProfile”}
```

Особенности:

1. Можно использовать множество тегов для пометки

*Пример*

```gherkin
@important @maintenance @db @auth
```

2. Теги наследуется

Любой тег из **Функции (Feature)** будет наследоваться в **Сценарии (Scenario)**,
**Структуры сценариев (Scenario Outline)** или **Примеры (Examples)**.


## 2.4. Хуки (Hooks)

***Хуки (Hooks)*** - методы выполняемые до и после для запуска сценариев.

**Хуки (Hooks)** представляют собой методы помеченные специальными аннотациями.

*Пример*

```java
import cucumber.api.java.After;
import cucumber.api.java.Before;

public class Hooks {
    @Before
    public void prepareData() {
        //подготовить данные
    }
    
    @After
    public void clearData() {
        //очистить данные
    }
}
```

Аннотации для **Хуков (Hooks)**:

|    |    |    |
|----|----|----|
| Before   | перед каждым сценарием   |    |
| After   | после   |    |
| Around   | Assumes control and runs around a scenario   |    |
| BeforeStep   |    |    |
| AfterStep   |    |    |
| AfterConfiguration   | Runs after Cucumber configuration and is passed an instance of the configuration   |    |

Особенности:

1. Класс с **Хуками (Hooks)** должен находиться в пакете, указанном в опциях фреймворка

2. **Хукам (Hooks)** можно задать порядок, в котором они будут выполняться

Для этого необходимо в аннотации указать параметр **order**. По умолчанию значение order равно 10000.

Для **@Before** чем меньше это значение, тем раньше выполнится метод

*Пример*

```java
// первым выполнится метод connectToServer()
@Before(order = 10)
    public void connectToServer() {
    // подключиться к серверу
}
// затем prepareData()
@Before(order = 20)
    public void prepareData() {
    // подготовить данные
}
```

Для **@After** отрабатывает в обратном порядке.

3. **Хукам (Hooks) @Before, @After, @Around** можно задать теги, чтобы задать фильтрацию сценариев, для которых будут применяться хуки.

В параметре **value** нужно указать тэги сценариев, для которых будут отрабатывать **Хуки (Hooks)**.
Список тегов сценариев в одной строке обрабатывается как **ИЛИ**, а отдельные аргументы обрабатываются как **И**.
Символ **~** означает «за исключением».

*Пример*

```java
// метод connectToServer() будет выполнен для всех сценариев с тэгом correct
@Before(value = "@correct", order = 30)
public void connectToServer() {
    //сделай что-нибудь
}
        
// метод prepareData() будет выполнен для всех сценариев за исключением сценариев с тэгом fail
@Before(value = "~@fail", order = 20)
public void prepareData() {
    //сделай что-нибудь
}
```

4. **Хукам (Hooks)** можно передать в качестве параметра объект класса **Scenario**

Если в определении **Хука (Hooks)** в аргументе указать объект класса **Scenario**,
то в данном методе можно будет узнать много полезной информации о запущенном сценарии.

*Пример*

Метод **getScenarioInfo(Scenario scenario)**

```java
@After
public void getScenarioInfo(Scenario scenario) {
    System.out.println(scenario.getId());
    System.out.println(scenario.getName());
    System.out.println(scenario.getStatus());
    System.out.println(scenario.isFailed());
    System.out.println(scenario.getSourceTagNames());
}
```

Для сценария

```gherkin
# language: ru
@all
Функция: Аутентификация банковской карты
  
    Банкомат должен спросить у пользователя PIN-код банковской карты
    Банкомат должен выдать предупреждение если пользователь ввел неправильный PIN-код
    Аутентификация успешна если пользователь ввел правильный PIN-код

    Предыстория:
    Допустим пользователь вставляет в банкомат банковскую карту
    И банкомат выдает сообщение о необходимости ввода PIN-кода

    @correct
    Сценарий: Успешная аутентификация
    Если пользователь вводит корректный PIN-код
    То банкомат отображает меню и количество доступных денег на счету
```

Выведет в консоль следующее

```text
аутентификация-банковской-карты;успешная-аутентификация
Успешная аутентификация
passed
false
[@correct, @all]
```

5. Необходимо помнить про нюансы работы с **Хуками (Hooks)**

* тестовый фреймворк может также добавить выполнение кода до и после выполнения каждого метода
* сценарии в **Cucumber** выполняются независимо друг от друга
* шаги описанные в **Предыстории (Background)** выполняются перед каждым сценарием

## 2.5. Раннер (Runner)

***Раннер (Runner)*** - класс для запуска сценариев.

**Раннер (Runner)** представляет собой специальный класс **Java** с аннотацией **@RunWith(Cucumber.class)**.

*Пример*

```java
@RunWith(Cucumber.class)
@CucumberOptions(
        features = "src/test/features",
        glue = "ru.test",
        tags = "@all",
        dryRun = false,
        strict = false,
        snippets = SnippetType.UNDERSCORE,
        plugin = {"pretty", "html:target/htmlreport", "json:report.json", "junit:report.xml"},
        monochrome = true, 
//      name = "^Успешное|Успешная.*"
)
public class RunnerTest {
    
}

```

В классе-раннере через аннотацию **@CucumberOptions** задается следующая информация - **опции Cucumber (Cucumber Options)**:

* *features* - путь к папке с **.feature** файлами

Фреймворк **Cucumber** будет искать файлы сценариев в этой и во всех дочерних папках.

Можно указать несколько папок запятую.

*Пример*

```java
features = {"src/test/features", "src/test/feat"},
```

Значение по умолчанию **{}**.

* *glue* - пакет **Java**, в котором находятся классы с реализацией шагов и хуков (**hooks**)

Фреймворк **Cucumber** будет искать классы с реализацией шагов в этом и во всех вложенных пакетах.

Можно указать несколько пакетов через запятую.

*Пример*

```java
glue = {"ru.test", "ru.hooks"}
```

Значение по умолчанию **{}**.

* *tags* - фильтр запускаемых тестов по тегам

Можно указать несколько тегов через запятую.

*Пример*

```java
tags = "@all, @dev, @int, @regress",
```

Символ **~** исключает тест из списка запускаемых тестов.

*Пример*

```java
tags = "@positive, ~@negative",
```

Значение по умолчанию **{}**.

* *dryRun* - проверка реализации всех шагов сценариев

Если задано **true**, то сразу после запуска теста фреймворк проверяет, все ли шаги теста разработаны.
Если нет, то выдает предупреждение.

Если задано **false**, то предупреждение будет выдаваться по достижении нереализованного шага.

Значение по умолчанию **false**.

* *strict* - пропуск нереализованных шагов

Если задано **true**, то при встрече нереализованного шага тест остановится с ошибкой.
Если задано **false**, то все нереализованные шаги пропускаются.

Значение по умолчанию **false**.

* *snippets* – формат нереализованных шагов

Фреймворк будет предлагать шаблон для нереализованных шагов.

Доступны значения: **SnippetType.CAMELCASE**, **SnippetType.UNDERSCORE**.

* *name* – фильтрация запускаемых тестов

Если задано, то фреймворк фильтрует запускаемые тесты по названиям удовлетворяющим регулярному выражению.
Для фильтрации запускаемых тестов нельзя одновременно использовать опции **tags** и **name**.

* *plugin* — to specify different formatting options for the output reports

* *monochrome* — to receive clean and readable output in your console

## 2.6. Прочие файлы

PageObjects, ConfigFiles e t c

***

# 3. Запуск (Run)

## Процесс запуска

При запуске теста **Cucumber** проходит по сценарию шаг за шагом.
Взяв шаг, он отделяет ключевое слово от описания шага и
пытается найти в **Java** классах пакета указанного в опции glue аннотацию с регулярным выражением,
подходящим описанию. Найдя совпадение, фреймворк вызывает метод с найденной аннотацией.
Если несколько регулярных выражений удовлетворяют описанию шага, фреймворк выбрасывает ошибку.

When Cucumber executes a Step in a Scenario, it will look for a matching Step Definition to execute.
When Cucumber matches a Step against a pattern in a Step Definition, it passes the value of all the capture groups to the Step Definition’s arguments.
The pattern is used to link the step definition to all the matching Steps and Cucumber will execute the code written inside Step Definition when it sees a Gherkin Step.


    Steps    │                 │     Step     │                 │           │
│ in Gherkin ├──matched with──>│ Definitions  ├───manipulates──>│  System

## Reports

Cucumber uses Formatter Plugins to provide output. Several common formats are provided by default, including

JSON
HTML
JUnit

Available formats are not standardized across different Cucumber implementations, so offerings may differ.
Cucumber also supports rich output formats like images and videos.

## Cucumber command-line

Cucumber comes with a built-in command line interface that covers a comprehensive list of instructions.
Like most command line tools, cucumber provides the --help option that provides a summary of arguments the command accepts.

$ cucumber --help
-r, --require LIBRARY|DIR        Require files before executing the features.
--i18n LANG                      List keywords for in a particular language.
Run with "--i18n help" to see all languages.
-f, --format FORMAT              How to format features (Default: pretty).
-o, --out [FILE|DIR]             Write output to a file/directory instead of
...
Cucumber command line can be used to quickly run defined tests. It also supports running a subset of scenarios by filtering tags.

$ cucumber --tags @tag-name
The above command helps in executing only those scenarios that have the specified @tag-name.[30] Arguments can be provided as a logical OR or AND operation of tags. Apart from tags, scenarios can be filtered on scenario names.[30]

$ cucumber --name logout
The above command will run only those scenarios that contain the word 'logout'.

It is also useful to be able to know what went wrong when a test fails. Cucumber makes it easy to catch bugs in the code with the --backtrace option.[30]

Cucumber can also be configured to ignore certain scenarios that have not been completed by marking them with the Work In Progress tag @wip. When Cucumber is passed the --wip argument, Cucumber ignores scenarios with the @wip tag.

***

# 3. Gherkin

***Gherkin*** - предметно-ориентированный человеко-читаемый язык, предназначенный для
описания поведения системы без подробностей его реализации.

**Gherkin** определяет структуру теста и набор ключевых слов.

Синтаксис **Gherkin** подобно синтаксису **Python**, **Ruby** или **YAML** ориентирован на строки и
использует отступы для задания структуры. Каждая строка представляет собой выражение -
шаг (**step**) и заканчивается переносом строки.

Почти каждая строка начинается с одного из ключевых слов и описывает один из шагов.
Ключевые слова переведены на множество языков, в том числе русский.

Комментарии начинаются с символа \# (решетка). Перед комментарием могут быть 1 или более пробелов.
Блочных комментариев на текущий момент нет в **Gherkin**.

Пробелы и табуляция могут быть использованы для отступов.

*Пример*

```gherkin
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
```

Список зарезервированных символов:

* *#* – обозначает комментарии
* *@* – тэгирует сценарии или функционал
* *|* – разделяет данные в табличном формате
* *"""* – обрамляет многострочные данные

## 3.1. Функция (Feature)

***Функция (Feature)*** - ключевое слово, предназначенное для описания поведения/функции системы и набора связанных с ней тестовых сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  # подробное описание
  # сценарии
```

**Функция (Feature)** описывается в отдельном файле с расширением **.feature**.
Любой документ **.feature** начинается с этого ключевого слова и краткого описания.
Каждая функция обычно состоит из списка сценариев (**Сценарий (Scenario)**, **Структура сценария (Scenario Outline)**).

На следующей строке после ключевого слова и наименования функции может идти **Подробное описание (Descriptions)**.

Наименование функции и подробное описание не имеют какого либо значения для **Cucumber**.

*Пример*

```Gherkin
Feature: Withdraw Money from ATM

  A user with an account at a bank would like to withdraw money from an ATM.

  Provided he has a valid account and debit or credit card, he should be allowed to make the transaction. The ATM will tend the requested amount of money, return his card, and subtract amount of the withdrawal from the user's account.

  Scenario: Scenario 1
    Given preconditions
    When actions
    Then results

  Scenario: Scenario 2
  ...
```

## 3.2. Подробное описание (Descriptions)

***Подробное описание (Descriptions)*** - более подробное описание фичи.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

    Подробное описание
    На нескольких строках

    # сценарии
```

**Подробное описание (Descriptions)** представляет собой текст, который располагается на следующих строках
после строки с ключевым словом и размечается отступами. Количество строк никак не ограничено и
**Подробное описание (Descriptions)** продолжается до первого встреченного ключевого слова.
Эти строки будут проигнорированы **Cucumber** при выполнении тестов, но будут использованы при формировании отчетов.

**Подробное описание (Descriptions)** можно добавлять после:

* *Примера (Example)* или *Сценария (Scenario)*
* *Предыстории (Background)*
* *Структуры сценария (Scenario Outline)*

*Пример*

```gherkin

```

## 3.3. Сценарий (Scenario)

***Сценарий (Scenario)*** - ключевое слово, предназначенное для описания конкретного тестового сценария.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
  # шаги сценария
```

**Сценарий (Scenario)** представляет собой одну из ключевых структур в языке **Gherkin**.
Каждый сценарий состоит из набора **Шагов (Steps)**.
Также **Сценарии (Scenario)** могут содержать **Предысторию (Background)** или
иметь множество примеров в виде **Структуры сценария (Scenario Outline)**.

**Сценарий (Scenario)** описывает поведение системы и является ее спецификацией.

*Пример*

```gherkin
#language: ru
Сценарий: Вася создает новую запись
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Лекарства"
То мне должен быть ответ "Ваша запись успешно добавлена."

Сценарий: Вася не может добавлять запись в справочник лечений
Дано я вошел в систему как Вася
Когда я пытаюсь добавить запись в справочник "Виды лечений"
То мне должен быть ответ "У вас нет прав доступа!"
```

## 3.4. Шаги (Steps)

***Шаги (Steps)*** - строительные блоки тестовых сценариев.

**Шаги (Steps)** представляют собой строки текста начинающиеся с одного из ключевых слов:

* *Дано (Given)* - данные
* *Когда (When)* - действия
* *То (Then)* - результаты
* *Но (But)*
* *И (And)*

Шаги **Но (But)** и **И (And)** существуют исключительно для удобства чтения и
по своим функциям повторяют ключевое слово, с которого начиналась предыдущая строка.

*Пример*

```gherkin
Scenario: A user attempts to withdraw more money than they have in their account
Given John has a valid Credit or Debit card
And his account balance is $20
When he inserts his card
And withdraws $40
Then the ATM displays an error
And returns his card
But his balance remains $20
```

### 3.4.1. Дано (Given)

***Дано (Given)*** - ключевое слово, предназначенное для описания предусловий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    # шаги сценария
```

Шаг ***Дано (Given)*** приводит систему в известное состояние перед тем
как пользователь (или внешняя система) начнет взаимодействие с системой.
Также можно рассматривать их как предусловия.

*Пример*

```gherkin
#language: ru
Дано нет пользователей в базе
Дано база данных пустая
```

### 3.4.2. Когда (When)

***Когда (When)*** - ключевое слово, предназначенное для описания событий или действий.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    # шаги сценария
```

Шаг **Когда (When)** изменяет состояние системы путем взаимодействия с системой пользователя (или внешней системы).
Настоятельно рекомендуется использовать только один шаг **Когда (When)** для каждого сценария.
[Если вы чувствуете необходимость добавить что-то еще, обычно это знак того, что вам следует разбить сценарий на несколько сценариев.
Постарайтесь придумать примеры, которые не предполагают никаких предположений о технологиях или пользовательском интерфейсе.
Представьте себе 1922 год, когда не было компьютеров.
Детали реализации должны быть скрыты в определениях шагов.]

*Пример*

```gherkin
#language: ru
Пример: взаимодействие со страницей
Когда я открыл форму добавления учреждения
Когда я ввел "Институт радости" в поле "Наименование"
Когда я выбрал в поле "Тип" значение "Институт"
Когда я нажал на кнопку "Сохранить"
```

### 3.4.3. Тогда / То (Then)

***Тогда / То (Then)*** - ключевое слово, предназначенное для описания ожидаемых результатов.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

Шаг ***Тогда / То (Then)*** проверяет результирующее состояние системы после выполнения действий.
Проверки результатов должны быть связаны с явной пользой, которая указаны в описании функции.
Также необходимо помнить, что должен проверяться вывод системы (отчеты, интерфейс, сообщения), а не что-то глубоко закопанное в систему.

*Пример*

```gherkin
#language: ru

```

### 3.4.4. И (And), Но (But), * (Asterisk)

Если **Сценарии (Scenario)** есть несколько шагов **Дано (Given)**, **Когда (When)**, или **Тогда (Then)**, то можно писать их так:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
    Дано что-то первое
    Дано что-то второе
    Дано и что-то ещё
    Когда я открою свои глаза
    То я увижу что-то
    То чего-то я не увижу
```  

Или можно использовать шаги **И (And)** и **Но (But)**, превращая **Сценарии (Scenario)** в нечто более читаемое:

*Пример*

```gherkin
#language: ru
Сценарий: множественные данные
Дано что-то первое
И что-то второе
И и что-то ещё
Когда я открою свои глаза
То я увижу что-то
Но чего-то я не увижу
```

***И (And)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Когда Действие
    И Действие
    Тогда Результат
    И Результат
    # шаги сценария
```

***Но (But)*** - ключевое слово, предназначенное для улучшения читаемости.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    И Предусловие
    Но Предусловие
    Когда Действие
    И Действие
    Но Действие
    Тогда Результат
    И Результат
    Но Результат
    # шаги сценария
```

***\* (Asterisk)*** - символ, заменяющий любое ключевое слово обозначающее **Шаг (Step)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции

  Подробное описание
  На нескольких строках

  Сценарий: Наименование сценария
    Дано Предусловие
    * Предусловие
    * Предусловие
    Когда Действие
    * Действие
    * Действие
    Тогда Результат
    * Результат
    * Результат
    # шаги сценария
```

**\* (Asterisk)** используется для улучшения восприятия текста сценария.

*Пример*

```gherkin
#language: ru

```

## 3.5. Предыстория (Background)

***Предыстория (Background)*** - ключевое слово, предназначенное для добавления определенного
контекста ко всем **Сценариям (Scenario)** в пределах **Функции (Feature)**.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  
  Подробное описание
  На нескольких строках

  Предыстория: 
    Дано Предусловие
    
  Сценарий: Наименование сценария 1
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария

  Сценарий: Наименование сценария 2
    Дано Предусловие
    Когда Действие
    Тогда Результат
    # шаги сценария
```

В каждой **Функции (Feature)** может быть всего одна **Предыстория (Background)**
и располагается она до первого **Сценария (Scenario)** описанного в **Функции (Feature)**.

Если нужно добавить еще одну **Предыстория (Background)**,
то нужно подумать над разбиением **Функции (Feature)** на части.
Либо же настроить **Хуки (Hooks)** на определенные **Теги (Tags)**,
которыми будут помечены нужные **Сценарии (Scenario)**.

**Предыстория (Background)** по сути, представляет собой **Сценарий (Scenario)** без имени,
состоящий из **Шагов (Steps)**, которые повторно выполняются в каждом **Сценарии (Scenario)** какой-либо **Функции (Feature)**.

Основное отличие в запуске: **Предыстория (Background)** запускается перед каждым **Сценарием (Scenario)**,
но после выполнения любого **Хука (Hooks)** помеченного аннотацией **@Before**.

*Пример*

```gherkin
# language: ru
Функция: поддержка многих справочников

    Предыстория:
        Дано есть пользователь с именем "Вася"
        И есть справочник "Лекарства"
        И у пользователя "Вася" есть право на запись в  "Лекарство"
        И есть справочник "Виды лечений"

    Сценарий: Вася создает новую запись
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Лекарства"
        То мне должен быть ответ "Ваша запись успешно добавлена."

    Сценарий: Вася не может добавлять запись в справочник лечений
        Дано я вошел в систему как Вася
        Когда я пытаюсь добавить запись в справочник "Виды лечений"
        То мне должен быть ответ "У вас нет прав доступа!"
```      

## 3.6. Структура сценария (Scenario outline)

***Структура сценария (Scenario outline)*** - ключевое слово, предназначенное для многократного параметризованного выполнения сценариев.

Синтаксис:

```gherkin
#language: ru
Функция: Наименование функции
  Структура сценария: Наименование сценария
    Дано Предусловие <параметр1>
    Когда Действие <параметр2>
    Тогда Результат <параметр3>

    Примеры:
      | параметр1 | параметр2 | параметр3 |
      | значение1 | значение1 | значение3 |
      | значение2 | значение2 | значение3 |
```

В некоторых случаях может потребоваться протестировать один и тот же сценарий несколько раз,
чтобы выполнить тестовые сценарии с применением техник **Эквивалентного разделения** и **Анализа граничных значений**.

*Пример*

```gherkin
#language: ru
Сценарий: удалить 5 записей из 12
Дано есть 12 записей
Когда я удаляю 5 записей
То у меня должно остаться 7 записей

Сценарий: удалить 5 записей из 20
Дано есть 20 записей
Когда я удаляю 5 записей
То у меня должно остаться 15 записей
```

**Структура сценария (Scenario outline)** позволяет более кратко описывать подобные наборы сценариев с помощью заглушек (\< \>).

***Примеры (Examples)*** - ключевое слово, предназначенное для определения значений параметров, которые будут подставляться вместо заглушек.

Шаги указанные в **Структуре сценария (Scenario outline)** не выполняются напрямую,
а используются для подстановки в места, обозначенные символами (\< \>) значений из таблицы **Примеров (Examples)**.
Каждая строка таблицы **Примеров (Examples)** будет обрабатываться как отдельный сценарий,
а значения из строки будут подставляться в сценарий вместо заглушек.
Названия колонок должно совпадать с названием мест вставки данных.

*Пример*

```gherkin
#language: ru
Структура сценария: удаление записей
Дано есть <было> записей
Когда я удаляю <удалено> записей
То у меня должно остаться <остаток> записей

    Примеры:
        | было  | удалено | остаток |
        | 12    |    5    |   7     |
        | 20    |    5    |   15    |
```

***

# 4. Выражения (Expressions)

***Выражения (Expressions)*** - текст, содержащийся в аннотациях шагов, записанный с применением регулярного выражения или выражения **Cucumber**.

## 4.1. Регулярные выражения (Regular Expression)

***Регулярные выражения (Regular Expressions)*** — используемый в компьютерных программах, работающих с текстом, 
формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов 
(**Символ подстановки (Wildcard Characters)**). 

Для поиска используется строка-образец (**Шаблон (Pattern)**), состоящая из символов и метасимволов и задающая правило поиска. 
Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.

В аннотациях **Шагов (Steps)** то, что в регулярных выражениях записано в скобках передается в метод в виде аргумента.
Фреймворк **Cucumber** самостоятельно определяет, что необходимо передавать из сценария в метод в виде аргумента.

*Пример*

```gherkin
Feature: Process refunds
  Scenario: Customer has their receipt
    Given the customer has purchased a kettle for €10
      And they have their "receipt"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10

  Scenario: Customer has their bank statement
    Given the customer has purchased a kettle for €10
      And they have their "bank statement"
     When the sales assistant processes the refund
     Then the stock inventory for kettles is incremented by 1
      And the customer's card is credited with €10
```

```java
@And("^they have their receipt$")
public void they_have_their_receipt() {
    //code
}
```

Регулярные выражения:

* __.__ - один любой символ (за исключение переноса строки)

*Пример*

```regexp
. 
```

Соответствует **Ф**, **2**, **j**.

* __.*__ - 0 или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.*
```

Соответствует **Abracadabra**, **789-160-87** или пустой строке.

* __.+__ - один или больше любых символов (за исключением переноса строки)

*Пример*

```regexp
.+ 
```

Соответствует **Abracadabra**, **789-160-87**, но не пустой строке.

* __.{n}__ - любые *n* символов (за исключением переноса строки)

*Пример*

```regexp
.{2}
```

Соответствует **Фф**, **22**, **$х**, **JJ**.

```regexp
.{3} 
```

Соответствует **Ффф**, **222**, **$хy**, **JJJ**.

* __.{n,m}__ - от *n* до *m* любых символов (за исключением переноса строки)

*Пример*

```regexp
.{1,3}
```

Соответствует **Жжж**, **Уу**, **!**.

```regexp
.{2,3} 
```

Соответствует **Жжж**, **Уу**.

* __^__ - якорь начала строки

*Пример*

```regexp
^aaa 
```

Соответствует **aaa** или **aaabbb**, но не соответствует **bbbaaa**.

* __$__ - якорь конца строки

*Пример*

```regexp
aaa$
```

Соответствует **aaa** или **bbbaaa**, но не соответствует **aaabbb**.

* __\d*__ или __\[0-9\]__ - любое число (или ничего)

*Пример*

```regexp
\d* 
```

Соответствует **12321**, **5323** или пустой строке.

* __\d+__ или __\[0-9\]+__ - любое число

*Пример*

```regexp
\d+
```

Соответствует **12321**, **5323**, но не пустой строке.

* __\w*__ - любая буква, цифра или нижнее подчеркивание (или ничего)

*Пример*

```regexp
\w* 
```

Соответствует **_we**, **_1ee**, **Gfd4**.

* __\s__ - пробел, табуляция или перенос строки

*Пример*

```regexp
\s 
```

Соответствует **\t**, **\r** или **\n**.

* __"\[^\\"\]*"__ - любой символ (или ничего) в кавычках

*Пример*

```regexp
"[^\"]*" 
```

Соответствует **"aaa"**, **"3213dsa"** или **""**.

* __?__ - символ или группу символов необязательные

*Пример*

```regexp
abc? 
```

Соответствует **ab** или **abc**, но не соответствует **b** или **bc**.

* __|__ - логическое ИЛИ

*Пример*

```regexp
aaa|bbb 
```

Соответствует **aaa** или **bbb**, но не соответствует **aaabbb**.

* __()__ - группа

В **Cucumber** группа передается в определение шага в виде аргумента.

*Пример*

```regexp
(\d+) рублей 
```

Соответствует **10 рублей**, при этом **10** передается в метод шага в виде аргумента, а **рублей**- нет.

* __(?: )__ - не передаваемая группа

Cucumber не воспринимает группу как аргумент.

*Пример*

```regexp
(\d+) (?:рублей|рубля) 
```

Соответствует **3 рубля**, при этом **3** передается в метод в виде аргумента, а **рубля**- нет.

## 4.2. Выражения Cucumber (Cucumber Expressions)

***Выражения Cucumber (Cucumber Expressions)*** - специальный формат записи выражений, используемый фреймворком **Cucumber** 
по функциональности похожий на **Регулярные выражения (Regular Expressions)**, но более удобный для восприятия.

По умолчанию фреймворк **Cucumber** воспринимает выражения как **Выражения Cucumber (Cucumber Expressions)**.
Чтобы фреймворк воспринимал их как **Регулярные выражения (Regular Expressions)**, то само выражение должно обрамляться: 
* или символами начала **^** и конца **$** (так называемые **Якоря (Anchors)**)
* или символами **/** в начале и в конце выражения

*Пример*

```java

```

В **Выражения Cucumber (Cucumber Expressions)** можно передавать параметры в методы, на которые мапятся шаги.

Выражения Cucumber:

* __{int}__ - тип **int** в Java

Соответствует **71**, **-10**.

* __{float}__ - тип **float** в Java

Соответствует **3.6**, **-1.30**.

* __{word}__ - тип **String** в Java (без пробелов)

Соответствует **banana**, но не **banana split**.

* __{string}__ - тип **String** в Java (с пробелами, но все в кавычках)

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.
В метод будет передан только текст расположенный между парными кавычками.

* __{}__ - тип любой, в Java (с пробелами, но все в кавычках)

Соответствует **"banana split"** или **'banana split'**, но не **banana split**.

On the JVM, there are additional parameter types for biginteger, bigdecimal, byte, short, long and double.

The anonymous parameter type will be converted to the parameter type of the step definition using an object mapper. 
Cucumber comes with a built-in object mapper that can handle most basic types. 
Aside from Enum it supports conversion to BigInteger, BigDecimal, Boolean, Byte, Short, Integer, Long, Float, Double and String.

To automatically convert to other types it is recommended to install an object mapper. See configuration to learn how.

## 4.2.1. Кастомные типы параметров (Custom Parameter Types)

Cucumber Expressions can be extended so they automatically convert output parameters to your own types. 

Consider this Cucumber Expression:

*Пример*

```java
I have a {color} ball
```

If we want the {color} output parameter to be converted to a Color object, we can define a custom parameter type in Cucumber's configuration.

*Пример*

```java
@ParameterType("red|blue|yellow")  // regexp
public Color color(String color){  // type, name (from method)
return new Color(color);       // transformer function
}
```

The table below explains the various arguments you can pass when defining a parameter type.

Argument	Description
*name*	The name the parameter type will be recognised by in output parameters.
*regexp*	A regexp that will match the parameter. May include capture groups.
*type*	The return type of the transformer method.
*transformer*	A method that transforms the match from the regexp. Must have arity 1 if the regexp doesn't have any capture groups. Otherwise the arity must match the number of capture groups in regexp.
*useForSnippets* Defaults to true. That means this parameter type will be used to generate snippets for undefined steps. If the regexp frequently matches text you don't intend to be used as arguments, disable its use for snippets with false.
*preferForRegexpMatch* Defaults to false. Set to true if you have step definitions that use regular expressions, and you want this parameter type to take precedence over others during a match.

## 4.2.2. Опциональный текст (Optional text)

It's grammatically incorrect to say 1 cucumbers, so we should make the plural s optional. That can be done by surrounding the optional text with parentheses:

*Пример*

```java
I have {int} cucumber(s) in my belly
```        
That expression would match this text:

*Пример*

```java
I have 1 cucumber in my belly
It would also match this text:
```
*Пример*

```java
I have 42 cucumbers in my belly
```

In Regular Expressions, parentheses indicate a capture group, but in Cucumber Expressions they mean optional text.

### 4.2.3. Альтернативный текст (Alternative text)

Sometimes you want to relax your language, to make it flow better. For example:

*Пример*

```java
I have {int} cucumber(s) in my belly/stomach
```

This would match either of those texts:

*Пример*

```java
I have 42 cucumbers in my belly
I have 42 cucumbers in my stomach
```

Alternative text only works when there is no whitespace between the alternative parts.

### 4.2.4. Эскейп последовательности (Escaping)

If you ever need to match () or {} literally, you can escape the opening ( or { with a backslash:
*Пример*

```java
I have {int} \{what} cucumber(s) in my belly \(amazing!)
```

This expression would match the following examples:

*Пример*

```gherkin
I have 1 {what} cucumber in my belly (amazing!)
I have 42 {what} cucumbers in my belly (amazing!)
```

You may have to escape the \ character itself with another \, depending on your programming language. For example, in Java, you have to use escape character \ with another backslash.

*Пример*

```java
I have {int} \\{what} cucumber(s) in my belly \\(amazing!)
```

Then this expression would match the following example:

*Пример*

```gherkin
I have 1 \{what} cucumber in my belly \(amazing!)
I have 42 \{what} cucumbers in my belly \(amazing!)
```

There is currently no way to escape a / character - it will always be interpreted as alternative text.

***

# 5. Передача данных в шаги

Часто возникает ситуация, когда из сценария в метод необходимо передать набор однотипных данных – коллекций.
Для подобной задачи в **Cucumber** есть несколько решений

## 5.1. Данные перечисленные через запятую (ArrayList)

Фреймворк **Cucumber** по умолчанию оборачивает данные, перечисленные через запятую, в **ArrayList**.

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл, Редактировать, О программе
```

```java
@Дано("^в меню доступны пункты (.*)$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

Для замены разделителя, можно воспользоваться аннотацией **@Delimiter**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты Файл и Редактировать и О программе
```

```java
@Дано("^в меню доступны пункты (.+)$")
public void вМенюДоступныПункты(@Delimiter(" и ") List<String> arg) {
    // что-то сделать
}
```

## 5.2. Данные в виде таблицы с одной колонкой (ArrayList)

Данные, записанные в виде таблицы с одной колонкой, **Cucumber** также может обернуть в **ArrayList**:

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          |
| Редактировать |
| О программе   |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<String> arg) {
    // что-то сделать
}
```

## 5.3. Данные в виде таблицы с двумя колонками (Map)

Данные, записанные в таблицу с двумя колонками, **Cucumber** может обернуть в ассоциативный массив,
где данные из первой колонки – это ключ, а из второй – данные

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  |
| Редактировать | false |
| О программе   | true  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(Map<String, Boolean> arg) {
    // что-то сделать
}
```

## 5.4. Таблицы данных (Data Tables)

***Таблицы данных (Data Tables)*** - конструкция для передачи списков данных в методы.

Синтаксис:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

[DataTable](https://github.com/cucumber/cucumber-jvm/tree/main/datatable)

***DataTable*** – класс, который эмулирует табличное представление данных. 

*Пример*

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
    // что-то сделать
}
```

Для доступа к данным в **DataTable* имеется большое количество методов.

### \<K,V\> List\<Map\<K,V\>\> asMaps(Class\<K\> keyType,Class\<V\> valueType)

```java
public <K,V> List<Map<K,V>> asMaps(Class<K> keyType,Class<V> valueType)
```

Конвертирует таблицу в список ассоциативных массивов. 
Первая строка таблицы используется для именования ключей, остальные как значения:

```gherkin
# language: ru
Дано в меню доступны пункты
| Название      | Доступен | Количество подменю |
| Файл          | true     | 5                  |
| Редактировать | false    | 8                  |
| О программе   | true     | 2                  |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<Map<String, String>> table = arg.asMaps(String.class, String.class);
System.out.println(table.get(0).get("Название"));
System.out.println(table.get(1).get("Название"));
System.out.println(table.get(2).get("Название"));
}
```

Данный пример выведет на консоль:

Файл
Редактировать
О программе

### \<T\> List\<List\<T\>\> asLists(Class\<T\> itemType)

```java
public <T> List<List<T>> asLists(Class<T> itemType)
```

Метод преобразует таблицу в список списков:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<List<String>> table = arg.asLists(String.class);
System.out.print(table.get(0).get(0) + " ");
System.out.print(table.get(0).get(1) + " ");
System.out.println(table.get(0).get(2) + " ");

    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

На консоль будет выведено:

Файл true 5
Редактировать false 8

### List\<List\<String\>\> cells(int firstRow)

```java
public List<List<String>> cells(int firstRow)
```

Этот метод делает то же, что и предыдущий метод, за исключением того, 
что нельзя определить какого типа данные находятся в таблице, всегда возвращает список строк – List. 
В качестве аргумента метод принимает номер первой строки:

```gherkin
# language: ru
Дано в меню доступны пункты
| Файл          | true  | 5 |
| Редактировать | false | 8 |
| О программе   | true  | 2 |
```

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(DataTable arg) {
List<List<String>> table = arg.cells(1);
System.out.print(table.get(0).get(0) + " ");
System.out.print(table.get(0).get(1) + " ");
System.out.println(table.get(0).get(2) + " ");

    System.out.print(table.get(1).get(0) + " ");
    System.out.print(table.get(1).get(1) + " ");
    System.out.println(table.get(1).get(2) + " ");
}
```

Метод выведет на консоль:

Редактировать false 8
О программе true 2

### Table Cell Escaping

If you want to use a newline character in a table cell, you can write this as \n. 
If you need a | as part of the cell, you can escape it as \|. 
And finally, if you need a \, you can escape that with \\.

## 5.4. Использование классов

Class
Cucumber может создать объекты из табличных данных, переданных из сценария. Существует два способа это сделать.

Создадим для примера класс Menu:

```java
public class Menu {
private String title;
private boolean isAvailable;
private int subMenuCount;

    public String getTitle() {
        return title;
    }

    public boolean getAvailable() {
        return isAvailable;
    }

    public int getSubMenuCount() {
        return subMenuCount;
    }
}
```

Для первого способа шаг в сценарии запишем в следующем виде:

```gherkin
# language: ru
Дано в меню доступны пункты
| title         | isAvailable | subMenuCount |
| Файл          | true        | 5            |
| Редактировать | false       | 8            |
| О программе   | true        | 2            |
```

Реализация:

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(List<Menu> arg) {
for (int i = 0; i < arg.size(); i++) {
System.out.print(arg.get(i).getTitle() + " ");
System.out.print(Boolean.toString(arg.get(i).getAvailable()) + " ");
System.out.println(Integer.toString(arg.get(i).getSubMenuCount()));
}
}
```

Вывод в консоль:

Файл true 5
Редактировать false 8
О программе true 2

Фреймворк создает связанный список объектов из таблицы с тремя колонками. В первой строке таблицы должны быть указаны наименования полей класса, создаваемого объекта. Если какое-то поле не указать, оно не будет инициализировано.

Для второго способа приведем шаг сценария к следующему виду:

```gherkin
# language: ru
Дано в меню доступны пункты
| title        | Файл | Редактировать | О программе |
| isAvailable  | true | false         | true        |
| subMenuCount | 5    | 8             | 2           |
```

А в аргументе описания шага используем аннотацию @Transpose.

```java
@Дано("^в меню доступны пункты$")
public void вМенюДоступныПункты(@Transpose List<Menu> arg) {
// что-то сделать
}
```

Cucumber, как и в предыдущем примере, создаст связанный список объектов, но, в данном случае, наименования полей записывается в первой колонке таблицы.

## 5.5. докстринг (Doc Strings)

***Докстринг (Doc Strings)*** - текст экранированный тремя двойными кавычками.

Для передачи многострочных данных в аргумент метода, их необходимо экранировать тремя двойными кавычками.

```gherkin
# language: ru
Тогда отображается форма с текстом

"""
На ваш номер телефона был выслан одноразовый пароль.
Для подтверждения платежа необходимо ввести полученный
одноразовый пароль.
"""
```

В реализации шага нет необходимости находить **Докстринг (Doc Strings)** с помощью шаблона.
Он будет автоматически передан в качестве последнего аргумента в определении шага.
Данные в метод приходят в виде объекта класса **String**:

```java
@Тогда("^отображается форма с текстом$")
public void отображаетсяФормаСТекстом(String expectedText) {
// что-то сделать
}
```

***

# 6. Преобразование данных

Фреймворк самостоятельно приводит данные из сценария к типу данных, указанному в аргументе метода. 
Если это невозможно, то выбрасывает исключение ConversionException. 
Это справедливо и для классов Date и Calendar. 

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04.05.2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Все прекрасно сработало, **Cucumber** преобразовал *04.05.2017* 
в объект класса **Date** со значением *Thu May 04 00:00:00 EET 2017*.

*Пример*

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (Date arg) {
// что-то сделать
}
```

Дойдя до этого шага, **Cucumber** выбросил исключение:

```text
cucumber.deps.com.thoughtworks.xstream.converters.ConversionException: Couldn't convert "04-05-2017" to an instance of: [class java.util.Date]

```

Почему первый пример сработал, а второй нет?

Дело в том, что в **Cucumber** встроена поддержка форматов дат чувствительных к текущей локали. 
Если необходимо записать дату в формате, отличающемся от формата текущей локали, нужно использовать аннотацию **Format**:

```gherkin
# language: ru
Дано дата создания документа 04-05-2017
```

```java
@Дано("^дата создания документа (.+)$")
public void датаСозданияДокумента (@Format("dd-MM-yyyy") Date arg) {
// что-то сделать
}
```

***

# 4. Плюсы и минусы

Why Gherkin?
Describe use cases for a software system in one way, easy to read and understand.
Allows business analysts, managers, developers and other third-parties involved to understand the requirements of the project and the life-cycle.
Makes it easy to create simple documentation of the code that’s being written.
Provides scripts for test automation.

Плюсы:

1. Использование естественного языка в свободной форме

Сценарии **Gherkin**, определяющие поведение системы, описываются в простой форме и
могут быть понятны всем участникам проекта (заказчикам, аналитикам, разработчикам, тестировщикам).
Не нужно быть экспертом, чтобы понять небольшой набор команд **Gherkin**.

2. Живая проектная документация

Значительная часть функциональных спецификаций написана в виде пользовательских историй.
Gherkin Testing нацелен на бизнес-требования

3. Эффективный инструмент для тестирования

Разделение тест-кейсов и кода тестов
Файлы, содержащие в себе спецификации, одновременно являются и исполняемыми автотестами.
Тестовая документация и программный код автотестов хранятся в одном проекте и неотделимы друг от друга.
Сценарии тестирования Gherkin напрямую связывают приемочные тесты с автоматизированными тестами
Наличие словаря доступных шагов допускает вариативность сценариев и
позволяет тестировщикам составлять новые автотесты, не обращаясь к программному коду.

Минусы:

1. Обязательное наличие высокой степени деловой активности и сотрудничества
2. Может работать не во всех сценариях
3. Плохо написанные тесты могут легко увеличить расходы на обслуживание тестов

***

# 5. Best practices of using Gherkin

Tips for using Background
Don’t use Background to set up complicated states, unless that state is actually something the client needs to know.
For example, if the user and site names don’t matter to the client, use a higher-level step such as Given I am logged in as a site owner.
Keep your Background section short.
The client needs to actually remember this stuff when reading the scenarios. If the Background is more than 4 lines long, consider moving some of the irrelevant details into higher-level steps.
Make your Background section vivid.
Use colourful names, and try to tell a story. The human brain keeps track of stories much better than it keeps track of names like "User A", "User B", "Site 1", and so on.
Keep your scenarios short, and don’t have too many.
If the Background section has scrolled off the screen, the reader no longer has a full overview of what’s happening. Think about using higher-level steps, or splitting the *.feature file.

Each scenario should execute separately
Every feature should able to be executed along
Steps information should be shown independently
Connect your Scenario’s with your requirements
Keep a complete track of what scenarios should be included in a requirement document
Create modular and easy to understand steps
Try to combine all your common scenarios

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)