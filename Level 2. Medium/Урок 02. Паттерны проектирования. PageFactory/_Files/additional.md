

## 2.4. Объект сущность (Entity)

***Объект Сущность (Entity)*** ⎼ класс в **Java**, который идентифицируется по уникальности значения идентификатора (**эквивалентность идентификаторов**).

![Объект Сущность (Entity))](./_Files/1.%20Patterns/08.jpg "Объект Сущность (Entity)")

***Ссылочная эквивалентность*** - равенство двух объектов в случае, если оба объекта ссылаются на один и тот же объект в куче.

![Ссылочная эквивалентность](./_Files/1.%20Patterns/06.png "Ссылочная эквивалентность")

***Эквивалентность идентификаторов*** - равенство двух объектов в случае, если у обоих объектов идентификаторы эквивалентны.
То есть, если два экземпляра одного класса обладают одинаковыми идентификаторами, то они равны.

![Эквивалентность идентификаторов](./_Files/1.%20Patterns/09.png "Эквивалентность идентификаторов")

### 2.4.1. Структура класса

1. *Класс*

Класс **Объект сущность (Entity)**:

* представляет модели сложных объектов

Объектами класса **Объект сущность (Entity)** могут быть клиент, продукт.

* обладает неотъемлемой идентичностью

То есть идентифицируется по уникальности значения идентификатора (**эквивалентность идентификаторов**),
а не по уникальности значения полей класса (**структурная эквивалентность**)

Два объекта класса **Объект сущность (Entity)** считаются равными, если значения их полей идентификаторов равны.
В то же время, даже если данные в двух объектах полностью одинаковы (за исключением поля идентификатора),
то они не являются одной и той же сущностью.

* является самостоятельной сущностью

Объект класса **Объект сущность (Entity)** может существовать сам по себе.

* обладает продолжительным жизненным циклом

Объекты класса **Объект сущность (Entity)** создаются не ради одноразового использования,
а живут какое-то время во время запуска программы или, что чаще, между запусками в каком-то хранилище (БД).

Объект класса **Объект сущность (Entity)** обладает историей (даже если не храним эту историю) того,
что с ними случилось и как они менялись в течение жизни (записи в БД).

Однако одни и те же вещи могут быть как **объектами-значениями** так и **объектами-сущностями**.
Всё зависит от конкретной предметной области. Для большинства компаний деньги - это действительно просто значения,
но не для тех кто их печатает. Им очень важно различать купюры между собой и поэтому на каждой из них есть уникальный номер,
который и позволяет проводить идентификацию.

2. *Поля класса*

Поля класса **Объект сущность (Entity)**:

* состоят из
    * примитивных типов данных
    * объектов класса **Объект Значение (Value Object (VO))**
    * объектов класса **Объект Сущность (Entity)**
* имеют поле идентификатор
* являются изменяемыми

3. *Методы доступа класса*

3.1. *Сеттеры*

У класса **Объект сущность (Entity)** есть методы установки значений полей класса (сеттеры)

3.2. *Геттеры*

У класса **Объект сущность (Entity)** есть методы получения значений полей класса (геттеры)

4. *Конструктор класса*

*Пример*

```java
class Order {
    ProductsList products;
    String number;

    public Order(String number) {
        this.number = number;
        products = new ArrayList<>();
    }

    public addProduct(Product p){
        products.add(p);
    }

    public boolean equals(Order order) {
        return number == order.number;
    }
}
```

### 2.4.2. Шаги реализации

1. *Создание класса, моделирующего объекты, которые идентифицируется по уникальности значения идентификатора*

2. *Создание закрытых полей класса, представленных примитивными типами данных, объектами-значениями и объектами-сущностями*

3. *Создание общедоступных методов доступа класса*

4. *Создание конструктора класса*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.4.3. Применимость паттерна

1. *Когда есть объекты, равенство которых определяется по значениям идентификаторов*



### 2.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Объект сущность (Entity)**:

* гибкость
* уменьшение дублирования
* повторное использование кода
* простота понимания

Минусы применения паттерна **Объект сущность (Entity)**:

* усложнение кодирования
* увеличение объема кода

### 2.4.5. Применение в автотестах

#### 2.4.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

## 2.5. Объект передачи данных (Data Transfer Object)

***Объект передачи данных (Data Transfer Object)*** - класс, содержащий данные без какой-либо логики для работы с ним.

![Объект передачи данных (Data Transfer Object)](./_Files/1.%20Patterns/10.jpg "Объект передачи данных (Data Transfer Object)")

### 2.5.1. Структура класса

1. *Класс*

Класс **Объект передачи данных (Data Transfer Object)**:

* должен быть общедоступным
* может содержать механизмы сериализации и десериализации
* может содержать статические классы
* может расширять другие классы **Объект передачи данных (Data Transfer Object)**
* не должен содержать переменных обобщенного типа

2. *Поля класса*

Поля класса **Объект передачи данных (Data Transfer Object)**:

* уровень доступа - *private*
* представлены легко сериализуемыми типами

Типы, которые могут использоваться в классе **Объект передачи данных (Data Transfer Object)**:

* примитивные типы данных
* обертки вокруг примитивных типов данных
* строковый тип данных String
* перечисления enum
* другие классы **Объект передачи данных (Data Transfer Object)**
* списки **List**
* множества **Set**
* словари **Map**
* массивы **Array**

При этом списки, множества, словари и массивы должны содержать только объекты выше перечисленных типов.

Граф объектов **Объект передачи данных (Data Transfer Object)** должен быть деревом (т. е. не иметь циклов),
чтобы упростить сериализацию и десериализацию.

3. *Методы доступа класса*

3.1. *Сеттеры*

У класса **Объект передачи данных (Data Transfer Object)** есть методы установки значений полей класса (сеттеры)

3.2. *Геттеры*

У класса **Объект передачи данных (Data Transfer Object)** есть методы получения значений полей класса (геттеры)

4. *Конструктор класс*

У класса паттерна **Объект передачи данных (Data Transfer Object)** должен быть конструктор без аргументов (конструктор по умолчанию).

*Пример*

```java
public class Employee implements Serializable{
    private long mEmployeeId;
    private String mEmployeeName;
    
    public void setEmployeeId(long pEmployeeId) {
        this.mEmployeeId = pEmployeeId;
    }
    
    public long getEmployeeId() {
        return this.mEmployeeId;
    }
    
    public void setEmployeeName(String pEmployeeName) {
        this.mEmployeeName = pEmployeeName;
    }
    
    public String getEmployeeName() {
        return this.mEmployeeName;
    }
}
```

### 2.5.2. Шаги реализации

1. *Создание класса, который реализует интерфейс java.io.Serializable*

2. *Создание закрытых полей класса*

3. *Создание общедоступных методов доступа класса*

4. *Создание конструктора класса без аргументов*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.5.3. Применимость

1. *Когда необходимо передавать данные нескольких объектов*

2. *Когда необходимо передавать много параметров за раз*

**Объект передачи данных (Data Transfer Object)** обычно используются для передачи данных между различными приложениями,
либо между слоями внутри одного приложения. Их можно рассматривать как хранилище информации,
единственная цель которого — передать эту информацию получателю.

### 2.5.4. Плюсы и минусы применения

Плюсы применения паттерна **Объект передачи данных (Data Transfer Object)**:

* уменьшение дублирования кода

Минусы применения паттерна **Объект передачи данных (Data Transfer Object)**:

* дополнительные классы

### 2.5.5. Применение в автотестах

#### 2.5.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```


## 3.2. Паттерн Фабричный метод (Factory Method)

***Фабричный метод (Factory Method)*** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![Паттерн Фабричный метод (Factory Method)](./_Files/1.%20Patterns/14.jpg "Паттерн Фабричный метод (Factory Method)")

Паттерн **Фабричный метод (Factory Method)** предлагает создавать объекты не напрямую, используя оператор new,
а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new,
но делать это будет фабричный метод.

### 3.2.1. Структура паттерна

![Структура паттерна Фабричный метод (Factory Method)](./_Files/1.%20Patterns/15.jpg "Паттерн Фабричный метод (Factory Method)")

1. *Базовый продукт (Product)*

***Базовый продукт (Product)*** - общий интерфейс для всех объектов, которые могут произвести создатели.

2. *Конкретный продукт (ConcreteProduct)*

***Конкретный продукт (ConcreteProduct)*** - конкретный класс, реализующий **Базовый продукт (Product)**.

Продукты будут отличаться реализацией, но интерфейс у них будет общий.

3. *Базовый создатель (Creator)*

***Базовый создатель (Creator)*** - общий интерфейс / абстрактный класс, который создает конкретные продукты.

Создание продуктов не является единственной функцией создателя. Обычно он содержит и другой полезный код работы с продуктом.

4. *Конкретный создатель (Concrete Creator)*

***Конкретный создатель (Concrete Creator)*** - класс, создающий конкретный объект.

Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.

### 3.2.2. Шаги реализации паттерна

1. *Создание Базового продукта*

Базовый продукт описывает общие методы для всех конкретных продуктов.

2. *Создание Конкретного продукта*

Конкретный продукт содержит логику в переопределенных общих методах.

3. *Создание Базового создателя*

Базовый создатель содержит фабричный метод для создания продукта.
Фабричный метод возвращает Базовый продукт.

4. *Создание Конкретного создателя*

Конкретный создатель переопределяет фабричный метод для создания Конкретных продуктов.

### 3.2.3. Применимость паттерна

1. *Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код*

Применение паттерна **Фабричный метод (Factory Method)** отделяет код производства продуктов от остального кода,
который эти продукты использует. Благодаря этому, код производства можно расширять, не трогая основной.
Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и
определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

2. *Когда необходимо дать возможность пользователям расширять части вашего фреймворка или библиотеки*

Применение паттерна **Фабричный метод (Factory Method)** дает возможность расширять не только желаемые компоненты,
но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы,
которые можно определить.

3. *Когда необходимо экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.*

Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими,
как подключение к базе данных, файловой системе и т. д.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов.
Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.
Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты.
Им и станет **Фабричный метод (Factory Method)**.

### 3.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Фабричный метод (Factory Method)**:

* избавление класса от привязки к конкретным классам продуктов
* выделение кода производства продуктов в одно место, упрощая поддержку кода
* упрощение добавление новых продуктов в программу
* реализация принципа открытости/закрытости

Минусы применения паттерна **Фабричный метод (Factory Method)**:

* может привести к созданию больших параллельных иерархий классов,
  так как для каждого класса продукта надо создать свой подкласс создателя.

### 3.2.5. Применение паттерна в автотестах

#### 3.2.5.1. Фабрика драйверов (WebDriverFactory)

##### До применения паттерна

##### После применения паттерна


## 3.4. Паттерн Одиночка (Singleton)

***Одиночка (Singleton)*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

![Паттерн Одиночка (Singleton)](./_Files/1.%20Patterns/02.jpg "Паттерн Одиночка (Singleton)")

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод,
который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

### 3.4.1. Структура паттерна

![Структура паттерна Одиночка (Singleton)](./_Files/1.%20Patterns/03.jpg "Паттерн Одиночка (Singleton)")

1. *Одиночка (Singleton)*

***Одиночка (Singleton)*** - класс определяющий статический метод **getInstance**,
который возвращает единственный экземпляр своего класса.

Конструктор **Одиночки (Singleton)** должен быть скрыт от клиентов.
Вызов метода **getInstance** должен стать единственным способом получить объект этого класса.

### 3.4.2. Шаги реализации паттерна

1. **

2. **

3. **

### 3.4.3. Применимость паттерна

1. *В программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам*

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода.
Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

2. *Больше контроля над глобальными переменными*

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса,
поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек,
поменяв код в одном месте (метод **getInstance**).

### 3.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Одиночка (Singleton)**:

* гарантия наличие единственного экземпляра класса
* предоставление к единственному экземпляру класса глобальной точки доступа
* реализация отложенной инициализацию объекта-одиночки

Минусы применения паттерна **Одиночка (Singleton)**:

* нарушение принципа единственной ответственности класса
* маскирование плохого дизайна
* проблемы многопоточности
* требование постоянного создания Mock-объектов при юнит-тестировании.

### 3.4.5. Применение паттерна в автотестах

#### 3.4.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja

## 4.1. Паттерн Декоратор (Decorator)

***Декоратор (Decorator)*** - паттерн, который позволяет динамически добавлять объектам новую функциональность.
Декораторы предоставляют гибкую альтернативу подклассам для расширения функциональности.

Паттерн **Декоратор (Decorator)** имеет альтернативное название — **Обёртка**.
Оно более точно описывает суть паттерна: целевой объект-оригинал помещается в другой объект-обёртку,
который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы,
с каким объектом работать — оригиналом или обёрткой.
Вы можете использовать несколько разных обёрток одновременно —
результат будет иметь объединённое поведение всех обёрток сразу.

Пример использования паттерна в библиотеке **Selenium** - **EventFiringDecorator** и **FieldDecorator**.

![Паттерн Декоратор (Decorator)](./_Files/1.%20Patterns/11.jpg "Паттерн Декоратор (Decorator)")

### 4.1.1. Структура паттерна

![Структура паттерна  Декоратор (Decorator)](./_Files/1.%20Patterns/12.jpg "Паттерн Декоратор (Decorator)")

1. *Базовый компонент (Component)*

***Базовый компонент (Component)*** – общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных компонентов (ConcreteComponent)** и **Базового декоратора (Decorator)**.

2. *Конкретный компонент (ConcreteComponent)*

***Конкретный компонент (ConcreteComponent)*** – конкретный класс со своей бизнес логикой, реализующий **Базовый компонент (Component)**,
функциональность которого необходимо модифицировать декораторами.

Декоратор способен работать как с самим исходным компонентом, так и его наследниками.
Однако, не следует использовать большое количество декораторов с тяжеловесными классами,
так как это может повлечь за собой большие накладные расходы.

3. *Базовый декоратор (Decorator)*

***Базовый декоратор (Decorator)*** – базовый класс для всех декораторов, реализующий **Базовый компонент (Component)** и
хранящий ссылку на экземпляр **Конкретного компонента (ConcreteComponent)**.

**Базовый декоратор (Decorator)** реализует тот же самый интерфейс чтобы:

* замещать конкретный компонент
* создавать цепочку декораторов

4. *Конкретный декоратор (ConcreteDecorator)*

***Конкретный декоратор (ConcreteDecorator)*** - конкретный класс, наследующий **Базовый декоратор (Decorator)** и
добавляющий определенные функции компоненту.

Добавление новой функциональности осуществляется подменой экземпляра оригинального компонента.
Такой объект может использоваться как вместо декорируемого компонента, так и самостоятельно.

**Конкретный декоратор (ConcreteDecorator)**:

* создает механизм подключения и хранения компонента
* реализует переадресацию всех методов и свойств
* добавляет новые свойства и методы

### 4.1.2. Шаги реализации паттерна

1. *Проверка наличия в задаче одного основного компонента и нескольких дополнительных опциональных дополнений или надстроек над ним*

2. *Создание Базового компонента*

Базовый компонент описывает общие методы как для основного компонента, так и для его дополнений.

3. *Создание Конкретного компонента*

Конкретный компонент содержит основную бизнес-логику.

4. *Создание Базового декоратора*

Базовый декоратор имеет поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора делегируют действие вложенному объекту.

5. *Создание Конкретных декораторов*

Конкретный декоратор выполняет свою добавочную функцию,
а затем (или перед этим) вызывает эту же операцию обёрнутого объекта.

### 4.1.3. Применимость паттерна

1. *Реализация множественного наследования*

В таких языках как **Java** и **C#** нет множественного наследования классов.
И когда требуется реализовать множество различных функциональностей и их комбинаций,
то для каждой такой функциональности и их комбинаций придется наследовать отдельный класс.
Структура классов при этом может очень сильно разрастись, что в свою очередь усложнит ее понимание и поддержку.

Применение паттерна **Декоратор (Decorator)** позволяет реализовать аналог множественного наследования, в языках его не поддерживающих,
путем вложения одного декоратора в другой и создания из них цепочек, поскольку паттерн реализует интерфейс исходного компонента.
Таким образом у объектов расширяются возможности без использования одиночного наследования.
Что в свою очередь разрешает проблему усложнения структуры классов путем уменьшения числа создаваемых классов
по сравнению с результатами использования одиночного наследования.

2. *Невозможность расширить обязанности объекта с помощью наследования*

Во многих языках программирования есть ключевое слово, с помощью которого можно заблокировать наследование класса.

Применение паттерна **Декоратор (Decorator)** позволяет добавить функциональность классу,
определение которого может быть скрыто или иным образом недоступно для подклассов, то есть когда наследование невозможно.

3. *Динамическое добавление новых возможностей на лету, незаметно для кода, который их использует*

Применение паттерна **Декоратор (Decorator)** обеспечивает динамическое добавление объекту новых функциональных возможностей.
Объекты помещаются в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс,
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

Позволяет комбинировать классы в процессе выполнения программы. дважды применить один и тот же Декоратор.

### 4.1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Декоратор (Decorator)**:

* большая гибкость, чем у наследования
* добавление обязанности на лету
* добавление нескольких новых обязанностей сразу
* изменение функциональности не только применением самих Декораторов, но и различным порядком их вложенности

Минусы применения паттерна **Декоратор (Decorator)**:

* трудность конфигурирования многократно обёрнутых объектов
* обилие крошечных классов
* несколько мелких объектов вместо одного объекта на все случаи жизни

### 4.1.5. Применение паттерна в автотестах

#### 4.1.5.1. Декоратор драйвера

##### До применения паттерна

Страница (Page Objects)

*Пример*

```java

```

Интерфейс **WebElement** не всегда удобно использовать.
Его невозможно расширить и добавить свои методы для работы с элементом.
Использовать свои методы можно только создавая классы-обвертки(CheckBox, Button и т.п.),
которые просто делегируют вызов методов настоящему **WebElement**.

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

#### 4.1.5.2. Декоратор тестовых данных

##### До применения паттерна



##### После применения паттерна



## 4.2. Паттерн Заместитель (Proxy)

***Заместитель (Proxy)*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заместители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Паттерн **Заместитель (Proxy)** предлагает создать новый объект-заместитель, имеющий тот же интерфейс, что и оригинальный объект.
Ни интерфейс ни функциональность замещенного объекта, с точки зрения клиента, не изменяются.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр оригинального объекта и
переадресовывал бы ему всю реальную работу.

![Паттерн Заместитель (Proxy)](./_Files/1.%20Patterns/13.jpg "Паттерн Заместитель (Proxy)")

### 4.2.1. Структура паттерна

![Структура паттерна Заместитель (Proxy)](./_Files/1.%20Patterns/14.jpg "Структура паттерна Заместитель (Proxy)")

1. *Базовый объект (Subject)*

***Базовый объект (Subject)*** – общий интерфейс / абстрактный класс для всех замещаемых объектов и заместителей.

Конкретная реализация скрыта от **Заместителя (Proxy)** и он может работать практически со всеми **Реальными объектами (RealSubject)**,
поддерживающими данный интерфейс.

2. *Реальный объект (RealSubject)*

***Реальный объект (RealSubject)*** – конкретный класс с полезной бизнес логикой, реализующий **Базовый объект (Subject)**,
который будет замещен **Заместителем**.

3. *Заместитель (Proxy)*

***Заместитель (Proxy)*** - класс, реализующий **Базовый объект (Subject)**, который замещает **Конкретный объект (RealSubject)** и перехватывает обращения к нему.

**Заместитель (Proxy)** :

* выполняет дополнительные действия (инициализацию, логирование и т д.) до или после вызова вложенного в него **Конкретного объекта (RealSubject)**
* отвечает за создание и удаление **Конкретного объекта (RealSubject)**.

Паттерн не накладывает ограничения на вложения одного заместителя в другой.
Такой подход позволяет строить их различные конфигурации в процессе работы программы.

### 4.2.2. Шаги реализации паттерна

1. *Определение интерфейса, который бы сделал заместитель и оригинальный объект взаимозаменяемыми*

2. *Создание Заместителя*

Заместитель должен содержать ссылку на оригинальный объект. Чаще всего, оригинальный объект создаётся самим заместителем.
В редких случаях заместитель получает готовый оригинальный объект от клиента через конструктор.

3. *Реализация методов Заместителя в зависимости от его предназначения*

В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос оригинальному объекту.

4. *Создание Фабрики*

Фабрика будет решать, какой из объектов создавать — заместитель или оригинальный объект.

5 *Реализация ленивой инициализации оригинального объекта*

При первом обращении клиента к методам заместителя.

### 4.2.3. Применимость паттерна

1. *Ленивая инициализация (Виртуальный Прокси (Virtual Proxy))*

Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда,
когда он действительно понадобится.

2. *Защита доступа (Защищающий Прокси (Protection Proxy))*

Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа.
Например, если ваши объекты — это важная часть операционной системы,
а пользователи — сторонние программы (хорошие или вредоносные).

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. *Локальный запуск сервиса (Удаленный Прокси (Remote Proxy))*

Когда настоящий сервисный объект находится на удалённом сервере.
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. *Логирование запросов (Логирующий Прокси (Logging Proxy))*

Когда требуется хранить историю обращений к сервисному объекту.
Заместитель может сохранять историю обращения клиента к сервисному объекту.

5. *Кеширование объектов (Умная Ссылка (Smart Reference))*

Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.
Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными.
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект.
Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

### 4.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Заместитель (Proxy)**:

* контроль оригинального объекта незаметно для клиента
* возможность работы, даже если оригинальный объект ещё не создан
* возможность контроля жизненного цикла служебного объекта

Минусы применения паттерна **Заместитель (Proxy)**:

* усложнение кода программы из-за введения дополнительных классов
* увеличение времени отклика от сервиса

### 4.2.5. Применение паттерна в автотестах

#### 4.2.5.1. Создание заместителя для WebDriver в UI автотестах Selenium WebDriver

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

#### 4.2.5.2.



## 5.2. Паттерн Стратегия (Strategy)

### 5.2.1. Структура паттерна

### 5.2.2. Шаги реализации паттерна

1. **

2. **

3. **

### 5.2.3. Применимость паттерна

1. **

2. **

3. **

### 5.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Стратегия (Strategy)**:

Шаблон стратегии используется всякий раз, когда мы хотим иметь более одной реализации одного и того же действия / последовательности действий,
что делается иначе. В зависимости от контекста мы могли выбрать реализацию.

Самый простой пример - регистрация пользователя. Возможно, вы захотите иметь две разные реализации этого конкретного действия.
Первый - это фактический поток переходов по страницам для успешной регистрации пользователя.
Другой - короткий вызов API, который вызывается, когда для теста нужен новый пользователь.

Возможно, вы не захотите вызывать «долгую» регистрацию каждый раз в своих тестах.
Но иногда он может понадобиться, например, когда вы подтверждаете фактическую регистрацию через Интернет.
И наоборот, мы хотим, чтобы создание новых пользователей для тестирования было быстрым и надежным. Поэтому здесь подойдет REST-регистрация.

Стратегия помогает сделать нашу среду автоматизации тестирования более гибкой и простой в обслуживании за счет разделения концепций.
Опять же, вам нужно быть осторожным и не применять его в ситуациях, когда вы можете обойтись без него.

Минусы применения паттерна **Стратегия (Strategy)**:

### 5.2.5. Применение паттерна в автотестах

#### 5.2.5.1.

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна


*Пример*

```java

```

*Пример*

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

# 5. Паттерны данных

***Паттерны данных*** - паттерны, которые разделяют данные и логику тестирования.

а также уменьшить дублирование кода в тестах.
Это должно сделать их более понятными и простыми в обслуживании для всех, кто с ними работает.

## 5.1. Паттерн Data Registry

***Data Registry*** - паттерн,

### 5.1.1. Проблемы, которые решает паттерн

### 5.1.2. До применения паттерна

*Пример*

```java

```

### 5.1.3. После применения паттерна

Интересен следующий паттерн. Основной подход заключается в следующем: мы хотим, чтобы наши тесты были независимыми и
попробуем разделить наши тестовые данные по ним, но в результате мы получим полную противоположность.
Например, в тесте A используются user1, user2 и user3, и они жестко запрограммированы как тестовые данные.
Это может быть проблемой, поскольку нам нужны полностью независимые тесты, верно?
Но мы заставляем другой тест знать, что user1, user2 и user3 уже заняты тестом A.
Другая проблема заключается в том, что разработчик, не знакомый с этим, может использовать этих пользователей в других тестах, и это может вызвать проблемы.

Реестр данных позволяет нам генерировать уникальные данные и избегать дублирования.
В приведенном ниже примере я использую самый простой из возможных подходов:
при каждом вызове getUser статический потокобезопасный счетчик будет увеличиваться на 1,
гарантируя, что каждый раз создается уникальный пользователь.

*Пример*

```java
public static class UserRegistry {
    private static AtomicInteger COUNTER = new AtomicInteger(0);
    
    public static getUser() {
        int index = COUNTER.incrementAndGet();
        return new User("User_" + index, index);
    }
}

```

В вашем случае логика шаблона может быть намного сложнее, например. реестр может брать пользователя из базы данных, файла, предопределенного набора данных и т. д.
Но результат будет таким же: ваши тесты будут по-настоящему независимыми, поскольку каждый раз, когда они используют UserRegistry, они получают эксклюзивного пользователя, избегая проблем с перехватом тестов.

## 5.2. Паттерн Data Provider

***Data Provider*** - паттерн,

### 5.2.1. Проблемы, которые решает паттерн

### 5.2.2. До применения паттерна

*Пример*

```java

```

### 5.2.3. После применения паттерна

Поставщик данных - один из наиболее широко используемых шаблонов данных среди инженеров-тестировщиков.
Если вы хотите реализовать тесты на основе данных и хотите запустить одну и
ту же логику тестирования для нескольких наборов данных,
вы можете загружать данные из внешних источников (таких как Excel или таблица CVS),
удаленных служб или жестко закодировать их на месте.

*Пример*

```java
@DataProvider
private static Object[][] testDataProvider() {
    try {
        return ReadExcelSheet.getTableArray("src/main/resources/TestData.xls");
    } catch (Exception e) {
        return null;
    }
}
```

Это можно сделать так, как я показал выше,
путем чтения из источника и возврата нетипизированных данных (простой массив массивов или строк).
Но современный подход заключался бы в использовании шаблона Value Object,
о котором мы говорили ранее, и предоставлении данных в терминах сущностей.

*Пример*

```java
@DataProvider
private static Iterator<Object[]> devices() {
    return asList(
        new Object[] { new Device("iPhone X", Platform.IOS, "11.2") },
        new Object[] { new Device("iPhone 7 Plus", Platform.IOS, "10.3") },
        new Object[] { new Device("Google Pixel 2", Platform.ANDROID, "8.0") }  
    ).iterator();
}

@Test(dataProvider = "devices")
public void pageShouldBeOpenedOnDevice(Device device) {
    startDevice(device);
    // some test steps
}
```

Вам нужно пометить свой метод аннотацией dataProvider или сделать его параметризованным с помощью JUnit и
заставить его возвращать набор данных для использования в тесте. Остальное (синтаксический анализ и итерация)
будет выполняться фреймворком, все, что вам нужно сделать, - это использовать данные, как в обычном тесте.

Важно, чтобы мы использовали оба шаблона (поставщик данных и объект значения) в одном подходе,
поскольку это помогло нам избежать передачи нескольких параметров методу и сделать код более чистым и читаемым.

Мне нравится использовать шаблоны данных в своей автоматизации,
они помогают мне поддерживать работоспособность кода и максимально оптимизировать управление ресурсами.
Если вас интересуют другие шаблоны, которые могут помочь вам в написании чистых и надежных тестов,
ознакомьтесь с другими моими сообщениями:

https://www.devbridge.com/articles/top-design-pattern-test-automation-frameworks/
https://antony-s-smirnov.medium.com/how-to-use-the-data-provider-pattern-in-the-project-ea12430d9275


## 3.5. Паттерн Абстрактная фабрика (Abstract Factory)

***Абстрактная фабрика (Abstract Factory)*** — паттерн, который позволяет создавать семейства связанных объектов,
не привязываясь к конкретным классам создаваемых объектов.

![Паттерн Абстрактная фабрика (Abstract Factory)](./_Files/1.%20Patterns/16.jpg "Паттерн Абстрактная фабрика (Abstract Factory)")

Паттерн **Абстрактная фабрика (Abstract Factory)** предлагает выделить общие интерфейсы для отдельных продуктов,
составляющих семейства.

общий интерфейс, который содержит методы создания всех продуктов семейства (например,

Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику, реализовав абстрактный интерфейс.
Фабрики создают продукты одной вариации.

### 3.5.1. Структура паттерна

![Структура паттерна Абстрактная фабрика (Abstract Factory)](./_Files/1.%20Patterns/03.jpg "Паттерн Абстрактная фабрика (Abstract Factory)")

1. **

2. **

3. **

### 3.5.2. Шаги реализации паттерна

1. **

2. **

3. **

### 3.5.3. Применимость паттерна

1. **

2. **

3. **

### 3.5.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна ****:

1. **

Минусы применения паттерна ****:

1. **

### 3.5.5. Применение паттерна в автотестах

#### 3.5.5.1.

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```
http://design-pattern.ru/patterns/abstract-factory.html
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b0%d0%b1%d1%81%d1%82%d1%80%d0%b0%d0%ba%d1%82%d0%bd%d0%b0%d1%8f-%d1%84%d0%b0%d0%b1%d1%80%d0%b8%d0%ba%d0%b0/
