Java_QA / Level 2. Medium - Продвинутые темы / Урок 02. Паттерны проектирования. PageFactory

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Паттерны проектирования GOF

***Шаблон проектирования или паттерн*** в разработке программного обеспечения —
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

## 1.1. История

В **1970-е** годы архитектор **Кристофер Александр** составил набор шаблонов проектирования. 
В области архитектуры эта идея не получила такого развития, как позже в области программной разработки.

В **1987** году **Кент Бэк (Kent Beck)** и **Вард Каннингем (Ward Cunningham)** взяли идеи Александра и 
разработали шаблоны применительно к разработке программного обеспечения для разработки графических оболочек на языке **Smalltalk**.

В **1988** году **Эрих Гамма (Erich Gamma)** начал писать докторскую диссертацию при цюрихском университете 
об общей переносимости этой методики на разработку программ.

В **1989—1991** годах **Джеймс Коплин (James Coplien)** трудился над разработкой идиом для программирования 
на **C++** и опубликовал в **1991** году книгу **Advanced C++ Idioms**.

В этом же году **Эрих Гамма** заканчивает свою докторскую диссертацию и переезжает в США, 
где в сотрудничестве с **Ричардом Хелмом (Richard Helm)**, **Ральфом Джонсоном (Ralph Johnson)** и **Джоном Влиссидесом (John Vlissides)** 
публикует книгу **Design Patterns — Elements of Reusable Object-Oriented Software**. 
В этой книге описаны **23 шаблона проектирования**. 
Также команда авторов этой книги известна общественности под названием **Банда четырёх» (Gang of Four, часто сокращается до GoF)**. 
Именно эта книга стала причиной роста популярности шаблонов проектирования.

## 1.2. 23 паттерна проектирования GOF

![23 паттерна проектирования GOF](./_Files/1.%20Patterns/01.png "23 паттерна проектирования GOF")

**23 паттерна проектирования**:

* *Порождающие*

1. **Одиночка (Singleton)**
2. **Фабричный метод (Factory Method)**
3. *Абстрактная фабрика (Abstract Factory)*
4. **Строитель (Builder)**
5. *Прототип (Prototype)*

* *Структурные*

6. **Декоратор (Decorator)**
7. **Заместитель (Proxy)**
8. **Фасад (Facade)**
9. **Приспособленец (Flyweight)**
10. *Адаптер (Adapter)*
11. *Мост (Bridge)*
12. *Компоновщик (Composite)*

* *Поведенческие*

13. **Цепочка обязанностей (Chain of responsibility)**
14. *Команда (Command)*
15. *Интерпретатор (Interpreter)*
16. *Итератор (Iterator)*
17. *Посредник (Mediator)*
18. *Хранитель (Memento)*
19. *Наблюдатель (Observer)*
20. *Состояние (State)*
21. *Стратегия (Strategy)*
22. *Шаблонный метод (Template method)*
23. *Посетитель (Visitor)*

***

# 2. Простые классы

**Java** — объектно-ориентированный язык, а значит, программы состоят из объектов и классов.
Если в коде программы на объектно-ориентированном языке нужно отразить сущность каких-то объектов, 
используется понятие класса.

**Класс** — шаблонная конструкция, которая позволяет описать в программе объект, 
его свойства (атрибуты или поля класса) и поведение (методы класса).

Объекты нужны для того, чтобы хранить информацию в удобном для нас виде.
Т.е. когда у себя в коде мы представляем данные в виде объектов реального мира.

![Простые классы](./_Files/1.%20Patterns/02.jpg "Простые классы")

Существуют следующие понятия:

* Простой Java Объект (Plain Old Java Object (POJO))
* Java Боб (JavaBean)
* Объект Значение (Value Object (VO))
* Объект сущность (Entity)
* Объект передачи данных (Data Transfer Object)

## 2.1. Паттерн Простой Java Объект (Plain Old Java Object (POJO))

***Простой Java Объект (Plain Old Java Object (POJO))*** - простой **Java** класс без ссылок на какие-либо 
конкретные фреймворки, не унаследованный от какого-то класса и не реализующий никаких интерфейсов сверх тех, 
которые нужны для бизнес-модели.

То есть это такой класс, который не связан какими-либо особыми ограничениями, кроме тех, что налагаются спецификацией **Java**.

![Паттерн Простой Java Объект (Plain Old Java Object (POJO))](./_Files/1.%20Patterns/03.jpg "Паттерн Простой Java Объект (Plain Old Java Object (POJO))")

Понятие **Простой Java Объект (Plain Old Java Object (POJO))** означает использование настолько простых классов 
насколько возможно для моделирования предметной области. 
Этот класс может использоваться в любом коде на **Java**, поскольку он не привязан к какой-либо структуре.

### 2.1.1. Структура паттерна

Структура паттерна:

1. *Класс*

Класс паттерна **Простой Java Объект (Plain Old Java Object (POJO))**:

* НЕ должен расширять заранее заданные классы

Открытый класс, который расширяет **javax.servlet.http.HttpServlet** 
не является **Простым Java Объектом (Plain Old Java Object (POJO))**.

* НЕ должен реализовывать заранее заданные интерфейсы

Открытый класс, который реализует **javax.ejb.EntityBean** 
не является **Простым Java Объектом (Plain Old Java Object (POJO))**.

* НЕ должен содержать предварительно определенные аннотации

Открытый класс, который содержит аннотацию **@javax.persistence.Entity** 
не является **Простым Java Объектом (Plain Old Java Object (POJO))**.

2. *Поля класса*
   
Поля класса паттерна **Простой Java Объект (Plain Old Java Object (POJO))** могут иметь любые уровни доступа:

* **public** - общедоступные
* **private** - закрытые
* **default** - по умолчанию
* **protected** - защищенные

У паттерна **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для полей класса.

3. *Методы доступа класса*

Методы доступа класса паттерна **Простой Java Объект (Plain Old Java Object (POJO))** могут иметь любые уровни доступа:

* **public** - общедоступные
* **private** - закрытые
* **default** - по умолчанию
* **protected** - защищенные

3.1. *Сеттеры*

У паттерна **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для сеттеров.

3.2. *Геттеры*

У паттерна **Простой Java Объект (Plain Old Java Object (POJO))** нет соглашения об именовании для геттеров.

4. *Конструктор класса*

В класс **Простой Java Объект (Plain Old Java Object (POJO))** нет необходимости добавлять специальный конструктор.
Есть конструктор по умолчанию.

5. *Переопределенные методы equals(), hashCode() и toString()*

Переопределение этих методов поможет при использовании класса **Простой Java Объект (Plain Old Java Object (POJO))** 
с различными классами коллекций **Java**.

*Пример*

```java
// Класс, который не расширяет классы, не реализует интерфейсы, не содержит аннотации  
public class EmployeePojo {
    // Поля класса с разными уровнями доступа
    public String firstName;
    public String lastName;
    private LocalDate startDate;

    // Конструктор класса с параметрами
    public EmployeePojo(String firstName, String lastName, LocalDate startDate) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.startDate = startDate;
    }

    // Методы класса
    public String name() {
        return this.firstName + " " + this.lastName;
    }

    public LocalDate getStart() {
        return this.startDate;
    }
}
```

### 2.1.2. Шаги реализации паттерна

1. *Создание класса, который не наследуется от какого-либо класса и не реализует какого-либо интерфейса*

2. *Создание полей класса*

3. *Создание методов доступа класса*

4. *Создание конструктора класса*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.1.3. Применимость паттерна

1. *Когда нет необходимости накладывать ограничения на поля класса*
  
Применение паттерна **Простой Java Объект (Plain Old Java Object (POJO))**
не налагает каких либо ограничений на поля, и может дать полный доступ к ним.

### 2.1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Простой Java Объект (Plain Old Java Object (POJO))**:

* повышение читабельности
* возможность повторного использования
* упрощенное тестирование

Минусы применения паттерна **Простой Java Объект (Plain Old Java Object (POJO))**:

* отсутствие соглашения об именовании

Из-за отсутствия соглашений об именовании классы паттерна **Простой Java Объект (Plain Old Java Object (POJO))**: 

* могут быть трудными для понимания другими программистами
* могут работать некорректно при анализе с использованием **Reflection API**

### 2.1.5. Применение паттерна в автотестах

#### 2.1.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

## 2.2. Паттерн Java Боб (JavaBean)

***Java Боб (JavaBean)*** - класс в **Java**, особый тип **Простого Java Объекта (Plain Old Java Object (POJO))** со строгим набором соглашений.

![Паттерн Java Боб (JavaBean)](./_Files/1.%20Patterns/04.jpg "Паттерн Java Боб (JavaBean)")

Все классы **Java Боб (JavaBean)** являются классами **Простого Java Объекта (Plain Old Java Object (POJO))**, 
но не все классы **Простого Java Объекта (Plain Old Java Object (POJO))** можно назвать классами **Java Боб (JavaBean)**.

Чтобы исправить некоторые проблемы классов POJO, классы Java Bean должны следовать некоторым стандартным правилам и соглашениям.

### 2.2.1. Структура паттерна

Структура паттерна:

1. *Класс*

Класс паттерна **Java Боб (JavaBean)** должен быть сериализуемыми (то есть реализовывать интерфейс **java.io.Serializable**).
Реализация интерфейса **java.io.Serializable** позволяет хранить состояние в виде **JSON** или **XML** объектов.

2. *Поля класса*

Поля класса паттерна **Java Боб (JavaBean)** должны иметь уровни доступа **private** (закрытые).

3. *Методы доступа класса*

Методы доступа класса паттерна **Java Боб (JavaBean)** должны иметь уровни доступа **public** (общедоступные).
Геттеры и сеттеры обеспечивают ограничение неконтролируемого доступа к полям класса.

3.1. *Сеттеры*

Соглашения:

* имена методов - *setX* (X - имя поля класса)
* уровень доступа - *public*
* тип возврата - *void*
* метод должен принимать параметр

3.2. *Геттеры*

Соглашения:

* имена методов 
  * в случае не логического возвращаемого значения - *getX* (X - имя поля класса) 
  * в случае логического возвращаемого значения - *isX* (X - имя поля класса) 
* уровень доступа - *public*
* тип возврата - любой, но не *void*
* метод 
  * в случае простого поля - не должен принимать параметр 
  * в случае поля коллекции - может принимать параметр индекс 

4. *Конструктор класса*

У класса паттерна **Java Боб (JavaBean)** должен быть конструктор без аргументов (конструктор по умолчанию).
Конструктор по умолчанию нужен для того, чтобы экземпляр класса можно было создать без предоставления аргументов.
Например, во время десериализации **JSON** объекта.

5. *Переопределенные методы equals(), hashCode() и toString()*

*Пример*

```java
// Класс, который реализует интерфейс Serializable
public class EmployeeBean implements Serializable {
    // Поля класса с уровнями доступа private
    private static final long serialVersionUID = -3760445487636086034L;
    private String firstName;
    private String lastName;
    private LocalDate startDate;

    // Конструктор класса без параметров
    public EmployeeBean() {
    }
    
    // Конструктор класса с параметрами
    public EmployeeBean(String firstName, String lastName, LocalDate startDate) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.startDate = startDate;
    }

    // Методы класса
    // Геттер 
    public String getFirstName() {
        return firstName;
    }
    
    // Сеттер
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}
```

### 2.2.2. Шаги реализации паттерна

1. *Создание класса, который реализует интерфейс java.io.Serializable*

2. *Создание закрытых полей класса*

3. *Создание общедоступных методов доступа класса*

4. *Создание конструктора класса без аргументов*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.2.3. Применимость паттерна

1. *Когда необходимо наличие стандартизированного класса*

Для работы некоторых библиотек (сериализации, рефлексии) нужны классы отвечающие требованиям **Java Боб (JavaBean)**.

### 2.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Java Боб (JavaBean)**:

* наличие соглашений по именованию, устраняющее минусы **Простого Java Объекта (Plain Old Java Object (POJO))**

Минусы применения паттерна **Java Боб (JavaBean)**:

* обязательное наличие сеттеров и геттеров, даже если этого не требуется 
* все поля класса изменяемы из-за наличия обязательных методов установки (сеттеров)
* обязательное наличие конструктора класса по умолчанию.

### 2.2.5. Применение паттерна в автотестах

#### 2.2.5.1. Сериализация тестовых данных в автотестах

##### До применения паттерна

##### После применения паттерна

#### 2.2.5.2.

## 2.3. Паттерн Объект Значение (Value Object (VO))

***Объект Значение (Value Object (VO))*** ⎼ класс в **Java**, который идентифицируется по уникальности значения полей класса (**структурная эквивалентность**).

![Паттерн Объект Значение (Value Object (VO))](./_Files/1.%20Patterns/05.png "Паттерн Объект Значение (Value Object (VO))")

***Ссылочная эквивалентность*** - равенство двух объектов в случае, если оба объекта ссылаются на один и тот же объект в куче.

![Ссылочная эквивалентность](./_Files/1.%20Patterns/06.png "Ссылочная эквивалентность")

***Структурная эквивалентность*** - равенство двух объектов в случае, если у обоих объектов все поля полностью эквивалентны.
То есть, если два экземпляра одного класса обладают одинаковым набором свойств (полей), то они равны.

![Структурная эквивалентность](./_Files/1.%20Patterns/07.png "Структурная эквивалентность")

### 2.3.1. Структура паттерна

Структура паттерна:

1. *Класс*
   
Класс **Объект Значение (Value Object (VO))**:

* представляет логически целостные объекты, для которых нет готовых стандартных типов 

Классы **Объект Значение (Value Object (VO))** могут представлять даты, время, деньги.

* НЕ обладает неотъемлемой идентичностью, то есть идентифицируется по уникальности значения полей класса (**структурная эквивалентность**), 
  а не уникальности значения идентификатора (**эквивалентность идентификаторов**)

Два объекта класса **Объект Значение (Value Object (VO))** считаются равными, если значения всех их полей равны.

* НЕ является самостоятельной сущностью, а представляет *кирпичики* для построения сущностей

Объект класса **Объект Значение (Value Object (VO))** не может существовать сам по себе, то есть они всегда должны принадлежать одной или нескольким сущностям.
Данные, которые представляет из себя **Объект Значение (Value Object (VO))**, имеют значение только в контексте какой-либо сущности.

Объект класса **Объект Значение (Value Object (VO))** не должны иметь собственной таблицы в базе данных.

* обладает нулевым жизненным циклом

Объекты класса **Объект Значение (Value Object (VO))** создаются и уничтожаются с легкостью. 
Это следствие, логично вытекающее из того, что они взаимозаменяемы.
Важны не объекты, а важны их значения. Объект здесь служит лишь способом организации кода, 
но он никак не идентифицирует хранящиеся внутри него данные.

Например, если есть 1 рубль, то все равно та же ли это монета, что была вчера.
До тех пор, пока эта монета является монетой ценностью в 1 рубль, ее можно заменить другой, точно такой же.
Концепция денег в таком случае является **объектом значением**. То же самое можно сказать и про многое другое 
(адреса доставки, страна проживания, путь до файла, адрес страницы сайта, точки на плоскости).

2. *Поля класса*

Поля класса **Объект Значение (Value Object (VO))**:

* состоят из 
  * примитивных типов данных 
  * объектов класса **Объект Значение (Value Object (VO))**
* НЕ имеют поля идентификатор
* являются неизменяемыми

Если необходимо изменить объект, то создается новый объект на основе имеющегося, вместо того чтобы изменять существующий.

* проверяются на действительность при создании

Если какой-либо из полей недействительно, то объект не должен создаваться и должна возникать ошибка или исключение.

Например, если есть класс Age (возраст), то не имеет смысла создавать экземпляр класс Age с отрицательным значением.
В **Java** можно выбросить исключение **IllegalArgumentException** или любое другое созданное исключение.

3. *Методы доступа класса*

3.1. *Сеттеры*

У класса **Объект Значение (Value Object (VO))** отсутствуют сеттеры.
Это следствие неизменяемости полей классов.

3.2. *Геттеры*

Геттеры класса **Объект Значение (Value Object (VO))** должны возвращать неизменяемые объекты или копии.

4. *Конструктор класса*

Так как объекты класса **Объект Значение (Value Object (VO))** неизменяемые, 
то их можно создать только одним способом - инициализацией в конструкторе.

*Пример*

```java
class Money {
    int value;
    String currency;

    public Money(int value, String currency) {
        this.value = value;
        this.currency = currency;
    }

    int getValue() {
        return value;
    }

    String getCurrency() {
        return currency;
    }

    public boolean equals(Money m) {
        return value == m.value and currency == m.currency;
    }
}
```

### 2.3.2. Шаги реализации паттерна

1. *Создание класса, моделирующего объекты, которые идентифицируется по уникальности значения полей*

2. *Создание закрытых полей класса, представленных примитивными типами данных и/или объектами-значениями*

3. *Создание общедоступных методов доступа класса, состоящих только из геттеров*

4. *Создание конструктора класса*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.3.3. Применимость паттерна

1. *Когда есть объекты, равенство которых определяется по значениям полей*

Данные объекты делаются неизменяемыми, т.е. чтобы после создания объекта значения его полей не изменялись.
Такие объекты можно передавать в виде значения, а не в виде ссылки на объект.
Два объекта считаются равными, если равны значения их полей. 
Обычно изменение полей объекта подразумевает полную замену старого объекта новым.

### 2.3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Объект Значение (Value Object (VO))**:

* уменьшение примитивной одержимости

***Примитивная одержимость (Primitive Obsession)*** - использование примитивов для хранения данных или в качестве параметров. 

*Пример*

Использование **String** для хранения адреса электронной почты, **double** для веса или **float** для расстояния.
Обычно это происходит потому, что создание нового класса только для хранения этого атрибута кажется излишним.

```java
String email;
double weight;
float distance;
```

* безопасность типов

Неправильная единица измерения

*Пример*

Есть следующее поле:

```java
private float distance;
```

Возможно, это расстояние в дюймах, а может, в метрах. Конечно, всегда можно назвать это distanceInMeters.
Теперь допустим что нужно расстояние в дюймах где-то еще в коде. Нужно будет преобразовать это расстояние перед его использованием.
Где должен быть этот код преобразования? В служебном классе? В статическом методе?
Что, если удалить этот код преобразования перед использованием расстояния?
Код все равно будет компилироваться, но будет использоваться неправильная единица измерения!
Такая ошибка может быть серьезной и может стоить компании больших денег.
Можно снизить этот риск, используя вместо этого **объект значение** Distance.

В этом случае мы бы просто сохранили Distance и больше не заботились о том, в какой единице она была создана. 
Этот класс теперь также содержит всю логику преобразования, и можно легко получить расстояние в любой единице, благодаря геттерам.

Смешивание параметров

*Пример*

Например, следующий метод:

```java
void sendEmail (String email, String тема, String body);
```

Очень легко перепутать параметры и назвать это так:

```java
sendEmail ("Некоторая тема", "Некоторое содержание", "john@doe.com");
```

Это кажется глупой ошибкой, но это может произойти при невнимательности. К сожалению, компилятор здесь не поможет.
Что произойдет, если будет необходимо отправлять составной контент? 
Или если нужно отправить электронное письмо нескольким получателям? 
Тогда нужно будет перегружать метод для каждого нового случая.

Используя **объекты значения** вместо примитивов, можно было бы получить следующее:

```java
sendEmail (адрес электронной почты получателя, тема темы, содержимое содержимого);
```

Инвертировать параметры будет невозможно, так как компилятор обнаружит ошибки. 
Тем не менее все равно нужно перегрузить метод, если понадобиться иметь 
возможность отправлять электронное письмо нескольким получателям. 
Это можно исправить, проделав еще один шаг:

```java
sendEmail (электронная почта);
```

Этот способ читать намного проще, чем первый метод. У него также есть еще одно преимущество - гибкость.

* гибкость

Продолжая предыдущий пример, теперь, когда у есть класс электронной почты, можно изменить его, чтобы он мог обрабатывать 
несколько получателей или разные типы контента без необходимости возвращаться и снова изменять сигнатуру метода.

* самопроверка

**Объект значение** должен быть действительным и неизменяемым. 
Благодаря чему, можно перестать задаваться вопросом, нужно ли проверять параметр или нет.

Если повторно использовать пример **sendEmail**, нужно будет убедиться, что адрес электронной почты действителен. 
Где это делать? Возможно, в самом методе? Почему нет. Но что, если нужно использовать электронную почту в другом месте? 
А что, если кто-то уже подтвердил электронное письмо перед вызовом метода **sendEmail**? Повсюду бы дублировался проверочный код! 
Что, если кто-то тем временем решит изменить значение электронного письма? Затем нужно будет снова его проверить.

Нет разумного места, куда поместить код проверки, и нет гарантии, что параметр допустимый.
Однако с **объектом значения** гарантируется, что он действителен, иначе он просто не существовал бы. 
Код проверки, также находится там, где должен, внутри самого объекта. 
Только этот объект должен знать, действителен он или нет.

* уменьшение дублирования

Вместо того чтобы иметь одну и ту же группу атрибутов в отдельных классах, можно вместо этого создать общий **объект значения**. 
Одним из примеров этого может быть **объект значение** адреса, который может совместно использоваться сотрудниками и офисами, 
вместо дублирования полей адреса в каждом классе. Повторное использование **объектов значений** среди сущностей или 
других **объектов значений** - хороший способ уменьшить дублирование.

* улучшение читабельности

Используя **объекты значения**, не нужно гадать, что значат переменные на самом деле. 
Вместо **List<String>** может быть **List<PhoneNumber>**. Больше не нужно беспокоиться о внутренних представлениях, 
а вместо этого думать о концепциях предметной области. Код намного выразительнее.
Кроме того, **объекты значения** централизуют логику связанной предметной области, что упрощает поиск и изменение.

* улучшение производительности

**Объекты значения** неизменяемы и поэтому могут использоваться в распараллеленном коде без риска. 
Если многие объекты используют один и тот же **объект значение** с одним и тем же значением, 
можно использовать паттерн **Легковес (Flyweight)**, разделяя один и тот же экземпляр для всех объектов. 
Так как важны только атрибуты, а не то, какой экземпляр используется.

Минусы применения паттерна **Объект Значение (Value Object (VO))**:

* дополнительные классы
* увеличение объема кода

### 2.3.5. Применение паттерна в автотестах

#### 2.3.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

##### После применения паттерна

#### 2.3.5.2.



## 2.4. Объект сущность (Entity)

***Объект Сущность (Entity)*** ⎼ класс в **Java**, который идентифицируется по уникальности значения идентификатора (**эквивалентность идентификаторов**).

![Паттерн Объект Сущность (Entity))](./_Files/1.%20Patterns/08.jpg "Паттерн Объект Сущность (Entity)")

***Ссылочная эквивалентность*** - равенство двух объектов в случае, если оба объекта ссылаются на один и тот же объект в куче.

![Ссылочная эквивалентность](./_Files/1.%20Patterns/06.png "Ссылочная эквивалентность")

***Эквивалентность идентификаторов*** - равенство двух объектов в случае, если у обоих объектов идентификаторы эквивалентны.
То есть, если два экземпляра одного класса обладают одинаковыми идентификаторами, то они равны.

![Эквивалентность идентификаторов](./_Files/1.%20Patterns/09.png "Эквивалентность идентификаторов")

### 2.4.1. Структура паттерна

Структура паттерна:

1. *Класс*

Класс **Объект сущность (Entity)**:

* представляет модели сложных объектов

Объектами класса **Объект сущность (Entity)** могут быть клиент, продукт.

* обладает неотъемлемой идентичностью

То есть идентифицируется по уникальности значения идентификатора (**эквивалентность идентификаторов**),
а не по уникальности значения полей класса (**структурная эквивалентность**)

Два объекта класса **Объект сущность (Entity)** считаются равными, если значения их полей идентификаторов равны.
В то же время, даже если данные в двух объектах полностью одинаковы (за исключением поля идентификатора),
то они не являются одной и той же сущностью.

* является самостоятельной сущностью

Объект класса **Объект сущность (Entity)** может существовать сам по себе.

* обладает продолжительным жизненным циклом

Объекты класса **Объект сущность (Entity)** создаются не ради одноразового использования, 
а живут какое-то время во время запуска программы или, что чаще, между запусками в каком-то хранилище (БД).

Объект класса **Объект сущность (Entity)** обладает историей (даже если не храним эту историю) того,
что с ними случилось и как они менялись в течение жизни (записи в БД). 

Однако одни и те же вещи могут быть как **объектами-значениями** так и **объектами-сущностями**.
Всё зависит от конкретной предметной области. Для большинства компаний деньги - это действительно просто значения, 
но не для тех кто их печатает. Им очень важно различать купюры между собой и поэтому на каждой из них есть уникальный номер,
который и позволяет проводить идентификацию.

2. *Поля класса*

Поля класса **Объект сущность (Entity)**:

* состоят из 
  * примитивных типов данных 
  * объектов класса **Объект Значение (Value Object (VO))**
  * объектов класса **Объект Сущность (Entity)**
* имеют поле идентификатор
* являются изменяемыми

3. *Методы доступа класса*
  
3.1. *Сеттеры*   

У класса **Объект сущность (Entity)** есть методы установки значений полей класса (сеттеры)

3.2. *Геттеры*

У класса **Объект сущность (Entity)** есть методы получения значений полей класса (геттеры)

4. *Конструктор класса*

*Пример*

```java
class Order {
    ProductsList products;
    String number;

    public Order(String number) {
        this.number = number;
        products = new ArrayList<>();
    }

    public addProduct(Product p){
        products.add(p);
    }

    public boolean equals(Order order) {
        return number == order.number;
    }
}
```

### 2.4.2. Шаги реализации паттерна

1. *Создание класса, моделирующий объекты, которые идентифицируется по уникальности значения идентификатора*

2. *Создание закрытых полей класса, представленных примитивными типами данных, объектами-значениями и объектами-сущностями*

3. *Создание общедоступных методов доступа класса*

4. *Создание конструктора класса*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.4.3. Применимость паттерна

1. *Когда*

### 2.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Объект сущность (Entity)**:

* гибкость
* уменьшение дублирования
* повторное использование кода
* простота понимания

Минусы применения паттерна **Объект сущность (Entity)**:

* усложнение кодирования
* увеличение объема кода

### 2.4.5. Применение паттерна в автотестах

#### 2.4.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

## 2.5. Паттерн Объект передачи данных (Data Transfer Object)

***Объект передачи данных (Data Transfer Object)*** - паттерн, представляющий собой класс, 
содержащий данные без какой-либо логики для работы с ним.

![Паттерн Data Transfer Object](./_Files/1.%20Patterns/10.jpg "Паттерн Data Transfer Object")

### 2.5.1. Структура паттерна

Структура паттерна:

1. *Класс*

Класс **Объект передачи данных (Data Transfer Object)**:

* должен быть общедоступным
* может содержать механизмы сериализации и десериализации
* может содержать статические классы 
* может расширять другие классы **Объект передачи данных (Data Transfer Object)**
* не должен содержать переменных обобщенного типа

2. *Поля класса*

Поля класса **Объект передачи данных (Data Transfer Object)**:

* уровень доступа - *private*
* представлены легко сериализуемыми типами

Типы, которые могут использоваться в классе **Объект передачи данных (Data Transfer Object)**:

* примитивные типы данных
* обертки вокруг примитивных типов данных
* строковый тип данных String
* перечисления enum
* другие классы **Объект передачи данных (Data Transfer Object)**
* списки **List**
* множества **Set**
* словари **Map**
* массивы **Array**

При этом списки, множества, словари и массивы должны содержать только объекты выше перечисленных типов.

Граф объектов **Объект передачи данных (Data Transfer Object)** должен быть деревом (т. е. не иметь циклов), 
чтобы упростить сериализацию и десериализацию.

3. *Методы доступа класса*
   
3.1. *Сеттеры*

У класса **Объект передачи данных (Data Transfer Object)** есть методы установки значений полей класса (сеттеры)

3.2. *Геттеры*

У класса **Объект передачи данных (Data Transfer Object)** есть методы получения значений полей класса (геттеры)

4. *Конструктор класс*

У класса паттерна **Объект передачи данных (Data Transfer Object)** должен быть конструктор без аргументов (конструктор по умолчанию).

*Пример*

```java
public class Employee implements Serializable{
    private long mEmployeeId;
    private String mEmployeeName;
    
    public void setEmployeeId(long pEmployeeId) {
        this.mEmployeeId = pEmployeeId;
    }
    
    public long getEmployeeId() {
        return this.mEmployeeId;
    }
    
    public void setEmployeeName(String pEmployeeName) {
        this.mEmployeeName = pEmployeeName;
    }
    
    public String getEmployeeName() {
        return this.mEmployeeName;
    }
}
```

### 2.5.2. Шаги реализации паттерна

1. *Создание класса, который реализует интерфейс java.io.Serializable*

2. *Создание закрытых полей класса*

3. *Создание общедоступных методов доступа класса*

4. *Создание конструктора класса без аргументов*

5. *Переопределение методов equals(), hashCode() и toString()*

### 2.5.3. Применимость паттерна

1. *Когда необходимо передавать данные нескольких объектов*

2. *Когда необходимо передавать много параметров за раз*

**Объект передачи данных (Data Transfer Object)** обычно используются для передачи данных между различными приложениями,
либо между слоями внутри одного приложения. Их можно рассматривать как хранилище информации,
единственная цель которого — передать эту информацию получателю.

### 2.5.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Объект передачи данных (Data Transfer Object)**:

* уменьшение дублирования кода

Минусы применения паттерна **Объект передачи данных (Data Transfer Object)**:

* дополнительные классы

### 2.5.5. Применение паттерна в автотестах

#### 2.5.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

## 2.6. Отличия понятий

Разница между объектами передачи данных и бизнес-объектами или объектами доступа к данным заключается в том,
что **Объект передачи данных (Data Transfer Object)** не имеет никакого поведения,
кроме хранения, извлечения, сериализации и десериализации своих собственных данных.


| C | POJO | JB | VO | EO | DTO |
|---|------|----|----|----|-----|
|   |      |    |    |    |     |
|   |      |    |    |    |     |


## 2.7. Библиотека Lombok



***

# 3. Порождающие паттерны

***Порождающие паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том,
как создавать объекты.

![Порождающие паттерны](./_Files/1.%20Patterns/11.jpg "Порождающие паттерны")

Обычная форма создания объекта может привести к проблемам проектирования или увеличивать сложность конструкции.
Порождающие паттерны проектирования решают эту проблему, определённым образом контролируя процесс создания объекта.
Порождающие паттерны позволяют сделать систему независимой от способа создания, композиции и представления объектов в системе.

https://refactoring.guru/ru/design-patterns/factory-comparison
https://qna.habr.com/q/677514

## 3.1. Паттерн Простая Фабрика (Simple Factory)

***Простая Фабрика (Simple Factory)*** - 

![Паттерн Простая Фабрика (Simple Factory)](./_Files/1.%20Patterns/12.jpg "Паттерн Простая Фабрика (Factory)")

### 3.1.1. Структура паттерна

![Структура паттерна Простая Фабрика (Simple Factory)](./_Files/1.%20Patterns/13.png "Структура паттерна Простая Фабрика (Simple Factory)")

1. *Базовый продукт (Product)*

***Базовый продукт (Product)*** - общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных продуктов (ConcreteProduct)**.

2. *Конкретный продукт (ConcreteProduct)* - конкретный класс со своей бизнес логикой, 
реализующий **Базовый продукт (Product)**, который будет создан **Простой фабрикой (SimpleFactory)**.

3. *Простая фабрика (SimpleFactory)*

***Простая фабрика (SimpleFactory)*** - класс, который содержит статический метод по созданию всех 
**Конкретных продуктов (ConcreteProduct)**.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вызывает статический метод **Простой фабрики (SimpleFactory)**, 
чтобы создать **Конкретный продукт (ConcreteProduct)**.

### 3.1.2. Шаги реализации паттерна

1. *Проверка наличия в задаче множества классов реализующих один интерфейс*

2. *Создание Базового продукта*

Базовый продукт описывает общие методы для всех продуктов.

3. *Создание Конкретных продуктов*

Конкретные продукты реализует свою логику.

4. *Создание Простой фабрики*

Простая фабрика создает продукты.

### 3.1.3. Применимость паттерна

1. *Когда нужно создавать однотипные объекты*
2. *Когда нужно вынести логику по созданию объектов*

### 3.1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Простая Фабрика (Factory)**:

* скрытие логики по созданию от клиента

Минусы применения паттерна **Простая Фабрика (Factory)**:

* при добавлении новых типов конкретных продуктов метод по созданию может стать очень громоздким
* нет контроля за процессом создания объектов 

### 3.1.5. Применение паттерна в автотестах

#### 3.1.5.1. Фабрика драйверов (WebDriverFactory)

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

#### 3.1.5.2. Фабрика страниц (PageFactory)

***Page Factory*** - паттерн, который моделирует объект страницы.

Page Factory is an extension to Page Object pattern. 
It helps to encapsulate page’s attributes and methods even more by providing FindBy annotations.

Pay attentions to PageFactory#initElements invocation.
This static helper initializes all fields with FindBy annotations on the page, which will be found on it on each call.
The main advantage is the fact that now we work directly with fields, buttons, windows etc.
and do not worry about low level driver’s interactions exactly the same way our app users do.

Composition of Page Elements

Any web, desktop or mobile application consists of repeatable elements, 
and logic of their usage should be implemented again and again in our tests.
For instance, every menu has list of links, every table has rows and columns, every form has input fields.
In real life when we work with those elements we do not separate those components from the main element consisting them.

Thanks to Composition we could implement some elements once and reuse them every time we need them.
Thus it helps to avoid code duplication by composing different web elements 
into widgets (high-level elements), like tables, menus, forms.
This significantly reduces costs of extending and scaling of test automation framework when, 
for example new Page Objects needs to be created.

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

#### 3.1.5.3. Фабрика элементов (ElementFactory)

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

#### 3.1.5.4. Фабрика тестовых данных

##### До применения паттерна

*Пример*

```java
class User1 {
    private String firstName;
    private String lastName;

    public User1() {}
    
    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
}

class User2 {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    public User2() {}

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
}

public void createUser1 (User1 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    
}

public void createUser2 (User2 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    age.enter(user.getAge());
    isMarried.check(user.getIsMarried());
}
```

##### После применения паттерна

*Пример*

```java

abstract class User {
    private String firstName;
    private String lastName;

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    abstract void someMethod();
}

class User1 extends User {
    public User1() { }
    public void someMethod() { }
}

class User2 extends User {
    private int age;
    private boolean isMarried;

    public User2() { }

    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
    public void someMethod() { }
}

class UserFactory
{
    public static User getUser(String userType) {
        switch (userType) {
            case "user1":
                User1 user1 = new User1();
                user1.setFirstName("First Name");
                user1.setLastName("Last Name");
                return user1;
            case "user2":
                User2 user2 = new User2();
                user2.setFirstName("First Name");
                user2.setLastName("Last Name");
                user2.setAge(40);
                user2.setIsMarried(false);
                return user2;
            default:
                throw new RuntimeException("Incorrect user type");
        }
    }
}
```

*Пример*

```java
public void createUser(String userType) {
    switch (userType) {
        case "user1":
            User1 user1 = UserFactory.getUser("user1");
            firstName.enter(user1.getFirstName());
            lastName.enter(user1.getLastName());
            age.enter(user1.getAge());
            isMarried.check(user1.getIsMarried());
            break;
        case "user2":
            User2 user2 = UserFactory.getUser("user2");
            firstName.enter(user2.getFirstName());
            lastName.enter(user2.getLastName());
            age.enter(user2.getAge());
            isMarried.check(user2.getIsMarried());
            premium.enter(user2.getPremium());
            break;
        default:
            throw new RuntimeException("Incorrect user type");
    }
}
```

Инициализация экземпляров **WebDriver** для разных браузеров.
Создание объектов страниц в **PageFactory**.

## 3.2. Паттерн Фабричный метод (Factory Method)

***Фабричный метод (Factory Method)*** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![Паттерн Фабричный метод (Factory Method)](./_Files/1.%20Patterns/14.jpg "Паттерн Фабричный метод (Factory Method)")

Паттерн **Фабричный метод (Factory Method)** предлагает создавать объекты не напрямую, используя оператор new, 
а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, 
но делать это будет фабричный метод.

### 3.2.1. Структура паттерна

![Структура паттерна Фабричный метод (Factory Method)](./_Files/1.%20Patterns/15.jpg "Паттерн Фабричный метод (Factory Method)")

1. *Продукт (Product)*

***Продукт (Product)*** - общий интерфейс для всех объектов, которые может произвести создатель.

2. *Конкретный продукт (ConcreteProduct)*

***Конкретный продукт (ConcreteProduct)*** - класс, представляющий объект со своей реализацией.

Продукты будут отличаться реализацией, но интерфейс у них будет общий.

3. *Создатель (Creator)*

***Создатель (Creator)*** - класс, который создает конкретные продукты.

Создание продуктов не является единственной функцией создателя. Обычно он содержит и другой полезный код работы с продуктом.

4. *Конкретный создатель (Concrete Creator)*

***Конкретный создатель (Concrete Creator)*** - класс, создающий конкретный объект.

Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.

### 3.2.2. Шаги реализации паттерна

1. **

2. **

3. **

### 3.2.3. Применимость паттерна

1. *Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код*

Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.
Благодаря этому, код производства можно расширять, не трогая основной. 
Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, 
возвращая оттуда экземпляр нового продукта.

2. *Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки*

возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. 
А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.

3. *Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.*

Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, 
файловой системе и т. д.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

### 3.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Фабричный метод (Factory Method)**:

Необходимо создание объектов с заранее неизвестным типом.

Необходимо наличие системы расширяемой и независимой от процесса создания новых объектов: 
в нее можно легко вводить новые классы, объекты которых система должна создавать.

Необходимо делегировать создание новых объектов из базового класса классам наследникам.

Избавляет класс от привязки к конкретным классам продуктов.
Выделяет код производства продуктов в одно место, упрощая поддержку кода.
Упрощает добавление новых продуктов в программу.
Реализует принцип открытости/закрытости.

Минусы применения паттерна **Фабричный метод (Factory Method)**:

Может привести к созданию больших параллельных иерархий классов, 
так как для каждого класса продукта надо создать свой подкласс создателя.

### 3.2.5. Применение паттерна в автотестах

#### 3.2.5.1. Фабрика драйверов (WebDriverFactory)

##### До применения паттерна

##### После применения паттерна



## 3.3. Паттерн Строитель (Builder)

***Строитель (Builder)*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

![Паттерн Строитель (Builder)](./_Files/1.%20Patterns/16.jpg "Паттерн Строитель (Builder)")

Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса, 
поручив это дело отдельным объектам, называемым строителями.

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов.

### 3.3.1. Структура паттерна

![Структура паттерна Строитель (Builder)](./_Files/1.%20Patterns/17.jpg "Паттерн Строитель (Builder)")

1. *Продукт (Product)*

***Продукт (Product)*** - общий интерфейс для всех объектов, которые может произвести создатель.

2. **

3. **

### 3.3.2. Шаги реализации паттерна

1. **

2. **

3. **

### 3.3.3. Применимость паттерна

1. **

2. **

3. **

### 3.3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Строитель (Builder)**:

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и с помощью современных IDE подсказок более интуитивно понятным.

Минусы применения паттерна **Строитель (Builder)**:

### 3.3.5. Применение паттерна в автотестах

#### 3.3.5.1. Билдер тестовых данных

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

    public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}
```

*Пример*

```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

https://habr.com/ru/company/otus/blog/552412/
https://www.softwaretestinghelp.com/design-patterns-in-java/#Builder_Pattern_In_Java



## 3.4. Паттерн Одиночка (Singleton)

***Одиночка (Singleton)*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

![Паттерн Одиночка (Singleton)](./_Files/1.%20Patterns/02.jpg "Паттерн Одиночка (Singleton)")

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод,
который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

### 3.4.1. Структура паттерна

![Структура паттерна Одиночка (Singleton)](./_Files/1.%20Patterns/03.jpg "Паттерн Одиночка (Singleton)")

1. *Одиночка (Singleton)*

***Одиночка (Singleton)*** - класс определяющий статический метод **getInstance**,
который возвращает единственный экземпляр своего класса.

Конструктор **Одиночки (Singleton)** должен быть скрыт от клиентов.
Вызов метода **getInstance** должен стать единственным способом получить объект этого класса.

### 3.4.2. Шаги реализации паттерна

1. **

2. **

3. **

### 3.4.3. Применимость паттерна

1. *В программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам*

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода.
Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

2. *Больше контроля над глобальными переменными*

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса,
поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек,
поменяв код в одном месте (метод **getInstance**).

### 3.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Одиночка (Singleton)**:

* гарантия наличие единственного экземпляра класса
* предоставление к единственному экземпляру класса глобальной точки доступа
* реализация отложенной инициализацию объекта-одиночки

Минусы применения паттерна **Одиночка (Singleton)**:

* нарушение принципа единственной ответственности класса
* маскирование плохого дизайна
* проблемы многопоточности
* требование постоянного создания Mock-объектов при юнит-тестировании.

### 3.4.5. Применение паттерна в автотестах

#### 3.4.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja



## 3.5. Паттерн Абстрактная фабрика (Abstract Factory)

***Абстрактная фабрика (Abstract Factory)*** — паттерн, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.

### 3.5.1. Структура паттерна

### 3.5.2. Шаги реализации паттерна

1. **

2. **

3. **

### 3.5.3. Применимость паттерна

1. **

2. **

3. **

### 3.5.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна ****:

1. **

Минусы применения паттерна ****:

1. **

### 3.5.5. Применение паттерна в автотестах

#### 3.5.5.1. 

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```
http://design-pattern.ru/patterns/abstract-factory.html
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b0%d0%b1%d1%81%d1%82%d1%80%d0%b0%d0%ba%d1%82%d0%bd%d0%b0%d1%8f-%d1%84%d0%b0%d0%b1%d1%80%d0%b8%d0%ba%d0%b0/

***

# 4. Структурные паттерны

***Cтруктурные паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том,
как из классов и объектов образуются более крупные структуры.

![Структурные паттерны](./_Files/1.%20Patterns/03.jpg "Структурные паттерны")

Структурные паттерны проектирования упрощают проектирование путем выявления
простого способа реализовать отношения между субъектами.

## 4.1. Паттерн Декоратор (Decorator)

***Декоратор (Decorator)*** - паттерн, который позволяет динамически добавлять объектам новую функциональность.
Декораторы предоставляют гибкую альтернативу подклассам для расширения функциональности.

Паттерн **Декоратор (Decorator)** имеет альтернативное название — **Обёртка**.
Оно более точно описывает суть паттерна: целевой объект-оригинал помещается в другой объект-обёртку,
который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы,
с каким объектом работать — оригиналом или обёрткой.
Вы можете использовать несколько разных обёрток одновременно —
результат будет иметь объединённое поведение всех обёрток сразу.

Пример использования паттерна в библиотеке **Selenium** - **EventFiringDecorator** и **FieldDecorator**.

![Паттерн Декоратор (Decorator)](./_Files/1.%20Patterns/11.jpg "Паттерн Декоратор (Decorator)")

### 4.1.1. Структура паттерна

![Структура паттерна  Декоратор (Decorator)](./_Files/1.%20Patterns/12.jpg "Паттерн Декоратор (Decorator)")

1. *Базовый компонент (Component)*

***Базовый компонент (Component)*** – общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных компонентов (ConcreteComponent)** и **Базового декоратора (Decorator)**.

2. *Конкретный компонент (ConcreteComponent)*

***Конкретный компонент (ConcreteComponent)*** – конкретный класс со своей бизнес логикой, реализующий **Базовый компонент (Component)**,
функциональность которого необходимо модифицировать декораторами.

Декоратор способен работать как с самим исходным компонентом, так и его наследниками.
Однако, не следует использовать большое количество декораторов с тяжеловесными классами,
так как это может повлечь за собой большие накладные расходы.

3. *Базовый декоратор (Decorator)*

***Базовый декоратор (Decorator)*** – базовый класс для всех декораторов, реализующий **Базовый компонент (Component)** и
хранящий ссылку на экземпляр **Конкретного компонента (ConcreteComponent)**.

**Базовый декоратор (Decorator)** реализует тот же самый интерфейс чтобы:

* замещать конкретный компонент
* создавать цепочку декораторов

4. *Конкретный декоратор (ConcreteDecorator)*

***Конкретный декоратор (ConcreteDecorator)*** - конкретный класс, наследующий **Базовый декоратор (Decorator)** и
добавляющий определенные функции компоненту.

Добавление новой функциональности осуществляется подменой экземпляра оригинального компонента.
Такой объект может использоваться как вместо декорируемого компонента, так и самостоятельно.

**Конкретный декоратор (ConcreteDecorator)**:

* создает механизм подключения и хранения компонента
* реализует переадресацию всех методов и свойств
* добавляет новые свойства и методы

### 4.1.2. Шаги реализации паттерна

1. *Проверка наличия в задаче одного основного компонента и нескольких дополнительных опциональных дополнений или надстроек над ним*

2. *Создание Базового компонента*

Базовый компонент описывает общие методы как для основного компонента, так и для его дополнений.

3. *Создание Конкретного компонента*

Конкретный компонент содержит основную бизнес-логику.

4. *Создание Базового декоратора*

Базовый декоратор имеет поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора делегируют действие вложенному объекту.

5. *Создание Конкретных декораторов*

Конкретный декоратор выполняет свою добавочную функцию,
а затем (или перед этим) вызывает эту же операцию обёрнутого объекта.

### 4.1.3. Применимость паттерна

1. *Реализация множественного наследования*

В таких языках как **Java** и **C#** нет множественного наследования классов.
И когда требуется реализовать множество различных функциональностей и их комбинаций,
то для каждой такой функциональности и их комбинаций придется наследовать отдельный класс.
Структура классов при этом может очень сильно разрастись, что в свою очередь усложнит ее понимание и поддержку.

Применение паттерна **Декоратор (Decorator)** позволяет реализовать аналог множественного наследования, в языках его не поддерживающих,
путем вложения одного декоратора в другой и создания из них цепочек, поскольку паттерн реализует интерфейс исходного компонента.
Таким образом у объектов расширяются возможности без использования одиночного наследования.
Что в свою очередь разрешает проблему усложнения структуры классов путем уменьшения числа создаваемых классов
по сравнению с результатами использования одиночного наследования.

2. *Невозможность расширить обязанности объекта с помощью наследования*

Во многих языках программирования есть ключевое слово, с помощью которого можно заблокировать наследование класса.

Применение паттерна **Декоратор (Decorator)** позволяет добавить функциональность классу,
определение которого может быть скрыто или иным образом недоступно для подклассов, то есть когда наследование невозможно.

3. *Динамическое добавление новых возможностей на лету, незаметно для кода, который их использует*

Применение паттерна **Декоратор (Decorator)** обеспечивает динамическое добавление объекту новых функциональных возможностей.
Объекты помещаются в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс,
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

Позволяет комбинировать классы в процессе выполнения программы. дважды применить один и тот же Декоратор.

### 4.1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Декоратор (Decorator)**:

* большая гибкость, чем у наследования
* добавление обязанности на лету
* добавление нескольких новых обязанностей сразу
* изменение функциональности не только применением самих Декораторов, но и различным порядком их вложенности

Минусы применения паттерна **Декоратор (Decorator)**:

* трудность конфигурирования многократно обёрнутых объектов
* обилие крошечных классов
* несколько мелких объектов вместо одного объекта на все случаи жизни

### 4.1.5. Применение паттерна в автотестах

#### 4.1.5.1. Декоратор драйвера

##### До применения паттерна

Страница (Page Objects)

*Пример*

```java

```

Интерфейс **WebElement** не всегда удобно использовать.
Его невозможно расширить и добавить свои методы для работы с элементом.
Использовать свои методы можно только создавая классы-обвертки(CheckBox, Button и т.п.),
которые просто делегируют вызов методов настоящему **WebElement**.

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

#### 4.1.5.2. Декоратор тестовых данных

##### До применения паттерна



##### После применения паттерна



## 4.2. Паттерн Заместитель (Proxy)

***Заместитель (Proxy)*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заместители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Паттерн **Заместитель (Proxy)** предлагает создать новый объект-заместитель, имеющий тот же интерфейс, что и оригинальный объект.
Ни интерфейс ни функциональность замещенного объекта, с точки зрения клиента, не изменяются.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр оригинального объекта и
переадресовывал бы ему всю реальную работу.

![Паттерн Заместитель (Proxy)](./_Files/1.%20Patterns/13.jpg "Паттерн Заместитель (Proxy)")

### 4.2.1. Структура паттерна

![Структура паттерна Заместитель (Proxy)](./_Files/1.%20Patterns/14.jpg "Структура паттерна Заместитель (Proxy)")

1. *Базовый объект (Subject)*

***Базовый объект (Subject)*** – общий интерфейс / абстрактный класс для всех замещаемых объектов и заместителей.

Конкретная реализация скрыта от **Заместителя (Proxy)** и он может работать практически со всеми **Реальными объектами (RealSubject)**,
поддерживающими данный интерфейс.

2. *Реальный объект (RealSubject)*

***Реальный объект (RealSubject)*** – конкретный класс с полезной бизнес логикой, реализующий **Базовый объект (Subject)**,
который будет замещен **Заместителем**.

3. *Заместитель (Proxy)*

***Заместитель (Proxy)*** - класс, реализующий **Базовый объект (Subject)**, который замещает **Конкретный объект (RealSubject)** и перехватывает обращения к нему.

**Заместитель (Proxy)** :

* выполняет дополнительные действия (инициализацию, логирование и т д.) до или после вызова вложенного в него **Конкретного объекта (RealSubject)**
* отвечает за создание и удаление **Конкретного объекта (RealSubject)**.

Паттерн не накладывает ограничения на вложения одного заместителя в другой.
Такой подход позволяет строить их различные конфигурации в процессе работы программы.

### 4.2.2. Шаги реализации паттерна

1. *Определение интерфейса, который бы сделал заместитель и оригинальный объект взаимозаменяемыми*

2. *Создание Заместителя*

Заместитель должен содержать ссылку на оригинальный объект. Чаще всего, оригинальный объект создаётся самим заместителем.
В редких случаях заместитель получает готовый оригинальный объект от клиента через конструктор.

3. *Реализация методов Заместителя в зависимости от его предназначения*

В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос оригинальному объекту.

4. *Создание Фабрики*

Фабрика будет решать, какой из объектов создавать — заместитель или оригинальный объект.

5 *Реализация ленивой инициализации оригинального объекта*

При первом обращении клиента к методам заместителя.

### 4.2.3. Применимость паттерна

1. *Ленивая инициализация (Виртуальный Прокси (Virtual Proxy))*

Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда,
когда он действительно понадобится.

2. *Защита доступа (Защищающий Прокси (Protection Proxy))*

Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа.
Например, если ваши объекты — это важная часть операционной системы,
а пользователи — сторонние программы (хорошие или вредоносные).

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. *Локальный запуск сервиса (Удаленный Прокси (Remote Proxy))*

Когда настоящий сервисный объект находится на удалённом сервере.
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. *Логирование запросов (Логирующий Прокси (Logging Proxy))*

Когда требуется хранить историю обращений к сервисному объекту.
Заместитель может сохранять историю обращения клиента к сервисному объекту.

5. *Кеширование объектов (Умная Ссылка (Smart Reference))*

Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.
Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными.
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект.
Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

### 4.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Заместитель (Proxy)**:

* контроль оригинального объекта незаметно для клиента
* возможность работы, даже если оригинальный объект ещё не создан
* возможность контроля жизненного цикла служебного объекта

Минусы применения паттерна **Заместитель (Proxy)**:

* усложнение кода программы из-за введения дополнительных классов
* увеличение времени отклика от сервиса

### 4.2.5. Применение паттерна в автотестах

#### 4.2.5.1. Создание заместителя для WebDriver в UI автотестах Selenium WebDriver

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

#### 4.2.5.2.



## 4.3. Паттерн Фасад (Facade)

***Фасад (Facade)*** — паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

![Паттерн Фасад (Facade)](./_Files/1.%20Patterns/15.jpg "Паттерн Фасад (Facade)")

**Фасад (Facade)** - простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь,
используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.
То есть содержит интерфейс, содержащий только методы для решения определённой задачи или
предоставляющий определённую абстракцию исходной системы.

### 4.3.1. Структура паттерна

![Структура паттерна Фасад (Facade)](./_Files/1.%20Patterns/16.jpg "Структура паттерна Фасад (Facade)")

1. *Подсистема (Subsystem)*

***Подсистема (Subsystem)*** - подсистема из множества разнообразных классов.

Нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее, чтобы заставить ее классы что-то делать.

2. *Фасад (Facade)*

***Фасад (Facade)*** - класс, который предоставляет быстрый доступ к определённой функциональности подсистемы.

Фасад выполняет:

* переадресацию запросов классам подсистемы

Классы подсистемы не знают о существовании Фасада и работают друг с другом напрямую.

* уменьшение числа параметров методов подстановкой заранее определенных значений

Часть исходных методов и свойств будут недоступны через Фасад, т.к. не играют роли для решения поставленной задачи

* создание новых методов, которые объединяют вызовы объектов подсистемы и/или добавляют свою логику

Фасад не является суммой всех методов объектов, входящих в систему.
Создание такой обобщенной версии приведет к появлению **божественного объекта**,
то есть интерфейса с огромным числом методов, без четко выраженной цели и порождающего большое количество зависимостей.
В итоге – прямо противоположный паттерну результат.

Дополнительный фасад можно ввести, чтобы не захламлять единственный фасад разнородной функциональностью.
Он может использоваться как клиентом, так и другими фасадами.

3. *Клиент (Client)*

***Клиент (Client)*** - класс, который использует фасад вместо прямой работы с объектами сложной подсистемы.

### 4.3.2. Шаги реализации паттерна

1. *Определение возможности создания более простого интерфейса, чем тот который предоставляется сложная подсистема*

Этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.

2. *Создание фасада, реализующего интерфейс подсистемы*

Фасад переадресовывает вызовы клиента нужным объектам подсистемы.

Фасад заботиться о том, чтобы правильно инициализировать объекты подсистемы

3. *Внедерение дополнительных фасадов*

### 4.3.3. Применимость паттерна

1. *Предоставление простого или урезанного интерфейса к сложной подсистеме*

Часто подсистемы усложняются по мере развития программы.
Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды,
но вместе с тем, применять подсистему без настройки становится труднее.
Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

2. *Разложение подсистемы на отдельные слои*

Фасады используются для определения точек входа на каждый уровень подсистемы.
Если подсистемы зависят друг от друга, то зависимость можно упростить,
разрешив подсистемам обмениваться информацией только через фасады.

### 4.3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Фасад (Facade)**:

* упрощает взаимодействие клиента с подсистемами
* изолирует клиентов от компонентов сложной подсистемы
* уменьшает зависимости клиентского кода от внутренней работы системы.

Минусы применения паттерна **Фасад (Facade)**:

* фасад рискует стать божественным объектом, привязанным ко всем классам программы

### 4.3.5. Применение в автотестах

#### 4.3.5.1. Скрытие технических деталей прохождения UI теста

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

#### 4.3.5.2.



## 4.4. Паттерн Легковес (Flyweight / Object Pool)

***Легковес (Flyweight / Object Pool)*** - паттерн, который позволяет вместить большее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой (внутреннее и внешнее),
вместо хранения одинаковых данных в каждом объекте.

![Паттерн Легковес (Flyweight / Object Pool)](./_Files/1.%20Patterns/17.jpg "Паттерн Легковес (Flyweight / Object Pool)")

***Внутреннее состояние*** - неизменяемые данные, которые хранятся в легковесном объекте и не используются за пределами объекта.
Внутреннее состояние не зависит от контекста, в котором используется объект-легковес.

***Внешнее состояние*** - изменяющиеся данные, которые не хранятся в легковесном объекте и используются за пределами объекта.
Внешнее состояние зависит от контекста. Клиенты несут ответственность за переход во внешнее состояние.

Паттерн **Легковес (Flyweight / Object Pool)** предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием,
а оно имеет не так много вариаций.

### 4.4.1. Структура паттерна

![Структура паттерна Легковес (Flyweight / Object Pool)](./_Files/1.%20Patterns/18.jpg "Структура паттерна Легковес (Flyweight / Object Pool)")

1. *Базовый легковес (Flyweight)*

***Базовый легковес (Flyweight)*** - интерфейс, общий для всех легковесов,
через который легковесы могут получать внешнее состояние или воздействовать на него.

2. *Конкретный легковес (ConcreteFlyweight)*

***Конкретный легковес (ConcreteFlyweight)*** - класс, который реализует **Базовый легковес (Flyweight)**
и добавляет хранилище для внутреннего состояния, если оно есть.

**Конкретный легковес (ConcreteFlyweight)** содержит состояние, которое повторялось во множестве первоначальных объектов.
Один и тот же легковес можно использовать в связке со множеством контекстов.

**Контекст**:

* содержит внешнюю часть состояния, уникальную для каждого объекта
* связан с одним из легковесов, хранящих внутреннюю часть состояния

3. *Фабрика легковесов (FlyweightFactory)*

***Фабрика легковесов (FlyweightFactory)*** - класс, который управляет созданием и повторным использованием легковесов.

Клиент должен запрашивать из фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
Фабрика легковесов получает запросы, в которых указано желаемое состояние легковеса.
Все созданные раннее легковесы хранятся в пуле. Если легковес с таким состоянием уже создан,
фабрика легковесов сразу его возвращает из пула, а если нет — создаёт новый объект, помещает его в пул и возвращает клиенту.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вычисляет или хранит контекст, то есть внешнее состояние легковесов.

Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.

### 4.4.2. Шаги реализации паттерна

1. *Разделение полей класса, который станет легковесом на две части: внутреннее и внешнее состояние*

2. *Создание фабрики, которая будет кешировать и повторно отдавать уже созданные объекты*

3. *Хранение или вычисление значения внешнего состояния (контекст) клиентом и передача его в методы объекта легковеса*

### 4.4.3. Применимость паттерна

1. *Большое количество однообразных объектов*

При использовании большого количества однообразных объектов происходит выделение
большого количества памяти для поддержки всех нужных объектов.
Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.

В зависимости от сложности структуры, хранящей разделяемые объекты, особенно если имеется большое количество легковесов,
то может увеличиваться время на поиск нужного легковеса.

### 4.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Легковес (Flyweight / Object Pool)**:

* экономия оперативной памяти

Минусы применения паттерна **Легковес (Flyweight / Object Pool)**:

* расход процессорного времени на поиск/вычисление контекста
* усложнение кода программы из-за введения множества дополнительных классов

### 4.4.5. Применение паттерна в автотестах

#### 4.4.5.1. Пул страниц

##### До применения паттерна

*Пример*

```java

```

Другой пример - использование страницы.
Вам не нужно ждать, пока откроется нужная страница, если все тесты начинаются с одной страницы.
Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать,
пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных.
Вместо того, чтобы работать с реальной базой данных, мы можем запустить необходимое количество контейнеров базы данных на разных портах
(это можно сделать с помощью Docker или другого инструмента виртуализации) и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. д.

##### После применения паттерна

*Пример*

```java

```

#### 4.4.5.2. Пул тестовых данных

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

***

# 5. Поведенческие паттерны

## 5.1. Паттерн Цепочка обязанностей (Chain of Invocations / Fluent)

### 5.1.1. Структура паттерна

### 5.1.2. Шаги реализации паттерна

1. **

2. **

3. **

### 5.1.3. Применимость паттерна

1. **

2. **

3. **

### 5.1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна ****:

1. **

Минусы применения паттерна ****:

1. **

### 5.1.5. Применение паттерна в автотестах

#### 5.1.5.1. Флуент фасад

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();
  assertThat(homePage.isSignedIn(user));  
}
```

Второй паттерн, о котором мы собирались поговорить, - это Chain of Invocations.
Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.
Например, пользователь находится на странице входа и нажимает какую-то кнопку.
Написав код по старинке, мы не будем уверены, находится ли он все еще на странице входа или уже на главной странице.

А теперь представьте, если бы в вашем тесте было 50 подобных методов.
Вы не можете быть уверены, можете ли вы вызвать их сразу, или они зависят от некоторого порядка,
или даже они не могут быть вызваны после того, как один из них был выполнен.
Например, могу ли я нажать на диалоговое окно подсказки, если я не ввел ни одного символа в поле ввода?
Наверное, нет, потому что на данный момент его еще нет!

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив Fluent Invocations, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

Обычно, если вы хотите прервать цепочку методов,
все, что вам нужно сделать, это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.
На этом этапе разработчик должен остановиться и подумать о следующем методе, который будет вызван в тестовом сценарии, прежде чем делать это.

Цепочку вызовов легко реализовать.
Все, что вам нужно сделать, это вернуть значение в каждом методе объекта страницы. Это может быть это, какое-то значение или любой другой объект,
например, следующий объект страницы после вызова метода (переход на другую страницу).

Этот шаблон не помогает значительно сократить код (это не его основная цель),
но это позволяет вам не повторяться, помещая объект снова и снова перед вызовом его методов.
Также IMO это делает код немного красивее.



## 5.2. Паттерн Стратегия (Strategy)

### 5.2.1. Структура паттерна

### 5.2.2. Шаги реализации паттерна

1. **

2. **

3. **

### 5.2.3. Применимость паттерна

1. **

2. **

3. **

### 5.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Стратегия (Strategy)**:

Шаблон стратегии используется всякий раз, когда мы хотим иметь более одной реализации одного и того же действия / последовательности действий,
что делается иначе. В зависимости от контекста мы могли выбрать реализацию.

Самый простой пример - регистрация пользователя. Возможно, вы захотите иметь две разные реализации этого конкретного действия.
Первый - это фактический поток переходов по страницам для успешной регистрации пользователя.
Другой - короткий вызов API, который вызывается, когда для теста нужен новый пользователь.

Возможно, вы не захотите вызывать «долгую» регистрацию каждый раз в своих тестах.
Но иногда он может понадобиться, например, когда вы подтверждаете фактическую регистрацию через Интернет.
И наоборот, мы хотим, чтобы создание новых пользователей для тестирования было быстрым и надежным. Поэтому здесь подойдет REST-регистрация.

Стратегия помогает сделать нашу среду автоматизации тестирования более гибкой и простой в обслуживании за счет разделения концепций.
Опять же, вам нужно быть осторожным и не применять его в ситуациях, когда вы можете обойтись без него.

Минусы применения паттерна **Стратегия (Strategy)**:

### 5.2.5. Применение паттерна в автотестах

#### 5.2.5.1. 

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна


*Пример*

```java

```

*Пример*

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)