Java_QA / Level 2. Medium - Продвинутые темы / Урок 02. Паттерны проектирования. PageFactory

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Паттерны проектирования GOF

***Шаблон проектирования или паттерн*** в разработке программного обеспечения —
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

## 1.1. История

В **1970-е** годы архитектор **Кристофер Александр** составил набор шаблонов проектирования. 
В области архитектуры эта идея не получила такого развития, как позже в области программной разработки.

В **1987** году **Кент Бэк (Kent Beck)** и **Вард Каннингем (Ward Cunningham)** взяли идеи Александра и 
разработали шаблоны применительно к разработке программного обеспечения для разработки графических оболочек на языке **Smalltalk**.

В **1988** году **Эрих Гамма (Erich Gamma)** начал писать докторскую диссертацию при цюрихском университете 
об общей переносимости этой методики на разработку программ.

В **1989—1991** годах **Джеймс Коплин (James Coplien)** трудился над разработкой идиом для программирования 
на **C++** и опубликовал в **1991** году книгу **Advanced C++ Idioms**.

В этом же году **Эрих Гамма** заканчивает свою докторскую диссертацию и переезжает в США, 
где в сотрудничестве с **Ричардом Хелмом (Richard Helm)**, **Ральфом Джонсоном (Ralph Johnson)** и **Джоном Влиссидесом (John Vlissides)** 
публикует книгу **Design Patterns — Elements of Reusable Object-Oriented Software**. 
В этой книге описаны **23 шаблона проектирования**. 
Также команда авторов этой книги известна общественности под названием **Банда четырёх» (Gang of Four, часто сокращается до GoF)**. 
Именно эта книга стала причиной роста популярности шаблонов проектирования.

## 1.2. 23 паттерна проектирования GOF

![23 паттерна проектирования GOF](./_Files/1.%20Patterns/01.png "23 паттерна проектирования GOF")

**23 паттерна проектирования**:

* *Порождающие*

1. **Одиночка (Singleton)**
2. **Фабричный метод (Factory Method)**
3. *Абстрактная фабрика (Abstract Factory)*
4. **Строитель (Builder)**
5. *Прототип (Prototype)*

* *Структурные*

6. **Декоратор (Decorator)**
7. **Заместитель (Proxy)**
8. **Фасад (Facade)**
9. **Приспособленец (Flyweight)**
10. *Адаптер (Adapter)*
11. *Мост (Bridge)*
12. *Компоновщик (Composite)*

* *Поведенческие*

13. **Цепочка обязанностей (Chain of responsibility)**
14. *Команда (Command)*
15. *Интерпретатор (Interpreter)*
16. *Итератор (Iterator)*
17. *Посредник (Mediator)*
18. *Хранитель (Memento)*
19. *Наблюдатель (Observer)*
20. *Состояние (State)*
21. *Стратегия (Strategy)*
22. *Шаблонный метод (Template method)*
23. *Посетитель (Visitor)*

***


## 1.1. Паттерн (Data Transfer Object)

***Data Transfer Object*** - паттерн, представляющий собой класс, содержащий данные без какой-либо логики для работы с ним.
По сути это простой класс.

![Паттерн Data Transfer Object](./_Files/1.%20Patterns/02.jpg "Паттерн Data Transfer Object")

Мотивация для его использования заключается в том, что связь между процессами обычно осуществляется с
использованием удаленных интерфейсов (например, веб-служб), где каждый вызов является дорогостоящей операцией.
Поскольку большая часть стоимости каждого вызова связана со временем двустороннего обмена между клиентом и сервером,
одним из способов уменьшения количества вызовов является использование объекта (DTO),
который объединяет данные, которые были бы переданы. несколькими вызовами, но обслуживается только одним вызовом.

Разница между объектами передачи данных и бизнес-объектами или объектами доступа к данным заключается в том,
что DTO не имеет никакого поведения, кроме хранения, извлечения, сериализации и десериализации своих собственных данных
(мутаторов, средств доступа, синтаксических анализаторов и сериализаторов).
Другими словами, DTO - это простые объекты, которые не должны содержать никакой бизнес-логики,
но могут содержать механизмы сериализации и десериализации для передачи данных по сети.

### 1.1.1. Структура паттерна

![Структура паттерна Data Transfer Object](./_Files/1.%20Patterns/02.jpg "Структура паттерна Data Transfer Object")

Объекты передачи данных (Data Transfer Objects)- это общедоступные (статические) классы без методов,
кроме предоставленного компилятором конструктора по умолчанию, имеющие только общедоступные поля,
ограниченные легко сериализуемыми типами: т.е.

DTO эквивалентно структуре в C. Предлагается (хотя и не требуется) ), что тип DTO расширяет базовый класс DTO.

Типы, которые могут использоваться в DTO, ограничены:

Primitive types
Wrapper classes for the primitive types
String
enum
Version
Data Transfer Objects
List
Set
Map
array

List, Set, Map и array Агрегаты должны содержать только объекты перечисленных типов.

Граф объектов из объекта передачи данных должен быть деревом (т. Е. Не иметь циклов), чтобы упростить сериализацию и десериализацию. Класс DTO также имеет некоторые другие особые требования:
public – Only public classes with public members work as DTO.
static – Fields must not be static but inner classes must be static.
no-arg constructor – To allow instantiation before setting the fields.
extend – DTOs can extend another DTO.
no generics – DTOs should never have a variable generic signature because this makes serialization really hard.

### 1.1.2. Шаги реализации паттерна



### 1.1.3. Применимость паттерна



### 1.1.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна:

1. *Необходимо передавать в метод в качестве параметра множество примитивных значений за раз.*

Минусы применения паттерна:

1. **

### 1.1.5. Применение паттерна в автотестах

#### 1.1.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

***

# 2. Порождающие паттерны

***Порождающие паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том,
как создавать объекты.

![Порождающие паттерны](./_Files/1.%20Patterns/02.jpg "Порождающие паттерны")

Обычная форма создания объекта может привести к проблемам проектирования или увеличивать сложность конструкции.
Порождающие паттерны проектирования решают эту проблему, определённым образом контролируя процесс создания объекта.
Порождающие паттерны позволяют сделать систему независимой от способа создания, композиции и представления объектов в системе.

## 1.2. Паттерн Singleton

***Одиночка (Singleton)*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

![Паттерн Singleton](./_Files/1.%20Patterns/02.jpg "Паттерн Singleton")

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, 
который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. 
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

### 1.2.1. Структура паттерна

![Структура паттерна  Singleton](./_Files/1.%20Patterns/03.jpg "Паттерн Singleton")

1. *Одиночка (Singleton)*

***Одиночка (Singleton)*** - класс определяющий статический метод **getInstance**, 
который возвращает единственный экземпляр своего класса.

Конструктор **одиночки** должен быть скрыт от клиентов. 
Вызов метода **getInstance** должен стать единственным способом получить объект этого класса.

### 1.2.2. Шаги реализации паттерна



### 1.2.3. Применимость паттерна

1. *В программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам*

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода. 
Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

2. *Больше контроля над глобальными переменными*

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса, 
поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, 
поменяв код в одном месте (метод **getInstance**).

### 1.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Singleton**:

* гарантия наличие единственного экземпляра класса
* предоставление к единственному экземпляру класса глобальной точки доступа
* реализация отложенной инициализацию объекта-одиночки

Минусы применения паттерна **Singleton**:

* нарушение принципа единственной ответственности класса
* маскирование плохого дизайна
* проблемы многопоточности
* требование постоянного создания Mock-объектов при юнит-тестировании.

### 1.2.5. Применение паттерна в автотестах

#### 1.2.5.1. Передача тестовых данных в автотестах

##### До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

##### После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja

## 1.3. Паттерн Factory Method

***Factory Method*** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![Паттерн Factory Method](./_Files/1.%20Patterns/04.jpg "Паттерн Factory Method")

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, 
а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, 
но делать это будет фабричный метод.

### 1.3.1. Структура паттерна

![Структура паттерна  Factory Method](./_Files/1.%20Patterns/05.jpg "Паттерн Factory Method")

### 1.3.2. Шаги реализации паттерна



### 1.3.3. Применимость паттерна



### 1.3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Factory Method**:

Необходимо создание объектов с заранее неизвестным типом.

Необходимо наличие системы расширяемой и независимой от процесса создания новых объектов: 
в нее можно легко вводить новые классы, объекты которых система должна создавать.

Необходимо делегировать создание новых объектов из базового класса классам наследникам.

Минусы применения паттерна **Factory Method**:

#### 1.3.5.1. Фабрика драйверов WebDriverFactory

##### До применения паттерна



##### После применения паттерна



#### 1.3.4.2. Фабрика страниц Page Factory

***Page Factory*** - паттерн, который моделирует объект страницы.
Page Factory is an extension to Page Object pattern. It helps to encapsulate page’s attributes and methods even more by providing FindBy annotations.

Pay attentions to PageFactory#initElements invocation.
This static helper initializes all fields with FindBy annotations on the page, which will be found on it on each call.
The main advantage is the fact that now we work directly with fields, buttons, windows etc.
and do not worry about low level driver’s interactions exactly the same way our app users do.

Composition of Page Elements

Any web, desktop or mobile application consists of repeatable elements, and logic of their usage should be implemented again and again in our tests.
For instance, every menu has list of links, every table has rows and columns, every form has input fields.
In real life when we work with those elements we do not separate those components from the main element consisting them.

Thanks to Composition we could implement some elements once and reuse them every time we need them.
Thus it helps to avoid code duplication by composing different web elements into widgets (high-level elements), like tables, menus, forms.
This significantly reduces costs of extending and scaling of test automation framework when, for example new Page Objects needs to be created.

##### До применения паттерна



##### После применения паттерна



#### 1.3.4.3. Фабрика элементов Element Factory

##### До применения паттерна



##### После применения паттерна



#### 1.3.4.4. Фабрика тестовых данных

##### До применения паттерна

*Пример*

```java
class User1 {
    private String firstName;
    private String lastName;

    public User1() {}
    
    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
}

class User2 {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    public User2() {}

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
}

public void createUser1 (User1 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    
}

public void createUser2 (User2 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    age.enter(user.getAge());
    isMarried.check(user.getIsMarried());
}
```

##### После применения паттерна

*Пример*

```java

abstract class User {
    private String firstName;
    private String lastName;

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    abstract void someMethod();
}

class User1 extends User {
    public User1() { }
    public void someMethod() { }
}

class User2 extends User {
    private int age;
    private boolean isMarried;

    public User2() { }

    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
    public void someMethod() { }
}

class UserFactory
{
    public static User getUser(String userType) {
        switch (userType) {
            case "user1":
                User1 user1 = new User1();
                user1.setFirstName("First Name");
                user1.setLastName("Last Name");
                return user1;
            case "user2":
                User2 user2 = new User2();
                user2.setFirstName("First Name");
                user2.setLastName("Last Name");
                user2.setAge(40);
                user2.setIsMarried(false);
                return user2;
            default:
                throw new RuntimeException("Incorrect user type");
        }
    }
}
```

*Пример*

```java
public void createUser(String userType) {
    switch (userType) {
        case "user1":
            User1 user1 = UserFactory.getUser("user1");
            firstName.enter(user1.getFirstName());
            lastName.enter(user1.getLastName());
            age.enter(user1.getAge());
            isMarried.check(user1.getIsMarried());
            break;
        case "user2":
            User2 user2 = UserFactory.getUser("user2");
            firstName.enter(user2.getFirstName());
            lastName.enter(user2.getLastName());
            age.enter(user2.getAge());
            isMarried.check(user2.getIsMarried());
            premium.enter(user2.getPremium());
            break;
        default:
            throw new RuntimeException("Incorrect user type");
    }
}
```

Инициализация экземпляров **WebDriver** для разных браузеров.
Создание объектов страниц в **PageFactory**.

https://javanerd.ru/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4/

## 1.4. Паттерн Builder

***Builder*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

### 1.4.1. Структура паттерна



### 1.4.2. Шаги реализации паттерна



### 1.4.3. Применимость паттерна



### 1.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Builder**:

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и с помощью современных IDE подсказок более интуитивно понятным.

Минусы применения паттерна **Builder**:

### 1.4.5. Применение паттерна в автотестах

#### 1.4.5.1. Билдер тестовых данных

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

    public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}
```

*Пример*

```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

https://habr.com/ru/company/otus/blog/552412/
https://www.softwaretestinghelp.com/design-patterns-in-java/#Builder_Pattern_In_Java

## 1.5. Паттерн Abstract Factory

***Abstract Factory*** — паттерн, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.

### 1.5.1. Структура паттерна



### 1.5.2. Шаги реализации паттерна



### 1.5.3. Применимость паттерна



### 1.5.4. Плюсы и минусы применения паттерна



### 1.5.5. Применение паттерна в автотестах

#### 1.5.5.1. 

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```
http://design-pattern.ru/patterns/abstract-factory.html

https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b0%d0%b1%d1%81%d1%82%d1%80%d0%b0%d0%ba%d1%82%d0%bd%d0%b0%d1%8f-%d1%84%d0%b0%d0%b1%d1%80%d0%b8%d0%ba%d0%b0/

***

# 2. Структурные паттерны

***Cтруктурные паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том,
как из классов и объектов образуются более крупные структуры.

![Структурные паттерны](./_Files/1.%20Patterns/03.jpg "Структурные паттерны")

Структурные паттерны проектирования упрощают проектирование путем выявления
простого способа реализовать отношения между субъектами.

## 2.1. Паттерн Декоратор (Decorator)

***Декоратор (Decorator)*** - паттерн, который позволяет динамически добавлять объектам новую функциональность.
Декораторы предоставляют гибкую альтернативу подклассам для расширения функциональности.

Паттерн **Декоратор (Decorator)** имеет альтернативное название — **Обёртка**.
Оно более точно описывает суть паттерна: целевой объект-оригинал помещается в другой объект-обёртку,
который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы,
с каким объектом работать — оригиналом или обёрткой.
Вы можете использовать несколько разных обёрток одновременно —
результат будет иметь объединённое поведение всех обёрток сразу.

Пример использования паттерна в библиотеке **Selenium** - **EventFiringDecorator** и **FieldDecorator**.

![Паттерн Decorator](./_Files/1.%20Patterns/11.jpg "Паттерн Decorator")

### 2.1.1. Структура паттерна

![Структура паттерна  Decorator](./_Files/1.%20Patterns/12.jpg "Паттерн Decorator")

1. *Базовый компонент (Component)*

***Базовый компонент (Component)*** – общий интерфейс / абстрактный класс с общими методами для всех
**Конкретных компонентов (ConcreteComponent)** и **Базового декоратора (Decorator)**.

2. *Конкретный компонент (ConcreteComponent)*

***Конкретный компонент (ConcreteComponent)*** – конкретный класс со своей бизнес логикой, реализующий **Базовый компонент (Component)**,
функциональность которого необходимо модифицировать декораторами.

Декоратор способен работать как с самим исходным компонентом, так и его наследниками.
Однако, не следует использовать большое количество декораторов с тяжеловесными классами,
так как это может повлечь за собой большие накладные расходы.

3. *Базовый декоратор (Decorator)*

***Базовый декоратор (Decorator)*** – базовый класс для всех декораторов, реализующий **Базовый компонент (Component)** и
хранящий ссылку на экземпляр **Конкретного компонента (ConcreteComponent)**.

**Базовый декоратор (Decorator)** реализует тот же самый интерфейс чтобы:

* замещать конкретный компонент
* создавать цепочку декораторов

4. *Конкретный декоратор (ConcreteDecorator)*

***Конкретный декоратор (ConcreteDecorator)*** - конкретный класс, наследующий **Базовый декоратор (Decorator)** и
добавляющий определенные функции компоненту.

Добавление новой функциональности осуществляется подменой экземпляра оригинального компонента.
Такой объект может использоваться как вместо декорируемого компонента, так и самостоятельно.

**Конкретный декоратор (ConcreteDecorator)**:

* создает механизм подключения и хранения компонента
* реализует переадресацию всех методов и свойств
* добавляет новые свойства и методы

### 2.1.2. Шаги реализации паттерна

1. *Проверка наличия в задаче одного основного компонента и нескольких дополнительных опциональных дополнений или надстроек над ним*

2. *Создание Базового компонента*

Базовый компонент описывает общие методы как для основного компонента, так и для его дополнений.

3. *Создание Конкретного компонента*

Конкретный компонент содержит основную бизнес-логику.

4. *Создание Базового декоратора*

Базовый декоратор имеет поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора делегируют действие вложенному объекту.

5. *Создание Конкретных декораторов*

Конкретный декоратор выполняет свою добавочную функцию,
а затем (или перед этим) вызывает эту же операцию обёрнутого объекта.

### 2.1.3. Применимость паттерна

1. *Реализация множественного наследования*

В таких языках как **Java** и **C#** нет множественного наследования классов.
И когда требуется реализовать множество различных функциональностей и их комбинаций,
то для каждой такой функциональности и их комбинаций придется наследовать отдельный класс.
Структура классов при этом может очень сильно разрастись, что в свою очередь усложнит ее понимание и поддержку.

Применение паттерна **Декоратор (Decorator)** позволяет реализовать аналог множественного наследования, в языках его не поддерживающих,
путем вложения одного декоратора в другой и создания из них цепочек, поскольку паттерн реализует интерфейс исходного компонента.
Таким образом у объектов расширяются возможности без использования одиночного наследования.
Что в свою очередь разрешает проблему усложнения структуры классов путем уменьшения числа создаваемых классов
по сравнению с результатами использования одиночного наследования.

2. *Невозможность расширить обязанности объекта с помощью наследования*

Во многих языках программирования есть ключевое слово, с помощью которого можно заблокировать наследование класса.

Применение паттерна **Декоратор (Decorator)** позволяет добавить функциональность классу,
определение которого может быть скрыто или иным образом недоступно для подклассов, то есть когда наследование невозможно.

3. *Динамическое добавление новых возможностей на лету, незаметно для кода, который их использует*

Применение паттерна **Декоратор (Decorator)** обеспечивает динамическое добавление объекту новых функциональных возможностей.
Объекты помещаются в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс,
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

Позволяет комбинировать классы в процессе выполнения программы. дважды применить один и тот же Декоратор.

### 2.1.4. Плюсы и минусы применения паттерна

Плюсы паттерна **Decorator**:

* большая гибкость, чем у наследования
* добавление обязанности на лету
* добавление нескольких новых обязанностей сразу
* изменение функциональности не только применением самих Декораторов, но и различным порядком их вложенности

Минусы применения паттерна **Decorator**:

* трудность конфигурирования многократно обёрнутых объектов
* обилие крошечных классов
* несколько мелких объектов вместо одного объекта на все случаи жизни

### 2.1.5. Применение паттерна в автотестах

#### 2.1.5.1. Декоратор драйвера

##### До применения паттерна

Страница (Page Objects)

*Пример*

```java

```

Интерфейс **WebElement** не всегда удобно использовать.
Его невозможно расширить и добавить свои методы для работы с элементом.
Использовать свои методы можно только создавая классы-обвертки(CheckBox, Button и т.п.),
которые просто делегируют вызов методов настоящему **WebElement**.

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

#### 2.1.5.2. Декоратор тестовых данных

##### До применения паттерна



##### После применения паттерна



## 2.2. Паттерн Заместитель (Proxy)

***Заместитель (Proxy)*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заместители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Паттерн **Заместитель (Proxy)** предлагает создать новый объект-заместитель, имеющий тот же интерфейс, что и оригинальный объект.
Ни интерфейс ни функциональность замещенного объекта, с точки зрения клиента, не изменяются.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр оригинального объекта и
переадресовывал бы ему всю реальную работу.

![Паттерн Proxy](./_Files/1.%20Patterns/13.jpg "Паттерн Proxy")

### 2.2.1. Структура паттерна

![Структура паттерна Proxy](./_Files/1.%20Patterns/14.jpg "Структура паттерна Proxy")

1. *Базовый объект (Subject)*

***Базовый объект (Subject)*** – общий интерфейс / абстрактный класс для всех замещаемых объектов и заместителей.

Конкретная реализация скрыта от **Заместителя (Proxy)** и он может работать практически со всеми **Реальными объектами (RealSubject)**,
поддерживающими данный интерфейс.

2. *Реальный объект (RealSubject)*

***Реальный объект (RealSubject)*** – конкретный класс с полезной бизнес логикой, реализующий **Базовый объект (Subject)**,
который будет замещен **Заместителем**.

3. *Заместитель (Proxy)*

***Заместитель (Proxy)*** - класс, реализующий **Базовый объект (Subject)**, который замещает **Конкретный объект (RealSubject)** и перехватывает обращения к нему.

**Заместитель (Proxy)** :

* выполняет дополнительные действия (инициализацию, логирование и т д.) до или после вызова вложенного в него **Конкретного объекта (RealSubject)**
* отвечает за создание и удаление **Конкретного объекта (RealSubject)**.

Паттерн не накладывает ограничения на вложения одного заместителя в другой.
Такой подход позволяет строить их различные конфигурации в процессе работы программы.

### 2.2.2. Шаги реализации паттерна

1. *Определение интерфейса, который бы сделал заместитель и оригинальный объект взаимозаменяемыми*

2. *Создание Заместителя*

Заместитель должен содержать ссылку на оригинальный объект. Чаще всего, оригинальный объект создаётся самим заместителем.
В редких случаях заместитель получает готовый оригинальный объект от клиента через конструктор.

3. *Реализация методов Заместителя в зависимости от его предназначения*

В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос оригинальному объекту.

4. *Создание Фабрики*

Фабрика будет решать, какой из объектов создавать — заместитель или оригинальный объект.

5 *Реализация ленивой инициализации оригинального объекта*

При первом обращении клиента к методам заместителя.

### 2.2.3. Применимость паттерна

1. *Ленивая инициализация (Виртуальный Прокси (Virtual Proxy))*

Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда,
когда он действительно понадобится.

2. *Защита доступа (Защищающий Прокси (Protection Proxy))*

Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа.
Например, если ваши объекты — это важная часть операционной системы,
а пользователи — сторонние программы (хорошие или вредоносные).

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. *Локальный запуск сервиса (Удаленный Прокси (Remote Proxy))*

Когда настоящий сервисный объект находится на удалённом сервере.
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. *Логирование запросов (Логирующий Прокси (Logging Proxy))*

Когда требуется хранить историю обращений к сервисному объекту.
Заместитель может сохранять историю обращения клиента к сервисному объекту.

5. *Кеширование объектов (Умная Ссылка (Smart Reference))*

Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.
Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными.
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект.
Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

### 2.2.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Proxy**:

* контроль оригинального объекта незаметно для клиента
* возможность работы, даже если оригинальный объект ещё не создан
* возможность контроля жизненного цикла служебного объекта

Минусы применения паттерна **Proxy**:

* усложнение кода программы из-за введения дополнительных классов
* увеличение времени отклика от сервиса

### 2.2.5. Применение паттерна в автотестах

#### 2.2.5.1. Создание заместителя для WebDriver в UI автотестах Selenium WebDriver

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

#### 2.2.5.2.



## 2.3. Паттерн Facade

***Фасад*** — паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

![Паттерн Facade](./_Files/1.%20Patterns/15.jpg "Паттерн Facade")

**Фасад** - простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь,
используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.
То есть содержит интерфейс, содержащий только методы для решения определённой задачи или
предоставляющий определённую абстракцию исходной системы.

### 2.3.1. Структура паттерна

![Структура паттерна Facade](./_Files/1.%20Patterns/16.jpg "Структура паттерна Facade")

1. *Подсистема (Subsystem)*

***Подсистема (Subsystem)*** - подсистема из множества разнообразных классов.

Нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее, чтобы заставить ее классы что-то делать.

2. *Фасад (Facade)*

***Фасад (Facade)*** - класс, который предоставляет быстрый доступ к определённой функциональности подсистемы.

Фасад выполняет:

* переадресацию запросов классам подсистемы

Классы подсистемы не знают о существовании Фасада и работают друг с другом напрямую.

* уменьшение числа параметров методов подстановкой заранее определенных значений

Часть исходных методов и свойств будут недоступны через Фасад, т.к. не играют роли для решения поставленной задачи

* создание новых методов, которые объединяют вызовы объектов подсистемы и/или добавляют свою логику

Фасад не является суммой всех методов объектов, входящих в систему.
Создание такой обобщенной версии приведет к появлению **божественного объекта**,
то есть интерфейса с огромным числом методов, без четко выраженной цели и порождающего большое количество зависимостей.
В итоге – прямо противоположный паттерну результат.

Дополнительный фасад можно ввести, чтобы не захламлять единственный фасад разнородной функциональностью.
Он может использоваться как клиентом, так и другими фасадами.

3. *Клиент (Client)*

***Клиент (Client)*** - класс, который использует фасад вместо прямой работы с объектами сложной подсистемы.

### 2.3.2. Шаги реализации паттерна

1. *Определение возможности создания более простого интерфейса, чем тот который предоставляется сложная подсистема*

Этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.

2. *Создание фасада, реализующего интерфейс подсистемы*

Фасад переадресовывает вызовы клиента нужным объектам подсистемы.

Фасад заботиться о том, чтобы правильно инициализировать объекты подсистемы

3. *Внедерение дополнительных фасадов*

### 2.3.3. Применимость паттерна

1. *Предоставление простого или урезанного интерфейса к сложной подсистеме*

Часто подсистемы усложняются по мере развития программы.
Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды,
но вместе с тем, применять подсистему без настройки становится труднее.
Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

2. *Разложение подсистемы на отдельные слои*

Фасады используются для определения точек входа на каждый уровень подсистемы.
Если подсистемы зависят друг от друга, то зависимость можно упростить,
разрешив подсистемам обмениваться информацией только через фасады.

### 2.3.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Facade**:

* упрощает взаимодействие клиента с подсистемами
* изолирует клиентов от компонентов сложной подсистемы
* уменьшает зависимости клиентского кода от внутренней работы системы.

Минусы применения паттерна **Facade**:

* фасад рискует стать божественным объектом, привязанным ко всем классам программы

### 2.3.5. Применение в автотестах

#### 2.3.5.1. Скрытие технических деталей прохождения UI теста

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

#### 2.3.5.2.



## 2.4. Паттерн Flyweight

***Flyweight*** - паттерн, который позволяет вместить большее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой (внутреннее и внешнее),
вместо хранения одинаковых данных в каждом объекте.

![Паттерн Flyweight](./_Files/1.%20Patterns/17.jpg "Flyweight")

***Внутреннее состояние*** - неизменяемые данные, которые хранятся в легковесном объекте и не используются за пределами объекта.
Внутреннее состояние не зависит от контекста, в котором используется объект-легковес.

***Внешнее состояние*** - изменяющиеся данные, которые не хранятся в легковесном объекте и используются за пределами объекта.
Внешнее состояние зависит от контекста. Клиенты несут ответственность за переход во внешнее состояние.

Паттерн **Flyweight** предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием,
а оно имеет не так много вариаций.

### 2.4.1. Структура паттерна

![Структура паттерна Flyweight](./_Files/1.%20Patterns/18.jpg "Flyweight")

1. *Базовый легковес (Flyweight)*

***Базовый легковес (Flyweight)*** - интерфейс, общий для всех легковесов,
через который легковесы могут получать внешнее состояние или воздействовать на него.

2. *Конкретный легковес (ConcreteFlyweight)*

***Конкретный легковес (ConcreteFlyweight)*** - класс, который реализует **Базовый легковес (Flyweight)**
и добавляет хранилище для внутреннего состояния, если оно есть.

**Конкретный легковес (ConcreteFlyweight)** содержит состояние, которое повторялось во множестве первоначальных объектов.
Один и тот же легковес можно использовать в связке со множеством контекстов.

**Контекст**:

* содержит внешнюю часть состояния, уникальную для каждого объекта
* связан с одним из легковесов, хранящих внутреннюю часть состояния

3. *Фабрика легковесов (FlyweightFactory)*

***Фабрика легковесов (FlyweightFactory)*** - класс, который управляет созданием и повторным использованием легковесов.

Клиент должен запрашивать из фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
Фабрика легковесов получает запросы, в которых указано желаемое состояние легковеса.
Все созданные раннее легковесы хранятся в пуле. Если легковес с таким состоянием уже создан,
фабрика легковесов сразу его возвращает из пула, а если нет — создаёт новый объект, помещает его в пул и возвращает клиенту.

4. *Клиент (Client)*

***Клиент (Client)*** - класс, который вычисляет или хранит контекст, то есть внешнее состояние легковесов.

Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.

### 2.4.2. Шаги реализации паттерна

1. *Разделение полей класса, который станет легковесом на две части: внутреннее и внешнее состояние*

2. *Создание фабрики, которая будет кешировать и повторно отдавать уже созданные объекты*

3. *Хранение или вычисление значения внешнего состояния (контекст) клиентом и передача его в методы объекта легковеса*

### 2.4.3. Применимость паттерна

1. *Большое количество однообразных объектов*

При использовании большого количества однообразных объектов происходит выделение
большого количества памяти для поддержки всех нужных объектов.
Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.

В зависимости от сложности структуры, хранящей разделяемые объекты, особенно если имеется большое количество легковесов,
то может увеличиваться время на поиск нужного легковеса.

### 2.4.4. Плюсы и минусы применения паттерна

Плюсы применения паттерна **Flyweight**:

* экономия оперативной памяти

Минусы применения паттерна **Flyweight**:

* расход процессорного времени на поиск/вычисление контекста
* усложнение кода программы из-за введения множества дополнительных классов

### 2.4.5. Применение паттерна в автотестах

#### 2.4.5.1. Пул страниц

##### До применения паттерна

*Пример*

```java

```

Другой пример - использование страницы.
Вам не нужно ждать, пока откроется нужная страница, если все тесты начинаются с одной страницы.
Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать,
пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных.
Вместо того, чтобы работать с реальной базой данных, мы можем запустить необходимое количество контейнеров базы данных на разных портах
(это можно сделать с помощью Docker или другого инструмента виртуализации) и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. д.

##### После применения паттерна

*Пример*

```java

```

#### 2.4.5.2. Пул тестовых данных

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

***

# 3. Поведенческие паттерны

## 3.1. Паттерн Fluent / Chain of Invocations

### 3.1.1. Структура паттерна



### 3.1.2. Шаги реализации паттерна



### 3.1.3. Применимость паттерна



### 3.1.4. Плюсы и минусы применения паттерна



### 3.1.5. Применение паттерна в автотестах

#### 3.1.5.1. Флуент фасад

##### До применения паттерна

*Пример*

```java

```

##### После применения паттерна

*Пример*

```java

```

*Пример*

```java

```


```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();

  assertThat(homePage.isSignedIn(user));  
}
```

Второй паттерн, о котором мы собирались поговорить, - это Chain of Invocations.
Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.
Например, пользователь находится на странице входа и нажимает какую-то кнопку.
Написав код по старинке, мы не будем уверены, находится ли он все еще на странице входа или уже на главной странице.

А теперь представьте, если бы в вашем тесте было 50 подобных методов.
Вы не можете быть уверены, можете ли вы вызвать их сразу, или они зависят от некоторого порядка,
или даже они не могут быть вызваны после того, как один из них был выполнен.
Например, могу ли я нажать на диалоговое окно подсказки, если я не ввел ни одного символа в поле ввода?
Наверное, нет, потому что на данный момент его еще нет!

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив Fluent Invocations, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

Обычно, если вы хотите прервать цепочку методов,
все, что вам нужно сделать, это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.
На этом этапе разработчик должен остановиться и подумать о следующем методе, который будет вызван в тестовом сценарии, прежде чем делать это.

Цепочку вызовов легко реализовать.
Все, что вам нужно сделать, это вернуть значение в каждом методе объекта страницы. Это может быть это, какое-то значение или любой другой объект,
например, следующий объект страницы после вызова метода (переход на другую страницу).

Этот шаблон не помогает значительно сократить код (это не его основная цель),
но это позволяет вам не повторяться, помещая объект снова и снова перед вызовом его методов.
Также IMO это делает код немного красивее.

## 3.2. Паттерн Strategy

### 3.2.1. Структура паттерна



### 3.2.2. Шаги реализации паттерна



### 3.2.3. Применимость паттерна



### 3.2.4. Плюсы и минусы применения паттерна



### 3.2.5. Применение паттерна в автотестах

#### 3.2.3.1. Преимущества

Шаблон стратегии используется всякий раз, когда мы хотим иметь более одной реализации одного и того же действия / последовательности действий,
что делается иначе. В зависимости от контекста мы могли выбрать реализацию.

Самый простой пример - регистрация пользователя. Возможно, вы захотите иметь две разные реализации этого конкретного действия.
Первый - это фактический поток переходов по страницам для успешной регистрации пользователя.
Другой - короткий вызов API, который вызывается, когда для теста нужен новый пользователь.

Возможно, вы не захотите вызывать «долгую» регистрацию каждый раз в своих тестах.
Но иногда он может понадобиться, например, когда вы подтверждаете фактическую регистрацию через Интернет.
И наоборот, мы хотим, чтобы создание новых пользователей для тестирования было быстрым и надежным. Поэтому здесь подойдет REST-регистрация.

Стратегия помогает сделать нашу среду автоматизации тестирования более гибкой и простой в обслуживании за счет разделения концепций.
Опять же, вам нужно быть осторожным и не применять его в ситуациях, когда вы можете обойтись без него.

#### 3.2.3.2. Недостатки



### 3.2.4. Применение в автотестах

#### 3.2.4.1. До применения паттерна

*Пример*

```java

```

#### 3.2.4.2. После применения паттерна


*Пример*

```java

```

*Пример*

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)