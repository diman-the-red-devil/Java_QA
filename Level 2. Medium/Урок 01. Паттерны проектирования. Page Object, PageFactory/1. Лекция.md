Java_QA / Level 2. Medium - Продвинутые темы / Урок 02. Page Object, PageFactory

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

***Шаблон проектирования или паттерн*** в разработке программного обеспечения —
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. 
Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, 
которую нужно будет ещё подстроить под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. 
Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, 
реализация которого может отличаться в двух разных программах.

Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами,
без определения того, какие конечные классы или объекты приложения будут использоваться.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, 
а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

***

# 2. Зачем нужны паттерны?

Вы можете вполне успешно работать, не зная ни одного паттерна. 
Более того, вы могли уже не раз реализовать какой-то из паттернов, даже не подозревая об этом.

Но осознанное владение инструментом как раз и отличает профессионала от любителя. 
Вы можете забить гвоздь молотком, а можете и дрелью, если сильно постараетесь. 
Но профессионал знает, что главная фишка дрели совсем не в этом. 

Итак, зачем же знать паттерны?

* *проверенные решения* 

Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. 
До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.

* *стандартизация кода*

Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, 
так как все скрытые проблемы в них уже давно найдены.

* *общий программистский словарь*

Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, 
какой крутой дизайн вы придумали и какие классы для этого нужны.

**Паттерны** - не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда.
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Не существует такого понятия как **хороший паттерн** или **плохой паттерн**. 
Сам термин **паттерн** был придуман в качестве формулировки проблемы и предложенного решения. 
Если задача не разделяет проблему, для которой **паттерн** был придуман – это не значит, 
что он плохой или вышел из моды, просто он не подходит для решения этой задачи. 
Если проблема каким-то образом совпадает и накладывается на этот **паттерн**, значит, стоит его рассмотреть.

Таким образом важно не просто приносить дизайн-паттерны в проект, 
важно понимать их назначение, проблематику, как и чем они могут помочь.

***

# 3. Паттерны в автотестировании 

Изначально классические паттерны были сформулированы давным-давно четверкой, которая выпустила книгу **Design Patterns**.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире.
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, пополняясь новыми паттернами.

Сегодня просматривается тенденция появления подобных паттернов в других областях, в которых накопилась проблематика.
Автоматизация тестирования имеет собственный набор задач, так что существует и набор полезных паттернов проектирования для этой области.

Основными драйверами практически всех паттернов в автоматизации тестирования являются **факторы**:

* *надежность*
* *понятность*
* *гибкость*
* *поддерживаемость*
* *стабильность*

Большая часть этих факторов находится под влиянием разделения компонентов.
В любом тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три **компонента**:

* *тестовая логика* (описание шагов тест кейсов)
* *тестовые данные* (описание данных для тест кейсов)
* *техническая часть* (отвечающая за непосредственное взаимодействие с приложением - вызов функций, клики на экран и т. п.)

Если эти **компоненты** хорошо разделены, тесты начинают хорошо попадать в выше упомянутые **факторы**,
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

Все паттерны можно поделить на группы:

* *структурные паттерны*

***Структурные паттерны*** - паттерны, которые показывают различные способы построения связей между объектами.

* *порождающие паттерны*

***Порождающие паттерны*** - паттерны, которые беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

* *поведенческие паттерны*

***Поведенческие паттерны*** - паттерны, которые заботятся об эффективной коммуникации между объектами.

***

# 4. Структурные паттерны

***Cтруктурные паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том, 
как из классов и объектов образуются более крупные структуры.

Структурные паттерны проектирования упрощают проектирование путем выявления 
простого способа реализовать отношения между субъектами.

***

# 5. Структурные паттерны в автотестировании

***Cтруктурные паттерны в автотестировании*** - паттерны, основная задача которых сводится к структурированию кода тестов,
чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью.
Таким образом, тестовым инженерам, работающим с теми же проблемами, будет проще понять их и изменить, и проще поддерживать.

## 5.1. Паттерн Page Object

***Page Object*** - паттерн, который моделирует объекты страницы в качестве объектов в коде и 
позволяет разделять логику выполнения тестов от их реализации.

![Page Object](./_Files/1.%20Patterns/01.png "Page Object")

### 5.1.1. Структура паттерна

Структура паттерна:

1. Класс *BasePage*
  
***BasePage*** - базовый класс для всех классов моделирующих веб страницы, 
в котором определяются базовые методы для работы с **WebDriver**.

Все классы конкретных веб страниц будут расширять **BasePage**, унаследовав, таким образом, все базовые методы.

2. Класс *<Наименование>Page*

***<Наименование>Page*** - конкретный класс, который расширяет **BasePage** и 
реализует методы для работы с конкретными веб страницами.

При использовании **Page Object** элементы страниц, а также методы непосредственного взаимодействия с ними, 
выносятся в отдельный классы, отвечающие за работу с **HTML** каждой конкретной веб страницы.
К примеру, можно создать отдельные классы для Главной страницы, страницы Авторизации и Регистрации.
 
3. Класс *Test*

***Test*** - класс, который реализует логику тестов.

Правила применения паттерна:

1. У объекта страницы не должно быть никаких утверждений
  
Объекты страницы никогда не должны делать проверки или утверждения.
Это часть теста и всегда должна быть в коде теста, а не в объекте страницы.
Объект страницы должен содержать элементы страницы и методы, с помощью которых можно с ними взаимодействовать.
Но никакой код, связанный с тем, что тестируется, не должен находиться в объекте страницы.

Существует одна, единственная проверка, которая может и должна быть внутри объекта страницы,
а именно проверка того, что страница и, возможно, критические элементы на странице были загружены правильно.
Эта проверка должна выполняться при создании экземпляра объекта страницы.

2. Объект страницы должен представлять значимые элементы страницы, а не обязательно полную страницу.

Класс не обязательно должен представлять собой всю страницу.
Он может быть частью страницы, которая часто используется на сайте (или даже на одной странице).
Например пагинация или блок ссылок.
Нет никакой необходимости моделировать все элементы представленные на странице, 
если в тестах с ними нет никакого взаимодействия. 
Лишний код только ухудшит восприятие и понимание.

### 5.1.2. Применимость



### 5.1.3. Преимущества и недостатки

#### 5.1.3.1. Преимущества

1. *Читаемость*

Код функциональных тестов написанных с использованием **Selenium WebDriver** в основном будет 
состоять из взаимодействий с веб-интерфейсом, который проверяется.
То есть любой код теста будет состоять из последовательностей:

* поиск элемента на странице
* получение свойства элемента или выполнения действия с элементом
* проверка некоторого состояние элемента или системы с помощью различных утверждений

Даже в самом простом тесте читаемость очень плохая, так присутствует много кода **Selenium WebDriver**,
который скрывает цель теста, делая его трудным для восприятия.

Применение паттерна **Page Object** обеспечивает четкое разделение технических деталей (взаимодействие с элементами веб интерфейса) и фактической логикой тестов.
Также паттерн объединяет все действий по работе с конкретной веб-страницей в одном месте (соответствующем классе).

2. *Дублирование*

При написании UI тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами в разных кейсах. 
Что в свою очередь приводит к написанию одинакового кода в разных местах.

Применение паттерна **Page Object** значительно уменьшает количество повторяющегося кода путем создания 
единого места (**объект страницы**) для определения операций, выполняемых на странице вместе разброса этих методов по тестам.

3. *Поддержка*

В любом в пользовательском интерфейсе, часто вносятся как незначительные, так и серьезные изменения.
Это может быть новый дизайн, реструктуризация полей и кнопок,и т д.
Изменения в пользовательском интерфейсе часто нарушают работу нескольких тестов в нескольких местах.
Без применения паттерна **Page Object** локаторы веб элементов на странице и 
методы работы с ними будут разнесены по нескольким классам, что сильно усложнить поддержку кода.

Применение паттерна **Page Object** позволяет легко обновить код, после любого изменения пользовательского интерфейса, 
путем добавления новых элементов, обновления или удаления существующих в одном месте (**объекте страницы**), 
а не исправлять каждый тест, в котором этот интерфейс используется.

4. *Повторное использование*
   
Как уже упоминалось выше при написании тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами.

Применение паттерна **Page Object** обеспечивает сохранение отдельных репозиториев объектов страницы независимо от тестов автоматизации. 
Что в свою очередь позволяет повторно использовать этот репозиторий для разных целей с разными инструментами.
Например, можно интегрировать объектную модель страницы в **Selenium** с **TestNG** / **JUnit** для функционального тестирования
и одновременно с **JBehave** / **Cucumber** для приемочного тестирования.

#### 5.1.3.2. Недостатки



### 5.1.4. Применение в автотестах

#### 5.1.4.1. До применения паттерна

*Пример*

```java
// Тест
public class LoginTest {
    @Test
    public void loginTest() {
        // Страница "Вход"
        // Ввести логин и пароль 
        driver.findElement(By.name("login")).sendKeys("login");
        driver.findElement(By.name("password")).sendKeys("password");
        driver.findElement(By.name("sign-in")).click();
        
        // Стартовая страница
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(driver.findElement(By.tagName("h1")).isDisplayed());
        Assertions.assertEquals(driver.findElement(By.tagName("h1")).getText(), "Стартовая страница", 
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

Очевидно, что во многих тестах потребуется вход с логином и паролем. 
Следовательно, в каждый тест придется копипастить фрагмент кода с входом по логину и паролю.
Если вдруг на странице входа по логину и паролю изменятся локаторы, то придется делать правки во многих местах.
Также по коду невозможно понять что и на какой странице происходит.
И это только небольшой фрагмент кода.

#### 5.1.4.2. После применения паттерна

Страницы (Page Objects)

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}

// Страница "Home"
public class HomePage { 
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
    
    // Конструктор
    public HomePage(WebDriver driver){
        this.driver = driver;
    }
    
    // Отображается элемент?
    public boolean isTextDisplyed() {
        return driver.findElement(tеxtBy).isDisplayed();
    }
    
    // Получение текста 
    public String getText() {
        return driver.findElement(tеxtBy).getText();
    }
}
```

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isTextDisplyed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

После применения паттерна в случае изменения верстки на страницах, нужно будет лишь поправить локаторы в одном классе, 
независимо от того, в скольких классах с тестами используются страницы.
Глядя на код теперь сразу понятно какие действия и на какой странице выполняется.

## 5.2. Паттерн Arrange Act Assert (Given When Then)

**Тест** – это процедура, которая проверяет поведение с целью определить, правильно ли оно функционирует. 
Тестов много видов (**unit**, **интеграционные**, **end-to-end**), но все функциональные тесты по сути делают одно и то же: 
пробуют что-то и сообщают **PASS** или **FAIL**.

***Arrange Act Assert (Подготовка, Действие, Проверка)*** – паттерн, который организует структуру тест-кейсов и задает порядок операций. 
Паттерн **AAA** предоставляет простую единообразную структуру для всех тестов в проекте. 
Это единообразие дает большое преимущество: привыкнув к нему, вы сможете легко прочитать и понять любой тест. 

![Arrange Act Assert](./_Files/1.%20Patterns/02.jpg "Arrange Act Assert")

### 5.2.1. Структура паттерна

Структура теста (метода) при использовании паттерна **AAA**:

1. Секция *Arrange* устанавливает начальные условия для выполнения теста
   
В этой секции выполняются шаги по подготовке тестируемой системы и ее зависимостей в нужное состояние.

Эти шаги должны подготовить тест-кейс:
* создание объектов
* выполнение особых настроек
* подготовка данных 
* передача подготовленных зависимостей
* сохранение выходного значения (если оно есть)
  
и т. д

2. Секция *Act* выполняет тест (обычно представляет одну строку кода)
   
В этой секции выполняются шаги по выполнению основной задачи теста.

Эти шаги должны выполнить тест кейс:
* вызов функции/метода
* вызов api 
* взаимодействие с веб-страницей

и т. д.

3. Секция *Assert* верифицирует результат теста
   
В этой секции выполняются шаги по проверке результата (возвращаемое значение или итоговое состояние тестируемой системы).
  
Эти шаги должны получить ответ на вопрос упал тест или прошел:
* проверка числовых или строковых значений
* проверка множества аспектов системы

и т. д.

В **BDD** паттерн **Подготовка, Действие, Проверка** называется иначе **Если, Когда, Тогда**. 
Язык Gherkin использует шаги **Если, Когда, Тогда** для описания поведенческих сценариев. 
По сути это та же самая формула, что и в **Подготовка, Действие, Проверка (Настрой, Действуй, Проверь)**

Правила применения паттерна:

1. В тесте не должно быть множественных секций arrange, act и assert

Время от времени встречаются тесты с несколькими секциями arrange (подготовка), act (действие) или assert (проверка). 
Обычно они работают так:

![Arrange Act Assert](./_Files/1.%20Patterns/03.jpg "Arrange Act Assert")

Когда присутствует несколько секций действий, разделенных секциями проверки и, возможно, секциями подготовки, это означает, 
что тест проверяет несколько единиц поведения. Такой структуры тестов лучше избегать.
Если есть тест, содержащий серию действий и проверок, то лучше отрефакторить его: выделить каждое действие в отдельный тест.
Иногда допустимо иметь несколько секций действий в тестах. 

2. В тесте не должно быть ветвлений

Наличие в тестах ветвления является антипаттерном. Тест должен представлять собой простую последовательность шагов без ветвлений.
Присутствие ветвления означает, что тест проверяет слишком много всего. Следовательно, такой тест должен быть разбит на несколько тестов.
Ветвление в тестах не дает ничего, кроме дополнительных затрат на сопровождение: команды if затрудняют чтение и понимание тестов.

3. Размеры секций не должны быть слишком большими

* секция подготовки обычно является самой большой из трех

Если она становится слишком большой, лучше выделить отдельные операции подготовки либо 
в приватные методы того же класса теста, либо в отдельный класс-фабрику.

* секция действия обычно состоит всего из одной строки кода

* секция проверки должна содержать одну проверку

Если секция проверки становится большой, то это может быть признаком того, что в коде недостает какой-то абстракции.
Например, вместо того чтобы по отдельности проверять все свойства объекта, возвращенного тестируемой системой, 
возможно, будет лучше добавить методы проверки равенства (equality members) в класс такого объекта. 
После этого объект можно будет сравнивать с ожидаемым значением всего одной командой.

4. Применение данного паттерна оверхед, если в тесте всего одна две проверки

Конечно, паттерн **Assert Object** не должен быть способом написания проверок по умолчанию.
Если вы можете завершить тест одним или двумя проверками, то, вероятно, лучше не оборачивать их какими-либо дополнительными объектами.
Наличие слишком большого количества проверок также может означать, что тестируемые объекты плохо спроектированы (проверяют слишком много всего).

### 5.2.2. Применимость



### 5.2.3. Преимущества и недостатки

#### 5.2.3.1. Преимущества

1. *Читаемость*

Применение паттерна **Arrange Act Assert** позволяет четко разделить действия по настройке от основных действий и действий проверки.
Использование шаблона **Arrange-Act-Assert** при написании тестов, намного повышает шансы других разработчиков понять код.

2. *Рефакторинг*

Применение паттерна **Arrange Act Assert** требует разбиения теста на три секции и 
обязательного выполнения единственной проверки в тесте, а не просто хождение по шагам. 

Что в свою очередь упрощает рефакторинг кода:
* выявление наличия тестов, пытающихся одновременно протестировать слишком много разных вещей (*настрой действуй проверь, настрой действуй проверь*).
* обнаружение общих блоков кода в секции **Arrange**, которые можно вынести в **SetUp** метод.

#### 5.2.3.2. Недостатки



### 5.2.4. Применение в автотестах

#### 5.2.4.1. До применения паттерна

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

Нет четкого разделения и понимания, где шаги по настройке/подготовке, а где шаги по выполнению действий и проверке. 

#### 5.2.4.2. После применения паттерна

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin(login, password);

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isTextDisplyed());
        Assertions.assertEquals(expected, homePage.getText(),
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }

    public HomePage getPageAfterLogin(String login, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(login, password);
    }
    ...
}
```

После применения паттерна и вынесения шагов действий тест стал более чистым и прозрачным. 

## 5.3. Паттерн Assert Object / Matchers

Одна из наиболее значительных проблем с написанными тестами, заключается в том, 
что тесты проверяют не бизнес-инварианты, а основные технические детали.

***Assert Object / Matchers*** - паттерн, который создает проверки специфичные для предметной области, скрывая технические детали реализации. 

Существует несколько библиотек, которые уже содержат множество готовых к использованию сопоставителей (**Mathcers**) 
и предоставляют простой в использовании API для создания кастомных сопоставителей.
Самые популярные из них - **Hamcrest** и **AssertJ**.

### 5.3.1. Структура паттерна

Структура патерна:

1. Класс *<Наименование>Assert*

***<Наименование>Assert*** - класс обертка вокруг тестируемого объекта, скрывающий технические детали проверок и 
предоставляющий предметно ориентированные названия методов для проверки.

2. Класс *Test*

***Test*** - класс, который реализует логику тестов.

### 5.3.2. Применимость



### 5.3.3. Преимущества и недостатки

#### 5.3.3.1. Преимущества

1. *Читаемость*

Применение паттерна **Assert Object** создает логику предметной области в тестах,
объединяя группу проверок нацеленных на конкретный объект в отдельный класс.

2. *Дублирование*

Применение паттерна **Assert Object** обеспечивает создание отдельного класса с проверками,
которые могут использоваться повторно, что сокращает общее дублирование кода.

#### 5.3.3.2. Недостатки



### 5.3.4. Применение в автотестах

#### 5.3.4.1. До применения паттерна

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

В исходном примере не видно очевидной логики проверок в тесте.
Пользователю может быть непонятно что именно будет проверяться.

#### 5.3.4.2. После применения паттерна

Тест

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```   

Класс с матчерами

```java
// Матчеры
public class HomePageAssert {
    private HomePage homePage;
    
    public HomePageAssert(HomePage homePage) {
        this.homePage = homePage;
    }
    
    // Проверка отображения текста после входа с логином и паролем
    public void displayedTextAfterLogin() {
        Assertions.assertTrue(homePage.isTextDisplyed());
    }
    
    // Проверка текста после входа с логином и паролем
    public void textAfterLoginIs(String expected) {
        Assertions.assertEquals(expected, homePage.getText(),
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

Теперь тест выглядит великолепно и его можно читать намного проще, чем раньше, а код утверждения внизу остается прежним.

***

# 6. Прочие структурные паттерны

## 6.1. Паттерн Decorator

***Decorator*** - паттерн, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные *обёртки*.

Декораторы предоставляют гибкую альтернативу подклассам для расширения функциональности.
Добавление новой функциональности осуществляется подменой экземпляра оригинального компонента.
Декоратор реализует тот же самый интерфейс, поэтому может замещать этот компонент.
Однако, цель шаблона не просто в переадресации запросов.
Он добавляет свой код до и/или после вызовов исходных методов, в крайнем случае замещая их полностью.
Это приводит к изменению исходного поведения и появлению новых возможностей.

Пример использования паттерна в библиотеке **Selenium** - **EventFiringDecorator** и **FieldDecorator**.

![Decorator](./_Files/1.%20Patterns/01.png "Decorator")

### 6.1.1. Структура паттерна

Структура паттерна:

1. *Базовый компонент* 

***Базовый компонент*** – общий интерфейс / абстрактный класс для всех оборачиваемых компонентов и самого декоратора.

2. *Конкретный компонент*

***Конкретный компонент*** – конкретный класс, реализующие базовый компонент, функциональность которого необходимо модифицировать декораторами.
Декоратор способен работать как с самим исходным компонентом, так и его наследниками.

3. *Базовый декоратор*

***Базовый декоратор*** – базовый класс для всех декораторов, реализующие базовый компонент.
   
4. *Конкретный декоратор*

***Конкретный декоратор*** - конкретный класс, наследующий базовый декоратор и добавляющий определенные функции компоненту.
Такой объект может использоваться как вместо декорируемого компонента, так и самостоятельно.

Конкретный декоратор:

* создает механизм подключения и хранения компонента
* реализует переадресацию всех методов и свойств
* добавляет новые свойства и методы

![Decorator](./_Files/1.%20Patterns/01.png "Decorator")

Правила применения паттерна:

1. Декораторы должны относиться к тому же типу, что и декорируемые объекты

Чтобы можно было создать цепочку декораторов, все декораторы должны иметь одинаковый тип с объектами к которым они применяются.

2. 

3. Не следует использовать большое количество декораторов с тяжеловесными классами.

Применение множества декораторов к тяжеловесным классам может повлечь за собой большие накладные расходы.

### 6.1.2. Применимость

*Реализация множественного наследования*

В таких языках как **Java** и **C#** нет множественного наследования классов.
И когда требуется реализовать множество различных функциональностей и их комбинаций,
то для каждой такой функциональности и их комбинаций придется наследовать отдельный класс.
Структура классов при этом может очень сильно разрастись, что в свою очередь усложнит ее понимание и поддержку.

Применение паттерна **Decorator** позволяет реализовать аналог множественного наследования, в языках его не поддерживающих, 
путем вложения одного декоратора в другой и создания из них цепочек, поскольку паттерн реализует интерфейс исходного компонента.
Таким образом у объектов расширяются возможности без использования одиночного наследования.
Что в свою очередь разрешает проблему усложнения структуры классов путем уменьшения числа создаваемых классов
по сравнению с результатами использования одиночного наследования.

*Невозможность наследования классов*

Во многих языках программирования есть ключевое слово, с помощью которого можно заблокировать наследование класса.

Применение паттерна **Decorator** позволяет добавить функциональность классу, 
определение которого может быть скрыто или иным образом недоступно для подклассов, то есть когда наследование невозможно.

*Динамическое добавление новых возможностей*

Применение паттерна **Decorator** обеспечивает динамическое добавление объекту новых функциональных возможностей.
Объекты помещаются в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, 
поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

### 6.1.3. Преимущества и недостатки

#### 6.1.3.1. Преимущества



#### 6.1.3.2. Недостатки



### 6.1.4. Применение в автотестах

#### 6.1.4.1. До применения паттерна

Страница (Page Objects)

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

Интерфейс **WebElement** не всегда удобно использовать. 
Его невозможно расширить и добавить свои методы для работы с элементом. 
Использовать свои методы можно только создавая классы-обвертки(CheckBox, Button и т.п.), 
которые просто делегируют вызов методов настоящему WebElement.

#### 6.1.4.2. После применения паттерна

Кастомные элементы (Decorator).

*Пример*

```java
public class Element {
    protected WebElement webElement;

    public Element(WebElement webElement) {
        this.webElement = webElement;
    }
}

public class TextBox extends Element {
    public TextBox(WebElement webElement) {
        super(webElement);
    }

    public void click(boolean value) {
        webElement.click();
    }

    public void setText(String text) {
        webElement.sendKeys(text);
    }
}

public class Button extends Element {
    public Button(WebElement webElement) {
        super(webElement);
    }

    public void click() {
        webElement.click();
    }
}

public class CheckBox extends  Element{
    public CheckBox(WebElement webElement) {
        super(webElement);
    }

    public void setChecked(boolean value) {
        if (value != isChecked()) {
            webElement.click();
        }
    }

    public boolean isChecked() {
        return webElement.isSelected();
    }
}
```

Теперь в объектах страниц используются кастомные элементы.

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");

    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }

    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        TextBox tbxLogin = new TextBox(driver.findElement(loginBy));
        tbxLogin.setText(login);
        TextBox tbxPassword = new TextBox(driver.findElement(passwordBy));
        tbxPassword.setText(password);
        Button btnSignIn = new Button(driver.findElement(signInBy));
        btnSignIn.click();
        return new HomePage(driver);
    }
}
```

## 6.2. Паттерн Proxy

***Proxy*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заместители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Заместитель предлагает создать новый объект-заместитель, имеющий тот же интерфейс, что и оригинальный объект.
Ни интерфейс ни функциональность замещенного объекта, с точки зрения клиента, не изменяются.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр оригинального объекта и 
переадресовывал бы ему всю реальную работу.

![Proxy](./_Files/1.%20Patterns/01.png "Proxy")

### 6.2.1. Структура паттерна

Структура паттерна:

1. *Базовый компонент*

***Базовый компонент*** – общий интерфейс / абстрактный класс для всех замещаемых **Конкретных компонентов** и самого **Заместителя**.

![Proxy](./_Files/1.%20Patterns/01.png "Proxy")

2. *Конкретный компонент*

***Конкретный компонент*** – конкретный класс, реализующий **Базовый компонент**, который будет замещен **Заместителем**.

3. *Заместитель*

***Заместитель*** - класс, реализующий **Базовый компонент**, который замещает **Конкретный компонент** и перехватывает обращения к нему.

**Заместитель** выполняет дополнительные действия (например, инициализацию, логирование, защиту или другое) 
до или после вызова вложенного в него **Конкретного компонента**.

**Заместитель** может сам отвечать за создание и удаление объекта **Конкретного компонента**.

### 6.2.2. Применимость



### 6.2.3. Преимущества и недостатки

#### 6.2.3.1. Преимущества



#### 6.2.3.2. Недостатки

Прокси - это шаблон, который позволяет вмешиваться в процесс, происходящий между вами и другим пользователем,
вводя новую логику между ними, не затрагивая ни одну из сторон.

*Контролируемый доступ*

Данный шаблон используется если:

работа с объектом не должна зависеть от того, где он реально расположен (от адресного пространства приложения до удаленного сервера);
(или) нужно выполнять определенные действия при доступе к объекту;
(или) необходимо оптимизировать взаимодействие объекта с клиентом.



Стоит отметить, что шаблон позволяет использовать интерфейс для взаимодействия с замещаемым объектом. 
В этом случае конкретная реализация скрыта от Прокси и он может работать практически со всеми объектами, поддерживающими данный интерфейс.
Шаблон не накладывает ограничения на вложения одного Прокси в другой. Такой подход позволяет строить их различные конфигурации в процессе работы программы.



Этот шаблон может быть полезен, когда вы, например, хотите добавить ведение журнала, включить или отключить что-то,
иметь контроль над некоторыми дополнительными ресурсами и т. Д.
Самый популярный метод использования его в тестах - это настройка HTTP-прокси.
Это позволяет динамически включать и отключать черные списки хостов,
исключая или заглушая сторонние сайты, такие как Facebook или Twitter, в ваших тестах.
Иногда это единственный способ проверить некоторые исключительные сценарии для внешних служб, подобных этим.


Преимущества и недостатки
+ Можно как угодно контролировать доступ к сервисному объекту;
+ Дополнительные возможности управления жизненным циклом сервисного объекта;
+ Работает без сервисного объекта;
+ Повышает быстродействие и безопасность кода.

Позволяет контролировать сервисный объект незаметно для клиента.
Может работать, даже если сервисный объект ещё не создан.
Может контролировать жизненный цикл служебного объекта.

Вы могли бы поместить в класс заместителя какую-то промежуточную логику, 
которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. 
А благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект.



Ленивая инициализация (виртуальный прокси). 
Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
Вместо того, чтобы грузить данные сразу после старта программы, 
можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

Защита доступа (защищающий прокси). 
Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. 
Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).
Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

Локальный запуск сервиса (удалённый прокси). 
Когда настоящий сервисный объект находится на удалённом сервере.
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

Логирование запросов (логирующий прокси). 
Когда требуется хранить историю обращений к сервисному объекту.
Заместитель может сохранять историю обращения клиента к сервисному объекту.

Кеширование объектов («умная» ссылка). 
Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.
Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными. 
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект. 
Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

### 6.2.4. Применение в автотестах

#### 6.2.4.1. До применения паттерна



#### 6.2.4.2. После применения паттерна



## 6.3. Паттерн Facade

### 6.3.1. Структура паттерна



### 6.3.2. Применимость



### 6.3.3. Преимущества и недостатки

#### 6.3.3.1. Преимущества



#### 6.3.3.2. Недостатки



### 6.3.4. Применение в автотестах

#### 6.3.4.1. До применения паттерна

*Пример*

```java

```

#### 6.3.4.2. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

## 6.4. Паттерн Flyweight

***Flyweight*** - паттерн, который позволяет вместить бóльшее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

![Flyweight](./_Files/1.%20Patterns/01.png "Flyweight")

### 6.4.1. Структура паттерна

Intrinsic state
We learnt that the flyweight pattern allows us to share objects and use it in multiple contexts. 
The flyweight objects act as an independent object with its own state. 
The state stored within a flyweight object is called as intrinsic state. 
In the above example, all fields in the StarFlyweight object are intrinsic state (name, color etc.,). These fields are not shared outside the object and are independent of the context in which the flyweight object is used.

Extrinsic state
An extrinsic state is a state that depends on the context. In the example, the location values (x and y) are the extrinsic state. 
The clients are responsible for passing the extrinsic state. 
When we create a star object we pick the right flyweight star object and pass the location (x and y) value to create a star in space.

Flyweight

Declares an interface through which flyweights can receive and act on extrinsic state.

ConcreteFlyweight

Implements the Flyweight interface and adds storage for intrinsic state, if any. A ConcreteFlyweight object must be sharable. 
Any state it stores must be intrinsic; that is, it must be independent of the ConcreteFlyweight object’s context.

FlyweightFactory

Creates and manages flyweight objects.
Ensures that flyweights are shared properly. When a client requests a flyweight, the FlyweightFactory object supplies an existing instance or creates one, if none exists.

Client

Maintains a reference to flyweight(s).
Computes or stores the extrinsic state of flyweight(s).

![Flyweight](./_Files/1.%20Patterns/01.png "Flyweight")

### 6.4.2. Применимость

*Когда не хватает оперативной памяти для поддержки всех нужных объектов*

Эффективность паттерна Легковес во многом зависит от того, как и где он используется. 
Применяйте этот паттерн, когда выполнены все перечисленные условия:

* в приложении используется большое число объектов;
* из-за этого высоки расходы оперативной памяти;
* большую часть состояния объектов можно вынести за пределы их классов;
* большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

### 6.4.3. Преимущества и недостатки

#### 6.4.3.1. Преимущества

Экономит оперативную память

#### 6.4.3.2. Недостатки

Расходует процессорное время на поиск/вычисление контекста.

Усложняет код программы из-за введения множества дополнительных классов.

### 6.4.4. Применение в автотестах

#### 6.4.4.1. До применения паттерна

*Пример*

```java

```

Используя этот паттерн, мы могли бы реализовать много интересного, например, пул браузеров.
Я слышал тихие жалобы от разных людей, что веб-тесты занимают безумно много времени,
потому что они требуют запуска браузера, загрузки первой страницы, импорта профилей пользователей и т. д.
Но необязательно создавать браузер в реальном тесте, вместо этого мы могли бы использовать фоновый пул, который настроен на сохранение необходимого количества «горячих» браузеров.
Закончив работу с браузером, мы просто возвращаем его в пул и очищаем его данные.
И это может быть сделано в фоновом режиме, параллельно с фактическими тестовыми потоками.
И только после того, как браузер снова будет готов к использованию, его можно будет вернуть на следующий тест в качестве нового экземпляра.

Тем не менее, эта конфигурация пула и настройки браузера могут быть исключены из теста,
значительно минимизируя затрачиваемое на это время и ресурсы.

Другой пример - использование страницы. Вам не нужно ждать, пока откроется нужная страница,
если все тесты начинаются с одной страницы. Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать, пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных. Вместо того, чтобы работать с реальной базой данных,
мы можем запустить необходимое количество контейнеров базы данных на разных портах (это можно сделать с помощью Docker или другого инструмента виртуализации)
и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. Д.

#### 6.4.4.2. После применения паттерна

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```

*Пример*

```java

```

Следующий паттерн используют еще меньше разработчиков.
Легковес - это классический паттерн из книги GoF, который решает проблему сохранения и работы с тяжелыми с точки зрения ресурсов объектами или набором объектов.
Вместо того, чтобы создавать их каждый раз, когда они нам нужны, мы берем их, используем и возвращаем в так называемый пул для использования в будущем.

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)