Java_QA / Level 2. Medium - Продвинутые темы / Урок 02. Page Object, PageFactory

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 2. Структурные паттерны

***Cтруктурные паттерны*** - паттерны, основная задача которых сводится к структурированию кода тестов,
чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью.
Таким образом, тестовым инженерам, работающим с теми же проблемами, будет проще понять их и изменить, и проще поддерживать.

## 2.1. Паттерн Page Object

***Page Object*** - паттерн, который моделирует объект страницы.

Что решает: разделение технических деталей (например, элементов пользовательского интерфейса на странице / экране).
и фактическая логика тестирования UI-теста.
уменьшить дублирование кода


Мы хотели бы повторно использовать наш код в различных тестовых сценариях, и Page Object может нам в этом помочь.
Иногда, когда я добавляю новые тесты в свои проекты, мне не нужно писать никаких дополнительных классов или функций, кроме тестового скрипта.
Потому что они уже были написаны с помощью Page Object!

И, наконец, Page Object делает тесты более читаемыми и понятными.
Он показывает, на какой странице сейчас находится пользователь, и предотвращает выполнение тестом действий, не связанных с текущей страницей.

Конечно, Page Object - не панацея.
Если бы в моем проекте было небольшое количество тестов (т.е. менее 20) и я не планировал их расширять,
Я бы подумал не использовать его. Просто потому, что усилия по созданию объектов страницы не окупились.
Каждый шаблон может принести большую пользу вашему проекту, но они не должны быть вашей целью в пользу потребностей проекта.

## 2.2. Паттерн Page Factory

Page Factory is an extension to Page Object pattern. It helps to encapsulate page’s attributes and methods even more by providing FindBy annotations.

```java
public class LoginPage extends BasePage {
    private static final By USERNAME_FIELD = By.id("usernameField");
    private static final By PASSWORD_FIELD = By.id("passwordField");
    private static final By LOGIN_BUTTON = By.id("loginButton");
    
    public LoginPage(WebDriver driver) {
        super(driver);
    }
    
    public HomePage loginAs(User user) {
        driver.findElement(USERNAME_FIELD).sendKeys(user.username);
        driver.findElement(PASSWORD_FIELD).sendKeys(user.password);
        driver.findElement(LOGIN_BUTTON).click();
        return new HomePage(driver);
    }
}

public class LoginPage extends BasePage {
    @FindBy
    private WebElement usernameField;
    @FindBy
    private WebElement passwordField;
    @FindBy
    private WebElement loginButton;
    
    public LoginPage(WebDriver driver) {
        super(driver);
        PageFactory.initElements(driver, this);
    }
    
    public HomePage loginAs(User user) {
        usernameField.sendKeys(user.username);
        passwordField.sendKeys(user.password);
        loginButton.click();
        return new HomePage(driver);
    }
}

```

Pay attentions to PageFactory#initElements invocation.
This static helper initializes all fields with FindBy annotations on the page, which will be found on it on each call.
The main advantage is the fact that now we work directly with fields, buttons, windows etc.
and do not worry about low level driver’s interactions exactly the same way our app users do.

Composition of Page Elements

Any web, desktop or mobile application consists of repeatable elements, and logic of their usage should be implemented again and again in our tests.
For instance, every menu has list of links, every table has rows and columns, every form has input fields.
In real life when we work with those elements we do not separate those components from the main element consisting them.

Thanks to Composition we could implement some elements once and reuse them every time we need them.
Thus it helps to avoid code duplication by composing different web elements into widgets (high-level elements), like tables, menus, forms.
This significantly reduces costs of extending and scaling of test automation framework when, for example new Page Objects needs to be created.

## Loadable Component

This pattern is used by most of the developers who works with user interface tests.
The thing is, when test makes the transition from one page to another, it doesn’t know if the targeted page was loaded completely.
Obviously, either regular sleep or not waiting at all is not a solution here. So how do we solve this problem? Usually test engineers create explicit wait in constructor of the page class or in its ancestor and override if it’s needed.

```java
public class HomePage extends BasPage {
@FindBy(id = "someId")
private WebElement element;

public HomePage(WebDriver driver) {
super(driver);
PageFactory.initElements(driver, this);
waitForElement(element);
}
}

```

Again, there is not strict rule how to do this wait.
Personally I like to move this waiting to BasePage and override abstract method for waiting particular element.
How to do that in your case, completely up to you.
But before implementing such complicated logic you need to be sure that your app page transition could cause you some problem.
Otherwise just usual implicit wait might be enough.
If you’re interested in implementation of explicit waits in your UI mobile tests and do not know where to start,
I recommend to read my post about explicit waits in Android or iOS.

## 2.3. Паттерн Fluent / Chain of Invocations

Второй паттерн, о котором мы собирались поговорить, - это Chain of Invocations.
Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.
Например, пользователь находится на странице входа и нажимает какую-то кнопку.
Написав код по старинке, мы не будем уверены, находится ли он все еще на странице входа или уже на главной странице.

А теперь представьте, если бы в вашем тесте было 50 подобных методов.
Вы не можете быть уверены, можете ли вы вызвать их сразу, или они зависят от некоторого порядка,
или даже они не могут быть вызваны после того, как один из них был выполнен.
Например, могу ли я нажать на диалоговое окно подсказки, если я не ввел ни одного символа в поле ввода?
Наверное, нет, потому что на данный момент его еще нет!

```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();

  assertThat(homePage.isSignedIn(user));  
}
```

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив Fluent Invocations, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

Обычно, если вы хотите прервать цепочку методов,
все, что вам нужно сделать, это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.
На этом этапе разработчик должен остановиться и подумать о следующем методе, который будет вызван в тестовом сценарии, прежде чем делать это.

Цепочку вызовов легко реализовать.
Все, что вам нужно сделать, это вернуть значение в каждом методе объекта страницы. Это может быть это, какое-то значение или любой другой объект,
например, следующий объект страницы после вызова метода (переход на другую страницу).

Этот шаблон не помогает значительно сократить код (это не его основная цель),
но это позволяет вам не повторяться, помещая объект снова и снова перед вызовом его методов.
Также IMO это делает код немного красивее.

## 2.4. Паттерн Strategy

Шаблон стратегии используется всякий раз, когда мы хотим иметь более одной реализации одного и того же действия / последовательности действий,
что делается иначе. В зависимости от контекста мы могли выбрать реализацию.

Самый простой пример - регистрация пользователя. Возможно, вы захотите иметь две разные реализации этого конкретного действия.
Первый - это фактический поток переходов по страницам для успешной регистрации пользователя.
Другой - короткий вызов API, который вызывается, когда для теста нужен новый пользователь.

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

Возможно, вы не захотите вызывать «долгую» регистрацию каждый раз в своих тестах.
Но иногда он может понадобиться, например, когда вы подтверждаете фактическую регистрацию через Интернет.
И наоборот, мы хотим, чтобы создание новых пользователей для тестирования было быстрым и надежным. Поэтому здесь подойдет REST-регистрация.

Стратегия помогает сделать нашу среду автоматизации тестирования более гибкой и простой в обслуживании за счет разделения концепций.
Опять же, вам нужно быть осторожным и не применять его в ситуациях, когда вы можете обойтись без него.

## 2.5. Паттерн AAA

***Настрой – действуй – проверь*** – отличный способ структуризации тест-кейсов. Он задает порядок операций.

The Pattern
Arrange-Act-Assert is a great way to structure test cases. It prescribes an order of operations:

Arrange inputs and targets. Arrange steps should set up the test case. Does the test require any objects or special settings? Does it need to prep a database? Does it need to log into a web app? Handle all of these operations at the start of the test.
Act on the target behavior. Act steps should cover the main thing to be tested. This could be calling a function or method, calling a REST API, or interacting with a web page. Keep actions focused on the target behavior.
Assert expected outcomes. Act steps should elicit some sort of response. Assert steps verify the goodness or badness of that response. Sometimes, assertions are as simple as checking numeric or string values. Other times, they may require checking multiple facets of a system. Assertions will ultimately determine if the test passes or fails.


"Настрой" данные и цели.
Эти шаги должны подготовить тест-кейс. Требует ли он объектов или особых настроек? Нужно ли подготовить базу данных? Нужен ли логин в веб-приложение? Разберитесь с этими операциями в начале теста.
"Действуй" согласно целевому поведению.
Эти шаги покрывают основную задачу теста. Это может быть вызов функции или метода, вызов RESTAPI или взаимодействие с веб-страницей. Действия должны быть сфокусированы на целевом поведении.
"Проверь" ожидаемые результаты.
Эти шаги должны получать какую-то разновидность ответа. Они убеждаются в правильности или ложности этого ответа. Иногда эти проверки просты – например, сверка числовых или строковых значений. В других случаях они требуют проверки множества аспектов системы. Проверка определяет, упал тест или прошел.
Шаг "Настрой" создает переменную с именем "negative".
Шаг "Действуй" вызывает функцию "abc" с использованием переменной "negative" и хранит возвращенное значение в переменной с именем "answer".
Шаг "Проверь" убеждается, что "answer" – положительное число.
Шаг "Настрой" формирует URL конечной точки для поиска "PythonProgramming". Обратите внимание на основной URL и параметры запроса.
Шаг "Действуй" вызывает API, используя URLи "requests", а затем интерпретирует тело ответа из JSON в словарь Python.
Шаг "Проверь" убеждается, что код HTTP-ответа – 200, что означает "ОК" или "успешно", и что слово "Python" появляется где-то в абстрактном тексте ответа.
В BDD паттерн "Настрой –Действуй – Проверь" называется иначе – Если – Когда – Тогда. Язык Gherkin использует шаги Если – Когда – Тогда для описания поведенческих сценариев. По сути это та же самая формула, что и в "Настрой – Действуй – Проверь"



***

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)