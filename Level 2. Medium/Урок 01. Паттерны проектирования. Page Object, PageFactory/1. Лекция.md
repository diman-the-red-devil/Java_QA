Java_QA / Level 2. Medium - Продвинутые темы / Урок 02. Page Object, PageFactory

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

***Шаблон проектирования или паттерн*** в разработке программного обеспечения —
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Обычно паттерн не является законченным образцом, который может быть прямо преобразован в код.
Это лишь пример решения задачи, который можно использовать в различных ситуациях.
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами,
без определения того, какие конечные классы или объекты приложения будут использоваться.

http://sd.blackball.lv/library/Patterny_proektirovanija_na_platforme_NET_(2015).pdf

***

# 2. Зачем нужны паттерны?

**Паттерны** - не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда.
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Не существует такого понятия как **хороший паттерн** или **плохой паттерн**. 
Сам термин **паттерн** был придуман в качестве формулировки проблемы и предложенного решения. 
Если задача не разделяет проблему, для которой **паттерн** был придуман – это не значит, 
что он плохой или вышел из моды, просто он не подходит для решения этой задачи. 
Если проблема каким-то образом совпадает и накладывается на этот **паттерн**, значит, стоит его рассмотреть.

Таким образом важно не просто приносить дизайн-паттерны в свой проект только потому, 
что вы о них услышали, важно понимать их назначение, проблематику, как и чем они могут вам помочь.

***

# 3. Паттерны в автотестировании 

Изначально классические паттерны были сформулированы давным-давно четверкой, которая выпустила книгу **Design Patterns**.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире.
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, пополняясь новыми паттернами.

Сегодня просматривается тенденция появления подобных паттернов в других областях, в которых накопилась проблематика.
Автоматизация тестирования имеет собственный набор задач, так что существует и набор полезных паттернов проектирования для этой области.

Основными драйверами практически всех паттернов в автоматизации тестирования являются **факторы**:

* *надежность*
* *понятность*
* *гибкость*
* *поддерживаемость*
* *стабильность*

Большая часть этих факторов находится под влиянием разделения компонентов.
В любом тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три **компонента**:

* *тестовая логика* (описание шагов тест кейсов)
* *тестовые данные* (описание данных для тест кейсов)
* *техническая часть* (отвечающая за непосредственное взаимодействие с приложением - вызов функций, клики на экран и т. п.)

Если эти **компоненты** хорошо разделены, тесты начинают хорошо попадать в выше упомянутые **факторы**,
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

Все паттерны можно поделить на группы:

* *структурные паттерны*
* *порождающие паттерны*
* *поведенческие паттерны*
* *паттерны данных*
* *технические паттерны*
* *бизнес паттерны*

***

# 4. Структурные паттерны

***Cтруктурные паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том, 
как из классов и объектов образуются более крупные структуры.

Структурные паттерны проектирования упрощают проектирование путем выявления 
простого способа реализовать отношения между субъектами.

***

# 5. Структурные паттерны в автотестировании

***Cтруктурные паттерны в автотестировании*** - паттерны, основная задача которых сводится к структурированию кода тестов,
чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью.
Таким образом, тестовым инженерам, работающим с теми же проблемами, будет проще понять их и изменить, и проще поддерживать.

## 5.1. Паттерн Page Object

***Page Object*** - паттерн, который моделирует объекты страницы в качестве объектов в коде и 
позволяет разделять логику выполнения тестов от их реализации.

![Page Object](./_Files/1.%20Patterns/01.png "Page Object")

Структура паттерна:

1. Класс *BasePage*
  
***BasePage*** - базовый класс для всех классов моделирующих веб страницы, 
в котором определяются базовые методы для работы с **WebDriver**.

Все классы конкретных веб страниц будут расширять **BasePage**, унаследовав, таким образом, все базовые методы.

2. Класс *<Наименование>Page*

***<Наименование>Page*** - конкретный класс, который расширяет **BasePage** и 
реализует методы для работы с конкретными веб страницами.

При использовании **Page Object** элементы страниц, а также методы непосредственного взаимодействия с ними, 
выносятся в отдельный классы, отвечающие за работу с **HTML** каждой конкретной веб страницы.
К примеру, можно создать отдельные классы для Главной страницы, страницы Авторизации и Регистрации.
 
3. Класс *Test*

***Test*** - класс, который реализует логику тестов.

Правила применения паттерна:

1. У объекта страницы не должно быть никаких утверждений
  
Объекты страницы никогда не должны делать проверки или утверждения.
Это часть теста и всегда должна быть в коде теста, а не в объекте страницы.
Объект страницы должен содержать элементы страницы и методы, с помощью которых можно с ними взаимодействовать.
Но никакой код, связанный с тем, что тестируется, не должен находиться в объекте страницы.

Существует одна, единственная проверка, которая может и должна быть внутри объекта страницы,
а именно проверка того, что страница и, возможно, критические элементы на странице были загружены правильно.
Эта проверка должна выполняться при создании экземпляра объекта страницы.

2. Объект страницы должен представлять значимые элементы страницы, а не обязательно полную страницу.

Класс не обязательно должен представлять собой всю страницу.
Он может быть частью страницы, которая часто используется на сайте (или даже на одной странице).
Например пагинация или блок ссылок.
Нет никакой необходимости моделировать все элементы представленные на странице, 
если в тестах с ними нет никакого взаимодействия. 
Лишний код только ухудшит восприятие и понимание.

### 5.1.1. Проблемы, которые решает паттерн

1. *Читаемость*

Код функциональных тестов написанных с использованием **Selenium WebDriver** в основном будет 
состоять из взаимодействий с веб-интерфейсом, который проверяется.
То есть любой код теста будет состоять из последовательностей:

* поиск элемента на странице
* получение свойства элемента или выполнения действия с элементом
* проверка некоторого состояние элемента или системы с помощью различных утверждений

Даже в самом простом тесте читаемость очень плохая, так присутствует много кода **Selenium WebDriver**,
который скрывает цель теста, делая его трудным для восприятия.

Применение паттерна **Page Object** обеспечивает четкое разделение технических деталей (взаимодействие с элементами веб интерфейса) и фактической логикой тестов.
Также паттерн объединяет все действий по работе с конкретной веб-страницей в одном месте (соответствующем классе).

2. *Дублирование*

При написании UI тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами в разных кейсах. 
Что в свою очередь приводит к написанию одинакового кода в разных местах.

Применение паттерна **Page Object** значительно уменьшает количество повторяющегося кода путем создания 
единого места (**объект страницы**) для определения операций, выполняемых на странице вместе разброса этих методов по тестам.

3. *Поддержка*

В любом в пользовательском интерфейсе, часто вносятся как незначительные, так и серьезные изменения.
Это может быть новый дизайн, реструктуризация полей и кнопок,и т д.
Изменения в пользовательском интерфейсе часто нарушают работу нескольких тестов в нескольких местах.
Без применения паттерна **Page Object** локаторы веб элементов на странице и 
методы работы с ними будут разнесены по нескольким классам, что сильно усложнить поддержку кода.

Применение паттерна **Page Object** позволяет легко обновить код, после любого изменения пользовательского интерфейса, 
путем добавления новых элементов, обновления или удаления существующих в одном месте (**объекте страницы**), 
а не исправлять каждый тест, в котором этот интерфейс используется.

4. *Повторное использование*
   
Как уже упоминалось выше при написании тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами.

Применение паттерна **Page Object** обеспечивает сохранение отдельных репозиториев объектов страницы независимо от тестов автоматизации. 
Что в свою очередь позволяет повторно использовать этот репозиторий для разных целей с разными инструментами.
Например, можно интегрировать объектную модель страницы в **Selenium** с **TestNG** / **JUnit** для функционального тестирования
и одновременно с **JBehave** / **Cucumber** для приемочного тестирования.

### 5.1.2. До применения паттерна

*Пример*

```java
public class LoginTest {
    public void loginTest() {
        // Ввести логин и пароль на странице Входа
        driver.findElement(By.name("login")).sendKeys("login");
        driver.findElement(By.name("password")).sendKeys("password");
        driver.findElement(By.name("sign-in")).click();
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(driver.findElement(By.tagName("h1")).isDisplayed());
        Assertions.assertEquals(driver.findElement(By.tagName("h1")).getText(), "Стартовая страница", 
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

Очевидно, что во многих тестах потребуется вход с логином и паролем. 
Следовательно, в каждый тест придется копипастить фрагмент кода с входом по логину и паролю.
Если вдруг на странице входа по логину и паролю изменятся локаторы, то придется делать правки во многих местах.
Также по коду невозможно понять что и на какой странице происходит.
И это только небольшой фрагмент копипасты.

### 5.1.3. После применения паттерна

Страницы (Page Objects)

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}

// Страница "Home"
public class HomePage { 
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
    
    // Конструктор
    public HomePage(WebDriver driver){
        this.driver = driver;
    }
    
    // Отображается элемент?
    public boolean isTextDisplyed() {
        return driver.findElement(tеxtBy).isDisplayed();
    }
    
    // Получение текста 
    public String getText() {
        return driver.findElement(tеxtBy).getText();
    }
}
```

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

После применения паттерна в случае изменения верстки на страницах, нужно будет лишь поправить локаторы в одном классе, 
независимо от того, в скольких классах с тестами используются страницы.
Глядя на код теперь сразу понятно какие действия и на какой странице выполняется.

## 5.2. Паттерн Arrange Act Assert (Given When Then)

**Тест** – это процедура, которая проверяет поведение с целью определить, правильно ли оно функционирует. 
Тестов много видов (**unit**, **интеграционные**, **end-to-end**), но все функциональные тесты по сути делают одно и то же: 
пробуют что-то и сообщают **PASS** или **FAIL**.

***Arrange Act Assert (Подготовка, Действие, Проверка)*** – паттерн, который организует структуру тест-кейсов и задает порядок операций. 
Паттерн **AAA** предоставляет простую единообразную структуру для всех тестов в проекте. 
Это единообразие дает большое преимущество: привыкнув к нему, вы сможете легко прочитать и понять любой тест. 

![Arrange Act Assert](./_Files/1.%20Patterns/02.jpg "Arrange Act Assert")

Структура теста (метода) при использовании паттерна **AAA**:

1. Секция *Arrange* устанавливает начальные условия для выполнения теста
   
В этой секции выполняются шаги по подготовке тестируемой системы и ее зависимостей в нужное состояние.

Эти шаги должны подготовить тест-кейс:
* создание объектов
* выполнение особых настроек
* подготовка данных 
* передача подготовленных зависимостей
* сохранение выходного значения (если оно есть)
  
и т. д

2. Секция *Act* выполняет тест (обычно представляет одну строку кода)
   
В этой секции выполняются шаги по выполнению основной задачи теста.

Эти шаги должны выполнить тест кейс:
* вызов функции/метода
* вызов api 
* взаимодействие с веб-страницей

и т. д.

3. Секция *Assert* верифицирует результат теста
   
В этой секции выполняются шаги по проверке результата (возвращаемое значение или итоговое состояние тестируемой системы).
  
Эти шаги должны получить ответ на вопрос упал тест или прошел:
* проверка числовых или строковых значений
* проверка множества аспектов системы

и т. д.

В **BDD** паттерн **Подготовка, Действие, Проверка** называется иначе **Если, Когда, Тогда**. 
Язык Gherkin использует шаги **Если, Когда, Тогда** для описания поведенческих сценариев. 
По сути это та же самая формула, что и в **Подготовка, Действие, Проверка (Настрой, Действуй, Проверь)**

Правила применения паттерна:

1. В тесте не должно быть множественных секций arrange, act и assert

Время от времени встречаются тесты с несколькими секциями arrange (подготовка), act (действие) или assert (проверка). 
Обычно они работают так:

![Arrange Act Assert](./_Files/1.%20Patterns/03.jpg "Arrange Act Assert")

Когда присутствует несколько секций действий, разделенных секциями проверки и, возможно, секциями подготовки, это означает, 
что тест проверяет несколько единиц поведения. Такой структуры тестов лучше избегать.
Если есть тест, содержащий серию действий и проверок, то лучше отрефакторить его: выделить каждое действие в отдельный тест.
Иногда допустимо иметь несколько секций действий в тестах. 

2. В тесте не должно быть ветвлений

Наличие в тестах ветвления является антипаттерном. Тест должен представлять собой простую последовательность шагов без ветвлений.
Присутствие ветвления означает, что тест проверяет слишком много всего. Следовательно, такой тест должен быть разбит на несколько тестов.
Ветвление в тестах не дает ничего, кроме дополнительных затрат на сопровождение: команды if затрудняют чтение и понимание тестов.

3. Размеры секций не должны быть слишком большими

* секция подготовки обычно является самой большой из трех

Если она становится слишком большой, лучше выделить отдельные операции подготовки либо 
в приватные методы того же класса теста, либо в отдельный класс-фабрику.

* секция действия обычно состоит всего из одной строки кода

* секция проверки должна содержать одну проверку

Если секция проверки становится большой, то это может быть признаком того, что в коде недостает какой-то абстракции.
Например, вместо того чтобы по отдельности проверять все свойства объекта, возвращенного тестируемой системой, 
возможно, будет лучше добавить методы проверки равенства (equality members) в класс такого объекта. 
После этого объект можно будет сравнивать с ожидаемым значением всего одной командой.

### 5.2.1. Проблемы, которые решает паттерн

1. *Читаемость*

Применение паттерна **Arrange Act Assert** позволяет четко разделить действия по настройке от основных действий и действий проверки.
Использование шаблона **Arrange-Act-Assert** при написании тестов, намного повышает шансы других разработчиков понять код.

2. *Рефакторинг*

Применение паттерна **Arrange Act Assert** требует разбиения теста на три секции и 
обязательного выполнения единственной проверки в тесте, а не просто хождение по шагам. 

Что в свою очередь упрощает рефакторинг кода:
* выявление наличия тестов, пытающихся одновременно протестировать слишком много разных вещей (*настрой действуй проверь, настрой действуй проверь*).
* обнаружение общих блоков кода в секции **Arrange**, которые можно вынести в **SetUp** метод.

### 5.2.2. До применения паттерна

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

### 5.2.3. После применения паттерна

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

## 5.3. Паттерн Assert Object / Matchers

Одна из наиболее значительных проблем с написанными тестами, заключается в том, 
что тесты проверяют не бизнес-инварианты, а основные технические детали.

***Assert Object / Matchers*** - паттерн, который создает проверки специфичные для предметной области, скрывая технические детали реализации. 

Существует несколько библиотек, которые уже содержат множество готовых к использованию сопоставителей (**Mathcers**) 
и предоставляют простой в использовании API для создания кастомных сопоставителей.
Самые популярные из них - **Hamcrest** и **AssertJ**.

Структура патерна:

1. Класс *<Наименование>Assert*

***<Наименование>Assert*** - класс обертка вокруг тестируемого объекта, скрывающий технические детали проверок и 
предоставляющий предметно ориентированные названия методов для проверки.

2. Класс *Test*

***Test*** - класс, который реализует логику тестов.

### 5.3.1. Проблемы, которые решает паттерн

1. *Читаемость*

Применение паттерна **Assert Object** создает логику предметной области в тестах, 
объединяя группу проверок нацеленных на конкретный объект в отдельный класс.

2. *Дублирование*

Применение паттерна **Assert Object** обеспечивает создание отдельного класса с проверками, 
которые могут использоваться повторно, что сокращает общее дублирование кода.

### 5.3.2. До применения паттерна

Тесты

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

В исходном примере не видно очевидной логики проверок в тесте.
Пользователю может быть непонятно что именно будет проверяться.

### 5.3.3. После применения паттерна

Тест
*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```   

Класс с матчерами
```java
// Матчеры
public class HomePageAssert {
    private HomePage homePage;
    
    public HomePageAssert(HomePage homePage) {
        this.homePage = homePage;
    }
    
    // Проверка отображения текста после входа с логином и паролем
    public void displayedTextAfterLogin() {
        Assertions.assertTrue(homePage.isDisplayed());
    }
    
    // Проверка текста после входа с логином и паролем
    public void textAfterLoginIs(String expected) {
        Assertions.assertEquals(homePage.getText(), expected, 
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

Теперь тест выглядит великолепно и его можно читать намного проще, чем раньше, а код утверждения внизу остается прежним.



Паттерн **Assert Object** может быть очень полезным методом рефакторинга кода тестов. 
Как программист, вы тратите большую часть своего времени не на написание, а на чтение исходного кода. 
Понятные и простые тесты могут сделать вашу работу (и ваших коллег) намного лучше.

Конечно, паттерн **Assert Object** не должен быть способом написания проверок по умолчанию. 
Если вы можете завершить тест одним или двумя проверками, то, вероятно, лучше не оборачивать их какими-либо дополнительными объектами. 
Наличие слишком большого количества проверок также может означать, что тестируемые объекты плохо спроектированы (проверяют слишком много всего). 

***

# 6. Прочие структурные паттерны



## 6.1. Паттерн Decorator

***Decorator*** - паттерн, который позволяет динамически добавлять объектам новую функциональность,
оборачивая их в полезные «обёртки»

### 6.1.1. Проблемы, которые решает паттерн

Декоратор - очень известный шаблон, поскольку он упоминался в списке GoF и
обсуждался во многих других книгах и статьях по программированию.
Пример этого прост. Представим, что вы работаете с какой-либо реализацией драйвера
(например, WebDriver) и хотите добавить к ней дополнительные функции, такие как ведение журнала или кеширование.
Но в то же время вы не хотите раскрывать эту дополнительную функциональность в ваших реальных тестах,
оставляя логику тестирования такой же, как и раньше. Вот где вы хотите использовать Decorator.

Декоратор помогает реализовать так называемый «принцип капусты»,
когда вы можете обернуть одну реализацию драйвера в другую, как образуются капустные листья.
Ваши тесты не будут знать об этом дополнительном слое, поскольку они работают с тем же интерфейсом, что и раньше.

Например, вы хотите регистрировать каждый щелчок по какому-либо элементу в ваших тестах.
Все, что вам нужно сделать, это украсить ваш исходный объект WebDriver,
заключив его в EventFiringWebDriver и зарегистрировав нового слушателя, при этом ваши тесты вообще не нужно менять:

### 6.1.2. До применения паттерна

*Пример*

```java

```

### 6.1.3. После применения паттерна

*Пример*

```java
new EventFiringWebDriver(driver)
    .register(new AbstractWebDriverEventListener() {
        @Override 
        public void afterClickOn(WebElement element, WebDriver driver) {
            LOG.log(Level.INFO, "Click on element " + element.getTagName());
        }
    }
);
```


*Пример*

```java

```

### 6.1.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/decorator
http://design-pattern.ru/patterns/abstract-factory.html
https://javadevcentral.com/decorator-design-pattern
https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm
https://java-design-patterns.com/patterns/decorator/
https://www.journaldev.com/1540/decorator-design-pattern-in-java-example
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b4%d0%b5%d0%ba%d0%be%d1%80%d0%b0%d1%82%d0%be%d1%80/
https://javarush.ru/groups/posts/3426-pattern-dekorator-decorator
https://metanit.com/sharp/patterns/4.1.php

## 6.2. Паттерн Proxy

***Proxy*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заменители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Прокси - это шаблон, который позволяет вмешиваться в процесс, происходящий между вами и другим пользователем,
вводя новую логику между ними, не затрагивая ни одну из сторон.

### 6.2.1. Проблемы, которые решает паттерн

Этот шаблон может быть полезен, когда вы, например, хотите добавить ведение журнала, включить или отключить что-то,
иметь контроль над некоторыми дополнительными ресурсами и т. Д.
Самый популярный метод использования его в тестах - это настройка HTTP-прокси.
Это позволяет динамически включать и отключать черные списки хостов,
исключая или заглушая сторонние сайты, такие как Facebook или Twitter, в ваших тестах.
Иногда это единственный способ проверить некоторые исключительные сценарии для внешних служб, подобных этим.

### 6.2.2. До применения паттерна

*Пример*

```java

```

### 6.2.3. После применения паттерна

*Пример*

```java

```


*Пример*

```java

```

### 6.2.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/proxy
https://javadevcentral.com/proxy-design-pattern
https://javadevcentral.com/proxy-pattern-vs-decorator-pattern
https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm
https://java-design-patterns.com/patterns/proxy/
https://www.journaldev.com/1572/proxy-design-pattern
https://habr.com/ru/company/jugru/blog/338836/
https://javarush.ru/groups/posts/2368-pattern-proektirovanija-proxy
https://metanit.com/sharp/patterns/4.5.php

## 6.3. Паттерн Object Pool / Flyweight

***Object Pool/Flyweight*** - паттерн, который позволяет вместить бóльшее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

### 6.3.1. Проблема

Используя этот паттерн, мы могли бы реализовать много интересного, например, пул браузеров.
Я слышал тихие жалобы от разных людей, что веб-тесты занимают безумно много времени,
потому что они требуют запуска браузера, загрузки первой страницы, импорта профилей пользователей и т. д.
Но необязательно создавать браузер в реальном тесте, вместо этого мы могли бы использовать фоновый пул, который настроен на сохранение необходимого количества «горячих» браузеров.
Закончив работу с браузером, мы просто возвращаем его в пул и очищаем его данные.
И это может быть сделано в фоновом режиме, параллельно с фактическими тестовыми потоками.
И только после того, как браузер снова будет готов к использованию, его можно будет вернуть на следующий тест в качестве нового экземпляра.

Тем не менее, эта конфигурация пула и настройки браузера могут быть исключены из теста,
значительно минимизируя затрачиваемое на это время и ресурсы.

Другой пример - использование страницы. Вам не нужно ждать, пока откроется нужная страница,
если все тесты начинаются с одной страницы. Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать, пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных. Вместо того, чтобы работать с реальной базой данных,
мы можем запустить необходимое количество контейнеров базы данных на разных портах (это можно сделать с помощью Docker или другого инструмента виртуализации)
и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. Д.

### 6.3.2. До применения паттерна

*Пример*

```java

```

### 6.3.3. После применения паттерна

Следующий паттерн используют еще меньше разработчиков.
Легковес - это классический паттерн из книги GoF, который решает проблему сохранения и работы с тяжелыми с точки зрения ресурсов объектами или набором объектов.
Вместо того, чтобы создавать их каждый раз, когда они нам нужны, мы берем их, используем и возвращаем в так называемый пул для использования в будущем.

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```


*Пример*

```java

```

### 6.3.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern
https://www.tutorialspoint.com/design_pattern/flyweight_pattern.htm
https://java-design-patterns.com/patterns/flyweight/
https://www.journaldev.com/1562/flyweight-design-pattern-java
https://habr.com/ru/post/88393/
https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-2/2.2-flyweight.html
https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern
https://metanit.com/sharp/patterns/4.7.php

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)