Java_QA / Level 2. Medium - Продвинутые темы / Урок 02. Page Object, PageFactory

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Что такое паттерны?

***Шаблон проектирования или паттерн*** в разработке программного обеспечения —
повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Обычно паттерн не является законченным образцом, который может быть прямо преобразован в код.
Это лишь пример решения задачи, который можно использовать в различных ситуациях.
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами,
без определения того, какие конечные классы или объекты приложения будут использоваться.

http://sd.blackball.lv/library/Patterny_proektirovanija_na_platforme_NET_(2015).pdf

***

# 2. Зачем нужны паттерны?

**Паттерны** - не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда.
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Не существует такого понятия как **хороший паттерн** или **плохой паттерн**. 
Сам термин **паттерн** был придуман в качестве формулировки проблемы и предложенного решения. 
Если задача не разделяет проблему, для которой **паттерн** был придуман – это не значит, 
что он плохой или вышел из моды, просто он не подходит для решения этой задачи. 
Если проблема каким-то образом совпадает и накладывается на этот **паттерн**, значит, стоит его рассмотреть.

Таким образом важно не просто приносить дизайн-паттерны в свой проект только потому, 
что вы о них услышали, важно понимать их назначение, проблематику, как и чем они могут вам помочь.

***

# 3. Паттерны в автотестировании 

Изначально классические паттерны были сформулированы давным-давно четверкой, которая выпустила книгу **Design Patterns**.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире.
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, пополняясь новыми паттернами.

Сегодня просматривается тенденция появления подобных паттернов в других областях, в которых накопилась проблематика.
Автоматизация тестирования имеет собственный набор задач, так что существует и набор полезных паттернов проектирования для этой области.

Основными драйверами практически всех паттернов в автоматизации тестирования являются **факторы**:

* *надежность*
* *понятность*
* *гибкость*
* *поддерживаемость*
* *стабильность*

Большая часть этих факторов находится под влиянием разделения компонентов.
В любом тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три **компонента**:

* *тестовая логика* (описание шагов тест кейсов)
* *тестовые данные* (описание данных для тест кейсов)
* *техническая часть* (отвечающая за непосредственное взаимодействие с приложением - вызов функций, клики на экран и т. п.)

Если эти **компоненты** хорошо разделены, тесты начинают хорошо попадать в выше упомянутые **факторы**,
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

Все паттерны можно поделить на группы:

* *структурные паттерны*
* *порождающие паттерны*
* *поведенческие паттерны*
* *паттерны данных*
* *технические паттерны*
* *бизнес паттерны*

***

# 4. Структурные паттерны

***Cтруктурные паттерны*** - паттерны проектирования, в которых рассматривается вопрос о том, 
как из классов и объектов образуются более крупные структуры.

Структурные паттерны проектирования упрощают проектирование путем выявления 
простого способа реализовать отношения между субъектами.

***

# 5. Структурные паттерны в автотестировании

***Cтруктурные паттерны в автотестировании*** - паттерны, основная задача которых сводится к структурированию кода тестов,
чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью.
Таким образом, тестовым инженерам, работающим с теми же проблемами, будет проще понять их и изменить, и проще поддерживать.

## 5.1. Паттерн Page Object

***Page Object*** - паттерн, который моделирует объект страницы в качестве объектов в коде и 
позволяет разделять логику выполнения тестов от их реализации.

Структура паттерна:

1. *BasePage*
  
В классе BasePage определяем базовые методы для работы с **WebDriver**.
Все классы объектов страницы будут расширять **BasePage**, унаследовав, таким образом, все базовые методы.

2. *Page*

Реализует методы для работы с элементами на конкретных веб-страницах.
К примеру, можно создать отдельные классы для Главной страницы, страницы Авторизации и Регистрации.
При использовании **Page Object** элементы страниц, а также методы непосредственного взаимодействия с ними, 
выносятся в отдельный классы, отвечающие за работу с **HTML** каждой конкретной веб-страницы.
 
3. *Test*

Класс который реализует логику тестов.

Правила применения паттерна:

* у объекта страницы не должно быть никаких утверждений
  
Объекты страницы никогда не должны делать проверки или утверждения.
Это часть теста и всегда должна быть в коде теста, а не в объекте страницы.
Объект страницы должен содержать элементы страницы и методы, с помощью которых можно с ними взаимодействовать.
Но никакой код, связанный с тем, что тестируется, не должен находиться в объекте страницы.

Существует одна, единственная проверка, которая может и должна быть внутри объекта страницы,
а именно проверка того, что страница и, возможно, критические элементы на странице были загружены правильно.
Эта проверка должна выполняться при создании экземпляра объекта страницы.

* объект страницы должен представлять значимые элементы страницы, а не обязательно полную страницу.

Класс не обязательно должен представлять собой всю страницу.
Он может быть частью страницы, которая часто используется на сайте (или даже на одной странице).
Например пагинация или блок ссылок.
Нет никакой необходимости моделировать все элементы представленные на странице, 
если в тестах с ними нет никакого взаимодействия. 
Лишний код только ухудшит восприятие и понимание.


### 5.1.1. Проблемы, которые решает паттерн

1. *Читаемость кода*

Код функциональных тестов написанных с использованием **Selenium WebDriver** в основном будет 
состоять из взаимодействий с веб-интерфейсом, который проверяется.
То есть любой код теста будет состоять из последовательностей:

* поиск элемента на странице
* получение свойства элемента или выполнения действия с элементом
* проверка некоторого состояние элемента или системы с помощью различных утверждений

Даже в самом простом тесте читаемость очень плохая, так присутствует много кода **Selenium WebDriver**,
который скрывает цель теста, делая его трудным для восприятия.

Применение паттерна **Page Object** обеспечивает четкое разделение технических деталей (взаимодействие с элементами веб интерфейса) и фактической логикой тестов.
Также паттерн объединяет все действий по работе с конкретной веб-страницей в одном месте (соответствующем классе).

2. *Дублирование кода*

При написании UI тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами в разных кейсах. 
Что в свою очередь приводит к написанию одинакового кода в разных местах.

Применение паттерна **Page Object** значительно уменьшает объем повторяющегося кода путем определения 
единого места (**объект страницы**) для определения операций, выполняемых на странице вместе разброса этих методов по тестам.

3. *Поддержка кода*

В любом в пользовательском интерфейсе, часто вносятся как незначительные, так и серьезные изменения.
Это может быть новый дизайн, реструктуризация полей и кнопок,и т д.
Изменения в пользовательском интерфейсе часто нарушают работу нескольких тестов в нескольких местах.

Применение паттерна **Page Object** позволяет легко обновить код, после любого изменения пользовательского интерфейса, 
путем добавления новых элементов, обновления или удаления существующих в одном месте (**объекте страницы**), 
а не исправлять каждый тест, в котором этот интерфейс используется.

4. *Повторное использование кода*
   
Как уже упоминалось выше при написании тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами.

Применение паттерна **Page Object** обеспечивает сохранение отдельных репозиториев объектов страницы независимо от тестов автоматизации. 
Что в свою очередь позволяет повторно использовать этот репозиторий для разных целей с разными инструментами.
Например, можно интегрировать объектную модель страницы в **Selenium** с **TestNG** / **JUnit** для функционального тестирования
и одновременно с **JBehave** / **Cucumber** для приемочного тестирования.

### 5.1.2. До применения паттерна

*Пример*

```java
public class Login {

  public void testLogin() {
    // fill login data on sign-in page
    driver.findElement(By.name("user_name")).sendKeys("testUser");
    driver.findElement(By.name("password")).sendKeys("my supersecret password");
    driver.findElement(By.name("sign-in")).click();

    // verify h1 tag is "Hello userName" after login
    driver.findElement(By.tagName("h1")).isDisplayed();
    assertThat(driver.findElement(By.tagName("h1")).getText(), is("Hello userName"));
  }
}
```
У этого подхода есть две проблемы.

Нет разделения между методом тестирования и локаторами AUT (в данном примере идентификаторами); 
оба переплетаются в едином методе. 
Если пользовательский интерфейс AUT изменяет свои идентификаторы, макет или способ ввода и обработки логина, сам тест должен измениться.

ID-локаторы будут распространяться в нескольких тестах, во всех тестах, которые должны использовать эту страницу входа.


### 5.1.3. После применения паттерна

*Пример*

```java
/**
 * Page Object encapsulates the Sign-in page.
 */
public class SignInPage {
  protected WebDriver driver;

  // <input name="user_name" type="text" value="">
  private By usernameBy = By.name("user_name");
  // <input name="password" type="password" value="">
  private By passwordBy = By.name("password");
  // <input name="sign_in" type="submit" value="SignIn">
  private By signinBy = By.name("sign_in");

  public SignInPage(WebDriver driver){
    this.driver = driver;
  }

  /**
    * Login as valid user
    *
    * @param userName
    * @param password
    * @return HomePage object
    */
  public HomePage loginValidUser(String userName, String password) {
    driver.findElement(usernameBy).sendKeys(userName);
    driver.findElement(passwordBy).sendKeys(password);
    driver.findElement(signinBy).click();
    return new HomePage(driver);
  }
}

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;

/**
 * Page Object encapsulates the Home Page
 */
public class HomePage {
  protected WebDriver driver;

  // <h1>Hello userName</h1>
  private By messageBy = By.tagName("h1");

  public HomePage(WebDriver driver){
    this.driver = driver;
    if (!driver.getTitle().equals("Home Page of logged in user")) {
      throw new IllegalStateException("This is not Home Page of logged in user," +
            " current page is: " + driver.getCurrentUrl());
    }
  }

  /**
    * Get message (h1 tag)
    *
    * @return String message text
    */
  public String getMessageText() {
    return driver.findElement(messageBy).getText();
  }

  public HomePage manageProfile() {
    // Page encapsulation to manage profile functionality
    return new HomePage(driver);
  }
  /* More methods offering the services represented by Home Page
  of Logged User. These methods in turn might return more Page Objects
  for example click on Compose mail button could return ComposeMail class object */
}
```

*Пример*

```java
/***
 * Tests login feature
 */
public class TestLogin {

  @Test
  public void testLogin() {
    SignInPage signInPage = new SignInPage(driver);
    HomePage homePage = signInPage.loginValidUser("userName", "password");
    assertThat(homePage.getMessageText(), is("Hello userName"));
  }

}
```

### 5.1.4. Использование в автотестах

Мы хотели бы повторно использовать наш код в различных тестовых сценариях, и Page Object может нам в этом помочь.
Иногда, когда я добавляю новые тесты в свои проекты, мне не нужно писать никаких дополнительных классов или функций, кроме тестового скрипта.
Потому что они уже были написаны с помощью Page Object!

И, наконец, Page Object делает тесты более читаемыми и понятными.
Он показывает, на какой странице сейчас находится пользователь, и предотвращает выполнение тестом действий, не связанных с текущей страницей.

Конечно, Page Object - не панацея.
Если бы в моем проекте было небольшое количество тестов (т.е. менее 20) и я не планировал их расширять,
Я бы подумал не использовать его. Просто потому, что усилия по созданию объектов страницы не окупились.
Каждый шаблон может принести большую пользу вашему проекту, но они не должны быть вашей целью в пользу потребностей проекта.

https://java-design-patterns.com/patterns/page-object/
http://internetka.in.ua/selenium-page-object/
https://alexilyenko.github.io/uiautomator-page-object/
https://www.softwaretestingmaterial.com/page-object-model/
https://www.softwaretestinghelp.com/page-object-model-pom-with-pagefactory/
https://devqa.io/page-object-framework-java-webdriver/
https://www.geeksforgeeks.org/page-object-model-pom/
https://www.guru99.com/page-object-model-pom-page-factory-in-selenium-ultimate-guide.html
https://www.seleniumeasy.com/selenium-tutorials/simple-page-object-model-framework-example
https://kreisfahrer.gitbooks.io/selenium-webdriver/content/page_object_pattern_arhitektura_testovogo_proekta/ispolzovanie_patterna_page_object.html
https://www.selenium.dev/documentation/en/guidelines_and_recommendations/page_object_models/
https://www.browserstack.com/guide/page-object-model-in-selenium
https://habr.com/ru/company/jugru/blog/474408/

## 5.2. Паттерн Page Factory

***Page Factory*** - паттерн, который моделирует объект страницы.
Page Factory is an extension to Page Object pattern. It helps to encapsulate page’s attributes and methods even more by providing FindBy annotations.

### 5.2.1. Проблемы, которые решает паттерн

разделение технических деталей (например, элементов пользовательского интерфейса на странице / экране).
и фактическая логика тестирования UI-теста.
уменьшить дублирование кода

### 5.2.2. До применения паттерна

*Пример*

```java

```

### 5.2.3. После применения паттерна

*Пример*

```java

```

*Пример*

```java
public class LoginPage extends BasePage {
    private static final By USERNAME_FIELD = By.id("usernameField");
    private static final By PASSWORD_FIELD = By.id("passwordField");
    private static final By LOGIN_BUTTON = By.id("loginButton");
    
    public LoginPage(WebDriver driver) {
        super(driver);
    }
    
    public HomePage loginAs(User user) {
        driver.findElement(USERNAME_FIELD).sendKeys(user.username);
        driver.findElement(PASSWORD_FIELD).sendKeys(user.password);
        driver.findElement(LOGIN_BUTTON).click();
        return new HomePage(driver);
    }
}

public class LoginPage extends BasePage {
    @FindBy
    private WebElement usernameField;
    @FindBy
    private WebElement passwordField;
    @FindBy
    private WebElement loginButton;
    
    public LoginPage(WebDriver driver) {
        super(driver);
        PageFactory.initElements(driver, this);
    }
    
    public HomePage loginAs(User user) {
        usernameField.sendKeys(user.username);
        passwordField.sendKeys(user.password);
        loginButton.click();
        return new HomePage(driver);
    }
}
```

### 5.2.4. Использование в автотестах

Pay attentions to PageFactory#initElements invocation.
This static helper initializes all fields with FindBy annotations on the page, which will be found on it on each call.
The main advantage is the fact that now we work directly with fields, buttons, windows etc.
and do not worry about low level driver’s interactions exactly the same way our app users do.

Composition of Page Elements

Any web, desktop or mobile application consists of repeatable elements, and logic of their usage should be implemented again and again in our tests.
For instance, every menu has list of links, every table has rows and columns, every form has input fields.
In real life when we work with those elements we do not separate those components from the main element consisting them.

Thanks to Composition we could implement some elements once and reuse them every time we need them.
Thus it helps to avoid code duplication by composing different web elements into widgets (high-level elements), like tables, menus, forms.
This significantly reduces costs of extending and scaling of test automation framework when, for example new Page Objects needs to be created.

## 5.3. Паттерн Arrange Act Assert (Given When Then)

**Тест** – это процедура, которая проверяет поведение с целью определить, правильно ли оно функционирует. 
Тестов много видов (**unit**, **интеграционные**, **end-to-end**), но все функциональные тесты по сути делают одно и то же: 
пробуют что-то и сообщают **PASS** или **FAIL**.

***Arrange Act Assert (Подготовка, Действие, Проверка)*** – паттерн, который организует структуру тест-кейсов и задает порядок операций. 
Паттерн **AAA** предоставляет простую единообразную структуру для всех тестов в проекте. 
Это единообразие дает большое преимущество: привыкнув к нему, вы сможете легко прочитать и понять любой тест. 

Структура теста (метода) при использовании паттерна **AAA** выглядит так:

1. Секция *Arrange* 
   
В этой секции выполняются шаги по подготовке тестируемой системы и ее зависимостей в нужное состояние.

Эти шаги должны подготовить тест-кейс:
* создание объектов
* выполнение особых настроек
* подготовка данных 
* передача подготовленных зависимостей
* сохранение выходного значения (если оно есть)
  
и т. д

2. Секция *Act* 
   
В этой секции выполняются шаги по выполнению основной задачи теста.

Эти шаги должны выполнить тест кейс:
* вызов функции/метода
* вызов api 
* взаимодействие с веб-страницей

и т. д.

3. Секция *Assert* 
   
В этой секции выполняются шаги по проверке результата (возвращаемое значение или итоговое состояние тестируемой системы).
  
Эти шаги должны получить ответ на вопрос упал тест или прошел:
* проверка числовых или строковых значений
* проверка множества аспектов системы

и т. д.

В **BDD** паттерн **Подготовка, Действие, Проверка** называется иначе **Если, Когда, Тогда**. 
Язык Gherkin использует шаги **Если, Когда, Тогда** для описания поведенческих сценариев. 
По сути это та же самая формула, что и в **Подготовка, Действие, Проверка (Настрой, Действуй, Проверь)**

### 5.3.1. Проблемы, которые решает паттерн

Улучшение читаемости кода автотестов.
Обеспечение строго порядка при написании автотестов.

### 5.3.2. До применения паттерна

*Пример*

```java
@Test
public void beforePatternTest() {
    driver.get("http://somesite.com");
    
    WebElement link = driver.findElement(By.xpath("//a[text()=\"Log In\"]"));
    waitToBeClickable(By.xpath("//a[text()=\"Log In\"]"));
    link.click();
    
    WebElement email = driver.findElement(By.xpath("//input[@id=\"email\"]"));
    waitToBeClickable(By.xpath("//input[@id=\"email\"]")));
    email.sendKeys("test@test.test");
    
    WebElement password = driver.findElement(By.xpath("//input[@id=\"password\"]"));
    waitToBeClickable(By.xpath("//input[@id=\"password\"]")));
    password.sendKeys("qwerty");
    
    waitToBeTitle("//h1");
    String title = driver.getTitle();
    Assert.asserEquals(title, "Page Title");
}
```

### 5.3.3. После применения паттерна

*Пример*

```java
@Test
public void afterPatternTest() {
    // Arrange
    String email = "test@test.test";
    String password = "qwerty";
    driver.get("http://somesite.com");
    
    // Act
    WebElement link = driver.findElement(By.xpath("//a[text()=\"Log In\"]"));    
    waitToBeClickable(By.xpath("//a[text()=\"Log In\"]"));
    link.click();
    
    WebElement email = driver.findElement(By.xpath("//input[@id=\"email\"]"));
    waitToBeClickable(By.xpath("//input[@id=\"email\"]")));
    email.sendKeys(email);
    
    WebElement password = driver.findElement(By.xpath("//input[@id=\"password\"]"));
    waitToBeClickable(By.xpath("//input[@id=\"password\"]")));
    password.sendKeys(password);
    
    waitToBeTitle("//h1");
    String title = driver.getTitle();
    
    // Assert
    Assert.assertEquals(title, "Page Title");
}
```

### 5.3.4. Использование в автотестах


### 5.3.5.

https://habr.com/ru/post/554808/

https://www.thephilocoder.com/unit-testing-aaa-pattern/
https://habr.com/ru/post/507594/
https://www.spbdk.ru/upload/iblock/3e7/3e7e5c4346ac2e2090ef6e24e9cbb1fb.pdf
https://freecontent.manning.com/making-better-unit-tests-part-1-the-aaa-pattern/
https://java-design-patterns.com/patterns/arrange-act-assert/

## 5.4. Паттерн Assert Object/Matchers

***Assert Object/Matchers*** - паттерн,

Большинство людей слышали о следующем паттерне, 
но я видел лишь несколько человек, которые действительно его использовали.
Его имя - «Утвердить объект» или просто Matcher.
Обычно его можно использовать всякий раз, когда нам нужно сделать утверждения, 
специфичные для предметной области, для некоторого объекта. Давайте посмотрим на пример ниже:

### 5.4.1. Проблемы, которые решает паттерн



### 5.4.2. До применения паттерна

*Пример*

```java
@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
    List<Response> responses = server.getResponses();
    assertEquals(1, responses.size());
    Response response = responses.get(0);
    assertEquals(ResponseCode.ERROR_403, response.getCode());
}
```

### 5.4.3. После применения паттерна

*Пример*

```java
@Test
public void onlyOneResponseWithErrorCodeShouldBeReturned() {
    assertThat(server).hadSingleResponseWithCode(ResponseCode.ERROR_403);
}
```   

```java
public static ServerAssert assertThat(Server server) {
    return new ServerAssert(server);
}

public class ServerAssert {
    private final Server server;
    public ServerAssert(Server server) {
        this.server = server;
    }
    
    public void hadSingleResponseWithCode(ResponseCode responseCode) {
        List<Response> responses = server.getResponses();
        assertEquals(1, responses.size());
        Response response = responses.get(0);
        assertEquals(responseCode, response.getCode());
    }
}
```

В исходном примере мы не видим очевидной логики проверок в тесте.
Пользователю может быть непонятно, что именно будет проверяться.
Сначала мы проверяем, что сервер возвращает только один ответ, а затем проверяем, что ответ содержит код ошибки 403.
Мы должны разделить эти проверки на два отдельных утверждения, потому что в противном случае было бы трудно понять, что пошло не так.
Но для того, кто не знаком с нашей предметной областью, все равно будет сложно понять такой тест.

Шаблон соответствия помогает нам создавать утверждения в виде многоразовых конструкций, что сокращает общее дублирование кода.
Например, если нам нужно убедиться, что сервер возвращает один ответ, но с кодом ответа 200.

Кроме того, этот подход создает логику предметной области в наших тестах.
Вот почему я предпочитаю реализовать его так, как показано выше, когда мы создаем группу утверждений и объединяем их в отдельный класс (например, ServerAssert),
который отвечает за все возможные проверки объекта Server.
Затем все, что нам нужно сделать, это создать статический метод assertThat, принимающий объект Server и возвращающий вместо него ServerAssert.
Он выглядит великолепно и его можно читать намного проще, чем раньше, а код утверждения внизу остается прежним.

Другой вариант создания сопоставителей - создание статических методов для каждого из них.
Существует несколько библиотек, которые уже содержат множество готовых к использованию сопоставителей и предоставляют простой в использовании API для создания ваших собственных.
Самые популярные из них - Hamcrest и AssertJ.
Если вы не использовали их раньше, я предлагаю хотя бы обратить на них внимание и подумать о том, чтобы встроить их в свой фреймворк.
Опять же, у них не будет сопоставителей для вашего домена, но они могут значительно упростить их создание.

### 5.4.4. Использование в автотестах

https://www.mikulskibartosz.name/assert-object-pattern/

***

# 6. Прочие структурные паттерны

The main goal of Technical Patterns is to encapsulate technical details from test logic, 
providing extra low-level control over them.

## 6.1. Паттерн Decorator

***Decorator*** - паттерн, который позволяет динамически добавлять объектам новую функциональность,
оборачивая их в полезные «обёртки»

### 6.1.1. Проблемы, которые решает паттерн

Декоратор - очень известный шаблон, поскольку он упоминался в списке GoF и
обсуждался во многих других книгах и статьях по программированию.
Пример этого прост. Представим, что вы работаете с какой-либо реализацией драйвера
(например, WebDriver) и хотите добавить к ней дополнительные функции, такие как ведение журнала или кеширование.
Но в то же время вы не хотите раскрывать эту дополнительную функциональность в ваших реальных тестах,
оставляя логику тестирования такой же, как и раньше. Вот где вы хотите использовать Decorator.

Декоратор помогает реализовать так называемый «принцип капусты»,
когда вы можете обернуть одну реализацию драйвера в другую, как образуются капустные листья.
Ваши тесты не будут знать об этом дополнительном слое, поскольку они работают с тем же интерфейсом, что и раньше.

Например, вы хотите регистрировать каждый щелчок по какому-либо элементу в ваших тестах.
Все, что вам нужно сделать, это украсить ваш исходный объект WebDriver,
заключив его в EventFiringWebDriver и зарегистрировав нового слушателя, при этом ваши тесты вообще не нужно менять:

### 6.1.2. До применения паттерна

*Пример*

```java

```

### 6.1.3. После применения паттерна

*Пример*

```java
new EventFiringWebDriver(driver)
    .register(new AbstractWebDriverEventListener() {
        @Override 
        public void afterClickOn(WebElement element, WebDriver driver) {
            LOG.log(Level.INFO, "Click on element " + element.getTagName());
        }
    }
);
```


*Пример*

```java

```

### 6.1.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/decorator
http://design-pattern.ru/patterns/abstract-factory.html
https://javadevcentral.com/decorator-design-pattern
https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm
https://java-design-patterns.com/patterns/decorator/
https://www.journaldev.com/1540/decorator-design-pattern-in-java-example
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b4%d0%b5%d0%ba%d0%be%d1%80%d0%b0%d1%82%d0%be%d1%80/
https://javarush.ru/groups/posts/3426-pattern-dekorator-decorator
https://metanit.com/sharp/patterns/4.1.php

## 6.2. Паттерн Proxy

***Proxy*** - паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заменители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Прокси - это шаблон, который позволяет вмешиваться в процесс, происходящий между вами и другим пользователем,
вводя новую логику между ними, не затрагивая ни одну из сторон.

### 6.2.1. Проблемы, которые решает паттерн

Этот шаблон может быть полезен, когда вы, например, хотите добавить ведение журнала, включить или отключить что-то,
иметь контроль над некоторыми дополнительными ресурсами и т. Д.
Самый популярный метод использования его в тестах - это настройка HTTP-прокси.
Это позволяет динамически включать и отключать черные списки хостов,
исключая или заглушая сторонние сайты, такие как Facebook или Twitter, в ваших тестах.
Иногда это единственный способ проверить некоторые исключительные сценарии для внешних служб, подобных этим.

### 6.2.2. До применения паттерна

*Пример*

```java

```

### 6.2.3. После применения паттерна

*Пример*

```java

```


*Пример*

```java

```

### 6.2.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/proxy
https://javadevcentral.com/proxy-design-pattern
https://javadevcentral.com/proxy-pattern-vs-decorator-pattern
https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm
https://java-design-patterns.com/patterns/proxy/
https://www.journaldev.com/1572/proxy-design-pattern
https://habr.com/ru/company/jugru/blog/338836/
https://javarush.ru/groups/posts/2368-pattern-proektirovanija-proxy
https://metanit.com/sharp/patterns/4.5.php

## 6.3. Паттерн Object Pool/Flyweight

***Object Pool/Flyweight*** - паттерн, который позволяет вместить бóльшее количество объектов в отведённую оперативную память.
Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

### 6.3.1. Проблема

Используя этот паттерн, мы могли бы реализовать много интересного, например, пул браузеров.
Я слышал тихие жалобы от разных людей, что веб-тесты занимают безумно много времени,
потому что они требуют запуска браузера, загрузки первой страницы, импорта профилей пользователей и т. д.
Но необязательно создавать браузер в реальном тесте, вместо этого мы могли бы использовать фоновый пул, который настроен на сохранение необходимого количества «горячих» браузеров.
Закончив работу с браузером, мы просто возвращаем его в пул и очищаем его данные.
И это может быть сделано в фоновом режиме, параллельно с фактическими тестовыми потоками.
И только после того, как браузер снова будет готов к использованию, его можно будет вернуть на следующий тест в качестве нового экземпляра.

Тем не менее, эта конфигурация пула и настройки браузера могут быть исключены из теста,
значительно минимизируя затрачиваемое на это время и ресурсы.

Другой пример - использование страницы. Вам не нужно ждать, пока откроется нужная страница,
если все тесты начинаются с одной страницы. Вы также можете получить пул страниц и запросить его оттуда.
Это означает, что он будет заранее открыт в одном из экземпляров браузера в фоновом режиме и будет ожидать, пока тест не обнаружит его в готовом к использованию состоянии.

Другой хорошо известный вариант использования этого подхода - Пул базы данных. Вместо того, чтобы работать с реальной базой данных,
мы можем запустить необходимое количество контейнеров базы данных на разных портах (это можно сделать с помощью Docker или другого инструмента виртуализации)
и «убить» его, когда он нам больше не понадобится.
Таким образом, у нас всегда будет чистая база данных без необходимости разбирать ее, очищать, собирать и загружать данные и т. Д.

### 6.3.2. До применения паттерна

*Пример*

```java

```

### 6.3.3. После применения паттерна

Следующий паттерн используют еще меньше разработчиков.
Легковес - это классический паттерн из книги GoF, который решает проблему сохранения и работы с тяжелыми с точки зрения ресурсов объектами или набором объектов.
Вместо того, чтобы создавать их каждый раз, когда они нам нужны, мы берем их, используем и возвращаем в так называемый пул для использования в будущем.

*Пример*

```java
private final UserPool USER_POOL = new UserPool();
private User user;

@Before
public void setUp() {
    user = USER_POOL.getAvailableUser();
}

@Test
public void userShouldBeAbleToLogin() {
    HomePage homePage = loginPage().loginAs(user);
    assertThat(homePage.getUsername(), is(user.getName()))
}

@After
public void tearDown() {
USER_POOL.releaseUser(user);
}
```


*Пример*

```java

```

### 6.3.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern
https://www.tutorialspoint.com/design_pattern/flyweight_pattern.htm
https://java-design-patterns.com/patterns/flyweight/
https://www.journaldev.com/1562/flyweight-design-pattern-java
https://habr.com/ru/post/88393/
https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-2/2.2-flyweight.html
https://refactoring.guru/ru/design-patterns/flyweight
https://javadevcentral.com/flyweight-design-pattern
https://metanit.com/sharp/patterns/4.7.php

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)