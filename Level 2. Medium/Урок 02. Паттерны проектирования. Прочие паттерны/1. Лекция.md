Java_QA / Level 2. Medium - Продвинутые темы / Урок 01. Паттерны проектирования

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Порождающие паттерны

https://www.baeldung.com/java-creational-design-patterns

# 2. Порождающие паттерны

## 2.1. Паттерн Data Transfer Object

***Data Transfer Object*** - паттерн, представляющий собой класс, содержащий данные без какой-либо логики для работы с ним.
По сути это простой класс.

### 2.1.1. Структура паттерна



### 2.1.2. Применимость



### 2.1.3. Преимущества и недостатки

#### 2.1.3.1. Преимущества

Необходимо передавать в метод в качестве параметра множество примитивных значений за раз.

#### 2.1.3.2. Недостатки



### 2.1.4. Применение в автотестах

#### 2.1.4.1. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

#### 2.1.4.2. После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

## 2.2. Паттерн Singleton

***Singleton*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

### 2.2.1. Структура паттерна



### 2.2.2. Применимость



### 2.2.3. Преимущества и недостатки

#### 2.2.3.1. Преимущества

Необходимо наличие единственного экземпляра класса.

Необходимо наличие глобальной точки доступа.

#### 2.2.3.2. Недостатки



### 2.2.4. Применение в автотестах

#### 2.2.4.1. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

#### 2.2.4.2. После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://refactoring.guru/ru/design-patterns/singleton
http://design-pattern.ru/patterns/singleton.html
https://www.tutorialspoint.com/design_pattern/singleton_pattern.htm
https://java-design-patterns.com/patterns/singleton/
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja
https://metanit.com/sharp/patterns/2.3.php

## 2.3. Паттерн Factory Method

***Factory Method*** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

### 2.3.1. Структура паттерна



### 2.3.2. Применимость



### 2.3.3. Преимущества и недостатки

#### 2.3.3.1. Преимущества

Необходимо создание объектов с заранее неизвестным типом.

Необходимо наличие системы расширяемой и независимой от процесса создания новых объектов: 
в нее можно легко вводить новые классы, объекты которых система должна создавать.

Необходимо делегировать создание новых объектов из базового класса классам наследникам.

#### 2.3.3.2. Недостатки



### 2.3.4. Применение в автотестах

#### 2.3.4.1. До применения паттерна

*Пример*

```java
class User1 {
    private String firstName;
    private String lastName;

    public User1() {}
    
    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
}

class User2 {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    public User2() {}

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
}

public void createUser1 (User1 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    
}

public void createUser2 (User2 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    age.enter(user.getAge());
    isMarried.check(user.getIsMarried());
}
```

#### 2.3.4.2. После применения паттерна

*Пример*

```java

abstract class User {
    private String firstName;
    private String lastName;

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    abstract void someMethod();
}

class User1 extends User {
    public User1() { }
    public void someMethod() { }
}

class User2 extends User {
    private int age;
    private boolean isMarried;

    public User2() { }

    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
    public void someMethod() { }
}

class UserFactory
{
    public static User getUser(String userType) {
        switch (userType) {
            case "user1":
                User1 user1 = new User1();
                user1.setFirstName("First Name");
                user1.setLastName("Last Name");
                return user1;
            case "user2":
                User2 user2 = new User2();
                user2.setFirstName("First Name");
                user2.setLastName("Last Name");
                user2.setAge(40);
                user2.setIsMarried(false);
                return user2;
            default:
                throw new RuntimeException("Incorrect user type");
        }
    }
}
```

*Пример*

```java
public void createUser(String userType) {
    switch (userType) {
        case "user1":
            User1 user1 = UserFactory.getUser("user1");
            firstName.enter(user1.getFirstName());
            lastName.enter(user1.getLastName());
            age.enter(user1.getAge());
            isMarried.check(user1.getIsMarried());
            break;
        case "user2":
            User2 user2 = UserFactory.getUser("user2");
            firstName.enter(user2.getFirstName());
            lastName.enter(user2.getLastName());
            age.enter(user2.getAge());
            isMarried.check(user2.getIsMarried());
            premium.enter(user2.getPremium());
            break;
        default:
            throw new RuntimeException("Incorrect user type");
    }
}
```

Инициализация экземпляров **WebDriver** для разных браузеров.
Создание объектов страниц в **PageFactory**.

#### 2.3.4.1. Паттерн Page Factory

***Page Factory*** - паттерн, который моделирует объект страницы.
Page Factory is an extension to Page Object pattern. It helps to encapsulate page’s attributes and methods even more by providing FindBy annotations.

Pay attentions to PageFactory#initElements invocation.
This static helper initializes all fields with FindBy annotations on the page, which will be found on it on each call.
The main advantage is the fact that now we work directly with fields, buttons, windows etc.
and do not worry about low level driver’s interactions exactly the same way our app users do.

Composition of Page Elements

Any web, desktop or mobile application consists of repeatable elements, and logic of their usage should be implemented again and again in our tests.
For instance, every menu has list of links, every table has rows and columns, every form has input fields.
In real life when we work with those elements we do not separate those components from the main element consisting them.

Thanks to Composition we could implement some elements once and reuse them every time we need them.
Thus it helps to avoid code duplication by composing different web elements into widgets (high-level elements), like tables, menus, forms.
This significantly reduces costs of extending and scaling of test automation framework when, for example new Page Objects needs to be created.



https://refactoring.guru/ru/design-patterns/factory-method
http://design-pattern.ru/patterns/factory-method.html
https://javadevcentral.com/factory-method
https://www.tutorialspoint.com/design_pattern/factory_pattern.htm
https://java-design-patterns.com/patterns/factory/
https://javanerd.ru/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4/
https://www.journaldev.com/1392/factory-design-pattern-in-java
https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://metanit.com/sharp/patterns/2.1.php

##### 2.3.4.1.1. До применения паттерна



##### 2.3.4.1.2. После применения паттерна



#### 2.3.4.2. Паттерн Element Factory

##### 2.3.4.2.1. До применения паттерна



##### 2.3.4.2.2. После применения паттерна



## 2.4. Паттерн Abstract Factory

***Abstract Factory*** — паттерн, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.

### 2.4.1. Структура паттерна



### 2.4.2. Применимость



### 2.4.3. Преимущества и недостатки

#### 2.4.3.1. Преимущества



#### 2.4.3.2. Недостатки



### 2.4.4. Применение в автотестах

#### 2.4.4.1. До применения паттерна

*Пример*

```java

```

#### 2.4.4.2. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

https://refactoring.guru/ru/design-patterns/abstract-factory
http://design-pattern.ru/patterns/abstract-factory.html
https://javadevcentral.com/abstract-factory-pattern
https://www.tutorialspoint.com/design_pattern/abstract_factory_pattern.htm
https://java-design-patterns.com/patterns/abstract-factory/
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b0%d0%b1%d1%81%d1%82%d1%80%d0%b0%d0%ba%d1%82%d0%bd%d0%b0%d1%8f-%d1%84%d0%b0%d0%b1%d1%80%d0%b8%d0%ba%d0%b0/
https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java
https://javarush.ru/groups/posts/2379-patternih-proektirovanija-abstractfactory
https://metanit.com/sharp/patterns/2.2.php

## 2.5. Паттерн Builder

***Builder*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

### 2.5.1. Структура паттерна



### 2.5.2. Применимость



### 2.5.3. Преимущества и недостатки

#### 2.5.3.1. Преимущества

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и с помощью современных IDE подсказок более интуитивно понятным.

#### 2.5.3.2. Недостатки



### 2.5.4. Применение в автотестах

#### 2.5.4.1. До применения паттерна

*Пример*

```java

```

#### 2.5.4.2. После применения паттерна

*Пример*

```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

    public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}
```

*Пример*

```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

https://refactoring.guru/ru/design-patterns/builder
http://design-pattern.ru/patterns/builder.html
https://javadevcentral.com/builder-design-pattern
https://www.tutorialspoint.com/design_pattern/builder_pattern.htm
https://java-design-patterns.com/patterns/builder/
https://www.journaldev.com/1425/builder-design-pattern-in-java
https://metanit.com/sharp/patterns/2.5.php
https://habr.com/ru/company/otus/blog/552412/
https://www.softwaretestinghelp.com/design-patterns-in-java/#Builder_Pattern_In_Java

***

# 3. Поведенческие паттерны

## 3.1. Паттерн Fluent / Chain of Invocations

### 3.1.1. Структура паттерна



### 3.1.2. Применимость



### 3.1.3. Преимущества и недостатки

#### 3.1.3.1. Преимущества



#### 3.1.3.2. Недостатки



#### 3.1.4.1. До применения паттерна

*Пример*

```java

```

#### 3.1.4.2. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```


```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();

  assertThat(homePage.isSignedIn(user));  
}
```

Второй паттерн, о котором мы собирались поговорить, - это Chain of Invocations.
Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.
Например, пользователь находится на странице входа и нажимает какую-то кнопку.
Написав код по старинке, мы не будем уверены, находится ли он все еще на странице входа или уже на главной странице.

А теперь представьте, если бы в вашем тесте было 50 подобных методов.
Вы не можете быть уверены, можете ли вы вызвать их сразу, или они зависят от некоторого порядка,
или даже они не могут быть вызваны после того, как один из них был выполнен.
Например, могу ли я нажать на диалоговое окно подсказки, если я не ввел ни одного символа в поле ввода?
Наверное, нет, потому что на данный момент его еще нет!

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив Fluent Invocations, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

Обычно, если вы хотите прервать цепочку методов,
все, что вам нужно сделать, это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.
На этом этапе разработчик должен остановиться и подумать о следующем методе, который будет вызван в тестовом сценарии, прежде чем делать это.

Цепочку вызовов легко реализовать.
Все, что вам нужно сделать, это вернуть значение в каждом методе объекта страницы. Это может быть это, какое-то значение или любой другой объект,
например, следующий объект страницы после вызова метода (переход на другую страницу).

Этот шаблон не помогает значительно сократить код (это не его основная цель),
но это позволяет вам не повторяться, помещая объект снова и снова перед вызовом его методов.
Также IMO это делает код немного красивее.

## 3.2. Паттерн Strategy

### 3.2.1. Структура паттерна



### 3.2.2. Применимость



### 3.2.3. Преимущества и недостатки

#### 3.2.3.1. Преимущества

Шаблон стратегии используется всякий раз, когда мы хотим иметь более одной реализации одного и того же действия / последовательности действий,
что делается иначе. В зависимости от контекста мы могли выбрать реализацию.

Самый простой пример - регистрация пользователя. Возможно, вы захотите иметь две разные реализации этого конкретного действия.
Первый - это фактический поток переходов по страницам для успешной регистрации пользователя.
Другой - короткий вызов API, который вызывается, когда для теста нужен новый пользователь.

Возможно, вы не захотите вызывать «долгую» регистрацию каждый раз в своих тестах.
Но иногда он может понадобиться, например, когда вы подтверждаете фактическую регистрацию через Интернет.
И наоборот, мы хотим, чтобы создание новых пользователей для тестирования было быстрым и надежным. Поэтому здесь подойдет REST-регистрация.

Стратегия помогает сделать нашу среду автоматизации тестирования более гибкой и простой в обслуживании за счет разделения концепций.
Опять же, вам нужно быть осторожным и не применять его в ситуациях, когда вы можете обойтись без него.


#### 3.2.3.2. Недостатки



### 3.2.4. Применение в автотестах

#### 3.2.4.1. До применения паттерна

*Пример*

```java

```

#### 3.2.4.2. После применения паттерна


*Пример*

```java

```

*Пример*

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)