Java_QA / Level 2. Medium - Продвинутые темы / Урок 01. Паттерны проектирования

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Порождающие паттерны

https://www.baeldung.com/java-creational-design-patterns

## 1.1. Паттерн Data Transfer Object

***Data Transfer Object*** - паттерн, представляющий собой класс, содержащий данные без какой-либо логики для работы с ним.
По сути это простой класс.

### 1.1.1. Проблемы, которые решает паттерн

Необходимо передавать в метод в качестве параметра множество примитивных значений за раз.

### 1.1.2. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

### 1.1.3. После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;
    
    public User(String firstName, String lastName, int age, boolean isMarried) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.isMarried = isMarried;
    }
    
    // Getters
    // Setters
}
```

*Пример*

```java
public void createUser(User user) {
    firstName.enter(user.getFirstName);
    lastName.enter(user.getLastName);
    age.enter(user.getAge));
    isMarried.check(user.getIsMarried);
}
```

### 1.1.4. Использование в автотестах

Передача параметров в методы.

## 1.2. Паттерн Singleton

***Singleton*** — паттерн, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

### 1.2.1. Проблемы, которые решает паттерн

Необходимо наличие единственного экземпляра класса.

Необходимо наличие глобальной точки доступа.

### 1.2.2. До применения паттерна

*Пример*

```java
public void createUser(String firstName, String lastName, int age, boolean isMarried) {
    firstName.enter(firstName);
    lastName.enter(lastName);
    age.enter(age);
    isMarried.check(isMarried);
}
```

### 1.2.3. После применения паттерна

*Пример*

```java
class User {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    private static User instance;

    private User () {
        this.firstName = "John";
        this.lastName = "Doe";
        this.age = 25;
        this.isMarried = true;
    }

    public static User getInstance() {
        if (instance == null)
            instance = new User();
        return instance;
    }
    
    // Getters
}
```

*Пример*

```java
public void createUser() {
    firstName.enter(User.getInstance().getFirstName());
    lastName.enter(User.getInstance().getLastName());
    age.enter(User.getInstance().getAge());
    isMarried.check(User.getInstance().getIsMarried());
}
```

### 1.2.4. Использование в автотестах

Ограничение **WebDriver** до одного экземпляра объекта на весь проект.

https://refactoring.guru/ru/design-patterns/singleton
http://design-pattern.ru/patterns/singleton.html
https://www.tutorialspoint.com/design_pattern/singleton_pattern.htm
https://java-design-patterns.com/patterns/singleton/
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%be%d0%b4%d0%b8%d0%bd%d0%be%d1%87%d0%ba%d0%b0/https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples
https://tproger.ru/translations/singleton-pitfalls/
https://javarush.ru/groups/posts/2365-patternih-proektirovanija-singleton
https://javarush.ru/groups/posts/589-patternih-i-singleton--dlja-vsekh-kto-vpervihe-s-nimi-stolknulsja
https://metanit.com/sharp/patterns/2.3.php

## 1.3. Паттерн Factory Method

***Factory Method*** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

### 1.3.1. Проблемы, которые решает паттерн

Необходимо создание объектов с заранее неизвестным типом.

Необходимо наличие системы расширяемой и независимой от процесса создания новых объектов: 
в нее можно легко вводить новые классы, объекты которых система должна создавать.

Необходимо делегировать создание новых объектов из базового класса классам наследникам.

### 1.3.2. До применения паттерна

*Пример*

```java
class User1 {
    private String firstName;
    private String lastName;

    public User1() {}
    
    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
}

class User2 {
    private String firstName;
    private String lastName;
    private int age;
    private boolean isMarried;

    public User2() {}

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
}

public void createUser1 (User1 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    
}

public void createUser2 (User2 user) {
    firstName.enter(user.getFirstName());
    lastName.enter(user.getLastName());
    age.enter(user.getAge());
    isMarried.check(user.getIsMarried());
}
```

### 1.3.3. После применения паттерна

*Пример*

```java

abstract class User {
    private String firstName;
    private String lastName;

    public void setFirstName(String firstName)  { this.firstName = firstName; }
    public String getFirstName()                { return this.firstName; }
    public void setLastName(String lastName)    { this.lastName = lastName; }
    public String getLastName()                 { return this.lastName; }
    abstract void someMethod();
}

class User1 extends User {
    public User1() { }
    public void someMethod() { }
}

class User2 extends User {
    private int age;
    private boolean isMarried;

    public User2() { }

    public void setAge(int age)                 { this.age = age; }
    public int getAge()                         { return this.age; }
    public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; }
    public boolean getIsMarried()               { return this.isMarried; }
    public void someMethod() { }
}

class UserFactory
{
    public static User getUser(String userType) {
        switch (userType) {
            case "user1":
                User1 user1 = new User1();
                user1.setFirstName("First Name");
                user1.setLastName("Last Name");
                return user1;
            case "user2":
                User2 user2 = new User2();
                user2.setFirstName("First Name");
                user2.setLastName("Last Name");
                user2.setAge(40);
                user2.setIsMarried(false);
                return user2;
            default:
                throw new RuntimeException("Incorrect user type");
        }
    }
}
```

*Пример*

```java
public void createUser(String userType) {
    switch (userType) {
        case "user1":
            User1 user1 = UserFactory.getUser("user1");
            firstName.enter(user1.getFirstName());
            lastName.enter(user1.getLastName());
            age.enter(user1.getAge());
            isMarried.check(user1.getIsMarried());
            break;
        case "user2":
            User2 user2 = UserFactory.getUser("user2");
            firstName.enter(user2.getFirstName());
            lastName.enter(user2.getLastName());
            age.enter(user2.getAge());
            isMarried.check(user2.getIsMarried());
            premium.enter(user2.getPremium());
            break;
        default:
            throw new RuntimeException("Incorrect user type");
    }
}
```

### 1.3.4. Использование в автотестах

Инициализация экземпляров **WebDriver** для разных браузеров.
Создание объектов страниц в **PageFactory**.

https://refactoring.guru/ru/design-patterns/factory-method
http://design-pattern.ru/patterns/factory-method.html
https://javadevcentral.com/factory-method
https://www.tutorialspoint.com/design_pattern/factory_pattern.htm
https://java-design-patterns.com/patterns/factory/
https://javanerd.ru/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4/
https://www.journaldev.com/1392/factory-design-pattern-in-java
https://javarush.ru/groups/posts/2372--patternih-proektirovanija-factorymethod
https://metanit.com/sharp/patterns/2.1.php

## 1.4. Паттерн Abstract Factory

***Abstract Factory*** — паттерн, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.

### 1.4.1. Проблемы, которые решает паттерн

### 1.4.2. До применения паттерна

*Пример*

```java

```

### 1.4.3. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

### 1.4.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/abstract-factory
http://design-pattern.ru/patterns/abstract-factory.html
https://javadevcentral.com/abstract-factory-pattern
https://www.tutorialspoint.com/design_pattern/abstract_factory_pattern.htm
https://java-design-patterns.com/patterns/abstract-factory/
https://javanerd.ru/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd%d1%8b-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f/%d0%bf%d0%b0%d1%82%d1%82%d0%b5%d1%80%d0%bd-%d0%b0%d0%b1%d1%81%d1%82%d1%80%d0%b0%d0%ba%d1%82%d0%bd%d0%b0%d1%8f-%d1%84%d0%b0%d0%b1%d1%80%d0%b8%d0%ba%d0%b0/
https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java
https://javarush.ru/groups/posts/2379-patternih-proektirovanija-abstractfactory
https://metanit.com/sharp/patterns/2.2.php

## 1.5. Паттерн Builder

***Builder*** - паттерн, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

### 1.5.1. Проблемы, которые решает паттерн

Есть чрезвычайно сложный объект, который можно настроить разными способами.
Первый вариант, который приходит на ум, - создать столько типов конструкторов, сколько у нас есть вариаций параметров в
этот объект, и каждый раз, когда мы встречаем новый, нам нужно будет создавать для него новый конструктор.
В результате мы получим безумное количество конструкторов, которые определенно запутают конечного пользователя фреймворка.

Шаблон Builder используется для того, чтобы сделать процесс создания таких объектов проще и с помощью современных IDE подсказок более интуитивно понятным.

### 1.5.2. До применения паттерна

*Пример*

```java

```

### 1.5.3. После применения паттерна

*Пример*

```java
public class Server {
    private final String url;
    private final int port;
    private final List<Response> responseQueue;
    private final boolean isLoggingEnabled;

    private Server(String url, int port, List<Response> responseQueue, boolean isLoggingEnabled) {
        this.url = url;
        this.port = port;
        this.responseQueue = responseQueue;
        this.isLoggingEnabled = isLoggingEnabled;
    }

    public static ServerBuilder runtimeBuilder() {
        return new ServerBuilder();
    }

    public static class ServerBuilder {
    private String url = "http://10.0.0.0"
    private final int port = 6767;
    private final List<Response> responseQueue = new ArrayList<>();
    private final boolean isLoggingEnabled = true;
    
    public Server build() {
        return new Server(url, port, responseQueue, isLoggingEnabled);
    }
    
    public ServerBuilder withUrl(String url) {
        this.url = url;
        return this;
    }
    
    public ServerBuilder withPort(int port) {
        this.port = port;
        return this;
    }
    
    public ServerBuilder withResponsesEnqueued(Response... responses) {
        this.responseQueue.clear();
        for (Response response : responses) {
            this.responseQueue.add(response);
        }
        return this;
    }
    
    public ServerBuilder withoutLogging() {
        this.isLoggingEnabled = false;
            return this;
        }
    }
    ...
    }
}
```

*Пример*

```java
Server server = Server.runtimeBuilder()
    .withUrl("http://localhost")
    .withPort(1234)
    .withoutLogging()
    .withResponsesEnqueued(new Response())
    .build();
```

### 1.5.4. Использование в автотестах

https://refactoring.guru/ru/design-patterns/builder
http://design-pattern.ru/patterns/builder.html
https://javadevcentral.com/builder-design-pattern
https://www.tutorialspoint.com/design_pattern/builder_pattern.htm
https://java-design-patterns.com/patterns/builder/
https://www.journaldev.com/1425/builder-design-pattern-in-java
https://metanit.com/sharp/patterns/2.5.php
https://habr.com/ru/company/otus/blog/552412/

https://www.softwaretestinghelp.com/design-patterns-in-java/#Builder_Pattern_In_Java

***

# 2. Поведенческие паттерны

## 2.1. Паттерн Fluent / Chain of Invocations

### 2.1.1. Проблемы, которые решает паттерн



### 2.1.2. До применения паттерна

*Пример*

```java

```

### 2.1.3. После применения паттерна

*Пример*

```java

```

*Пример*

```java

```

### 2.1.4. Использование в автотестах

Второй паттерн, о котором мы собирались поговорить, - это Chain of Invocations.
Обычно он используется вместе с Page Object, поэтому большинство из вас, возможно, тоже знакомы с ним.
Проблема, которую он решает, помогает разработчику тестов определить, может ли она использовать объект или ей следует переключиться на другой.
Например, пользователь находится на странице входа и нажимает какую-то кнопку.
Написав код по старинке, мы не будем уверены, находится ли он все еще на странице входа или уже на главной странице.

А теперь представьте, если бы в вашем тесте было 50 подобных методов.
Вы не можете быть уверены, можете ли вы вызвать их сразу, или они зависят от некоторого порядка,
или даже они не могут быть вызваны после того, как один из них был выполнен.
Например, могу ли я нажать на диалоговое окно подсказки, если я не ввел ни одного символа в поле ввода?
Наверное, нет, потому что на данный момент его еще нет!

```java
public void loginToAccountShouldWork() {
  homePage
     .typeLogin(user.login)
     .typePassword(user.password)
     .tapSignInButton();

  assertThat(homePage.isSignedIn(user));  
}
```

Этот шаблон важен, если вы пытаетесь масштабировать свою среду автоматизации тестирования.
Большое количество страниц, элементов и методов, доступных для использования, может создать путаницу,
особенно для тех, кто не очень хорошо знаком с вашим доменом.
Но, внедрив Fluent Invocations, современная среда IDE будет давать вам подсказку каждый раз, когда вы
попробуйте вызвать какой-либо метод объекта с помощью функции автозаполнения.

Обычно, если вы хотите прервать цепочку методов,
все, что вам нужно сделать, это присвоить возвращаемое значение (например, строку, число и т. д.) некоторой переменной.
Таким образом вы покажете, что это конец последовательности вызовов.
На этом этапе разработчик должен остановиться и подумать о следующем методе, который будет вызван в тестовом сценарии, прежде чем делать это.

Цепочку вызовов легко реализовать.
Все, что вам нужно сделать, это вернуть значение в каждом методе объекта страницы. Это может быть это, какое-то значение или любой другой объект,
например, следующий объект страницы после вызова метода (переход на другую страницу).

Этот шаблон не помогает значительно сократить код (это не его основная цель),
но это позволяет вам не повторяться, помещая объект снова и снова перед вызовом его методов.
Также IMO это делает код немного красивее.

## 2.2. Паттерн Strategy

### 2.2.1. Проблемы, которые решает паттерн



### 2.2.2. До применения паттерна

*Пример*

```java

```

### 2.2.3. После применения паттерна

*Пример*

```java

```

*Пример*

```java
interface UserRegistrationStrategy {
    User register();
}

class WebUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        String username = UserRegistry.getUsername();
        String password = PasswordGenerator.generatePassword();
        SignInPage
                .open()
                .pressSignUpButton()
                .enterUsername(username)
                .enterPassword(password)
                .clickRegisterButton();
        return new User(username, password);   
    }
}
```

```java
class ApiUserRegistrationStrategy implements UserRegistrationStrategy {
    @Override
    public User register() {
        User user = new User(
                UserRegistry.getNewUsername(), 
                PasswordGenerator.generatePassword());
        put("api/user").withBody(user.toJson());
        return user;   
    }
}
```

### 2.2.4. Использование в автотестах

Шаблон стратегии используется всякий раз, когда мы хотим иметь более одной реализации одного и того же действия / последовательности действий,
что делается иначе. В зависимости от контекста мы могли выбрать реализацию.

Самый простой пример - регистрация пользователя. Возможно, вы захотите иметь две разные реализации этого конкретного действия.
Первый - это фактический поток переходов по страницам для успешной регистрации пользователя.
Другой - короткий вызов API, который вызывается, когда для теста нужен новый пользователь.

Возможно, вы не захотите вызывать «долгую» регистрацию каждый раз в своих тестах.
Но иногда он может понадобиться, например, когда вы подтверждаете фактическую регистрацию через Интернет.
И наоборот, мы хотим, чтобы создание новых пользователей для тестирования было быстрым и надежным. Поэтому здесь подойдет REST-регистрация.

Стратегия помогает сделать нашу среду автоматизации тестирования более гибкой и простой в обслуживании за счет разделения концепций.
Опять же, вам нужно быть осторожным и не применять его в ситуациях, когда вы можете обойтись без него.

***

# 5. Паттерны данных

***Паттерны данных*** - паттерны, которые разделяют данные и логику тестирования.

а также уменьшить дублирование кода в тестах.
Это должно сделать их более понятными и простыми в обслуживании для всех, кто с ними работает.

## 5.1. Паттерн Data Registry

***Data Registry*** - паттерн,

### 5.1.1. Проблемы, которые решает паттерн

### 5.1.2. До применения паттерна

*Пример*

```java

```

### 5.1.3. После применения паттерна

Интересен следующий паттерн. Основной подход заключается в следующем: мы хотим, чтобы наши тесты были независимыми и
попробуем разделить наши тестовые данные по ним, но в результате мы получим полную противоположность.
Например, в тесте A используются user1, user2 и user3, и они жестко запрограммированы как тестовые данные.
Это может быть проблемой, поскольку нам нужны полностью независимые тесты, верно?
Но мы заставляем другой тест знать, что user1, user2 и user3 уже заняты тестом A.
Другая проблема заключается в том, что разработчик, не знакомый с этим, может использовать этих пользователей в других тестах, и это может вызвать проблемы.

Реестр данных позволяет нам генерировать уникальные данные и избегать дублирования.
В приведенном ниже примере я использую самый простой из возможных подходов:
при каждом вызове getUser статический потокобезопасный счетчик будет увеличиваться на 1,
гарантируя, что каждый раз создается уникальный пользователь.

*Пример*

```java
public static class UserRegistry {
    private static AtomicInteger COUNTER = new AtomicInteger(0);
    
    public static getUser() {
        int index = COUNTER.incrementAndGet();
        return new User("User_" + index, index);
    }
}

```

В вашем случае логика шаблона может быть намного сложнее, например. реестр может брать пользователя из базы данных, файла, предопределенного набора данных и т. д.
Но результат будет таким же: ваши тесты будут по-настоящему независимыми, поскольку каждый раз, когда они используют UserRegistry, они получают эксклюзивного пользователя, избегая проблем с перехватом тестов.

## 5.2. Паттерн Data Provider

***Data Provider*** - паттерн,

### 5.2.1. Проблемы, которые решает паттерн

### 5.2.2. До применения паттерна

*Пример*

```java

```

### 5.2.3. После применения паттерна

Поставщик данных - один из наиболее широко используемых шаблонов данных среди инженеров-тестировщиков.
Если вы хотите реализовать тесты на основе данных и хотите запустить одну и
ту же логику тестирования для нескольких наборов данных,
вы можете загружать данные из внешних источников (таких как Excel или таблица CVS),
удаленных служб или жестко закодировать их на месте.

*Пример*

```java
@DataProvider
private static Object[][] testDataProvider() {
    try {
        return ReadExcelSheet.getTableArray("src/main/resources/TestData.xls");
    } catch (Exception e) {
        return null;
    }
}
```

Это можно сделать так, как я показал выше,
путем чтения из источника и возврата нетипизированных данных (простой массив массивов или строк).
Но современный подход заключался бы в использовании шаблона Value Object,
о котором мы говорили ранее, и предоставлении данных в терминах сущностей.

*Пример*

```java
@DataProvider
private static Iterator<Object[]> devices() {
    return asList(
        new Object[] { new Device("iPhone X", Platform.IOS, "11.2") },
        new Object[] { new Device("iPhone 7 Plus", Platform.IOS, "10.3") },
        new Object[] { new Device("Google Pixel 2", Platform.ANDROID, "8.0") }  
    ).iterator();
}

@Test(dataProvider = "devices")
public void pageShouldBeOpenedOnDevice(Device device) {
    startDevice(device);
    // some test steps
}
```

Вам нужно пометить свой метод аннотацией dataProvider или сделать его параметризованным с помощью JUnit и
заставить его возвращать набор данных для использования в тесте. Остальное (синтаксический анализ и итерация)
будет выполняться фреймворком, все, что вам нужно сделать, - это использовать данные, как в обычном тесте.

Важно, чтобы мы использовали оба шаблона (поставщик данных и объект значения) в одном подходе,
поскольку это помогло нам избежать передачи нескольких параметров методу и сделать код более чистым и читаемым.

Мне нравится использовать шаблоны данных в своей автоматизации,
они помогают мне поддерживать работоспособность кода и максимально оптимизировать управление ресурсами.
Если вас интересуют другие шаблоны, которые могут помочь вам в написании чистых и надежных тестов,
ознакомьтесь с другими моими сообщениями:

https://www.devbridge.com/articles/top-design-pattern-test-automation-frameworks/
https://antony-s-smirnov.medium.com/how-to-use-the-data-provider-pattern-in-the-project-ea12430d9275

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)