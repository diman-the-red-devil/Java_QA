Java_QA / 02. Selenium WebDriver. Начало

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Selenium](#1-selenium)
  * [1.1. Selenium RC](#11-selenium-rc)
  * [1.2. Selenium WebDriver](#12-selenium-webdriver)
  * [1.3. Selenium Server](#13-selenium-server)
  * [1.4. Selenium Grid](#14-selenium-grid)
  * [1.5. Selenium IDE](#15-selenium-ide)
* [2. Selenium 4.0](#2-selenium-40)
  * [2.1. В чем важность Selenium 4.0?](#21-в-чем-важность-selenium-40)
  * [2.2. Особенности версии Selenium 4.0](#22-особенности-версии-selenium-40)
    * [2.2.1. Основные изменения в Selenium 4](#221-основные-изменения-в-selenium-4)
    * [2.2.2. Новые возможности в Selenium 4](#222-новые-возможности-в-selenium-4)
    * [2.2.3. Стандарт W3C WebDriver](#223-стандарт-w3c-webdriver)
* [3. Архитектура Selenium WebDriver](#3-архитектура-selenium-webdriver)
  * [3.1. Компоненты Selenium WebDriver](#31-компоненты-selenium-webdriver)
  * [3.2. Принцип работы Selenium WebDriver](#32-принцип-работы-selenium-webdriver)
    * [3.2.1. В Selenium < 4 версии](#321-в-selenium--4-версии)
    * [3.2.2. В Selenium 4 версии](#322-в-selenium-4-версии)
* [4. Команды Selenium WebDriver](#4-команды-selenium-webdriver)
  * [4.1. Классификация команд](#41-классификация-команд)
  * [4.2. Однородность команд](#42-однородность-команд)
    * [4.2.1. Java](#421-java)
    * [4.2.2. C#](#422-c)
    * [4.2.3. Ruby](#423-ruby)
    * [4.2.4. Python](#424-python)
    * [4.2.5. JS](#425-js)
    * [4.2.6. Kotlin](#426-kotlin)
* [5. Настройка окружения](#5-настройка-окружения)
* [6. Язык программирования Java (JDK)](#6-язык-программирования-java-jdk)
  * [6.1. Почему Java?](#61-почему-java)
  * [6.2. Где взять Java?](#62-где-взять-java)
  * [6.3. Какую версию Java устанавливать?](#63-какую-версию-java-устанавливать)
  * [6.4. Что устанавливать, JRE или JDK?](#64-что-устанавливать-jre-или-jdk)
* [7. IDE IntelliJ IDEA](#7-ide-intellij-idea)
  * [7.1. Почему IntelliJ IDEA?](#71-почему-intellij-idea)
  * [7.2. Где взять IntelliJ IDEA?](#72-где-взять-intellij-idea)
  * [7.3. Какую версию IntelliJ IDEA устанавливать?](#73-какую-версию-intellij-idea-устанавливать)
  * [7.4. Где посмотреть документацию на IntelliJ IDEA?](#74-где-посмотреть-документацию-на-intellij-idea)
* [8. Сборщик проекта Maven](#8-сборщик-проекта-maven)
  * [8.1. Почему Maven?](#81-почему-maven)
  * [8.2. Где взять Maven?](#82-где-взять-maven)
  * [8.3. Какую версию Maven устанавливать?](#83-какую-версию-maven-устанавливать)
  * [8.4. Где посмотреть документацию на Maven?](#84-где-посмотреть-документацию-на-maven)
* [9. Система контроля версий Git](#9-система-контроля-версий-git)
  * [9.1. Почему Git?](#91-почему-git)
  * [9.2. Где взять Git?](#92-где-взять-git)
  * [9.3. Какую версию Git устанавливать?](#93-какую-версию-git-устанавливать)
  * [9.4. Где посмотреть документацию на Git?](#94-где-посмотреть-документацию-на-git)
  * [9.5. Что такое файл .gitignore?](##95-что-такое-файл-gitignore)
* [10. Веб сервис для хостинга IT проектов GitHub](#10-веб-сервис-для-хостинга-it-проектов-github)
  * [10.1. Почему GitHub?](#101-почему-github)
  * [10.2. Где посмотреть документацию на GitHub?](#102-где-посмотреть-документацию-на-github)
* [11. Подключение библиотек](#11-Подключение-библиотек)
* [12. Тестовый фреймворк JUnit5](#12-тестовый-фреймворк-junit5)
  * [12.1. Почему JUnit5?](#121-почему-junit5)
  * [12.2. Где взять JUnit5?](#122-где-взять-junit5)
  * [12.3. Какую версию JUnit5 подключать?](#123-какую-версию-junit5-подключать)
  * [12.4. Где посмотреть документацию на JUnit5?](#124-где-посмотреть-документацию-на-junit5)
* [13. Веб драйвер Selenium WebDriver](#13-веб-драйвер-selenium-webdriver)
  * [13.1. Почему Selenium WebDriver?](#131-почему-selenium-webdriver)
  * [13.2. Где взять Selenium WebDriver?](#132-где-взять-selenium-webdriver)
  * [13.3. Какую версию Selenium WebDriver подключать?](#133-какую-версию-selenium-webdriver-подключать)
  * [13.4. Где посмотреть документацию на Selenium WebDriver?](#134-где-посмотреть-документацию-на-selenium-webdriver)
* [14. Менеджер веб драйверов WebDriverManager](#14-менеджер-веб-драйверов-webdrivermanager)
  * [14.1. Почему WebDriverManager?](#141-почему-webdrivermanager)
  * [14.2. Где взять WebDriverManager?](#142-где-взять-webdrivermanager)
  * [14.3. Какую версию WebDriverManager подключать?](#143-какую-версию-webdrivermanager-подключать)
  * [14.4. Где посмотреть документацию на WebDriverManager?](#144-где-посмотреть-документацию-на-webdrivermanager)
* [15. Система логирования Log4J2](#15-система-логирования-log4j2)
  * [15.1. Почему Log4j2?](#151-почему-log4j2)
  * [15.2. Где взять Log4j2?](#152-где-взять-log4j2)
  * [15.3. Какую версию Log4j2 подключать?](#153-какую-версию-log4j2-подключать)
  * [15.4. Где посмотреть документацию на Log4j2?](#154-где-посмотреть-документацию-на-log4j2)

***

# 1. Selenium

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Selenium*** – проект, в рамках которого разрабатывается серия программных продуктов с открытым исходным кодом (open source):

* **Selenium RC**
* **Selenium WebDriver**
* **Selenium Server**
* **Selenium Grid**
* **Selenium IDE**

Называть просто словом **Selenium** любой из этих пяти продуктов, вообще говоря, неправильно, хотя так часто делают, 
если из контекста понятно, о каком именно из продуктов идёт речь, или если речь идёт о нескольких продуктах одновременно, 
или обо всех сразу.

## 1.1. Selenium RC

***Selenium RC ("R"-emote "C"-ontrol)*** - система для управления браузером. 

Является предшественником **Selenium WebDriver**.

Эта версия с функциональной точки зрения значительно уступает **WebDriver**. 
Сейчас она находится в законсервированном состоянии, не развивается и даже известные баги не исправляются. 
А всем, кто сталкивается с ограничениями **Selenium RC**, предлагается переходить на использование **WebDriver**.

Иногда **Selenium RC** называется также **Selenium 1.0**, тогда как **WebDriver** называется **Selenium 2.0**. 
Хотя на самом деле дистрибутив версии 2.0 включает в себя одновременно обе реализации – 
и **Selenium RC**, и **WebDriver**. А вот когда выйдет версия 3.0 – в ней останется только **WebDriver**.

С технической точки зрения **WebDriver** не является результатом эволюционного развития **Selenium RC**, 
они построены на совершенно разных принципах и у них практически нет общего кода. 
Объединяет их лишь тот факт, что обе реализации были сделаны в рамках проекта **Selenium**. 
Ну, или если быть совсем точным, **WebDriver** сначала был самостоятельным проектом, 
но в 2008 году произошло слияние и сейчас **WebDriver** представляет собой основной вектор развития проекта **Selenium**.

## 1.2. Selenium WebDriver

***Selenium WebDriver*** - программная библиотека для управления браузерами, 
которая отправляет команды непосредственно в браузер, и извлекает результаты.

Является преемником **Selenium RC**. Это основной продукт, разрабатываемый в рамках проекта **Selenium**.

**Selenium WebDriver** представляет собой семейство драйверов для различных браузеров,
а также набор клиентских библиотек на разных языках, 
позволяющих работать с этими драйверами на разных языках программирования. 

В рамках проекта **Selenium** разрабатываются драйверы для браузеров **Firefox**, **Internet Explorer** и **Safari**, 
а также драйверы для мобильных браузеров **Android** и **iOS**. 
Драйвер для браузера **Google Chrome** разрабатывается в рамках проекта **Chromium**, 
а драйвер для браузера **Opera** (включая мобильные версии) разрабатывается компанией **Opera Software**. 
Поэтому они формально не являются частью проекта **Selenium**, распространяются и поддерживаются независимо. 
Но логически, конечно, можно считать их частью семейства продуктов **Selenium**.

Аналогичная ситуация и с клиентскими библиотеками – в рамках проекта **Selenium** 
разрабатываются библиотеки для языков **Java**, **.Net (C#)**, **Python**, **Ruby**, **JavaScript**. 
Все остальные реализации не имеют отношения к проекту **Selenium**, хотя, возможно, 
в будущем, какие-то из них могут влиться в этот проект.

![Selenium WebDriver](./_Files/1.%20Selenium/01.jpg "Selenium WebDriver")

## 1.3. Selenium Server

***Selenium Server*** - сервер, который позволяет управлять браузером с удалённой машины, по сети. 

Сначала на той машине, где должен работать браузер, устанавливается и запускается сервер. 
Затем на другой машине (технически можно и на той же самой, конечно) запускается программа, которая, 
используя специальный драйвер RemoteWebDriver, соединяется с сервером и отправляет ему команды. 
Он в свою очередь запускает браузер и выполняет в нём эти команды, используя драйвер, соответствующий этому браузеру.

**Selenium Server** поддерживает одновременно два набора команд – для новой версии (**WebDriver**) 
и для старой версии (**Selenium RC**).

![Selenium Server](./_Files/1.%20Selenium/02.jpg "Selenium Server")

## 1.4. Selenium Grid

***Selenium Grid*** - кластер, состоящий из нескольких **Selenium**-серверов, предназначенный для организации распределённой сети, 
позволяющей параллельно запускать много браузеров на большом количестве машин.

Используется для параллельного тестирования на разных компьютерах и разных браузерах одновременно, 
что приводит к минимизации времени выполнения.

**Selenium Grid** имеет топологию **звезда**, то есть в его составе имеется выделенный сервер, 
который носит название **хаб** или **коммутатор**, а остальные сервера называются **ноды** или **узлы**. 
Сеть может быть гетерогенной, то есть коммутатор и узлы могут работать под управлением разных операционных систем, 
на них могут быть установлены разные браузеры. 
Одна из задач **Selenium Grid** заключается в том, чтобы "подбирать" подходящий узел, 
когда во время старта браузера указываются требования к нему – 
тип браузера, версия, операционная система, архитектура процессора и ряд других атрибутов.

Ранее **Selenium Grid** был самостоятельным продуктом. Сейчас физически продукт один – 
**Selenium Server**, но у него есть несколько режимов запуска: он может работать как самостоятельный сервер, 
как коммутатор кластера, либо как узел кластера, это определяется параметрами запуска.

![Selenium Grid](./_Files/1.%20Selenium/03.jpg "Selenium Gri")

## 1.5. Selenium IDE

***Selenium IDE ("I"-ntegrated "D"-evelopment "E"-nvironment)*** - плагин к браузеру Firefox для записи и воспроизведения действий пользователя, 
а также генерации исходного кода для **WebDriver** или **Selenium RC**, в котором выполняются те же самые действия.

Тестировщики, которые не умеют (или не хотят) программировать, используют **Selenium IDE** как самостоятельный продукт, 
без преобразования записанных сценариев в программный код. 
Это, конечно, не позволяет разрабатывать достаточно сложные тестовые наборы, но некоторым хватает и простых линейных сценариев.

***

# 2. Selenium 4.0

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 2.1. В чем важность Selenium 4.0?

**Selenium** стал отраслевым стандартом для проведения автоматизированного тестирования. 
Он считается первоочередным инструментом для тестирования веб-приложений уже слишком масштабных для проведения ручного тестирования.

## 2.2. Особенности версии Selenium 4.0

### 2.2.1. Основные изменения в Selenium 4

* *стандартизация W3C*

Благодаря этому изменению запросы и ответы, передаваемые по протоколу, не требуют API кодирования и декодирования. 
На основе обновления стандартов W3C любое программное обеспечение, соответствующее стандартам W3C, 
может быть интегрировано с Selenium 4 без каких-либо проблем совместимости.

* *драйверы от производителей*

Почти все браузеры, такие как Chrome, Safari и IE, уже соответствуют стандарту W3C и имеют официальные драйверы.

* *движок для различных инструментов*

API WebDriver стал актуальным и за пределами Selenium и теперь используется в различных инструментах для автоматизации. 
Например, на нем основываются такие мобильные инструменты для тестирования, как Appium и iOS Driver.

* *поддержка браузеров*

Встроенная поддержка была удалена для Opera и PhantomJS, поскольку реализации WebDriver для этих браузеров больше не находятся в активной разработке.

* *обновление Selenium IDE*

Предыдущая версия **Selenium IDE** устарела в 2017 году. 
Новая версия **Selenium IDE** предлагает более продвинутые возможности:

1. улучшенный пользовательский интерфейс
2. экспорт кода для всех официальных языков (Java, Python, JavaScript, .Net и Ruby)
3. новый CLI runner

Он полностью основан на NodeJS, а не на HTML, как было раньше, также он будет иметь следующий возможности:

1. WebDriver Playback - новый runner будет полностью основан на WebDriver
2. параллельное выполнение - новый runner будет поддерживать параллельное выполнение тестов и предоставит полезную информацию, 
такую как затраченное время, а также набор пройденных и неудачных тестов

* *оптимизация Selenium Grid*

Каждый, кто когда-либо работал с **Selenium Grid** знает как сложно его настраивать.
До настоящего времени процесс присоединения узла к хабу в **Selenium Grid** вызывал серьезные сложности.
В **Selenium 4** работа с **Selenium Grid** обещает быть простой, 
так как больше не будет необходимости настраивать и запускать хабы и узлы отдельно. 
После запуска сервера в **Selenium Grid 4**, он будет работать одновременно и как узел, и как хаб.
**Selenium 4** будет поставляться с более стабильной версией **Selenium Grid**. 
Будут устранены ошибки потокобезопасности и улучшена поддержка Docker.

* *обновленная документация*

Документация играет ключевую роль в успехе любого проекта. Документация Selenium не обновлялась с выпуска **Selenium 2.0**. 
Это значит, что каждый, кто пытался изучить Selenium в последние несколько лет, пользовался старыми туториалами.
**Selenium 4** выходит с официальной и подробной документацией по **Selenium IDE**, **Selenium WebDriver** и **Selenium Grid**.

* *реализации на всех популярных языках*

### 2.2.2. Новые возможности в Selenium 4

* *относительные локаторы*

В **Selenium 4** появились относительные локаторы (также известные как дружественные локаторы), 
которые позволяют находить веб-элементы по их положению относительно других веб-элементов.

* *несколько вкладок и окон*

В **Selenium 4** можно работать с несколькими вкладками или окнами. 
То есть открыть новую вкладку или окно в том же сеансе, не создавая новый объект драйвера.

* *скриншоты WebElement*

**Selenium 3** позволяет делать снимки только веб-страниц и не позволяет делать снимки экрана с конкретными веб-элементами. 
**Selenium 4** позволяет делать снимки экрана определенного веб-элемента.

* *инструменты разработчика Chrome (Chrome Dev Tools)*

**Selenium 4** имеет встроенную поддержку протокола Chrome DevTools через интерфейс **DevTools**. 
Благодаря этому мы можем получить такие свойства разработки Chrome, как кэш приложения, выборка, производительность, сеть, профилировщик, 
синхронизация ресурсов, безопасность и целевые домены CDP и т. Д.

### 2.2.3. Стандарт W3C WebDriver

***Стандарт W3C WebDriver*** - документ, обеспечивающий совместимость между различными реализациями программного обеспечения с WebDriver API.

Стандарт описывает:

* набор команд (поиск элементов, действия и т д)
* алгоритмы (определение видимости элемента и т д)
* сетевой протокол (описание команд)
* механизм расширения протокола (добавление новых команд)

[WebDriver. W3C Recommendation. 05 June 2018](https://www.w3.org/TR/webdriver1/)

***

# 3. Архитектура Selenium WebDriver

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 3.1. Компоненты Selenium WebDriver

Основные компоненты **Selenium WebDriver**:

1. *готовая клиентская библиотека*

***Готовая клиентская библиотека*** - библиотека для каждого языка программирования, 
реализующего функциональность **Selenium**.

Клиентские библиотеки доступны на языках:

* **Java** - [Selenium Java](https://www.selenium.dev/selenium/docs/api/java/overview-summary.html)
* **.Net (C#)** - [Selenium .Net / C#](https://www.selenium.dev/selenium/docs/api/dotnet/)
* **Python** - [Selenium Python](https://www.selenium.dev/selenium/docs/api/py/)
* **Ruby** - [Selenium Ruby](https://www.selenium.dev/selenium/docs/api/rb/)
* **JavaScript** - [Selenium JavaScript](https://www.selenium.dev/selenium/docs/api/javascript/)

![Клиентские библиотеки](./_Files/1.%20Selenium/04.jpg)

2. *драйвер браузера*

***Драйвер браузера*** - специально написанные модули для взаимодействия с браузером. 
Каждый браузер работает только со своим специально написанным драйвером браузера.

Драйверы реализованы для браузеров:

* **Chrome** - [Google Chrome WebDriver](https://chromedriver.chromium.org/)
* **Edge** - [Microsoft Edge WebDriver](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/)
* **Firefox** - [Mozilla Firefox WebDriver](https://github.com/mozilla/geckodriver/releases)
* **InternetExplorer**
* **Opera**
* **Safari**

![Драйверы браузеров](./_Files/1.%20Selenium/05.jpg)

3. *протокол передачи данных*

**JSON Wire** - REST API, который передает информацию между клиентом и сервером по **HTTP**.
Используется в **Selenium WebDriver** до 4 версии.

Поскольку клиентские библиотеки используют протокол JSON, а веб-браузер использует протокол W3C, 
во всем процессе было задействовано кодирование и декодирование API.

**WebDriver W3C** - протокол W3C, который заменяет **JSON Wire**.
Используется в **Selenium WebDriver** начиная с 4 версии.

Это означает, что больше не нужно кодировать и декодировать запрос API с использованием протокола W3C,
и тесты могут напрямую связываться с веб-браузером.
Информация не будет передаваться путем отправки и получения HTTP-запросов и HTTP-ответов соответственно.

Поскольку **Selenium WebDriver** и веб-браузеры используют один и тот же протокол,
автотесты будет выполняться более согласованно между разными браузерами.

## 3.2. Принцип работы Selenium WebDriver

### 3.2.1. В Selenium < 4 версии

Общая схема работы следующая:

1. Пользователь запускает **скрипт/тест** (на Java, Python, C#, Ruby) использующий готовые клиентские библиотеки (**Selenium Client Library** / **Language Binding**).

2. Скрипт по протоколу **JSON Wire** посылает запросы по **HTTP** драйверу браузера **Browser Driver** с указанием действия, 
которое должен совершить браузер в рамках текущей сессии. 

Примерами таких команд могут быть команды нахождения элементов по локатору, переход по ссылкам, парсинг текста страницы/элемента, 
нажатие кнопок или переход по ссылкам на странице веб-сайта.

3. Драйвер браузера **Browser Driver** (ChromeDriver, FirefoxDriver, OperaDriver, EdgeDriver) посылает запросы реальному браузеру **Browser** (Chrome, Firefox, Opera, Edge).

4. Драйвер браузера **Browser Driver** (ChromeDriver, FirefoxDriver, OperaDriver, EdgeDriver) получает ответы от реального браузера **Browser** (Chrome, Firefox, Opera, Edge).

5. **Скрипт/тест** (на Java, Python, C#, Ruby) по протоколу **JSON Wire** получает ответы по **HTTP** от драйвера браузера **Browser Driver** (полученные от реального браузера). 

![Схема работы Selenium 3](./_Files/1.%20Selenium/06.jpg)

### 3.2.2. В Selenium 4 версии

Общая схема работы такая же как и в Selenium < 4 версии, однако вместо протокола **JSON Wire** используется **WebDriver W3C**.
Протокол **WebDriver W3C** предлагает множество преимуществ по сравнению с протоколом **JSON Wire**. 
Все современные веб-браузеры также используют протокол W3C, избегая необходимости кодирования и декодирования API в Selenium 4 
(который использует протокол **WebDriver W3C**). 

Проблемы, с которыми сталкиваются тестировщики автоматизаторы при переносе кода **Selenium** из одного веб-браузера в другой, 
останутся в прошлом с **Selenium 4**.

![Схема работы Selenium 4](./_Files/1.%20Selenium/07.jpg)

***

# 4. Команды Selenium WebDriver

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 4.1. Классификация команд

Все команды можно разделить на следующие группы:

* инициализация драйвера
* настройка драйвера
* действия со страницами
* действия с окнами
* действия с диалогами
* поиск элементов
* свойства элементов
* действия с элементами
* действия с фреймами
* выполнение JS кода

## 4.2. Однородность команд

Независимо от того на каком языке программирования будет написан скрипт или тестовый сценарий, 
названия и смысл команд будут везде одинаковыми, разумеется с учетом специфики языка (правил именования и т д).

### 4.2.1. Java

```java
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.support.ui.WebDriverWait;
import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated;
import java.time.Duration;

public class HelloSelenium {
    public static void main(String[] args) { 
        WebDriver driver = new FirefoxDriver();
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        try {
            driver.get("https://google.com/ncr");
            driver.findElement(By.name("q")).sendKeys("cheese" + Keys.ENTER);
            WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector("h3>div")));
            System.out.println(firstResult.getAttribute("textContent"));
        } finally {
            driver.quit();
        }
    }
}
```

### 4.2.2. C#

```csharp
using System;
using OpenQA.Selenium;
using OpenQA.Selenium.Firefox;
using OpenQA.Selenium.Support.UI;

class HelloSelenium {
    public static void Main() {
        using(IWebDriver driver = new FirefoxDriver()) {
            WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
            driver.Navigate().GoToUrl("https://www.google.com/ncr");
            driver.FindElement(By.Name("q")).SendKeys("cheese" + Keys.Enter);
            wait.Until(webDriver => webDriver.FindElement(By.CssSelector("h3>div")).Displayed);
            IWebElement firstResult = driver.FindElement(By.CssSelector("h3>div"));
            Console.WriteLine(firstResult.GetAttribute("textContent"));
        }
    }
}
```

### 4.2.3. Ruby 

```rb
require 'selenium-webdriver'

driver = Selenium::WebDriver.for :firefox
wait = Selenium::WebDriver::Wait.new(timeout: 10)

begin
    driver.get 'https://google.com/ncr'
    driver.find_element(name: 'q').send_keys 'cheese', :return
    first_result = wait.until { driver.find_element(css: 'h3>div') }
    puts first_result.attribute('textContent')
ensure
    driver.quit
end
```

### 4.2.4. Python 

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:
    wait = WebDriverWait(driver, 10)
    driver.get("https://google.com/ncr")
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, "h3>div")))
    print(first_result.get_attribute("textContent"))
```

### 4.2.5. JS

```js
const {Builder, By, Key, until} = require('selenium-webdriver');

(async function example() {
    let driver = await new Builder().forBrowser('firefox').build();
    try {
        // Navigate to Url
        await driver.get('https://www.google.com');
        // Enter text "cheese" and perform keyboard action "Enter"
        await driver.findElement(By.name('q')).sendKeys('cheese', Key.ENTER);
        let firstResult = await driver.wait(until.elementLocated(By.css('h3>div')), 10000);
        console.log(await firstResult.getAttribute('textContent'));
    }
    finally{
        driver.quit();
    }
})();
```

### 4.2.6. Kotlin

```kotlin
import org.openqa.selenium.By
import org.openqa.selenium.Keys
import org.openqa.selenium.firefox.FirefoxDriver
import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated
import org.openqa.selenium.support.ui.WebDriverWait
import java.time.Duration

fun main() {
    val driver = FirefoxDriver()
    val wait = WebDriverWait(driver, Duration.ofSeconds(10))
    try {
        driver.get("https://google.com/ncr")
        driver.findElement(By.name("q")).sendKeys("cheese" + Keys.ENTER)
        val firstResult = wait.until(presenceOfElementLocated(By.cssSelector("h3>div")))
        println(firstResult.getAttribute("textContent"))
    } finally {
        driver.quit()
    }
}
```

***

# 5. Настройка окружения

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Перед тем как начать автоматизировать тестовые сценарии, необходимо настроить окружение.

Нам понадобятся:

* язык программирования - **Java**
* ide - **IntelliJ IDEA**
* сборщик проекта - **Maven**
* система контроля версий - **Git**
* веб-сервис для хостинга IT-проектов - **Github**

***

# 6. Язык программирования Java (JDK)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве языка программирования будет использоваться **Java**.

![Java](./_Files/2.%20Java/01.jpg "Java")

## 6.1. Почему Java?

***Java*** – строго типизированный объектно-ориентированный язык программирования общего назначения, 
разработанный компанией Sun Microsystems (в последующем приобретённой компанией Oracle).
Программы на Java транслируются в байт-код Java, выполняемый виртуальной машиной Java (JVM) — программой, 
обрабатывающей байтовый код и передающей инструкции оборудованию как интерпретатор.
Достоинством подобного способа выполнения программ является полная независимость байт-кода 
от операционной системы и оборудования, что позволяет выполнять Java-приложения на любом устройстве,
для которого существует соответствующая виртуальная машина.

Преимущества:

* **Java** широко распространен в разработке (бек/микросервисы на фреймворке Spring, приложения для ОС Android)

Разработчики на Java смогут помочь в решении многих вопросов.

* **Java** давно используется в автотестах

Широкий набор библиотек для автоматизации тестирования (в частности в C# нет аналога Selenide -
библиотеки для более изящного написания кода для автотестов).

Стек тестирования: JUnit, TestNG, Selenide, Cucumber.

Разрабатывать автотесты можно и на других языках программирования:

* Python
* Ruby
* C#

Рассмотрим подробнее:

**Python**

Простой синтаксис (и нет проклятых операторных скобок), колоссальное количество библиотек, огромное коммьюнити.

Стек тестирования: PyTest, PyTest BDD, Behave.

**Ruby**

Удобный и гибкий синтаксис (и нет проклятых операторных скобок), множество библиотек,
сильное развитие инструментов тестирования (в частности изначально BDD фреймворк Cucumber разрабатывался на Ruby).

Стек тестирования: RSpec, Capybara, Cucumber.

**C#**

Поддержка Microsoft, Си подобный синтаксис (с проклятыми операторными скобками).

Стек тестирования: NUnit, SpecFlow.

Каждый из языков программирования обладает примерно равными возможностями, а выбор конкретного языка - это уже вопрос предпочтений.

## 6.2. Где взять Java?

На сайте [Oracle](https://www.oracle.com/java/technologies/javase-downloads.html).

## 6.3. Какую версию Java устанавливать?

Релизы **Java** выходят раз в полгода (не считая мелких обновлений).
Но не стоит гнаться за новизной. Если вы установите **Java** последней версии, приготовьтесь к тому, что не все приложения будут хорошо работать с ней.
Новые недавно добавленные возможности иногда приводят к проблемам совместимости.

В сентябре 2019 вышла версия 13, в 2020 вышла версия 15, но при этом большинство продолжает использовать **Java 8**!
Поэтому если вы хотите максимальной стабильности и совместимости — берите **Java 8**.

Второе место по популярности занимает **Java 11**, это так называемый релиз с долгосрочной поддержкой (Long Term Support, LTS), ориентированный на корпоративных пользователей, для которых стабильность важнее новых фич.
Поддержка **Java 8** официально прекращается в декабре 2020 года, к этому времени все корпоративные пользователи будут вынуждены перейти на **Java 11**.

Выбирая из 32-битной и 64-битной версий, берите 64-битную, если ваша операционная система это позволяет.

## 6.4. Что устанавливать, JRE или JDK?

***Java Development Kit, или JDK*** — набор инструментов для разработки программ на языке программирования **Java**
(компилятор, архиватор, генератор документации и прочие), среду выполнения (Java Runtime Environment), стандартную библиотеку языка,
примеры и документацию.

***Java Runtime Environment, или JRE*** — виртуальная машина, позволяющая запускать приложения, написанные на языке программирования **Java**.

**Правило очень простое:** если вы собираетесь что-нибудь писать на языке программирования **Java**, значит вам потребуется JDK.
А если только запускать готовые программы — тогда достаточно JRE.

***

# 7. IDE IntelliJ IDEA

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве IDE будет использоваться **IntelliJ IDEA**.

![IntelliJ IDEA](./_Files/3.%20IntelliJ%20IDEA/01.jpg "IntelliJ IDEA")

## 7.1. Почему IntelliJ IDEA?

***IntelliJ IDEA*** — известная IDE для **Java**, написанная, как ни странно, на **Java**.
Укомплектована уникальными инструментами и позволяет без проблем ориентироваться в программе.
Нахождение ошибок и отладка кода никогда не были такими легкими, как с IntelliJ IDEA.

Преимущества:

* глубокий анализ кода
  * умное автодополнение
  * автодополнение цепочек вызовов
  * автодополнение статических членов
  * анализ потоков данных
  * языковые вставки
  * рефакторинги для разных языков
  * поиск дубликатов
  * инспекции и быстрые исправления
* эргономичная среда
  * все необходимое прямо в редакторе
  * сочетания клавиш для любого действия
  * эргономичный интерфейс
  * встроенный отладчик
* встроенные инструменты для разработчиков
  * интеграция с системами контроля версий
  * инструменты сборки
  * инструмент запуска тестов и анализ покрытия кода
  * декомпилятор
  * терминал
  * инструменты для работы с базами данных
  * интеграция с серверами приложений
  * Docker
* разработка на разных языках
  * поддержка лучших фреймворков
  * универсальная IDE для разных языков
  * богатая экосистема плагинов

В качестве IDE можно взять:

* Eclipse
* NetBeans
* JDeveloper

Однако все они уступают по возможностям даже бесплатной версии IntelliJ.

## 7.2. Где взять IntelliJ IDEA?

На сайте [JetBrains](https://www.jetbrains.com/idea/download/#section=windows).

## 7.3. Какую версию IntelliJ IDEA устанавливать?

Существует две версии IntelliJ IDEA – **Community** и **Ultimate**.

![Два варианта IntelliJ IDEA](./_Files/3.%20IntelliJ%20IDEA/02.jpg "Два варианта IntelliJ IDEA")

***IntelliJ Community Edition*** - бесплатная версия.

Для начинающих программистов бесплатная IDE предоставляет широкие возможностями, которые помогут им сделать первые шаги в веб-разработке на Java.

**Языки**: Java, Groovy, Kotlin, Scala, Go, Dart, Erlang и Python.

**Фреймворки и платформы**: Android, Swing и JavaFX.

**Системы контроля версий**: Git/GitHub, SVN, Mercurial и CVS.

Кроме этого данная IDE является довольно компактной и содержит несколько других функций, таких как:

* выполнение тестов JUnit/TestNG
* отладка
* автоматическое завершение кода
* проверка кода, рефакторинг кода
* визуальный графический редактор GUI

Доступен плагин Docker, обеспечивающий поддержку развертывания веб-приложений.
Бесплатная версия также включает в себя Decompiler и ByteCode для выполнения расширенного анализа.

***IntelliJ Ultimate Edition*** - платная версия.

Более продвинутые пользователи, скорее всего, предпочтут платную версию, которая дает возможность использовать продвинутые функции.
Платная версия включает в себя всевозможные фичи для коллективной разработки, но бесплатна будет только 30 дней пробного периода.
Потом вам придётся заплатить минимум 500 долларов США.

**Языки**: все что бесплатная + JavaScript, TypeScript, SQL, CSS, LESS, Sass, Stylus, CoffeeScript, ActionScript, Ruby и PHP.

**Фреймворки и платформы**: все что бесплатная + Spring MVC, J2EE (JSF/JAX-RS/CDI/JPA), Grails, Griffin, React, Angular JS, Node.js, Django, Flask, Drupal, WordPress, Laravel.

**Системы контроля версий**: все что бесплатная + TFS, Perforce, ClearCase и Visual SourceSafe.

В ней доступно множество вариантов настройки стратегии развертывания с использованием Tomcat, TomEE, GAE, GlassFish, JBoss, WebLogic, WebSphere, Geronimo, Jetty и Virgo.
В этой версии реализована поддержка NPM, WebPack, Gulp и Grunt.
Она включает в себя такие инструменты, как диаграммы (UML / Dependencies), матрица зависимостей.

Для прохождения курса вполне хватит возможностей бесплатной версии IDE.

## 7.4. Где посмотреть документацию на IntelliJ IDEA?

На сайте [JetBrains](https://www.jetbrains.com/help/idea/discover-intellij-idea.html).

***

# 8. Сборщик проекта Maven

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве сборщика проекта будет использоваться **Maven**.

![Maven](./_Files/4.%20Maven/01.jpg "Maven")

## 8.1. Почему Maven?

***Apache Maven*** — система управления жизненным циклом проекта, фреймворк для автоматизации сборки проектов на основе описания их структуры в файлах на языке POM
(англ. Project Object Model), являющемся подмножеством XML. Проект Maven издаётся сообществом Apache Software Foundation, где формально является частью Jakarta Project.

Преимущества:

* декларативный язык описания проекта (POM)
* автоматическое управление зависимостями
* огромный, поддерживаемый в актуальном состоянии репозиторий артефактов
* модульная расширяемая за счет плагинов архитектура, огромное количество плагинов

В качестве сборщика можно взять:

* Ant
* Gradle

Рассмотрим подробнее:

**Ant**

***Ant*** - cамый древний сборщик проектов, ограничения Ant привели к созданию Maven.

**Gradle**

***Gradle*** - сборщик проектов, который взял самое лучшее от Ant и Maven.
Однако Gradle использует DSL на основе Groovy, что потребует изучение еще одного языка программирования.
Также у Gradle нет собственной инфраструктуры, это просто сборщик.
И если вы решили разрабатывать библиотеку на Gradle, то придётся не только загружать её в Maven-репозиторий, но генерировать и сам pom.xml.

## 8.2. Где взять Maven?

На сайте [Apache Maven](https://maven.apache.org/download.cgi).

## 8.3. Какую версию Maven устанавливать?

Устанавливать следует самую свежую версию.

## 8.4. Где посмотреть документацию на Maven?

На сайте [Apache Maven](https://maven.apache.org/guides/index.html).

***

# 9. Система контроля версий Git

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве системы контроля версий будет использоваться **Git**.

![Git](./_Files/5.%20Git/01.jpg "Git")

## 9.1. Почему Git?

***Git*** – распределённая система контроля версий, позволяющая сохранять изменения, внесённые в файлы, которые хранятся в репозитории.

Преимущества:

* бесплатный и open-source

Это значит, что его можно бесплатно скачать и вносить любые изменения в исходный код.

* небольшой и быстрый

Он выполняет все операции локально, что увеличивает его скорость.
Кроме того, **Git** локально сохраняет весь репозиторий в небольшой файл без потери качества данных.

* резервное копирование

**Git** эффективен в хранении бэкапов, поэтому известно мало случаев, когда кто-то терял данные при использовании **Git**.

* простое ветвление.

В других СКВ создание веток — утомительная и трудоёмкая задача, так как весь код копируется в новую ветку.
В **Git** управление ветками реализовано гораздо проще и эффективнее.

В качестве системы контроля версий можно взять:

* SVN
* Mercurial

## 9.2. Где взять Git?

На сайте [Git](https://git-scm.com/download/win).

## 9.3. Какую версию Git устанавливать?

Устанавливать следует самую свежую версию.

## 9.4. Где посмотреть документацию на Git?

На сайте [Git](https://git-scm.com/doc).

## 9.5. Что такое файл .gitignore?

В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью исходного кода.
Все эти файлы можно условно разделить на несколько групп:

* инструментарий
  * служебные файлы, добавляемые операционной системой (например, .DS_Store в Mac)
  * конфигурационные и временные файлы редакторов (например, .idea, .vscode)
* временные файлы
  * логи - файлы, содержащие полезную информацию для отладки, которая собирается во время запуска и работы приложения
  * кеши - файлы, которые нужны для ускорения разных процессов
* артефакты
  * результаты сборки проекта (например, после компиляции или сборки фронтенда)
  * устанавливаемые во время разработки зависимости (например, node_modules, vendor)
  * результаты выполнения тестов (например, информация о покрытии кода тестами)

Всё это в обычной ситуации не должно попадать в репозиторий. Как правило, эти файлы не несут никакой пользы с точки зрения исходного кода.
Они создаются либо автоматически (кеши, логи), либо по запросу (например, скачиваются зависимости или собирается проект).
Главная проблема с этими файлами в их постоянном изменении при, как правило, очень больших размерах.
Если добавлять их в репозиторий, то практически в каждом коммите кроме изменений исходного кода будет и пачка изменений в этих файлах.
Читать историю таких коммитов крайне сложно.

Git позволяет гибко настраивать игнорирование определенных файлов и директорий. Делается это с помощью файла **.gitignore**

Как только в проект добавляется файл **.gitignore**, то он сразу начинает работать.
Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды git status.

Основной синтаксис **.gitignore**:

* каждая строка - отдельный шаблон
* пустые строки игнорируются
* строки начинающиеся с **решетки** \# являются комментариями
* **слеш** \/ в начале строки указывает на текущую папку (где лежит .gitignore)
* **звёздочк** \*  заменяет любое количество символов
* две **звёздочки** \** используются для указания всех подпапок
* **восклицательный знак** \! в начале строки инвертирует шаблон (используется для исключений)
* для экранирования спецсимволов используется **обратный слэш** \\
* для игнорирования всей директории, правило должно оканчиваться на **слэш** \/, в противном случае правило считается именем файла

*Пример*

```gitignore
# Игнорировать файл foo.txt.
foo.txt
# Игнорировать html файлы
*.html
# Но конкретно foo.html не игнорировать
!foo.html
# Игнорировать rar файлы в корне проекта
# Допустим файл /temp/main.rar не будет проигнорирован т.к. он не в корне
/*.rar
# Игнорировать css файлы из папки bar не включая подпапки
# Допустим файл /bar/temp/main.css не будет проигнорирован т.к. он в подпапке temp
/bar/*.css
# Игнорировать js файлы из папки bar и подпапок, если таковые будут
/bar/**.*.js
```
***

# 10. Веб сервис для хостинга IT проектов GitHub

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве веб-сервис для хостинга IT-проектов будет использоваться **GitHub**.

![GitHub](./_Files/6.%20GitHub/01.jpg "GitHub")

## 10.1. Почему GitHub?

***GitHub*** — сервис онлайн-хостинга репозиториев, обладающий всеми функциями распределённого контроля версий и
функциональностью управления исходным кодом — всё, что поддерживает **Git** и даже больше.

Цель **GitHub** — содействовать взаимодействию разработчиков.

Преимущества:

* контроль доступа
* багтрекинг
* управление задачами
* вики для каждого проекта
* интеграция со множеством популярных сервисов
* графики
* вложенные списки задач

В качестве сервиса онлайн-хостинга репозиториев можно взять:

* Bitbucket
* GitLab

Все сервисы обладают примерно равными базовыми возможностями.

## 10.2. Где посмотреть документацию на GitHub?

На сайте [GitHub Docs](https://docs.github.com/en).

***

# 11. Подключение библиотек

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Перед тем как начать писать автотесты, необходимо подключить все необходимые либы.

Нам понадобятся:

* тестовый фреймворк - **JUnit5**
* веб драйвер - **Selenium WebDriver**
* менеджер драйверов - **WebDriverManager**
* система логирования - **Log4J2**

***

# 12. Тестовый фреймворк JUnit5

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве тестового фреймворка будет использоваться **JUnit5**.

## 12.1. Почему JUnit5?

***JUnit5*** — это мощное и гибкое обновление фреймворка **JUnit**,
которое предоставляет множество улучшений и новых функций для написания тестов.

В **Java** есть несколько широко используемых тестовых фреймворков - **JUnit4**, **JUnit5** и **TestNG**.
На текущий момент **JUnit4** считается устаревшим, взамен ему вышла новая версия **JUnit5**.
А вот и **JUnit5** и **TestNG** являются современными инструментами для тестирования в экосистеме **Java**
и предоставляют практически схожие возможности.

[Сравнение тестовых фреймворков JUnit5 и TestNG](_JUnit%20VS%20TestNG.md).

## 12.2. Где взять JUnit5?

На сайте скопировать параметры зависимости [Maven Repository](https://mvnrepository.com/artifact/org.junit).

## 12.3. Какую версию JUnit5 подключать?

Наиболее свежую.

## 12.4. Где посмотреть документацию на JUnit5?

На сайте [JUnit 5](https://junit.org/junit5/).

В репозитории [junit-team/junit5](https://github.com/junit-team/junit5/).

***

# 13. Веб драйвер Selenium WebDriver

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве веб драйвер будет использоваться **Selenium WebDriver**.

## 13.1. Почему Selenium WebDriver?

***Selenium Webdriver*** - инструмент для автоматизации реального браузера, как локально, так и удалённо,
наиболее близко имитирующий действия пользователя.

***Selenium WebDriver*** – спецификация интерфейса для управления браузером.

Существуют различные обертки поверх API Selenium - такие как Selenide. Но нет полноценных аналогов.

## 13.2. Где взять Selenium WebDriver?

На сайте скопировать параметры зависимости [Maven Repository](https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java).

## 13.3. Какую версию Selenium WebDriver подключать?

Наиболее свежую

## 13.4. Где посмотреть документацию на Selenium WebDriver?

На сайте [Selenium](https://www.selenium.dev/).

В репозитории [SeleniumHQ/selenium](https://github.com/SeleniumHQ/selenium).

***

# 14. Менеджер веб драйверов WebDriverManager

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве менеджера веб драйверов будет использоваться **WebDriverManager**.

## 14.1. Почему WebDriverManager?

***WebDriverManager*** - библиотека, которая позволяет автоматизировать управление драйверами.

Без него необходимо скачивать драйвер для каждого файла и в коде прописывать путь до исполняемого файла.

```java
System.setProperty("webdriver.chrome.driver", "/path/to/chromedriver");
```
## 14.2. Где взять WebDriverManager?

На сайте скопировать параметры зависимости [Maven Repository](https://mvnrepository.com/artifact/io.github.bonigarcia/webdrivermanager).

## 14.3. Какую версию WebDriverManager подключать?

Наиболее свежую.

## 14.4. Где посмотреть документацию на WebDriverManager?

В репозитории [bonigarcia/webdrivermanager](https://github.com/bonigarcia/webdrivermanager).

***

# 15. Система логирования Log4J2

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

В качестве системы логирования будет использоваться **Log4J2**.

## 15.1. Почему Log4j2?

***Log4j2*** — библиотека журналирования (логирования) **Java** программ, часть общего проекта **Apache Logging Project**.

Из известных решений по логированию в **Java** можно выделить:

* *log4j*
* *JUL* — java.util.logging
* *JCL* — jakarta commons logging
* *Logback*
* *SLF4J* — simple logging facade for java

На текущий момент наиболее используемые решения - **Log4J**, **Log4J2** и **SLF4j**.

## 15.2. Где взять Log4j2?

На сайте скопировать параметры зависимости [Maven Repository](https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j)

## 15.3. Какую версию Log4j2 подключать?

Наиболее свежую

## 15.4. Где посмотреть документацию на Log4j2?

На сайте [Apache Log4j2](https://logging.apache.org/log4j/2.x/)

В репозитории [apache/logging-log4j2](https://github.com/apache/logging-log4j2)

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)