Java_QA / 06. Selenium WebDriver. Ожидания

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Как происходит загрузка страницы?](#1-как-происходит-загрузка-страницы)
  * [1.1. Поэтапный процесс загрузки веб страницы в браузере](#11-поэтапный-процесс-загрузки-веб-страницы-в-браузере)
  * [1.2. Важные события жизненного цикла веб страницы](#12-важные-события-жизненного-цикла-веб-страницы)
    * [1.2.1. Особенности события document.DOMContentLoaded](#121-особенности-события-documentdomcontentloaded)
      * [1.2.1.1. DOMContentLoaded и скрипты](#1211-domcontentloaded-и-скрипты)
      * [1.2.1.2. DOMContentLoaded и стили](#1212-domcontentloaded-и-стили)
    * [1.2.2. Свойство document.readyState](#122-свойство-documentreadystate)
* [2. Стратегия загрузки страницы](#2-стратегия-загрузка-страницы)
  * [2.1. Перечисление PageLoadStrategy](#21-перечисление-pageloadstrategy)
    * [2.1.1. PageLoadStrategy.NORMAL](#211-pageloadstrategynormal)
    * [2.1.2. PageLoadStrategy.EAGER](#212-pageloadstrategyeager)
    * [2.1.3. PageLoadStrategy.NONE](#213-pageloadstrategynone)
* [3. Что такое ожидание?](#3-что-такое-ожидание)
* [4. Неявные ожидания (Implicit Waits)](#4-неявные-ожидания-implicit-waits)
  * [4.1. Интерфейс WebDriver.Options](#41-интерфейс-webdriveroptions)
  * [4.2. Интерфейс WebDriver.Timeouts](#42-интерфейс-webdrivertimeouts)
    * [4.2.1. implicitlyWait(Duration duration)](#421-implicitlywaitduration-duration)
    * [4.2.2. pageLoadTimeout(Duration duration)](#422-pageloadtimeoutduration-duration)
    * [4.2.3. setScriptTimeout(Duration duration)](#423-setscripttimeoutduration-duration)
  * [4.3. Исключения](#43-исключения)
    * [4.3.1. TimeoutException](#431-timeoutexception)
      * [4.3.1.1. Причины](#4311-причины)
      * [4.3.1.2. Решение](#4312-решение)
* [5. Явные ожидания (Explicit Waits)](#5-явные-ожидания-explicit-waits)
  * [5.1. Интерфейс Wait](#51-интерфейс-wait)
  * [5.2. Класс FluentWait](#52-класс-fluentwait)
  * [5.3. Класс WebDriverWait](#53-класс-webdriverwait)
  * [5.4. Игнорирование определенных событий](#54-игнорирование-определенных-событий)
  * [5.5. Задержка Thread.sleep](#55-задержка-threadsleep)
  * [5.6. Исключения](#56-исключения)
* [6. Ожидаемые условия](#6-ожидаемые-условия)
  * [6.1. Интерфейс ExpectedCondition](#61-интерфейс-expectedcondition)
  * [6.2. Класс ExpectedConditions](#62-класс-expectedconditions)
  * [6.3. Кастомные условия ожидания](#63-кастомные-условия-ожидания)
    * [6.3.1. Кастомные условия ожидания с использованием именованного класса](#631-кастомные-условия-ожидания-с-использованием-именованного-класса)
    * [6.3.2. Кастомные условия ожидания с использованием анонимного класса](#632-кастомные-условия-ожидания-с-использованием-анонимного-класса)
* [7. Сравнение явных и неявных ожиданий](#7-сравнение-явных-и-неявных-ожиданий)

***

# 1. Как происходит загрузка страницы?

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 1.1. Поэтапный процесс загрузки веб страницы в браузере

Этапы загрузки веб страницы:

* *открытие пользователем нужной страницы сайта (URL) в браузере*

* *обработка запросов к DNS-серверу*

Запрос к хосту, на котором размешен сайт со всеми файлами и папками.

***DNS (Domain Name System)*** — система доменных имён, компьютерная распределённая система для получения информации о доменах. 
Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), 
получения информации о маршрутизации почты, обслуживающих узлах для протоколов в домене (SRV-запись).

***DNS-сервер (name server)*** — приложение, предназначенное для ответов на DNS-запросы по соответствующему протоколу. 
Также DNS-сервером могут называть хост, на котором запущено приложение.

* *обработка редиректов*

Время, которое будет потрачено на отработку HTTP-переадресации при загрузке страницы.

* *подключение к серверу*

Время, в течение которого браузер ожидает подключения к HTTP-серверу при получении содержимого страницы.

* *ответ сервера*

Время, в течение которого передается ответ с содержимым страницы от HTTP-сервера к браузеру.

* *обработка HTML*

Время, в течение которого браузер обрабатывает содержимое страницы после ее загрузки с сервера и до начала отрисовки.

* *отрисовка браузером страницы*

Время, которое пройдет от начала перехода на страницу до момента, когда страница начинает отрисовываться.

* *полная загрузка*

Время, которое пройдет от начала перехода на страницу до полной загрузки страницы со всеми ее компонентами 
(изображения, CSS, скрипты и т. п.). Это значение субъективно воспринимается посетителем как «качество» страницы.

![Этапы загрузки веб страниц](_Files/1.%20PageLoadStrategy/01.png "Этапы загрузки веб страниц")

## 1.2. Важные события жизненного цикла веб страницы

У жизненного цикла HTML страницы есть следующие события:

* *document.DOMContentLoaded* – браузер полностью загрузил HTML, было построено **DOM** дерево, но внешние ресурсы, 
  такие как картинки <img> и стили, могут быть ещё не загружены

**DOM** дерево готово, так что обработчик может искать **DOM**-узлы и инициализировать интерфейс.

* *window.onload* – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.)

Внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д - можно с ними работать.

* *window.onbeforeunload* – пользователь покидает страницу

* *window.onunload* - пользователь почти ушёл

### 1.2.1. Особенности события document.DOMContentLoaded

Событие **DOMContentLoaded** срабатывает на объекте **document**.
На первый взгляд событие **DOMContentLoaded** очень простое. 
DOM-дерево готово – получаем событие. Хотя тут есть несколько особенностей.

#### 1.2.1.1. DOMContentLoaded и скрипты

Когда браузер обрабатывает HTML-документ и встречает тег \<script\>, 
он должен выполнить его перед тем, как продолжить строить DOM. 
Это делается на случай, если скрипт захочет изменить **DOM** или даже дописать в него (**document.write**), 
так что **DOMContentLoaded** должен подождать.

Есть два исключения из этого правила:

* скрипты с атрибутом **async** не блокируют **DOMContentLoaded**
* скрипты, сгенерированные динамически при помощи **document.createElement('script')** 
и затем добавленные на страницу, также не блокируют это событие

#### 1.2.1.2. DOMContentLoaded и стили

Внешние таблицы стилей не затрагивают **DOM**, поэтому **DOMContentLoaded** их не ждёт.
Но здесь есть подводный камень. Если после стилей у нас есть скрипт, 
то этот скрипт должен дождаться, пока загрузятся стили
Причина в том, что скрипту может понадобиться получить координаты или другие свойства элементов, 
зависящих от стилей, как в примере выше. Естественно, он должен дождаться, пока стили загрузятся.
Так как **DOMContentLoaded** дожидается скриптов, то теперь он так же дожидается и стилей перед ними.

### 1.2.2. Свойство document.readyState

Свойство **document.readyState** показывает нам текущее состояние загрузки.

Есть три возможных значения:

* *loading* – документ загружается
  
* *interactive* – документ был полностью прочитан

Свойство **document.readyState** станет **interactive** прямо перед **DOMContentLoaded**. 
Эти две вещи, на самом деле, обозначают одно и то же.

* *complete* – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены 

Свойство **document.readyState** станет **complete**, когда все ресурсы загрузятся. 
Переключение на состояние **complete** означает то же самое, что и **window.onload**.
Разница заключается в том, что **window.onload** всегда срабатывает после всех load других обработчиков.

***

# 2. Стратегия загрузки страницы

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

## 2.1. Перечисление PageLoadStrategy

Можно настроить поведение при загрузке страницы, задав нужный параметр **PageLoadStrategy**.

***PageLoadStrategy*** - перечисление определяющее стратегии загрузки страницы.

Константы перечисления **PageLoadStrategy**

| Тип    | Описание                                                   | document.readyState | событие          |
|--------|------------------------------------------------------------|---------------------|------------------|
| NORMAL | Загрузка всей страницы (по умолчанию)                      | complete            | window.onload    |
| EAGER  | Загрузка только HTML части (без стилей, изображений и т д) | interactive         | DOMContentLoaded |
| NONE   | Загрузки начальной страницы                                | any                 |                  |

[selenium/docs/api : PageLoadStrategy](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/PageLoadStrategy.html)

### 2.1.1. PageLoadStrategy.NORMAL

Если установлено значение **PageLoadStrategy.NORMAL**, **Selenium WebDriver** ожидает, 
пока не будет возвращено событие загрузки **window.onload** (**document.readyState = complete**). 

То есть **Selenium WebDriver** будет ждать, 
пока исходный **HTML** документ не будет полностью загружен со всеми ресурсами.

Используется по умолчанию.

*Пример*

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

### 2.1.2. PageLoadStrategy.EAGER

Если установлено значение **PageLoadStrategy.EAGER**, **Selenium WebDriver** ожидает, 
пока не будет возвращено событие загрузки **document.DOMContentLoaded** (**document.readyState = interactive**).

То есть **Selenium WebDriver** будет ждать, 
пока исходный **HTML** документ не будет полностью загружен 
и проанализирован, и отменит загрузку таблиц стилей, изображений и т д.

*Пример*

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

### 2.1.3. PageLoadStrategy.NONE

Если установлено значение **PageLoadStrategy.NONE**, **Selenium WebDriver** ожидает 
только загрузки начальной страницы. 

То есть **Selenium WebDriver** не блокируется вообще.

*Пример*

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

***

# 3. Что такое ожидание?

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Ожидание*** - некий временной интервал между произведенными действиями 
(поиск элемента или любой другой вид операции с элементом).

Когда страница приложения загружена в браузере, элементы на этой странице могут подгружаться с различными временными интервалами.
Скрипт выполняется намного быстрее реакции приложения на команды.
Это затрудняет поиск элементов, если элемент не присутствует в **DOM**, возникает исключение **ElementNotVisibleException**.
Поэтому часто в скриптах необходимо дожидаться определенного состояния приложения для дальнейшего с ним взаимодействия.
Используя ожидания, мы можем решить эту проблему.
Таким образом ожидания нужны для синхронизации работы тестируемого приложения и тестового скрипта.

Так как **Selenium WebDriver** работает с **DOM**, то ожидание загрузки страницы происходит через ожидание состояния 
**document.readyState == complete**. Это происходит автоматически после открытия страницы **driver.get()**, 
перезагрузки **driver.navigate.refresh()**, перехода на другие страницы посредством нажатия на веб элементы и т.д.
**Selenium WebDriver** ожидает загрузку **DOM**-а страницы автоматически.

**Selenium WebDriver** предоставляет два типа ожиданий: 

* *неявные ожидания (Implicit Waits)* заставляют **Selenium WebDriver** опрашивать **DOM** определенное количество времени, когда пытается найти элемент
* *явные ожидания (Explicit Waits)* заставляют **Selenium WebDriver** ожидать возникновение определенного условия до произведения действий

![Ожидания (Waits)](_Files/2.%20Waits/01.jpg "Ожидания")

***

# 4. Неявные ожидания (Implicit Waits)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Неявное ожидание (Implicit Waits)*** - ожидание, которое конфигурируют экземпляр **Selenium WebDriver** 
на совершение многократных попыток найти элемент (элементы) на странице в течении заданного периода времени, 
если элемент не найден сразу, и только по истечении этого времени (по умолчанию 0)
**Selenium WebDriver** бросит **ElementNotFoundException**. 

![Неявные ожидания (Implicit Waits)](_Files/3.%20Implicit%20Waits/01.jpg "Неявные ожидания (Implicit Waits)")

Неявные ожидания обычно настраиваются сразу после создания экземпляра **Selenium WebDriver** 
и действуют в течении всей жизни этого экземпляра, хотя переопределить их можно в любой момент. 

## 4.1. Интерфейс WebDriver.Options

Неявные ожидания настраиваются с помощью **WebDriver.Options**.

***WebDriver.manage()*** - реализация интерфейса **WebDriver.Options**.

Методы интерфейса **WebDriver.Options** для конфигурации неявных ожиданий:

| Тип                | Метод      | Описание                   | 
|--------------------|------------|----------------------------|
| WebDriver.Timeouts | timeouts() | Настройка неявных ожиданий |

[selenium/docs/api : WebDriver.Options](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Options.html)

## 4.2. Интерфейс WebDriver.Timeouts

***WebDriver.Timeouts*** - интерфейс представляющий методы для настройки неявных ожиданий.

Методы интерфейса **WebDriver.Timeouts**:

| Тип                | Метод                               | Описание                                                                                    | 
|--------------------|-------------------------------------|---------------------------------------------------------------------------------------------|
| WebDriver.Timeouts | implicitlyWait(Duration duration)   | Настройка ожидания до появления элемента на странице (неявные ожидания)                     |
| WebDriver.Timeouts | pageLoadTimeout(Duration duration)  | Настройка ожидания до завершения загрузки страница перед появлением ошибки                  |
| WebDriver.Timeouts | setScriptTimeout(Duration duration) | Настройка ожидания до завершения выполнения асинхронного сценария перед появлением ошибки   |

[selenium/docs/api : Timeouts](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html)

### 4.2.1. implicitlyWait(Duration duration)

Ожидание указывается глобально на уровне объекта **driver**. 
Все вызовы элементов **driver.findElement()** будут продолжаться то тех пор, 
пока элемент не будет найден или достигнута граница времени ожидания.
Если элемент не будет найден, то будет выброшено исключение **NoSuchElementException**.

*Пример*

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().implicitlyWait(Duration.ofMillis(100000));
driver.get("http://some_url");
WebElement dynamicElement = driver.findElement(By.id("dynamicElement_id"));
```

### 4.2.2. pageLoadTimeout(Duration duration)

Ожидание указывается для загрузки страницы.
Если **DOM** страницы не загрузился к тому моменту, то будет выброшено исключение **TimeoutException**.

*Пример*

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().pageLoadTimeout(Duration.ofMillis(100000));
pageLoad();
```

### 4.2.3. setScriptTimeout(Duration duration)

Ожидание указывается для функции **executeAsyncScript** как граничное значение времени ожидания завершения запроса.
Если скрипт не завершится к тому времени, то будет выброшено исключение **TimeoutException**.

*Пример*

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().setScriptTimeout(Duration.ofMillis(100000));
performScript();
```

## 4.3. Исключения

### 4.3.1. TimeoutException

***TimeoutException*** - исключение, которое вызывается, когда выполнение какой-либо
команды не завершилось в отведенный промежуток времени, так как выполнение команды занимает больше времени, чем время ожидания.

[selenium/docs/api : TimeoutException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/TimeoutException.html)

#### 4.3.1.1. Причины

* Страница не была загружена за определенное время

*Пример*

В примере ниже установлено ожидание загрузки страницы в 1 миллисекунду.
Страница не успевает загрузиться за этот промежуток времени.

```java
@Test
public void test() {
    driver.manage().timeouts().pageLoadTimeout(Duration.ofMillis(1));
    driver.manage().window().maximize();
    driver.get("https://www.mvideo.ru/");
}
```

В результате вызывается исключение **TimeoutException**.

```text
org.openqa.selenium.TimeoutException: 
timeout: Timed out receiving message from renderer: 0.001
```

* Искомый веб элемент не был найден за определенное время

*Пример*

В примере ниже ожидается появление веб элемента.
Веб элемент не успевает отобразиться в отведенный промежуток времени.

```java
@Test
public void test() {
    driver.manage().timeouts().pageLoadTimeout(Duration.ofMillis(6000));
    driver.manage().window().maximize();
    driver.get("https://www.mvideo.ru/");
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofMillis(1));
    wait.until(ExpectedConditions.presenceOfElementLocated(By.xpath("//a[text()=\"ЭКСПРЕСС-ДОСТАВКА\"]")));
    driver.findElement(By.xpath("//a[text()=\"ЭКСПРЕСС-ДОСТАВКА\"]"));
}
```

В результате вызывается исключение **TimeoutException**

```text
org.openqa.selenium.TimeoutException: Expected condition failed: 
waiting for presence of element located by: By.xpath: //a[text()="Смартфоны"] 
(tried for 0 second(s) with 500 milliseconds interval)

```

#### 4.3.1.2. Решение

* Неявное ожидание в течение промежутка времени, за которое страница успевает загрузится

*Пример*

```java
@Test
public void test() {
    driver.manage().timeouts().pageLoadTimeout(Duration.ofMillis(6000));
    driver.manage().window().maximize();
    driver.get("https://www.mvideo.ru/");
}
```

* Явное ожидание наступления конкретного события, в течение промежутка времени,
  за которое событие успевает наступить

*Пример*

```java
@Test
public void test() {
    driver.manage().timeouts().pageLoadTimeout(Duration.ofMillis(6000));
    driver.manage().window().maximize();
    driver.get("https://www.mvideo.ru/");
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofMillis(6000));
    wait.until(ExpectedConditions.presenceOfElementLocated(By.xpath("//a[text()=\"ЭКСПРЕСС-ДОСТАВКА\"]")));
    driver.findElement(By.xpath("//a[text()=\"ЭКСПРЕСС-ДОСТАВКА\"]"));
}
```

* Явное ожидание с применением скрипта на **JS**

*Пример*

В приведенном ниже примере после открытия страницы вызывается на **JS**

```js
return document.readyState
```

пока не будет возвращено **complete**.

```java
@Test
public void test() {
    driver.get("https://www.mvideo.ru/");
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    wait.until(webDriver -> ((JavascriptExecutor) webDriver)
            .executeScript("return document.readyState")
            .equals("complete"));
}
```

Ниже пример перехвата исключения.

*Пример*

```java
    @Test
public void test() {
    try {
        driver.manage().timeouts().pageLoadTimeout(Duration.ofMillis(1));
        driver.manage().window().maximize();
        driver.get("https://www.mvideo.ru/");
    } catch(TimeoutException e) {
        logger.info("TimeoutException: " + e.getRawMessage());
    }
}
```

***

# 5. Явные ожидания (Explicit Waits)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Явные ожидания (Explicit Waits)*** - ожидание, которое определяет какое необходимое событие 
должно произойти для того, чтобы дальнейший код исполнился. 

![Явные ожидания (Implicit Waits)](_Files/4.%20Explicit%20Waits/01.jpg "Неявные ожидания (Explicit Waits)")

Такое ожидание срабатывает один раз в указанном месте.

## 5.1. Интерфейс Wait<F>

**Wait** - интерфейс предоставляющий методы явных ожиданий.

Классы реализующие интерфейс:

* *FluentWait*
* *WebDriverWait*

Методы интерфейса **Wait**:

| Тип     | Метод                               | Описание                       |
|---------|-------------------------------------|--------------------------------|
| \<T\> T | until(Function<? super F,T> isTrue) | Ожидание определенного условия |	

[selenium/docs/api : Wait](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/Wait.html)

## 5.2. Класс FluentWait

***FluentWait*** - класс реализующий явные ожидания, у которого время ожидания и интервал опроса могут быть настроены на лету.
Кроме того, пользователь может настроить ожидание так, чтобы игнорировать определенные типы исключений во время ожидания, 
такие как **NoSuchElementExceptions**, при поиске элемента на странице.

Класс реализует интерфейс **Wait**.

Методы класса **FluentWait**:

| Тип                                 | Метод                                                                    | Описание                                     |
|-------------------------------------|--------------------------------------------------------------------------|----------------------------------------------|
| <K extends Throwable> FluentWait<T> | ignoreAll(Collection<Class<? extends K>> exs)                            | Игнорирование исключений                     |
| FluentWait<T>                       | ignoring(Class<? extends Throwable> ex)                                  | Игнорирование исключения                     |                                                                                         |
| FluentWait<T>                       | ignoring(Class<? extends Throwable> ex1, Class<? extends Throwable> ex2) | Игнорирование исключений                     |                                                                                          |
| FluentWait<T>                       | pollingEvery(java.time.Duration interval)                                | Частота опроса для проверки условий ожидания |
| protected RuntimeException          | timeoutException(String message, Throwable lastException)                | Исключение по таймауту                       |
| <V> V                               | until(Function<? super T,V> isTrue)                                      | Ожидание определенного условия               |
| FluentWait<T>                       | withMessage(String message)                                              | Сообщение отображаемое по таймауту           |
| FluentWait<T>                       | withMessage(Supplier<String> messageSupplier)                            | Сообщение отображаемое по таймауту           |
| FluentWait<T>                       | withTimeout(Duration timeout)                                            | Интервал оценки условий ожидания             |

[selenium/docs/api : FluentWait](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/FluentWait.html)

*Пример*

```java
driver = new ChromeDriver();
FluentWait<WebDriver> wait = new FluentWait<WebDriver>(driver)
    .withTimeout(7, TimeUnit.SECONDS)
    .pollingEvery(500, TimeUnit.MILLISECONDS)
    .ignoring(NoSuchElementException.class);

WebElement element = wait.until(new Function<WebDriver, WebElement>() {
    public WebElement apply(WebDriver driver) {
        return driver.findElement(locator);
    }
});

element.click();
```

## 5.3. Класс WebDriverWait

***WebDriverWait*** - класс реализующий явные ожидания.

Класс наследует класс **FluentWait**.
Класс реализует интерфейс **Wait**.

Конструкторы класса **WebDriverWait**:

| Конструктор                                                                                     | 
|-------------------------------------------------------------------------------------------------|
| WebDriverWait(WebDriver driver, Duration timeout)                                               |
| WebDriverWait(WebDriver driver, Duration timeout, Duration sleep)                               |
| WebDriverWait(WebDriver driver, Duration timeout, Duration sleep, Clock clock, Sleeper sleeper) |

Параметры конструкторов:

* *driver* - инстанс **WebDriver** 
* *timeout* - интервал в течение которого проверяется ожидаемое условие (посылаются запросы)
* *sleep* - интервал между посылаемыми запросами
* *clock* - экземпляр класса Clock (получение данных о текущем времени)
* *sleeper* - экземпляр класс Sleeper (обертка вокруг Thread.sleep())

[selenium/docs/api : WebDriverWait](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/WebDriverWait.html)

*Пример*

```java
WebDriverWait wait = new WebDriverWait(driver, 10L, 125L);
wait.until(driver -> driver.findElements(By.cssSelector("div.super")).size() > 10);
```

## 5.4. Игнорирование определенных событий

Во время процесса поиска **WebDriver** регулярно опрашивает браузер на наличие элемента в **DOM** модели. 
При этом существует ряд исключительных ситуаций, которые могут возникнуть (см ниже).

Когда пойман один из таких случаев, то цикл остановится и выбросит исключение.
Для того чтобы игнорировать исключения предусмотрены методы **ignoring**:

```java
private final Wait<WebDriver> wait = new WebDriverWait(driver, 5)
        .ignoring(StaleElementReferenceException.class, ElementNotVisibleException.class);
```

## 5.5. Задержка Thread.sleep

Самым худшим вариантом явного ожидания является использование **Thread.sleep**, в
случае с которым скрипт просто будет ждать определенное количество времени.
Это не гарантирует наступление нужного события либо будет слишком избыточным и увеличит время выполнения теста.

*Пример*

```java
By xpath = By.xpath("//button")
WebElement element = driver.findElement(xpath);
element.click();
Thread.sleep(1000);
...
```

## 5.6. Исключения

Те же самые что и для неявных ожиданий

***

# 6. Ожидаемые условия

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Явные ожидания требуют наступления определенных условий.

## 6.1. Интерфейс ExpectedCondition<T>

***ExpectedCondition<T>*** - интерфейс моделирующий ожидаемое условие.

Интерфейс реализует следующие интерфейсы:

* **com.google.common.base.Function<WebDriver, T>**
* **java.util.function.Function<WebDriver, T>**

[selenium/docs/api : ExpectedCondition](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedCondition.html)

## 6.2. Класс ExpectedConditions

Существуют некие условия, которые часто встречаются при автоматизации.

***ExpectedConditions*** - класс представляющий часто встречающиеся условия ожидания.

Класс реализует интерфейс **ExpectedCondition**.

Методы класса **ExpectedConditions**:

* *атрибуты и свойства элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | attributeContains(By by, String attr, String val)         | Атрибут элемента содержит значение      |
| ExpectedCondition<Boolean>          | attributeContains(WebElement el, String attr, String val) | Атрибут элемента содержит значение      |
| ExpectedCondition<Boolean>          | attributeToBe(By by, String attr, String val)             | Атрибут элемента равен значению         |
| ExpectedCondition<Boolean>          | attributeToBe(WebElement el, String attr, String val)     | Атрибут элемента равен значению         |
| ExpectedCondition<Boolean>          | attributeToBeNotEmpty(WebElement el, String attr)         | Атрибут элемента не пустой              |
| ExpectedCondition<Boolean>          | domAttributeToBe(WebElement el, String attr, String val)  | DOM атрибут элемента равен значению     |
| ExpectedCondition<Boolean>          | domPropertyToBe(WebElement el, String prop, String val)   | DOM свойство элемента равно значению    |

* *состояние элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<WebElement>       | elementToBeClickable(By by)                               | Возможность кликнуть на элемент         |
| ExpectedCondition<WebElement>       | elementToBeClickable(WebElement el)                       | Возможность кликнуть на элемент         |
| ExpectedCondition<Boolean>          | elementToBeSelected(By by)                                | Возможность выбрать элемент             |
| ExpectedCondition<Boolean>          | elementToBeSelected(WebElement el)                        | Возможность выбрать элемент             |
| ExpectedCondition<Boolean>          | elementSelectionStateToBe(By by, boolean state)           | Состояние выбираемого элемента          |
| ExpectedCondition<Boolean>          | elementSelectionStateToBe(WebElement el, boolean state)   | Состояние выбираемого элемента          |

* *количество элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<List<WebElement>> | numberOfElementsToBe(By by, Integer number)               | Количество элементов равно заданному    |
| ExpectedCondition<List<WebElement>> | numberOfElementsToBeLessThan(By by, Integer number)       | Количество элементов меньше заданного   |
| ExpectedCondition<List<WebElement>> | numberOfElementsToBeMoreThan(By by, Integer number)       | Количество элементов больше заданного   |

* *наличие элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<WebElement>       | presenceOfElementLocated(By by)                           | Наличие элемента                        |
| ExpectedCondition<List<WebElement>> | presenceOfAllElementsLocatedBy(By by)                     | Наличие элементов                       |
| ExpectedCondition<WebElement>       | presenceOfNestedElementLocatedBy(By pr, By ch)            | Наличие вложенного элемента в элемент   |
| ExpectedCondition<WebElement>       | presenceOfNestedElementLocatedBy(WebElement pr, By ch)    | Наличие вложенного элемента в элемент   |
| ExpectedCondition<List<WebElement>> | presenceOfNestedElementsLocatedBy(By pr, By ch)           | Наличие вложенных элементов в элемент   |

* *отсутствие элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | stalenessOf(WebElement el)                                | Отсутствие элемента                     |

* *видимость элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<WebElement>       | visibilityOf(WebElement el)                               | Видимость элемента                      |
| ExpectedCondition<List<WebElement>> | visibilityOfAllElements(List<WebElement> els)             | Видимость всех элементов                |
| ExpectedCondition<List<WebElement>> | visibilityOfAllElements(WebElement... els)                | Видимость всех элементов                |
| ExpectedCondition<List<WebElement>> | visibilityOfAllElementsLocatedBy(By by)                   | Видимость всех элементов                |
| ExpectedCondition<WebElement>       | visibilityOfElementLocated(By by)                         | Видимость элемента                      |
| ExpectedCondition<List<WebElement>> | visibilityOfNestedElementsLocatedBy(By pr, By ch)         | Видимость вложенных элементов в элемент |
| ExpectedCondition<List<WebElement>> | visibilityOfNestedElementsLocatedBy(WebElement pr, By ch) | Видимость вложенных элементов в элемент |

* *невидимость элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | invisibilityOf(WebElement el)                             | Невидимость элемента                    |
| ExpectedCondition<Boolean>          | invisibilityOfAllElements(List\<WebElement\> els)         | Невидимость всех элементов              |
| ExpectedCondition<Boolean>          | invisibilityOfAllElements(WebElement... els)              | Невидимость всех элементов              |
| ExpectedCondition<Boolean>          | invisibilityOfElementLocated(By by)                       | Невидимость элемента                    |
| ExpectedCondition<Boolean>          | invisibilityOfElementWithText(By by, String text)         | Невидимость элемента с текстом          |

* *текстовое содержимое элементов*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | textMatches(By by, Pattern pattern)                       | Текст в элементе совпадает с паттерном  |
| ExpectedCondition<Boolean>          | textToBe(By by, String value)                             | Текст в элементе равен заданному        | 
| ExpectedCondition<Boolean>          | textToBePresentInElement(WebElement el, String text)      | Текст в элементе равен заданному        |
| ExpectedCondition<Boolean>          | textToBePresentInElementLocated(By by, String text)       | Текст в элементе равен заданному        |
| ExpectedCondition<Boolean>          | textToBePresentInElementValue(By by, String text)         | Текст в элементе равен заданному        |
| ExpectedCondition<Boolean>          | textToBePresentInElementValue(WebElement el, String text) | Текст в элементе равен заданному        |

* *работа со страницей*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | titleContains(String title)                               | Заголовок содержит текст                |
| ExpectedCondition<Boolean>          | titleIs(String title)                                     | Заголовок равен заданному               |
| ExpectedCondition<Boolean>          | urlContains(String fraction)                              | URL содержит текст                      |
| ExpectedCondition<Boolean>          | urlMatches(String regex)                                  | URL совпадает по регулярному выражению  |
| ExpectedCondition<Boolean>          | urlToBe(String url)                                       | URL равен заданному                     |
| static <T> ExpectedCondition<T>     | refreshed(ExpectedCondition<T> condition)                 | Обновление страницы                     |

* *работа с алертами*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Alert>            | alertIsPresent()                                          | Появление алерта на странице            |

* *работа с фреймами*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(int frame)                | Доступность фрейма для переключения     |
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(String locator)           | Доступность фрейма для переключения     |
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(By by)                    | Доступность фрейма для переключения     |
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(WebElement el)            | Доступность фрейма для переключения     |

* *работа с окнами*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | numberOfWindowsToBe(int windows)                          | Количество окон равно заданному         |

* *работа с JS скриптом*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | javaScriptThrowsNoExceptions(String script)               | JS скрипт не выбрасывает исключение     |
| ExpectedCondition<Object>           | jsReturnsValue(String script)                             | JS скрипт возвращает значение           |

* *логические операции*

| Тип                                 | Метод                                                     | Описание                                |
|-------------------------------------|-----------------------------------------------------------|-----------------------------------------|
| ExpectedCondition<Boolean>          | and(ExpectedCondition\<?\>... conditions)                 | Логическое условие **И**                |
| ExpectedCondition<Boolean>          | or(ExpectedCondition\<?\>... conditions)                  | Логическое условие **ИЛИ**              |
| ExpectedCondition<Boolean>          | not(ExpectedCondition\<?\> condition)                     | Логическое условие **НЕ**               |

[selenium/docs/api : ExpectedConditions](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html)

*Пример*

```java
By xpath = By.xpath("//button")
WebElement element = driver.findElement(xpath);
element.click();
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.elementToBeClickable(element));
```

## 6.3. Кастомные условия ожидания

Встроенные условия ожидания (**ExpectedConditions**) не всегда способны удовлетворить потребности автотеста.
В таких случаях можно написать собственные методы, которые удержат автотесты от падения.
Работать кастомные ожидания будут по тому же принципу, что и встроенные **ExpectedConditions**.

Для написания своих условий ожидания необходимо создать класс (именованный или анонимный) реализующий интерфейс **ExpectedCondition**.

### 6.3.1. Кастомные условия ожидания с использованием именованного класса

Можно создать отдельный именованный класс реализующий интерфейс **ExpectedCondition**.
И далее использовать его в коде автотеста.

*Пример*

```java
private class ElementContainsText implements ExpectedCondition<Boolean> {

    private By findBy;    
    private String textToFind;
    
    public ElementContainsText (final By elementFindBy, final String textToFind) {
        this.findBy = elementFindBy;
        this.textToFind = textToFind;
    }
    
    @Override
    public Boolean apply(WebDriver webDriver) {
        WebElement element = webDriver.findElement(this.findBy);
        if (element.getText().contains(this.textToFind)) { 
            return true;
        } else {
            return false;
        }
    }
    
    @Override
    public String toString() {
        return ": \"Does " + this.findBy + " contain " + this.textToFind + "?\"";
    }
}
```

### 6.3.2. Кастомные условия ожидания с использованием анонимного класса

Можно применить анонимный класс реализующий интерфейс **ExpectedCondition** прямо в коде автотеста.

*Пример*

```java
wait.until((ExpectedCondition<Boolean>) webDriver -> {
    return webDriver
        .findElement(By.xpath("//div/button[@id='btn1']"))
        .getText()
        .contains(String.valueOf(year));
});
```

***

# 7. Сравнение явных и неявных ожиданий

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

|            | Неявные                  | Явные                   |
|------------|--------------------------|-------------------------|
| Проверка   | На стороне браузера      | На стороне клиента      |
| Событие    | Ожидание появления в DOM | Ждать можно чего угодно |
| Применение | Ко всем элементам        | К конкретному элементу  |
| Исключение | NoSuchElementException   | TimeoutException        |
| Режим      | Работают автоматически   | Надо писать явно        |
| Запросы    | Один сетевой запрос      | Много сетевых запросов  |

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)