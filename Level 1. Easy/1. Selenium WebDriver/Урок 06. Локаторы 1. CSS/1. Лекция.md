# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 1. CSS

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

## 1. Веб элементы

***Веб-элементы*** – DOM объекты, находящиеся на веб странице.

*Веб-элементы* – это все то, что пользователь видит (а иногда и не видит) на странице – заголовки, кнопки "ОК", поля ввода, текстовые блоки и т д.
Элементы в HTML определяются через имя тэга, атрибуты и содержание. У них также могут быть дочерние элементы – например, таблицы. 
CSS может применяться к элементам и менять их цвета, размеры и расположение. 
Языки программирования обычно получают доступ к веб-элементам как к нодам в объектной модели документа (DOM).

## 2. Локаторы

Поскольку Webdriver - это инструмент для автоматизации веб приложений, то большая часть работы с ним это работа с веб-элементами.
А для того, чтобы осуществлять какие-то действия над веб-элементами (DOM объектами) необходимо их точным образом определить(найти).
Для поиска элементов в Selenium используются локаторы.

***Локатор*** – объект, который находит и возвращает веб-элементы на странице по заданному запросу. 


### Зачем нужны локаторы? 

Как пользователи, мы взаимодействуем с веб-страницами визуально. Мы смотрим, скроллим, кликаем и печатаем посредством браузера. 
Тест-автоматизация, однако, взаимодействует со страницами программно: ей нужен закодированный способ поиска и манипулирования теми же самыми элементами. 
Традиционная автоматизация не будет "смотреть" на страницу, как человек – вместо этого она будет искать через DOM.

WebDriver предоставляет следующие типы запросов для локаторов через "By":

### Класс By

provides the following locator query types using “By”:

Class name (Имя класса)
CSS Selector
ID
Link text (текст ссылки)
Name (имя)
Partial link text (частичный текст ссылки)
Tag name (название тэга)
XPath


## 3. Поиск HTML элементов

Существует ряд способов поиска элементов на странице. Вы вправе использовать наиболее уместные для конкретных задач. 
Selenium предоставляет следующие методы поиска элементов на странице:

### Поиск элемента по ID

Использование идентификаторов — самый простой и безопасный способ поиска элемента в HTML. 
Если страница соответствует W3C HTML, идентификаторы должны быть уникальными и идентифицироваться в веб-элементах управления. 
По сравнению с текстами тестовые сценарии, использующие идентификаторы, менее склонны к изменениям приложений 
(например, разработчики могут принять решение об изменении метки, но с меньшей вероятностью изменить идентификатор).

```java
driver.find_element_by_id("submit_btn").click() # Клик по кнопке
driver.find_element_by_id("cancel_link").click() # Клик по ссылке
driver.find_element_by_id("username").send_keys("agileway") # Ввод символов
driver.find_element_by_id("alert_div").text # Получаем текст
driver.find_element_by_id("submit_btn").click() # Клик по кнопке
driver.find_element_by_id("cancel_link").click() # Клик по ссылке
driver.find_element_by_id("username").send_keys("agileway") # Ввод символов
driver.find_element_by_id("alert_div").text # Получаем текст
```

### Поиск элемента по имени

Атрибут имени используются в элементах управления формой, такой как текстовые поля и переключатели (radio кнопки). 
Значения имени передаются на сервер при отправке формы. С точки зрения вероятности будущих изменений, атрибут name,  второй по отношению к ID.

```java
driver.find_element_by_name("comment").send_keys("Selenium Cool")
driver.find_element_by_name("comment").send_keys("Selenium Cool")
```

### Поиск элемента по тексту ссылки

Только для гиперссылок. Использование текста ссылки — это, пожалуй, 
самый прямой способ щелкнуть ссылку, так как это то, что мы видим на странице.

```java
driver.find_element_by_link_text("Cancel").click()
driver.find_element_by_link_text("Cancel").click()
```

```HTML
<a href="/cancel">Cancel</a>
<a href="/cancel">Cancel</a>
```

### Поиск элемента по частичному тексту ссылки

Selenium позволяет идентифицировать элемент управления гиперссылкой с частичным текстом. 
Это может быть полезно, если текст генерируется динамически. 
Другими словами, текст на одной веб-странице может отличаться при следующем посещении. 
Мы могли бы использовать общий текст, общий для этих динамически создаваемых текстов ссылок, для их идентификации.

```java
driver.find_element_by_partial_link_text("ance").click()
driver.find_element_by_partial_link_text("ance").click()
``` 

```HTML
<a href="/cancel">Cancel me</a>
<a href="/cancel">Cancel me</a>
```

### Поиск элемента по имени тега

В HTML есть ограниченный набор имен тегов. Другими словами, многие элементы используют одни и те же имена тегов на веб-странице. 
Обычно мы не используем локатор tag_name для поиска элемента. Мы часто используем его с другими элементами в цепочке локаторах. 
Однако есть исключение.

```java
driver.find_element_by_tag_name("body").text
driver.find_element_by_tag_name("body").text
```

Вышеприведенная тестовая инструкция возвращает текстовое содержимое веб-страницы из тега body.

### Поиск элемента по имени класса

Атрибут class элемента HTML используется для стилизации. Он также может использоваться для идентификации элементов. 
Как правило, атрибут класса элемента HTML имеет несколько значений, как показано ниже.

```HTML
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-deault btn-primary">
    Submit
</input>
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-deault btn-primary">
    Submit
</input>
```

Вы можете использовать любой из них.

```java
driver.find_element_by_class_name("btn-primary").click() # Клик по кнопки
driver.find_element_by_class_name("btn").click() # Клик по ссылке
driver.find_element_by_class_name("btn-primary").click() # Клик по кнопки
driver.find_element_by_class_name("btn").click() # Клик по ссылке
```

Метод class_name удобен для тестирования библиотек JavaScript / CSS (таких как TinyMCE), которые обычно используют набор определенных имен классов.

```java
driver.find_element_by_id("client_notes").click()
time.sleep(0.5)
driver.find_element_by_class_name("editable-textarea").send_keys("inline notes")
time.sleep(0.5)
driver.find_element_by_class_name("editable-submit").click()
driver.find_element_by_id("client_notes").click()
time.sleep(0.5)
driver.find_element_by_class_name("editable-textarea").send_keys("inline notes")
time.sleep(0.5)
driver.find_element_by_class_name("editable-submit").click()
```

### Поиск элемента с помощью селектора CSS

Вы также можете использовать CSS селектор для поиска веб-элемента.

```java
driver.find_element_by_css_selector("#div2 > input[type='checkbox']").click()
driver.find_element_by_css_selector("#div2 > input[type='checkbox']").click()
```

Однако использование селектора CSS, как правило, более подвержено структурным изменениям веб-страницы.

### Используем find_elements для поиска дочерних элементов

Для страницы, содержащей более одного элемента с такими же атрибутами, как приведенный ниже, мы могли бы использовать XPath селектор.

```HTML
<div id="div1">
    <input type="checkbox" name="same" value="on"> Same checkbox in Div 1
</div>

<div id="div2">
    <input type="checkbox" name="same" value="on"> Same checkbox in Div 2
</div>

<div id="div1">
    <input type="checkbox" name="same" value="on"> Same checkbox in Div 1
</div>

<div id="div2">
    <input type="checkbox" name="same" value="on"> Same checkbox in Div 2
</div>
```

Есть еще один способ: цепочка из find_element чтобы найти дочерний элемент.

```java
driver.find_element_by_id("div2").find_element_by_name("same").click()
driver.find_element_by_id("div2").find_element_by_name("same").click()
```


***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)