# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 1. CSS

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

## 1. Document Object Model (DOM)

***Document Object Model (DOM)*** - объектная модель документа, независящий от платформы и языка программный интерфейс,
позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов,
а также изменять содержимое, структуру и оформление таких документов.

Согласно DOM-модели, документ является иерархией, состоящей из равноправных узлов дерева DOM.
Основные типы узлов:

* теги - **узлы-элементы (element node)**
* текст - **текстовые узлы (text node)**

Корневым элементом иерархии является **html**. У него есть два потомка.
Первый - **head**, второй - **body**. И так далее, каждый вложенный тег является потомком тега выше.

Модель DOM не накладывает ограничений на структуру документа. 
Любой документ известной структуры с помощью DOM может быть представлен в виде дерева узлов,
каждый узел которого представляет собой элемент, атрибут, текстовый, графический или любой другой объект. 
Узлы связаны между собой отношениями *Родитель - Потомок*.

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/01.jpg "Document Object Model (DOM)")

Проще говоря, DOM - это представление документа в виде дерева тегов.
Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел.

Основные характеристики DOM:

* основана на валидном HTML-коде
* может быть модифицирована из JavaScript
* не включает псевдоэлементы, созданные из CSS
* включает скрытые элементы (display: none)

Возможности DOM:

* поиск узлов (элементов)
* доступ к узлам вверх и вниз по иерархии (родителям и потомкам)
* получение и изменение содержимого узлов (текст, имя тега и т д)

Например для следующего фрагмента HTML

```html
<html>
  <head>
    <title>Заголовок</title>
  </head>
  <body>
     Прекрасный документ
   </body>
</html>
```

будет построено следующее дерево

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/02.jpg "Document Object Model (DOM)")

> Изначально различные браузеры имели собственные модели документов (DOM), несовместимые с остальными.
Для обеспечения взаимной и обратной совместимости специалисты международного консорциума W3C классифицировали эту модель по уровням,
для каждого из которых была создана своя спецификация. Все эти спецификации объединены в общую группу, носящую название **W3C DOM**.

***Веб-элементы*** – DOM объекты, находящиеся на веб странице, то, что пользователь видит (а иногда и не видит) на странице – 
заголовки, кнопки "ОК", поля ввода, текстовые блоки и т д.

Языки программирования обычно получают доступ к веб-элементам как к нодам в **объектной модели документа (DOM)**.

Selenium WebDriver также работает с **объектной моделью документа (DOM)**.

***

## 2. Команды поиска веб элементов

Для поиска вэб-элементов на странице в Selenium WebDriver есть следующие методы

| Тип              | Метод               | Описание                                                     | 
|------------------|---------------------|--------------------------------------------------------------|
| WebElement       | findElement(By by)  | поиск элемента (возвращает первый найденный элемент)         |
| List<WebElement> | findElements(By by) | поиск всех элементов (возвращает список найденных элементов) |

[selenium/docs/api : WebDriver](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.html)

### Поиск одного веб элемента - findElement

Для поиска одного элемента используется команда **findElement**

```java
WebElement element = driver.findElement(By.tagName("p"));
System.out.println("Paragraph text:" + element.getText());
```

### Поиск набора веб элементов - findElements

Для поиска одного элемента используется команда **findElements**

```java
List<WebElement> elements = driver.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println("Paragraph text:" + element.getText());
}
```

### Поиск веб элемента в веб элементе

В найденном вэб-элементе можно найти другой вэб-элемент.

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
WebElement element = rootElement.findElement(By.tagName("p"));
System.out.println(element.getText());
```

### Поиск набора веб элементов в веб элементе

В найденном вэб-элементе можно найти другие вэб-элементы.

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
List<WebElement> elements = rootElement.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println(element.getText());
}
```

### Цепочка из findElement

```java
WebElement element1 = driver
        .findElement(By.id("div1")
        .findElement(By.name("same");
WebElement element2 = driver.
        findElement(By.id("div2")
        .findElement(By.name("same");
```

***

## 3. Локаторы

Поскольку Webdriver - это инструмент для автоматизации веб приложений, то большая часть работы с ним это работа с веб-элементами.
А для того, чтобы осуществлять какие-то действия над веб-элементами (DOM объектами) необходимо их точным образом определить(найти).
Для поиска элементов в Selenium используются локаторы.

***Локатор*** – объект, который находит и возвращает веб-элементы на странице по заданному запросу.

### Класс By

Selenium WebDriver предоставляет следующие типы локаторов элементов на странице:

| Тип | Метод                                      | Описание                                   | 
|-----|--------------------------------------------|--------------------------------------------|
| By  | By.id(String id)                           | поиск элемента по атрибуту id              |
| By  | By.name(String name)                       | поиск элемента по атрибуту name            |
| By  | By.className(String className)             | поиск элемента по атрибуту class           |
| By  | By.tagName(String tagName)                 | поиск элемента по тегу                     |
| By  | By.linkText(String linkText)               | поиск элемента по тексту ссылки            |   
| By  | By.partialLinkText(String partialLinkText) | поиск элемента по частичному тексту ссылки |
| By  | By.cssSelector(String cssSelector)         | поиск элемента по CSS селектору            |
| By  | By.xPath(String xpath)                     | поиск элемента по XPATH запросу            |

Далее рассмотрим каждый из них подробнее.

### Поиск элемента по атрибуту id

Использование идентификаторов — самый простой и безопасный способ поиска элемента в HTML. 
Если страница соответствует W3C HTML, идентификаторы должны быть уникальными и идентифицироваться в веб-элементах управления. 
По сравнению с текстами тестовые сценарии, использующие идентификаторы, менее склонны к изменениям приложений 
(например, разработчики могут принять решение об изменении метки, но с меньшей вероятностью изменить идентификатор).

```HTML
<div id="menu_go">
    <a href="http://go.go" id="link_go">Go!</a>
    <input type="button" id="button_go">Go!</input>
</div>
```

```java
WebElement menuGo = driver.findElement(By.id("menu_go"));
WebElement linkGo = driver.findElement(By.id("link_go"));
WebElement buttonGo = driver.findElement(By.id("button_go"));
```

### Поиск элемента по атрибуту name

Атрибут name используются в элементах управления формой. 
Значения имени передаются на сервер при отправке формы. 
С точки зрения вероятности будущих изменений, атрибут name, второй по отношению к ID.

```HTML
<input type="submit" name="button_submit">Submit</input>
<input type="submit" name="button_cancel">Cancel</input>
```

```java
WebElement buttonSubmit = driver.findElement(By.name("button_submit");
WebElement buttonCancel = driver.findElement(By.name("button_cancel");
```

### Поиск элемента по атрибуту class

Атрибут class элемента HTML используется для стилизации. 
Он также может использоваться для идентификации элементов.
Как правило, атрибут класса элемента HTML имеет несколько значений, как показано ниже.

```HTML
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-default btn-primary">Submit</input>
```

```java
WebElement element1 = driver.findElement(By.className("btn");
WebElement element2 = driver.findElement(By.className("btn-primary");
WebElement element3 = driver.findElement(By.className("btn btn-default");
WebElement element4 = driver.findElement(By.className("btn btn-primary");
WebElement element5 = driver.findElement(By.className("btn btn-default btn-primary");
```

Метод **className** удобен для тестирования библиотек JavaScript / CSS, которые обычно используют набор определенных имен классов.

```java
driver.findElement(By.className("editable-textarea");
driver.findElement(By.className("editable-submit");
```

### Поиск элемента по имени тега

В HTML есть ограниченный набор имен тегов. Другими словами, многие элементы используют одни и те же имена тегов на веб-странице.
Обычно мы не используем локатор tagName для поиска элемента. Мы часто используем его с другими элементами в цепочке локаторах.
Однако есть исключение.

```java
driver.findElement(By.tag_name("body").text
driver.findElement(By.tag_name("body").text
```

### Поиск элемента по тексту ссылки

Только для гиперссылок. Использование текста ссылки — это, пожалуй, 
самый прямой способ щелкнуть ссылку, так как это то, что мы видим на странице.

```java
driver.findElement(By.link_text("Cancel").click()
driver.findElement(By.link_text("Cancel").click()
```

```HTML
<a href="/cancel">Cancel</a>
<a href="/cancel">Cancel</a>
```

### Поиск элемента по частичному тексту ссылки

Selenium позволяет идентифицировать элемент управления гиперссылкой с частичным текстом. 
Это может быть полезно, если текст генерируется динамически. 
Другими словами, текст на одной веб-странице может отличаться при следующем посещении. 
Мы могли бы использовать общий текст, общий для этих динамически создаваемых текстов ссылок, для их идентификации.

```java
driver.findElement(By.partial_link_text("ance").click()
driver.findElement(By.partial_link_text("ance").click()
``` 

```HTML
<a href="/cancel">Cancel me</a>
<a href="/cancel">Cancel me</a>
```

***

## 4. CSS селекторы

### Поиск элемента с помощью селектора CSS

Вы также можете использовать CSS селектор для поиска веб-элемента.

```java
driver.findElement(By.css_selector("#div2 > input[type='checkbox']").click()
driver.findElement(By.css_selector("#div2 > input[type='checkbox']").click()
```

Однако использование селектора CSS, как правило, более подвержено структурным изменениям веб-страницы.

***

## 5. XPATH запросы

***

## 6. Исключения

Вэб элемент не найден

Вэб элемент не существует

***

## 7. Правила

Как писать хорошие локаторы?

Поиск элемента – это полдела. Создание уникального запроса для локатора – вот вторая половина. Если локатор чересчур широк, он будет возвращать ложноположительные значения. При слишком узком подходе он начнет ломаться при любом изменении DOM, и его будет сложно читать другим людям. Лучший подход здесь такой – пишите наиболее простой запрос, который уникально идентифицирует целевой элемент или элементы.

Мой список предпочтения типов запросов в порядке убывания:

ID (если уникален)
Имя (если уникально)
Имя класса
CSS-селектор
XPath без текста или индексирования
Текст ссылки/частичный текст ссылки.
XPath с текстом и/или индексированием.
Уникальные ID, имена и имена классов крайне упрощают создание локаторов: запросы будут краткими и не требуют дополнительных якорей. Всегда ратуйте, чтобы ваши разработчики использовали уникальные идентификаторы (например, имена классов) для всех элементов. Однако у многих элементов таких идентификаторов нет, и локаторам приходится полагаться на более сложные CSS-селекторы и (содрогнувшись) XPath. Если это случилось с вами, вот мои рекомендации:

Используйте родительские элементы как якоря, если у них есть уникальный идентификатор:
Пример CSS-селектора: “#some-list > li”
XPath-пример: “//ul[@id=’some-list’]/li”
Избегайте XPath с текстом/индексированием при любой возможности.
Плохой пример: “//div[3]//span[text()=’hello’]”
Это наиболее хрупкие тесты.
Используйте функцию "contains", проверяя классы в XPath.
Пример: “//div[contains(@class, ‘some-class’)]”
У элементов зачастую больше одного класса.
“contains” проверит подстроку вместо полной строки класса.
Но будьте осторожны, потому что под выдачу попадут также “some-class2”!
Всегда тестируйте локаторы, в них часто встречаются ошибки синтаксиса и ложноположительные значения. Chrome DevTools упрощает их тестирование – нажмите Ctrl+F на вкладке элементов и вставьте запрос локатора в поле поиска. DevTools подсветит все соответствующие элементы по порядку. Шик-блеск-красота!

Что делать, если тесты нестабильны?

Тестирование через Web UI часто критикуют за нестабильность, потому что тесты часто падают из-за непредвиденных причин. Однако большая часть ненадежности, с которой сталкиваются тестировщики Web UI (и, зачастую, пользователи Selenium WebDriver как такового) связана с тем, что все Web-взаимодействия изначально создают гоночные условия. Автоматизация и браузер работают независимо друг от друга, и взаимодействие должно синхронизироваться с состоянием страницы. В противном случае WebDriver будет выдавать исключения из-за таймаутов, устаревших и не найденных элементов. В ряде случаев эти проблемы возникают не каждый раз, поэтому их тяжело отследить и исправить.

Лучший способ избежать гоночных условий таков – всегда ожидайте существования элемента, прежде чем взаимодействовать с ним. Это кажется элементарным, но про это легко забыть. Пакеты Selenium WebDriver всегда предлагают какую-то разновидность объекта WebDriverWait, заставляющего драйвер ожидать истинности определенного условия перед дальнейшими действиями. Простейший способ проверить, существует ли элемент – это проверить список элементов, возвращаемый вызовом FindElements (для списка элементов) и убедиться, что он непустой. Добавление дополнительного вызова для каждого взаимодействия может показаться затратным, однако дизайн-шаблоны хорошо спроектированных фреймворков (например, Screenplay) могут автоматически осуществлять подобные проверки.

Еще одна хорошая практика – всегда получать "свежие" элементы. Иногда автоматизация вначале получит ряд элементов, а затем через второй запрос получит следующую часть. Или же, в случае с Page Object Factory (никогда ей не пользуйтесь – если в трех словах, она отвратительна), элементы получаются один раз при конструировании Page Object, а затем на них ссылаются. Вне зависимости от способа – чем дольше существует объект на веб-странице, тем более он подвержен тому, чтобы устареть и вызвать исключения. Я видел элементы, необъяснимо устаревающие, даже если они еще присутствовали на странице. Всегда запрашивайте элемент тогда, когда он нужен – в этом случае он не успеет устареть!

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)