# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 1. CSS

[![Назад](https://img.shields.io/badge/-%D0%9D%D0%B0%D0%B7%D0%B0%D0%B4-brightgreen)](1.%20Лекция.md)

***

## Что такое HTML?

***HTML (HyperText Markup Language)*** — стандартизированный язык разметки веб-страниц во Всемирной паутине. 
Код *HTML* интерпретируется браузерами; полученная в результате интерпретации страница отображается 
на экране монитора компьютера или мобильного устройства.

Язык *HTML* до 5-й версии определялся как приложение *SGML* (стандартного обобщённого языка разметки по стандарту ISO 8879). 
Спецификации *HTML5* формулируются в терминах *DOM* (объектной модели документа).
Строгим вариантом *HTML* является *XHTML*, он наследует синтаксис *XML* и является приложением языка *XML*в области разметки гипертекста.

*HTML* как и *XML* имеет древовидную структуру. 
В документе всегда имеется один корневой элемент, содержащий ряд вложенных элементов, 
некоторые из которых тоже могут содержать вложенные элементы. 
Так же могут встречаться текстовые узлы, комментарии и инструкции. 
Можно считать, что XML-элемент содержит массив вложенных в него элементов и массив атрибутов.

У элементов дерева бывают **элементы-предки** и **элементы-потомки**.
У корневого элемента предков нет, а у тупиковых элементов (листьев дерева) нет потомков. 
Каждый элемент дерева находится на определённом уровне вложенности (далее — **уровень**). 
Элементы упорядочены в порядке расположения в тексте *XML*, и поэтому можно говорить об их предыдущих и следующих элементах. 
Это очень похоже на организацию каталогов в файловой системе.

## Что такое XPath?

***XPath (XML Path Language)*** — язык запросов к элементам XML-документа. 
Разработан для организации доступа к частям документа *XML* в файлах трансформации *XSLT* и является стандартом консорциума *W3C*. 
*XPath* призван реализовать навигацию по *DOM* в *XML*. 

В *XPath* используется компактный синтаксис, отличный от принятого в *XML*. 
Так же как и *SQL*, *XPath* является декларативным языком запросов. 
Чтобы получить нужные данные, необходимо всего лишь создать запрос, описывающий эти данные. 
Всю "чёрную" работу за вас выполнит интерпретатор языка xpath.

## Синтаксис XPath

XML-документы представляют собой иерархию, или дерево узлов, в чем-то схожее с иерархией каталогов и файлов в файловой системе. 
Этим и объясняется сходство синтаксиса URL и XPath:

* иерархия сущностей
   * URL - *иерархия каталогов и файлов*
   * XPath - *иерархия элементов и других узлов* XML-документа

* имя сущности
   * URL - файлы на каждом из уровней имеют *уникальные имена* (URL всегда идентифицирует один файл)
   * XPath - элементов на каждом уровне могут иметь *неуникальные имена* (шаблоны XPath соответствуют набору всех соответствующих элементов) 

* путь до сущности
   * URL - путь вычисляется *относительно конкретного каталога*, именуемого текущим каталогом
   * XPath - путь вычисляется *относительно конкретного узла*, в запросе именуемого контекстом

## Как работает XPath запрос?

Строка XPath описывает способ выбора нужных элементов из массива элементов, которые могут содержать вложенные элементы. 
Начинается отбор с переданного множества элементов, на каждом шаге пути отбираются элементы, соответствующие выражению шага, 
и в результате оказывается отобрано подмножество элементов, соответствующих данному пути.

При исполнении XPath-запроса всегда имеется так называемый контекст исполнения, то есть текущая ветка, относительно которой производится поиск. Это сходно с активным каталогом при выполнении команды CD файловой системы. Как контекст XPath-запроса может использоваться любой узел XML-документа. В XSLT контекстом для запроса является узел, в данный момент обрабатываемый элементами <xsl:template> или <xsl:for-each>. При использовании XPath непосредственно из DOM вы определяете контекст, выполняя запрос из конкретного узла.

Путь состоит из шагов адресации, которые разделяются символом **/** (косая черта).

Каждый шаг адресации состоит из трёх частей:

* ось (по умолчанию child::, ось элементов). 

Кроме отбора по оси вложенных элементов, можно отбирать разным другим осям элементов и по оси атрибутов (attribute::, она же обозначается символом @) (см. ниже).

* выражение, определяющее отбираемые элементы (в примере отбор делается по соответствию элементов документа именам html, body, span, и используется символ *, который отберёт все элементы оси)

* предикаты (в данном примере это attribute::class) - дополнительные условия отбора. Их может быть несколько. 

Каждый предикат заключается в квадратные скобки, и подразумевает логическое выражение для проверки отбираемых элементов. 
Если предиката нет, то отбираются все подходящие элементы.

XPath-путь 

```html
<html>
 <body>
    <div>Первый слой
      <span>блок текста в первом слое</span>
    </div>
    <div>Второй слой</div>
    <div>Третий слой
      <span class="text">первый блок в третьем слое</span>
      <span class="text">второй блок в третьем слое</span>
      <span>третий блок в третьем слое</span>
    </div>
    <span>четвёртый слой</span>
    <img />
 </body>
</html>
```

```xpath
/html/body/*/span[@class]
```

будет соответствовать в нём двум элементам исходного документа — 

<span class="text">

первый блок в третьем слое

</span> и <span class="text">

второй блок в третьем слое

</span>.

Элементы пути преимущественно пишутся в XPath в краткой форме. 
Полная форма приведённого выше пути имеет вид 

```xpath
/child::html/child::body/child::*/child::span[attribute::class]
```

Анализ пути ведётся слева направо, и начинается либо в контексте первого элемента корневого узла (в данном примере это элемент html), 
и тогда по оси child:: будут вложенные в него элементы (в данном примере это один элемент body), 
что удобно в случае обработки обычного XML-документа с одним корневым узлом, либо, если в начале XPath указан символ /, 
в контексте со всеми корневыми элементами переданого XML по оси child:: (в даном примере это будет один элемент html). 
На каждом шаге адресации в текущем контексте отбираются элементы, подходящие под указанные в шаге условия, 
и их перечень берётся как контекст для следующего шага или как возвращаемый результат.

Таким образом, первый шаг /child::html явным образом делает текущим контекстом для следующего шага перечень из одного элемента html, 
что было бы и так сделано неявно, если этот шаг не был обозначен.

На втором шаге адресации в данном примере (шаг child::body) контекстом является перечень из одного элемента html. 
Ось child:: говорит о том, что необходимо смотреть на имена вложенных элементов в текущем контексте, 
а условие проверки body говорит о том, что в формируемый набор элементов нужно включить те узлы, у которых имя body. 
Таким образом, в ходе второго шага адресации получаем набор узлов, состоящий всего из одного элемента body, 
который и становится контекстом для третьего шага.

Третий шаг адресации: child::* . Ось child:: содержит всех непосредственных потомков элемента body, 
а условие проверки * говорит о том, что в формируемый перечень нужно включить элементы основного типа с любым именем. 
В ходе этого шага получаем перечень, состоящий из трёх элементов div, одного span и одного элемента img — итого, пять элементов.

Четвёртый шаг адресации: child::span/@class. Его контекстом является перечень из пяти элементов, 
поэтому исходящий перечень создаётся в пять проходов (за пять итераций). 
При первой итерации узлом контекста становится первый div. Согласно заданной оси child:: и правилу проверки span, 
в набор должны включаться непосредственные потомки этого div-а, имя которых равно span. 
Там такой один. При второй итерации в набор ничего добавляться не будет, так как у второго div нет потомков. 
Третья итерация увидит сразу три элемента span. 
Четвёртая ничего не увидит, так как у элемента span нет потомков span, а то что он сам span — не важно, 
ведь просматриваются именно потомки. Пятая тоже ничего не увидит, у элемента img тоже нет потомков span. 
Итак, в ходе проверки мог бы быть получен набор узлов, состоящий из четырёх элементов span. 
Это и было бы контекстом для последующей обработки, не будь на этом шаге указано предиката.

Но так как предикат на четвёртом шаге есть, по мере выполнения каждого из пяти проходов 
будет производиться дополнительная фильтрация отбираемых элементов. 
В данном случае у предиката ось attribute:: говорит о необходимости проверить, есть ли у отбираемого узла атрибуты, 
а условие class требует оставить лишь те узлы, у которых задан атрибут с именем class. 
И поэтому на первой итерации единственный найденный span фильтрацию предикатом не пройдёт, 
на третьей итерации фильтрацию пройдут два элемента из трёх, и в итоге, несмотря на то, 
что фильтрация происходит за пять итераций, в окончательный набор попадают только два элемента span.

## Выражения XPath

Выражения XPath создаются с помощью операторов и специальных символов

XPath использует выражения пути для выбора отдельных узлов или набора узлов в документе XML. Эти выражения очень похожи на выражения, которые вы видите, когда работаете с традиционной файловой системой компьютера.



## Узлы

В XPath существует семь видов узлов: 
элемент, 
атрибут, 
текст, 
пространство имён, 
инструкции обработки, 
комментарии и узлы документа. 

XML-документы обрабатываются в виде деревьев узлов. 
Верхний элемент дерева называется корневым элементом. 
Посмотрите на следующий документ XML:

<?xml version="1.0" encoding="UTF-8"?>
<bookstore>
    <book>
        <title lang="en">Harry Potter</title>
        <author>J. K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
</bookstore>

Пример узлов в документе XML выше:

<bookstore> (корневой элемент)
<author>J. K. Rowling</author> (узел)
lang="en" (атрибут)

Атомарные значения
Атомарные значения являются узлами, не имеющие детей или родителей. Пример атомарных значений:

J. K. Rowling
"en"
Элементы
Элементы – это атомарные значения или узлы.

### Отношения узлов

Родитель

Каждый элемент и атрибут имеет одного родителя. В следующем примере элемент «книга» (book) является родителем элементов «название» (title), «автор» (author), «год» (year) и «цена» (price):

<book>
    <title>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
</book>

Потомки

Узлы элементов могут иметь ноль, один или более потомков. В следующем примере элементы «название», «автор», «год» и «цена» – они все потомки элемента книга:

<book>
    <title>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
</book>

Элементы одного уровня

Это узлы, которые имеют одного и того же родителя. В следующем примере элементы «название», «автор», «год» и «цена» все являются элементами одного уровня:

<book>
    <title>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
</book>

Предки

Родитель узла, родитель родителя узла и т.д. В следующем примере предки элемента «название» (title) – это элементы «книга» (book) и «книжный магазин» (bookstore):

<bookstore>
    <book>
        <title>Harry Potter</title>
        <author>J K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
</bookstore>

Потомки

Дети узла, дети детей узла и т.д. В следующем примере потомками элемента «книжный магазин» являются элементы «книга», «название», «автор», «год» и «цена»:

<bookstore> 
    <book> 
        <title>Harry Potter</title>
        <author>J K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
</bookstore>

### Выбор узлов

С помощью выражений XPath для выбора узлов в документе XML можно выбрать узел, следуя пути или шагам.

Выбор неизвестных узлов
Специальные символы XPath могут использоваться для выбора неизвестных XML узлов.

В приведённой ниже таблице мы перечислили некоторые пути выражения и результаты выражений:

Выбор нескольких путей
С помощью оператора | в выражениях XPath вы можете выбрать несколько путей. В таблице ниже перечислены несколько выражений путей и результаты их применения:


## Оси XPath

***Оси*** — база языка XPath. 

Для некоторых осей существуют сокращённые обозначения.

child:: — содержит множество элементов-потомков (элементов, расположенных на один уровень ниже). Это название сокращается полностью, то есть его можно вовсе опускать.
descendant:: — содержит полное множество элементов-потомков (то есть, как ближайших элементов-потомков, так и всех их элементов-потомков).
descendant-or-self:: — содержит полное множество элементов-потомков и текущий элемент. Выражение /descendant-or-self::node()/ можно сокращать до //. С помощью этой оси, например, можно вторым шагом организовать отбор элементов с любого узла, а не только с корневого: достаточно первым шагом взять всех потомков корневого. Например, путь //span отберёт все узлы span документа, независимо от их положения в иерархии, взглянув как на имя корневого, так и на имена всех его дочерних элементов, на всю глубину их вложенности.
ancestor:: — содержит множество элементов-предков.
ancestor-or-self:: — содержит множество элементов-предков и текущий элемент.
parent:: — содержит элемент-предок на один уровень назад. Это обращение можно заменить на ..
self:: — содержит текущий элемент. Это обращение можно заменить на .
following:: — содержит множество элементов, расположенных ниже текущего элемента по дереву (на всех уровнях и слоях), исключая собственных потомков.
following-sibling:: — содержит множество братских элементов того же уровня, следующих за текущим слоем.
preceding:: — содержит множество элементов, расположенных выше текущего элемента по дереву (на всех уровнях и слоях), исключая множество собственных предков.
preceding-sibling:: — содержит множество братских элементов того же уровня, предшествующих текущему слою.
attribute:: — содержит множество атрибутов текущего элемента. Это обращение можно заменить на символ @
namespace:: — содержит множество элементов, относящихся к тому или иному пространству имён (то есть присутствует атрибут xmlns).


В рамках содержимого оси отбор выполняется согласно выражению, определяющему отбираемые элементы.

В качестве выражения может быть

указано конкретное имя, тогда отбираются элементы оси, соответствующие этому имени
указан символ *, что отберёт все элементы оси
указано выражение, составленное из функций, и тогда будут отобраны результаты вычисления выражения в контексте каждого элемента оси

## Предикаты

***Предикаты*** - логические выражения в квадратных скобках, составленные по тем же принципам, что и выражение отбора. 

Выражения, возвращающие не логическое значение, а пустой набор элементов, считаются **ложными**. 

Выражение, возвращающее число, считается выражением, сравнивающим число с **position()**. 
Когда предикатов более одного, каждый из них фильтрует результаты фильтрации предыдущим предикатом.

Предикаты используются для поиска специфического узла или узла, который содержит специфическое значение. 
Предикаты всегда обрамляются квадратными скобками. 

## Операторы

Выражения XPath возвращают как набор узлов, строки, булевы или числовые значения. Ниже представлен список операторов, используемых в выражениях XPath:

| Оператор | Значение |
|----------|----------|
| / |  Выбирает дочерние элементы коллекции, находящейся слева от него. При использовании в начале шаблона означает поиск от корневого элемента. |
| // | Рекурсивный спуск; ищет указанный элемент на любой глубине. При использовании в начале шаблона означает рекурсивный поиск от корневого элемента. |
| . | Текущий контекст. |
| * | Wildcard, выбирает все элементы, независимо от имени. |
| @ | Атрибут; префикс имени атрибута. При использовании без имени атрибута выбирает все атрибуты, независимо от их имени. |
| : | Сепаратор пространств имен. Отделяет префикс пространства имен от имени элемента или атрибута. |
| ( ) | Группирует операции для явного задания очередности. |
| [ ] | 1. Накладывает фильтр. 2. Используется для индексации коллекции. |
| |	  |Вычисляет два набора узлов	 |

Числовые операторы

| Оператор | Значение |
|----------|----------|
| +	| сложение |
|  −| вычитание |
| *	| умножение |
| div | обычное деление (не нацело!) |
| mod | остаток от деления |

Логические операторы

| Оператор | Значение |
|----------|----------|
| or	   | логическое «или» |
| and	   | логическое «и» |
| =	| логическое «равно» |
| !=	| Неравенство	price!=9.80 |
| < | 	логическое «меньше» |
| <= | 	логическое «меньше либо равно» |
| > | 	логическое «больше» |
| >= | логическое «больше либо равно» |

## Функции

XPath включает в себя более 100 встроенных функций. 
Есть функции для строковых и числовых значений, даты и времени, сравнения узлов и манипулирования QName, управления последовательностями, булевых значений, и многое другое.

Функции делятся на 5 групп:

* функции над множеством узлов
* строковые функции
* логические функции
* числовые функции
* системные функции

### Функции над множествами узлов

| Тип      | Функция                  | Описание                                                          |
|----------|--------------------------|-------------------------------------------------------------------|
| node-set | node()                   | Возвращает сам узел                                               |
| string   | text()	                  | Возвращает узел, если он текстовый                                |
| node-set | current()                | Возвращает множество из одного элемента, который является текущим |
| number   | position()               | Возвращает позицию элемента в множестве элементов оси             |
| number   | last()                   | Возвращает номер последнего элемента в множестве элементов оси    |
| number   | count(node-set)          | Возвращает количество элементов в node-set.                       |
| string   | name(node-set?)          | Возвращает полное имя первого тега в множестве                    |
| string   | namespace-url(node-set?) | Возвращает ссылку на URL, определяющий пространство имён          |
| string   | local-name(node-set?)    | Возвращает имя первого тега в множестве, без пространства имён    |
| node-set | id(object)               | Находит элемент с уникальным идентификатором                      |

Вместо функции **node()** часто используют заменитель *, но, в отличие от звёздочки, функция **node()** возвращает и текстовые узлы.

Функция **current()** при обработке множества с предикатами, является единственным способом дотянуться из предиката до текущего элемента.

Функции **position()** и **last()** корректно работают только в цикле **<xsl:for-each/>**.

### Строковые функции

| Тип     | Функция                            | Описание |
|---------|------------------------------------|----------|
| string  | string(object?)	                   | Возвращает текстовое содержимое элемента. По сути, возвращает объединённое множество текстовых элементов на один уровень ниже |
| string  | concat(string, string, string*)	   | Соединяет строки, указанные в аргументах |
| number  | string-length(string?)	           | Возвращает длину строки |
| boolean | contains(string, string)	       | Возвращает true, если первая строка содержит вторую, иначе — false |
| string  | substring(string, number, number?) | Возвращает строку, вырезанную из строки, начиная с указанного номера, и, если указан второй номер, — количество символов |
| string  | substring-before(string, string)   | Если найдена вторая строка в первой, возвращает строку до первого вхождения второй строки |
| string  | substring-after(string, string)	   | Если найдена вторая строка в первой, возвращает строку после первого вхождения второй строки |
| boolean | starts-with(string, string)	       | Возвращает true, если вторая строка входит в начало первой, иначе — false |
| boolean | ends-with(string, string)	       | Возвращает true, если вторая строка входит в конец первой, иначе — false |
| string  | normalize-space(string?)	       | Убирает лишние и повторные пробелы, а также управляющие символы, заменяя их пробелами |
| string  | translate(string, string, string)  | Заменяет символы первой строки, которые встречаются во второй строке, на соответствующие позиции символам из второй строки символы из третьей строки.  |

Например, translate("bar", "abc", "ABC") вернёт BAr.

### Логические функции 

| Тип     | Функция | Описание |
|---------|----------|----------|
| boolean | boolean(object)	| Приводит объект к логическому типу
| boolean | true()	| Возвращает истину
| boolean | false()	| Возвращает ложь
| boolean | not(boolean)	| Отрицание, возвращает истину если аргумент ложь и наоборот

### Числовые функции 

| Тип     | Функция | Описание |
|---------|----------|----------|
| number | number(object?)	| Переводит объект в число |
| number | sum(node-set)	| Вернёт сумму множества. Каждый тег множества будет преобразован в строку и из него получено число |
| number | floor(number)	| Возвращает наибольшее целое число, не большее, чем аргумент (округление к меньшему) |
| number | ceiling(number)	| Возвращает наименьшее целое число, не меньшее, чем аргумент (округление к большему) |
| number | round(number)	| Округляет число по математическим правилам |

### Системные функции

| Тип     | Функция | Описание |
|---------|----------|----------|
| node-set | document(object, node-set?)	| Возвращает документ, указанный в параметре object |
| string | format-number(number, string, string?)	| Форматирует число согласно образцу, указанному во втором параметре. Третий параметр указывает именованный формат числа, который должен быть учтён |
| string | generate-id(node-set?)	| Возвращает строку, являющуюся уникальным идентификатором |
| node-set | key(string, object)	| Возвращает множество с указанным ключом (аналогично функции id для идентификаторов) |
| string | unparsed-entity-uri(string)	| Возвращает непроанализированный URI. Если такового нет, возвращает пустую строку |
| boolean | element-available(string)	| Проверяет, доступен ли элемент или множество, указанное в параметре. Параметр рассматривается как XPath |
| boolean | function-available(string)	| Проверяет, доступна ли функция, указанная в параметре. Параметр рассматривается как XPath |
| object | system-property(string)	| Параметры, возвращающие системные переменные. Могут быть: |
| | xsl: version — возвращает версию XSLT процессора. |
| | xsl: vendor — возвращает производителя XSLT процессора. |
| | xsl: vendor-url — возвращает URL, идентифицирующий производителя. |
| | Если используется неизвестный параметр, функция возвращает пустую строку |
| boolean | lang(string)	| Возвращает true, если у текущего тега имеется атрибут xml: lang, либо родитель тега имеет атрибут xml: lang и в нём указан совпадающий строке символ |


## Правила

Итак, несколько правил использования xpath:

Никогда не используй плагины или копирование xpath из кода страницы средствами браузера или веб-разработчика. Вот например как показывает одну ссылку плагин к Файрфокс: //header/div/ul/li[2]/a . Разве из этой ссылки понятно, о каком элементе речь, что мы ищем? Ведь порой бывает, что взглянув на локатор  в коде или в тексте исключения мы должны понять о каком элементе речь. Как это можно понять из такой строки? Я уже не говорю о том, что любой код, основанный на таких локаторах упадет при любом дуновении ветерка. Каждый раз, когда ты пишешь локатор подобный  //div[1]/div[2]/ul/li (продолжать можно долго) в мире умирает что-то хорошее!!! Это, если хотите, говнокод тестировщика, который нужно выжигать каленым железом.
Старайся написать xpath как можно короче и понятнее, используй его возможности и схожесть с языком программирования, чтобы и через месяц ты сам мог понять о каком элементе речь и что нужно поправить в случае изменения верстки
Xpath’у время и место! Если есть возможность использовать id, name или попросить разработчиков внести в код id то сделай это!
Вместо длинной цепочки слешей, как указано выше, используй отношения элементов: предок, потомок, сестринский элемент
Можно и нужно использовать логические операции and, not , or
Нормальный xpath всегда начинается с // и не использует фильтры с номером элемента в стиле [2] (например //div[2])