# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 1. CSS

[![Назад](https://img.shields.io/badge/-%D0%9D%D0%B0%D0%B7%D0%B0%D0%B4-brightgreen)](1.%20Лекция.md)

***

## 1. Что такое XML?



## 2. Что такое HTML?

***HTML (HyperText Markup Language)*** — стандартизированный язык разметки веб-страниц во Всемирной паутине. 
Код *HTML* интерпретируется браузерами; полученная в результате интерпретации страница отображается 
на экране монитора компьютера или мобильного устройства.

Язык *HTML* до 5-й версии определялся как приложение *SGML* (стандартного обобщённого языка разметки по стандарту ISO 8879). 
Спецификации *HTML5* формулируются в терминах *DOM* (объектной модели документа).
Строгим вариантом *HTML* является *XHTML*, он наследует синтаксис *XML* и является приложением языка *XML*в области разметки гипертекста.

*HTML*, как и *XML* имеет древовидную структуру. 
В документе всегда имеется один корневой элемент, содержащий ряд вложенных элементов, 
некоторые из которых тоже могут содержать вложенные элементы. 
Так же могут встречаться текстовые узлы, комментарии и инструкции. 
Можно считать, что XML-элемент содержит массив вложенных в него элементов и массив атрибутов.

У элементов дерева бывают **элементы-предки** и **элементы-потомки**.
У корневого элемента предков нет, а у тупиковых элементов (листьев дерева) нет потомков. 
Каждый элемент дерева находится на определённом уровне вложенности (далее — **уровень**). 
Элементы упорядочены в порядке расположения в тексте *XML*, и поэтому можно говорить об их предыдущих и следующих элементах. 
Это очень похоже на организацию каталогов в файловой системе.

## 3. Что такое XPath?

***XPath (XML Path Language)*** — язык запросов к элементам XML-документа. 
Разработан для организации доступа к частям документа *XML* в файлах трансформации *XSLT* и является стандартом консорциума *W3C*. 
*XPath* призван реализовать навигацию по *DOM* в *XML*. 

В *XPath* используется компактный синтаксис, отличный от принятого в *XML*. 
Так же как и *SQL*, *XPath* является декларативным языком запросов. 
Чтобы получить нужные данные, необходимо всего лишь создать запрос, описывающий эти данные. 
Всю "чёрную" работу за вас выполнит интерпретатор языка xpath.

## 4. Синтаксис XPath

XML-документы представляют собой иерархию, или дерево узлов, в чем-то схожее с иерархией каталогов и файлов в файловой системе. 
Этим и объясняется сходство синтаксиса URL и XPath:

* иерархия сущностей
   * URL - *иерархия каталогов и файлов*
   * XPath - *иерархия элементов и других узлов* XML-документа

* имя сущности
   * URL - файлы на каждом из уровней имеют *уникальные имена* (URL всегда идентифицирует один файл)
   * XPath - элементов на каждом уровне могут иметь *неуникальные имена* (шаблоны XPath соответствуют набору всех соответствующих элементов) 

* путь до сущности
   * URL - путь вычисляется *относительно конкретного каталога*, именуемого текущим каталогом
   * XPath - путь вычисляется *относительно конкретного узла*, в запросе именуемого контекстом

Терминология XPath:

* узлы
* оси

## 5. Узлы

XML-документы обрабатываются в виде деревьев узлов.
Весь документ представляет собой узел документа.

В XPath существует семь видов узлов: 

* элемент
* атрибут элемента
* текстовое содержимое элемента
* пространство имён
* инструкции обработки
* комментарии и узлы документа

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore>
    <book>
        <!-- Книга Гарри Поттер -->
        <title lang="en">Harry Potter</title>
        <author>J. K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
        <publisher />
    </book>
</bookstore>
```

Пример узлов в документе XML выше:

* *<bookstore>* - корневой элемент
* *<author>J. K. Rowling</author>* - элемент
* *lang="en"* - атрибут элемента
* *J. K. Rowling* - текстовое содержимое элемента 
* *xmlns="namespace"* - пространство имён 
* *<?Processing detail="2"?>* - инструкции обработки  
* *<!-- Книга Гарри Поттер -->* - комментарий

### 5.1. Элемент

***Элемент*** - базовый строительный блок XML (не может быть XML документа без элементов (тэгов)).

Границы элемента задаются 2 способами:

* начальным и конечным тегом (текст межу тегами называется содержанием элемента)

```xml
<title lang="en">Harry Potter</title>
<author>J. K. Rowling</author>
<year>2005</year>
<price>29.99</price>
<publisher />
```

* тегом пустого элемента (пустой элемент не имеет содержания)

```xml
<book />
```

Вместо пустого элемента можно использовать эквивалентную ему запись начального и конечного тега: 

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore>
    <book><!-- Элемент -->
    ...
    </book>
</bookstore>
```

Обычно элементы имеют потомков, которыми являются другие элементы, текстовые узлы или их комбинация.
Элементные узлы также являются единственным типом узлов, имеющим атрибуты.

### 5.2. Корневой элемент

***Корневой элемент*** - верхний элемент дерева.

Это тег, с которого документ начинается, и им заканчивается.

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore><!-- Корневой элемент -->
...
</bookstore>
```

### 5.3. Атрибут элемента

***Атрибут элемента*** - характеристики элемента.

Атрибуты содержат информацию об элементном узле, но не рассматриваются как потомки элемента.

```xml
<book id="num-582" year="2010"><!-- Атрибуты элемента: id и year -->
```

Атрибуты могут применяться либо в начальном теге, либо в теге пустого элемента.
Элемент может не иметь атрибутов или иметь любое их количество.

Следует иметь в виду, что каких-либо правил относительно того, какую информацию задавать в виде элемента, а какую в виде атрибута нет.

Использовать или не использовать атрибуты, если использовать, то как – это при создании корректного XML документа определяет его разработчик, 
а при создании действительного XML документа должно быть задано в его схеме.

### 5.4. Текстовое содержимое элемента

***Текстовое содержимое элемента*** - текст, расположенный внутри элементов между открывающими и закрывающими тегами

Эквивалентно тексту объектной модели документов (DOM) и типам узлов CDATA. Содержит, по крайней мере, один символ.

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?>
<bookstore>
    <book>
        <!-- Книга Гарри Поттер -->
        <title lang="en">Harry Potter</title><!-- Текстовое содержимое: Harry Potter -->
        <author>J. K. Rowling</author><!-- Текстовое содержимое: J. K. Rowling -->
        <year>2005</year><!-- Текстовое содержимое: 2005 -->
        <price>29.99</price><!-- Текстовое содержимое: 29.99 -->
        <publisher />
    </book>
</bookstore>
```

### 5.5. Пространства имен

***Пространства имен*** - пространства имен являются зонами, в которых все имена должны быть уникальны.

Кроме атрибутов, в начальный тег элемента могут быть включены объявления пространств имен.

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?><!-- Пространства имен: xmlns="namespace" -->
<?Processing detail="2"?>
<bookstore>
...
</bookstore>
```

Поддержка пространств имен позволяет разработчикам использовать информацию из разных источников или в разных целях без конфликтов.

### 5.6. Инструкция обработки

***Инструкция обработки (PI)*** – информация, специально адресованная приложению для передачи определенных указаний обработчику XML документа.

Инструкция обработки всегда должна обрамляться символами *\<?* и *?\>* и иметь следующий формат: *\<?код содержание?\>*, где:

* код – имя, идентифицирующее приложение, которому предназначена инструкция
* cодержание – текст, который передается приложению для обработки

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
<?Processing detail="2"?><!-- Инструкция обработки: ?Processing detail="2"? -->
<bookstore>
  ...
</bookstore>
```

Обработчик XML документа, принимая такую инструкцию, должен знать, что с ней делать.
Возможный набор допустимых инструкций обработки не определяется в Рекомендации XML и зависит от используемого обработчика XML документа.

Рекомендация XML зарезервировала имена **xml** и **XML** для собственных нужд, поэтому они не могут принимать значение кода инструкции обработки.

```xml
<?xml version="1.0" xmlns="namespace" encoding="UTF-8"?>
```

### 5.7. Комментарии

***Комментарии*** - информация о данных (обычно игнорируются приложением).

Текст комментария должен заключаться между символами *\<!--* и *--\>*:

```xml
<!-- Книга Гарри Поттер -->
```

### 5.8. Атомарные значения

***Атомарные значения*** - узлы, не имеющие детей или родителей. 

Пример атомарных значений:

* *lang="en"* - атрибут
* *J. K. Rowling* - текстовое содержимое узла

## 6. Отношения узлов

### 6.1. Родители (Parent)

***Родители*** - узлы, которые вмещают в себя другие узлы (**дети**).

Каждый элемент и атрибут имеет одного родителя. 

```xml
<book><!-- Родитель элементов: title, author, year и price -->
    <title>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
</book>
```

### 6.2. Дети (Child)

***Дети*** - узлы, которые содержатся внутри других узлов (**родители**).

Узлы элементов могут иметь ноль, один или более дочерних узлов. 

```xml
<book>
    <title>Harry Potter</title><!-- Дети элемента book -->
    <author>J K. Rowling</author><!-- Дети элемента book -->
    <year>2005</year><!-- Дети элемента book -->
    <price>29.99</price><!-- Дети элемента book -->
</book>
```

### 6.3. Узлы одного уровня

***Узлы одного уровня*** - узлы, которые имеют одного и того же родителя. 

```xml
<book>
    <title>Harry Potter</title><!-- Узлы одного уровня -->
    <author>J K. Rowling</author><!-- Узлы одного уровня -->
    <year>2005</year><!-- Узлы одного уровня -->
    <price>29.99</price><!-- Узлы одного уровня -->
</book>
```

### 6.4. Предки (Ancestor)

***Предки*** - все узлы начиная от родителя, которые вмещают себя данный узел (родитель узла, родитель родителя узла и т.д.).

```xml
<bookstore><!-- Предки элементов title, author, year, price -->
    <book><!-- Предки элементов title, author, year, price -->
        <title>Harry Potter</title>
        <author>J K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
</bookstore>
```

### 6.5. Потомки (Descendant)

***Потомки*** - все узлы начиная от первого вложенного и далее (дети узла, дети детей узла и т.д.).

```xml
<bookstore> 
    <book> 
        <title>Harry Potter</title><!-- Потомки элемента book и bookstore -->
        <author>J K. Rowling</author><!-- Потомки элемента book и bookstore -->
        <year>2005</year><!-- Потомки элемента book и bookstore -->
        <price>29.99</price><!-- Потомки элемента book и bookstore -->
    </book>
</bookstore>
```

## 7. Оси XPath

***Оси*** — функция перемещения по дереву узлов.

**Оси** являются базой языка XPath. 

| Ось                  | Значение                                                                                                                                                       |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| child::              | содержит множество элементов-потомков (элементов, расположенных на один уровень ниже).<br>Это название сокращается полностью, то есть его можно вовсе опускать.|
| descendant::         | содержит полное множество элементов-потомков (то есть, как ближайших элементов-потомков, так и всех их элементов-потомков).                                    |
| descendant-or-self:: | содержит полное множество элементов-потомков и текущий элемент.<br>Выражение */descendant-or-self::node()/* можно сокращать до *//*.                           |
| ancestor::           | содержит множество элементов-предков.                                                                                                                          |
| ancestor-or-self::   | содержит множество элементов-предков и текущий элемент.                                                                                                        |
| parent::             | содержит элемент-предок на один уровень назад.<br>Это обращение можно заменить на *..*.                                                                        |
| self::               | содержит текущий элемент.<br>Это обращение можно заменить на *.*.                                                                                              |
| following::          | содержит множество элементов, расположенных ниже текущего элемента по дереву (на всех уровнях и слоях), исключая собственных потомков.                         |
| following-sibling::  | содержит множество братских элементов того же уровня, следующих за текущим слоем.                                                                              |
| preceding::          | содержит множество элементов, расположенных выше текущего элемента по дереву (на всех уровнях и слоях), исключая множество собственных предков.                |
| preceding-sibling::  | содержит множество братских элементов того же уровня, предшествующих текущему слою.                                                                            |
| attribute::          | содержит множество атрибутов текущего элемента.                                                                |
| namespace::          | содержит множество элементов, относящихся к тому или иному пространству имён (то есть присутствует атрибут *xmlns*).                                           |

Для некоторых осей существуют сокращённые обозначения.

| Ось                  | Сокращение                                                             |
|----------------------|------------------------------------------------------------------------|
| child::              | Это обращение сокращается полностью, то есть его можно вовсе опускать. |
| descendant-or-self:: | Это обращение можно заменить на *//*.                                  |
| parent::             | Это обращение можно заменить на *..*.                                  |
| self::               | Это обращение можно заменить на *.*.                                   |
| attribute::          | Это обращение можно заменить на *@*.                                   |

## 8. Выражения XPath

В рамках содержимого оси отбор выполняется согласно выражению, определяющему отбираемые элементы.
XPath использует выражения для выбора отдельных узлов или набора узлов в документе XML.
С помощью выражений XPath для выбора узлов в документе XML можно выбрать узел, следуя пути или шагам.

В качестве выражения может быть указано:

* конкретное имя, тогда отбираются элементы оси, соответствующие этому имени
* символ *, что отберёт все элементы оси
* выражение, составленное из функций, и тогда будут отобраны результаты вычисления выражения в контексте каждого элемента оси

Эти выражения очень похожи на выражения, которые вы видите, когда работаете с традиционной файловой системой компьютера.

Выражения XPath возвращают как набор узлов, строки, булевы или числовые значения.

### 8.1. Операторы

#### Операторы поиска

| Оператор | Значение                                                                                                                                                  |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| /        | Получение дочерних элементов коллекции, находящейся слева от него.<br>При использовании в начале шаблона означает поиск от корневого элемента.            |
| //       | Поиск указанного элемента на любой глубине (*Рекурсивный спуск*).<br>При использовании в начале шаблона означает рекурсивный поиск от корневого элемента. |
| ..       | Получение элемента на один уровень вверх.                                                                                                                             |
| .        | Получение текущего контекста.                                                                                                                             |
| *        | Выбор всех элементов, независимо от имени (*Wildcard*).                                                                                                   |
| @        | Указание атрибута (*Префикс имени атрибута*).<br>При использовании без имени атрибута выбирает все атрибуты, независимо от их имени.                      |
| :        | Отделение префикса пространства имен от имени элемента или атрибута (*Сепаратор пространств имен*).                                                       |
| ( )      | Явное задание очередности (*Группировка операции*).                                                                                                       |
| [ ]      | 1. Фильтрация результатов поиска.<br>2. Индексация элементов коллекции.                                                                                   |
| &#124;   | Вычисление двух наборов узлов.	                                                                                                                           |

#### Числовые операторы

| Оператор | Значение             |
|----------|----------------------|
| +	       | Сложение             |
| −        | Вычитание            |
| *	       | Умножение            |
| div      | Деление (не нацело!) |
| mod      | Остаток от деления   |

#### Логические операторы

| Оператор | Значение                       |
|----------|--------------------------------|
| or	   | Логическое *ИЛИ*               |
| and	   | Логическое *И*                 |
| =	       | Логическое *Равно*             |
| !=	   | Логическое *Не Равно*          |
| <        | Логическое *Меньше*            |
| <=       | Логическое *Меньше либо Равно* |
| >        | Логическое *Больше*            |
| >=       | Логическое *Больше либо Равно* |

### 8.2. Функции

XPath включает в себя более 100 встроенных функций. 
Есть функции для строковых и числовых значений, даты и времени, сравнения узлов и манипулирования QName, управления последовательностями, булевых значений, и многое другое.

Функции делятся на 5 групп:

* функции над множеством узлов
* строковые функции
* логические функции
* числовые функции
* системные функции

#### Функции над множествами узлов

| Тип      | Функция                  | Описание                                                          |
|----------|--------------------------|-------------------------------------------------------------------|
| node-set | node()                   | Возвращает сам узел                                               |
| string   | text()	                  | Возвращает узел, если он текстовый                                |
| node-set | current()                | Возвращает множество из одного элемента, который является текущим |
| number   | position()               | Возвращает позицию элемента в множестве элементов оси             |
| number   | last()                   | Возвращает номер последнего элемента в множестве элементов оси    |
| number   | count(node-set)          | Возвращает количество элементов в node-set.                       |
| string   | name(node-set?)          | Возвращает полное имя первого тега в множестве                    |
| string   | namespace-url(node-set?) | Возвращает ссылку на URL, определяющий пространство имён          |
| string   | local-name(node-set?)    | Возвращает имя первого тега в множестве, без пространства имён    |
| node-set | id(object)               | Находит элемент с уникальным идентификатором                      |

Вместо функции **node()** часто используют заменитель *, но, в отличие от звёздочки, функция **node()** возвращает и текстовые узлы.

Функция **current()** при обработке множества с предикатами, является единственным способом дотянуться из предиката до текущего элемента.

Функции **position()** и **last()** корректно работают только в цикле **<xsl:for-each/>**.

#### Строковые функции

| Тип     | Функция                            | Описание                                                                                                                                              |
|---------|------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| string  | string(object?)	                   | Возвращает текстовое содержимое элемента.<br>По сути, возвращает объединённое множество текстовых элементов на один уровень ниже.                     |
| string  | concat(string, string, string*)	   | Соединяет строки, указанные в аргументах.                                                                                                             |
| number  | string-length(string?)	           | Возвращает длину строки.                                                                                                                              |
| boolean | contains(string, string)	       | Возвращает true, если первая строка содержит вторую, иначе — false.                                                                                   |
| string  | substring(string, number, number?) | Возвращает строку, вырезанную из строки, начиная с указанного номера, и, если указан второй номер, — количество символов.                             |
| string  | substring-before(string, string)   | Если найдена вторая строка в первой, возвращает строку до первого вхождения второй строки.                                                            |
| string  | substring-after(string, string)	   | Если найдена вторая строка в первой, возвращает строку после первого вхождения второй строки.                                                         |
| boolean | starts-with(string, string)	       | Возвращает true, если вторая строка входит в начало первой, иначе — false.                                                                            |
| boolean | ends-with(string, string)	       | Возвращает true, если вторая строка входит в конец первой, иначе — false.                                                                             |
| string  | normalize-space(string?)	       | Убирает лишние и повторные пробелы, а также управляющие символы, заменяя их пробелами.                                                                |
| string  | translate(string, string, string)  | Заменяет символы первой строки, которые встречаются во второй строке, на соответствующие позиции символам из второй строки символы из третьей строки. |

#### Логические функции 

| Тип     | Функция         | Описание                                                   |
|---------|-----------------|------------------------------------------------------------|
| boolean | boolean(object)	| Приводит объект к логическому типу                         |
| boolean | true()	        | Возвращает истину                                          |
| boolean | false()	        | Возвращает ложь                                            |
| boolean | not(boolean)	| Отрицание, возвращает истину если аргумент ложь и наоборот |

#### Числовые функции 

| Тип    | Функция         | Описание                                                                                              |
|--------|-----------------|-------------------------------------------------------------------------------------------------------|
| number | number(object?) | Переводит объект в число.                                                                             |
| number | sum(node-set)   | Вернёт сумму множества.<br>Каждый тег множества будет преобразован в строку и из него получено число. |
| number | floor(number)   | Возвращает наибольшее целое число, не большее, чем аргумент (округление к меньшему).                  |
| number | ceiling(number) | Возвращает наименьшее целое число, не меньшее, чем аргумент (округление к большему).                  |
| number | round(number)   | Округляет число по математическим правилам.                                                           |

#### Системные функции

| Тип      | Функция                                | Описание                                                                                                                                              |
|----------|----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| node-set | document(object, node-set?)	        | Возвращает документ, указанный в параметре object.                                                                                                    |
| string   | format-number(number, string, string?)	| Форматирует число согласно образцу, указанному во втором параметре.<br>Третий параметр указывает именованный формат числа, который должен быть учтён. |
| string   | generate-id(node-set?)	                | Возвращает строку, являющуюся уникальным идентификатором.                                                                                             |
| node-set | key(string, object)	                | Возвращает множество с указанным ключом (аналогично функции id для идентификаторов).                                                                  |
| string   | unparsed-entity-uri(string)	        | Возвращает непроанализированный URI.<br>Если такового нет, возвращает пустую строку.                                                                  |
| boolean  | element-available(string)	            | Проверяет, доступен ли элемент или множество, указанное в параметре.<br>Параметр рассматривается как XPath.                                           |
| boolean  | function-available(string)	            | Проверяет, доступна ли функция, указанная в параметре.<br>Параметр рассматривается как XPath.                                                         |
| object   | system-property(string)	            | Параметры, возвращающие системные переменные.                                                                                                         |
| boolean  | lang(string)	                        | Возвращает true, если у текущего тега есть атрибут *xml: lang*, или его родитель имеет атрибут *xml: lang* и в нём указан совпадающий строке символ.  |

В **system-property(string)** могут быть переданы следующие параметры: 

* *xsl: version* — возвращает версию XSLT процессора
* *xsl: vendor* — возвращает производителя XSLT процессора
* *xsl: vendor-url* —  возвращает URL, идентифицирующий производителя
* *неизвестный параметр* - возвращает пустую строку

## 9. Предикаты

***Предикаты*** - логические выражения в квадратных скобках, составленные по тем же принципам, что и выражение отбора.

Каждый предикат заключается в квадратные скобки, и подразумевает логическое выражение для проверки отбираемых элементов.

Выражения, возвращающие не логическое значение, а пустой набор элементов, считаются **ложными**.

Выражение, возвращающее число, считается выражением, сравнивающим число с **position()**.
Когда предикатов более одного, каждый из них фильтрует результаты фильтрации предыдущим предикатом.

Предикаты используются для поиска специфического узла или узла, который содержит специфическое значение.
Предикаты всегда обрамляются квадратными скобками.

## 10. Как работает XPath запрос?

Строка XPath описывает способ выбора нужных элементов из массива элементов, которые могут содержать вложенные элементы.
Начинается отбор с переданного множества элементов, на каждом шаге пути отбираются элементы, соответствующие выражению шага,
и в результате оказывается отобрано подмножество элементов, соответствующих данному пути.

При исполнении XPath-запроса всегда имеется так называемый контекст исполнения, то есть текущая ветка, относительно которой производится поиск. 
Это сходно с активным каталогом при выполнении команды CD файловой системы. Как контекст XPath-запроса может использоваться любой узел XML-документа. 
В *XSLT* контекстом для запроса является узел, в данный момент обрабатываемый элементами <xsl:template> или <xsl:for-each>. 
При использовании XPath непосредственно из *DOM* вы определяете контекст, выполняя запрос из конкретного узла.

Путь состоит из шагов адресации, которые разделяются символом **/** (косая черта).

Каждый шаг адресации состоит из трёх частей:

* *ось* (по умолчанию child::, ось элементов)

Кроме отбора по оси вложенных элементов, можно отбирать разным другим осям элементов и по оси атрибутов (attribute::, она же обозначается символом @).

* *выражение* - определяющее отбираемые элементы 
  
* *предикаты* - дополнительные условия отбора (их может быть несколько)

Если предиката нет, то отбираются все подходящие элементы.

Пример HTML документа:

```html
<html>
 <body>
    <div>Первый слой
      <span>блок текста в первом слое</span>
    </div>
    <div>Второй слой</div>
    <div>Третий слой
      <span class="text">первый блок в третьем слое</span>
      <span class="text">второй блок в третьем слое</span>
      <span>третий блок в третьем слое</span>
    </div>
    <span>Четвёртый слой</span>
    <img />
 </body>
</html>
```

XPath-путь:

```xpath
/html/body/*/span[@class]
```

будет соответствовать в нём двум элементам исходного документа:

* первый блок в третьем слое 

```html
<span class="text">первый блок в третьем слое</span>
```
* второй блок в третьем слое

```html
<span class="text">второй блок в третьем слое</span>
```

Элементы пути преимущественно пишутся в XPath в краткой форме.
Полная форма приведённого выше пути имеет вид

```xpath
/child::html/child::body/child::*/child::span[attribute::class]
```

Анализ пути ведётся слева направо, и начинается либо в контексте первого элемента корневого узла (в данном примере это элемент *html*),
и тогда по оси *child::* будут вложенные в него элементы (в данном примере это один элемент body).
Это удобно в случае обработки обычного XML-документа с одним корневым узлом, либо, если в начале XPath указан символ */*,
в контексте со всеми корневыми элементами переданого XML по оси *child::* (в даном примере это будет один элемент *html*).

На каждом шаге адресации в текущем контексте отбираются элементы, подходящие под указанные в шаге условия,
и их перечень берётся как контекст для следующего шага или как возвращаемый результат.

Таким образом 

* первый шаг 

```xpath  
/child::html
```

Явным образом задается текущим контекстом для следующего шага перечень из одного элемента *html*,
что было бы и так сделано неявно, если этот шаг не был обозначен

* второй шаг 

```xpath  
/child::body
```  
 
Контекстом является перечень из одного элемента *html*.
Ось *child::* говорит о том, что необходимо смотреть на имена вложенных элементов в текущем контексте,
а условие проверки *body* говорит о том, что в формируемый набор элементов нужно включить те узлы, у которых имя *body*.
Таким образом, в ходе второго шага адресации получаем набор узлов, состоящий всего из одного элемента *body*,
который и становится контекстом для третьего шага.

* третий шаг

```xpath  
/child::*
```
Ось *child::* содержит всех непосредственных потомков элемента *body*,
а условие проверки * говорит о том, что в формируемый перечень нужно включить элементы основного типа с любым именем.
В ходе этого шага получаем перечень, состоящий из трёх элементов *div*, одного *span* и одного элемента *img* — итого, пять элементов.

* четвёртый шаг 

```xpath  
child::span/@class. 
```

Его контекстом является *перечень из пяти элементов*, поэтому исходящий перечень создаётся в пять проходов (за пять итераций)^

  * первая итерация 
    
Узлом контекста становится первый *div*. Согласно заданной оси *child::* и правилу проверки *span*,
в набор должны включаться непосредственные потомки этого *div*, имя которых равно *span*.
Там такой один. 

  * второй итерации 
    
В набор ничего добавляться не будет, так как у второго *div* нет потомков.

  * третья итерация 

В набор попадут сразу три элемента *span*.

  * четвёртая итерация
    
Ничего не увидит, так как у элемента *span* нет потомков *span*, а то что он сам *span* — не важно, ведь просматриваются именно потомки. 

  * пятая итерация
    
Тоже ничего не увидит, у элемента *img* тоже нет потомков *span*.

Итак, в ходе проверки мог бы быть получен набор узлов, состоящий из четырёх элементов *span*.
Это и было бы контекстом для последующей обработки, не будь на этом шаге указано предиката.

Но так как предикат на четвёртом шаге есть, по мере выполнения каждого из пяти проходов будет производиться дополнительная фильтрация отбираемых элементов.
В данном случае у предиката ось *attribute::* говорит о необходимости проверить, есть ли у отбираемого узла атрибуты,
а условие *class* требует оставить лишь те узлы, у которых задан атрибут с именем *class*.
И поэтому на первой итерации единственный найденный *span* фильтрацию предикатом не пройдёт,
на третьей итерации фильтрацию пройдут два элемента из трёх.

И в итоге, несмотря на то, что фильтрация происходит за пять итераций, в окончательный набор попадают только два элемента *span*.

## 11. Правила

Итак, несколько правил использования xpath:

Никогда не используй плагины или копирование xpath из кода страницы средствами браузера или веб-разработчика. 
Вот например как показывает одну ссылку плагин к Файрфокс: //header/div/ul/li[2]/a . 
Разве из этой ссылки понятно, о каком элементе речь, что мы ищем? Ведь порой бывает, что взглянув на локатор  в коде или в тексте исключения мы должны понять о каком элементе речь. 
Как это можно понять из такой строки? Я уже не говорю о том, что любой код, основанный на таких локаторах упадет при любом дуновении ветерка. 
Каждый раз, когда ты пишешь локатор подобный  //div[1]/div[2]/ul/li (продолжать можно долго) в мире умирает что-то хорошее!!! 
Это, если хотите, говнокод тестировщика, который нужно выжигать каленым железом.

Старайся написать xpath как можно короче и понятнее, используй его возможности и схожесть с языком программирования, 
чтобы и через месяц ты сам мог понять о каком элементе речь и что нужно поправить в случае изменения верстки

Xpath’у время и место! Если есть возможность использовать id, name или попросить разработчиков внести в код id то сделай это!

Вместо длинной цепочки слешей, как указано выше, используй отношения элементов: предок, потомок, сестринский элемент

Можно и нужно использовать логические операции and, not , or

Нормальный xpath всегда начинается с // и не использует фильтры с номером элемента в стиле [2] (например //div[2])