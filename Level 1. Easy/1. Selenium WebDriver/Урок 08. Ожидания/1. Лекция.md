# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 08. Ожидания

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

## 1. Загрузка страницы

### 1.1. Поэтапный процесс загрузки веб страниц сайтов в браузере

Этапы загрузки веб страниц:

0). Пользователь открывает нужную страницу сайта в браузере (URL).

1). Обработка запросов к DNS-серверу. 

Запрос к хосту, на котором размешен сайт со всеми файлами и папками.

***DNS (Domain Name System)*** — система доменных имён, компьютерная распределённая система для получения информации о доменах. 
Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), 
получения информации о маршрутизации почты, обслуживающих узлах для протоколов в домене (SRV-запись).

***DNS-сервер (name server)*** — приложение, предназначенное для ответов на DNS-запросы по соответствующему протоколу. 
Также DNS-сервером могут называть хост, на котором запущено приложение.»

2). Обработка редиректов.

Время, которое будет потрачено на отработку HTTP-переадресации при загрузке страницы.

3). Подключение к серверу. 

Время, в течение которого браузер ожидает подключения к HTTP-серверу при получении содержимого страницы.

4). Ответ сервера.

Время, в течение которого передается ответ с содержимым страницы от HTTP-сервера к браузеру.

5). Обработка HTML.

Время, в течение которого браузер обрабатывает содержимое страницы после ее загрузки с сервера и до начала отрисовки.

6). Отрисовка браузером страницы

Время, которое пройдет от начала перехода на страницу до момента, когда страница начинает отрисовываться.

7). Полная загрузка

Время, которое пройдет от начала перехода на страницу до полной загрузки страницы со всеми ее компонентами 
(изображения, CSS, скрипты и т. п.). Это значение субъективно воспринимается посетителем как «качество» страницы.

![Этапы загрузки веб страниц](_Files/1.%20PageLoadStrategy/01.png)

### 1.2. Важные события ЖЦ HTML страницы

У жизненного цикла HTML-страницы есть события:

* *document.DOMContentLoaded* – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, 
  такие как картинки <img> и стили, могут быть ещё не загружены
  
Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс. 

* *window.load* – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.)

Событие window.load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.

* *window.beforeunload* – пользователь покидает страницу

Событие window.beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить,
на самом ли деле он хочет уйти.

* *window.unload* - пользователь почти ушёл

Событие window.unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.

#### Событие document.DOMContentLoaded

Событие **DOMContentLoaded** срабатывает на объекте **document**.
На первый взгляд событие **DOMContentLoaded** очень простое. 
DOM-дерево готово – получаем событие. Хотя тут есть несколько особенностей.

**DOMContentLoaded и скрипты**

Когда браузер обрабатывает HTML-документ и встречает тег <script>, 
он должен выполнить его перед тем, как продолжить строить DOM. 
Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (document.write), 
так что DOMContentLoaded должен подождать.

Есть два исключения из этого правила:

* скрипты с атрибутом async, который мы рассмотрим немного позже, не блокируют **DOMContentLoaded**
* скрипты, сгенерированные динамически при помощи document.createElement('script') и затем добавленные на страницу, 
также не блокируют это событие

**DOMContentLoaded и стили**

Внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт.
Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили
Причина в том, что скрипту может понадобиться получить координаты или другие свойства элементов, зависящих от стилей, как в примере выше. Естественно, он должен дождаться, пока стили загрузятся.
Так как DOMContentLoaded дожидается скриптов, то теперь он так же дожидается и стилей перед ними.

#### Свойство document.readyState

Свойство **document.readyState** показывает нам текущее состояние загрузки.

Есть три возможных значения:

* *loading* – документ загружается
  
* *interactive* – документ был полностью прочитан

Свойство **document.readyState** станет **interactive** прямо перед **DOMContentLoaded**. 
Эти две вещи, на самом деле, обозначают одно и то же.

* *complete* – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены 

Свойство **document.readyState** станет **complete**, когда все ресурсы загрузятся. 
Переключение на состояние **complete** означает то же самое, что и **window.onload**.
Разница заключается в том, что **window.onload** всегда срабатывает после всех load других обработчиков.

### 1.3. Перечисление PageLoadStrategy

Можно настроить поведение при загрузке страницы, задав нужный параметр PageLoadStrategy.

***PageLoadStrategy*** - перечисление определяющее стратегии загрузки страницы.

Константы перечисления *PageLoadStrategy*:

| Тип    | Описание                                                   | 
|--------|------------------------------------------------------------|
| NORMAL | Загрузка всей страницы (по умолчанию)                      |
| EAGER  | Загрузка только HTML части (без стилей, изображений и т д) |
| NONE   | Загрузки начальной страницы                                |

[selenium/docs/api : PageLoadStrategy](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/PageLoadStrategy.html)

**NORMAL**

Если установлено значение **NORMAL**, Selenium WebDriver ждет, 
пока не будет возвращено событие загрузки **window.load**.

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

**EAGER**

Если установлено значение **NORMAL**, Selenium WebDriver ждет, 
пока не будет возвращено событие **document.DOMContentLoaded**.

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

**NONE**

Если установлено значение **NONE**, Selenium WebDriver ожидает только загрузки начальной страницы.

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

***

## 2. Что такое ожидание?

***Ожидание*** - некий временной интервал между произведенными действиями 
(поиск элемента или любой другой вид операции с элементом).

Когда страница приложения загружена в браузере, элементы на этой странице могут подгружаться с различными временными интервалами.
Скрипт выполняется намного быстрее реакции приложения на команды.
Это затрудняет поиск элементов, если элемент не присутствует в **DOM**, возникает исключение **ElementNotVisibleException**.
Поэтому часто в скриптах необходимо дожидаться определенного состояния приложения для дальнейшего с ним взаимодействия.
Используя ожидания, мы можем решить эту проблему.
Таким образом ожидания нужны для синхронизации работы тестируемого приложения и тестового скрипта.

Так как Selenium работает с **DOM**, то ожидание загрузки страницы происходит через ожидание состояния **document.readyState == complete**.
Это происходит автоматически после открытия страницы **driver.get()**, перезагрузки **driver.navigate.refresh()**,
перехода на другие страницы посредством нажатия на веб элементы и т.д.
WebDriver ожидает загрузку **DOM**-а страницы автоматически потому не нужно вызывать **waitForPageToLoad()**
после каждого действия, как это было в Selenium RC.
Selenium WebDriver предоставляет два типа ожиданий — **неявное (implicit)** и **явное (explicit)**. 

* *явное ожидание* заставляет WebDriver ожидать возникновение определенного условия до произведения действий
* *неявное ожидание* заставляет WebDriver опрашивать DOM определенное количество времени, когда пытается найти элемент

***

## 3. Неявные ожидания (Implicit Waits)

***Неявное ожидание (Implicit Waits)*** - ожидание, которое конфигурируют экземпляр WebDriver на совершение многократных попыток 
найти элемент (элементы) на странице в течении заданного периода времени, если элемент не найден сразу, и
только по истечении этого времени (по умолчанию 0) WebDriver бросит **ElementNotFoundException**. 

Неявные ожидания обычно настраиваются сразу после создания экземпляра WebDriver и действуют в течении всей жизни этого экземпляра, 
хотя переопределить их можно в любой момент. 

### 3.1. Интерфейс WebDriver.Options

Неявные ожидания настраиваются с помощью **WebDriver.Options**.

Методы интерфейса *WebDriver.Options*

| Тип      | Метод      | Описание                   | 
|----------|------------|----------------------------|
| Timeouts | timeouts() | Настройка неявных ожиданий |

[selenium/docs/api : WebDriver.Options](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Options.html)

### 3.2. Интерфейс Timeouts

***Timeouts*** - интерфейс представляющий методы для настройки неявных ожиданий.

Методы интерфейса *Timeouts*

| Тип                | Метод                               | Описание                                                                                    | 
|--------------------|-------------------------------------|---------------------------------------------------------------------------------------------|
| WebDriver.Timeouts | implicitlyWait(Duration duration)   | Настройка ожидания до появления элемента на странице (неявные ожидания)                     |
| WebDriver.Timeouts | pageLoadTimeout(Duration duration)  | Настройка ожидания до завершения загрузки страница перед появлением ошибки                  |
| WebDriver.Timeouts | setScriptTimeout(Duration duration) | Настройка ожидания до завершения выполнения асинхронного сценария перед появлением ошибки   |

[selenium/docs/api : Timeouts](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html)

**implicitlyWait(Duration duration)**

Ожидание указывается глобально на уровне объекта **driver**. 
Все вызовы элементов **driver.findElement()** будут продолжаться то тех пор, 
пока элемент не будет найден или достигнута граница времени ожидания.

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
driver.get("http://some_url");
WebElement dynamicElement = driver.findElement(By.id("dynamicElement_id"));
```

**pageLoadTimeout(Duration duration)**

Ожидание указывается для загрузки страницы.
Если **DOM** не загрузился к тому моменту, то будет выброшено исключение **TimeoutException**.

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().pageLoadTimeout(10, TimeUnit.SECONDS);
pageLoad();
```

**setScriptTimeout(Duration duration)**

Ожидание указывается для функции **executeAsyncScript** как граничное значение времени ожидания завершения запроса.
Если скрипт не завершится к тому времени, то будет выброшено исключение **TimeoutException**.

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().setScriptTimeout(10, TimeUnit.SECONDS);
performScript();
```

***

## 4. Явные ожидания (Explicit Waits)

***Явные ожидания (Explicit Waits)*** - ожидание, которое определяет какое необходимое событие должно произойти для того, 
чтобы дальнейший код исполнился. 

Такое ожидание срабатывает один раз в указанном месте.

### 4.1. Интерфейс Wait<F>

**Wait** - интерфейс предоставляющий методы явных ожиданий.

Классы реализующие интерфейс:

* FluentWait
* WebDriverWait

Методы интерфейса

| Тип | Метод | Описание|
|-|-|-|
| <T> T	| until(Function<? super F,T> isTrue) | ожидание до выполнения	

T - the return type of the method, which must not be Void
Parameters:
isTrue - the parameter to pass to the ExpectedCondition
Returns:
truthy value from the isTrue condition

[selenium/docs/api : Wait](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/Wait.html)

### 4.2. Класс WebDriverWait

**WebDriverWait** - класс реализующий явные ожидания.

Класс реализует интерфейс **Wait**

Конструкторы класса:

* WebDriverWait(WebDriver driver, Duration timeout)
  
* WebDriverWait(WebDriver driver, Duration timeout, Duration sleep)
  
* WebDriverWait(WebDriver driver, Duration timeout, Duration sleep, Clock clock, Sleeper sleeper)

Parameters:

driver - The WebDriver instance to pass to the expected conditions
timeout - The timeout when an expectation is called
sleep - The duration in milliseconds to sleep between polls.

[selenium/docs/api : WebDriverWait](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/WebDriverWait.html)

```java
WebDriverWait wait = new WebDriverWait(driver, 10L, 125L);
wait.until(driver -> driver.findElements(By.cssSelector("div.super")).size() > 10);
```

### 4.3. Класс Expected Conditions

Существуют некие условия, которые часто встречаются при автоматизации веб-сайтов. 
Ниже перечислены реализации каждого.

Класс **Expected Conditions** - класс представляющий определенные условия ожидания.

Методы класса:

| Тип                                 | Метод                                                                     | Описание                                                   |
|-------------------------------------|---------------------------------------------------------------------------|------------------------------------------------------------|
| ExpectedCondition<Alert>            | alertIsPresent()                                                          | |
| ExpectedCondition<Boolean>          | and(ExpectedCondition\<?\>... conditions)                                 | Логическое условие **И** |
| ExpectedCondition<Boolean>          | attributeContains(By locator, String attribute, String value)             | WebElement имеет атрибут с определенным значением |
| ExpectedCondition<Boolean>          | attributeContains(WebElement element, String attribute, String value)     | WebElement имеет атрибут с определенным значением |
| ExpectedCondition<Boolean>          | attributeToBe(By locator, String attribute, String value)                 | WebElement имеет атрибут с определенным значением |
| ExpectedCondition<Boolean>          | attributeToBe(WebElement element, String attribute, String value)         | WebElement имеет атрибут с определенным значением |
| ExpectedCondition<Boolean>          | attributeToBeNotEmpty(WebElement element, String attribute)               | WebElement имеет атрибут с любым непустым значением |
| ExpectedCondition<Boolean>          | domAttributeToBe(WebElement element, String attribute, String value)      | WebElement имеет атрибут DOM с определенным значением|
| ExpectedCondition<Boolean>          | domPropertyToBe(WebElement element, String property, String value)        | WebElement имеет свойство DOM с определенным значением|
| ExpectedCondition<Boolean>          | elementSelectionStateToBe(By locator, boolean selected)                   | выбран ли данный элемент |
| ExpectedCondition<Boolean>          | elementSelectionStateToBe(WebElement element, boolean selected)           | |
| ExpectedCondition<WebElement>       | elementToBeClickable(By locator)                                          | элемента видно и включено, так что вы можете щелкнуть по нему.|
| ExpectedCondition<WebElement>       | elementToBeClickable(WebElement element)                                  | |
| ExpectedCondition<Boolean>          | elementToBeSelected(By locator)                                           | выбран ли данный элемент.|
| ExpectedCondition<Boolean>          | elementToBeSelected(WebElement element)                                   | |
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(int frameLocator)                         | доступен ли данный фрейм для переключения.|
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(String frameLocator)                      | |
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(By locator)                               | |
| ExpectedCondition<WebDriver>        | frameToBeAvailableAndSwitchToIt(WebElement frameLocator)                  | |
| ExpectedCondition<Boolean>          | invisibilityOf(WebElement element)                                        | невидимость элемента|
| ExpectedCondition<Boolean>          | invisibilityOfAllElements(List\<WebElement\> elements)                    | невидимость всех элемн|
| ExpectedCondition<Boolean>          | invisibilityOfAllElements(WebElement... elements)                         | |
| ExpectedCondition<Boolean>          | invisibilityOfElementLocated(By locator)                                  | |
| ExpectedCondition<Boolean>          | invisibilityOfElementWithText(By locator, String text)                    | |
| ExpectedCondition<Boolean>          | javaScriptThrowsNoExceptions(String javaScript)                           | |
| ExpectedCondition<Object>           | jsReturnsValue(String javaScript)                                         | |
| ExpectedCondition<Boolean>          | not(ExpectedCondition\<?\> condition)                                     | |
| ExpectedCondition<List<WebElement>> | numberOfElementsToBe(By locator, Integer number)                          | |
| ExpectedCondition<List<WebElement>> | numberOfElementsToBeLessThan(By locator, Integer number)                  | |
| ExpectedCondition<List<WebElement>> | numberOfElementsToBeMoreThan(By locator, Integer number)                  | |
| ExpectedCondition<Boolean>          | numberOfWindowsToBe(int expectedNumberOfWindows)                          | |
| ExpectedCondition<Boolean>          | or(ExpectedCondition<?>... conditions)                                    | |
| ExpectedCondition<List<WebElement>> | presenceOfAllElementsLocatedBy(By locator)                                | |
| ExpectedCondition<WebElement>       | presenceOfElementLocated(By locator)                                      | |
| ExpectedCondition<WebElement>       | presenceOfNestedElementLocatedBy(By locator, By childLocator)             | |
| ExpectedCondition<WebElement>       | presenceOfNestedElementLocatedBy(WebElement element, By childLocator)     | |
| ExpectedCondition<List<WebElement>> | presenceOfNestedElementsLocatedBy(By parent, By childLocator)             | |
| static <T> ExpectedCondition<T>     | refreshed(ExpectedCondition<T> condition)                                 | |
| ExpectedCondition<Boolean>          | stalenessOf(WebElement element)                                           | |
| ExpectedCondition<Boolean>          | textMatches(By locator, Pattern pattern)                                  | |
| ExpectedCondition<Boolean>          | textToBe(By locator, String value)                                        | | 
| ExpectedCondition<Boolean>          | textToBePresentInElement(WebElement element, String text)                 | |
| ExpectedCondition<Boolean>          | textToBePresentInElementLocated(By locator, String text)                  | |
| ExpectedCondition<Boolean>          | textToBePresentInElementValue(By locator, String text)                    | |
| ExpectedCondition<Boolean>          | textToBePresentInElementValue(WebElement element, String text)            | |
| ExpectedCondition<Boolean>          | titleContains(String title)                                               | |
| ExpectedCondition<Boolean>          | titleIs(String title)                                                     | |
| ExpectedCondition<Boolean>          | urlContains(String fraction)                                              | |
| ExpectedCondition<Boolean>          | urlMatches(String regex)                                                  | |
| ExpectedCondition<Boolean>          | urlToBe(String url)                                                       | |
| ExpectedCondition<WebElement>       | visibilityOf(WebElement element)                                          | |
| ExpectedCondition<List<WebElement>> | visibilityOfAllElements(List<WebElement> elements)                        | |
| ExpectedCondition<List<WebElement>> | visibilityOfAllElements(WebElement... elements)                           | |
| ExpectedCondition<List<WebElement>> | visibilityOfAllElementsLocatedBy(By locator)                              | |
| ExpectedCondition<WebElement>       | visibilityOfElementLocated(By locator)                                    | |
| ExpectedCondition<List<WebElement>> | visibilityOfNestedElementsLocatedBy(By parent, By childLocator)           | |
| ExpectedCondition<List<WebElement>> | visibilityOfNestedElementsLocatedBy(WebElement element, By childLocator)  | |

[selenium/docs/api : ExpectedConditions](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html)

***

## 5. Fluent Waits


Wait wait = new FluentWait()

Fluent
driver = new ChromeDriver();
FluentWait<WebDriver> wait = new FluentWait<WebDriver>(driver)
.withTimeout(7, TimeUnit.SECONDS)
.pollingEvery(500, TimeUnit.MILLISECONDS)
.ignoring(NoSuchElementException.class);

***

## 6. Задержка (Thread.sleep)

Самым худшим вариантом является использование Thread.sleep(1000), в
случае с которым скрипт просто будет ждать определенное количество времени.
Это не гарантирует наступление нужного события либо будет слишком избыточным и увеличит время выполнения теста.

***

## 7. Сравнение явных и неявных ожиданий 

|            | Неявные                  | Явные                   |
|------------|--------------------------|-------------------------|
| Проверка   | На стороне браузера      | На стороне клиента      |
| Событие    | Ожидание появления в DOM | Ждать можно чего угодно |
| Исключение | NoSuchElementException   | TimeoutException        |
| Режим      | Работают автоматически   | Надо писать явно        |
| Запросы    | Один сетевой запрос      | Много сетевых запросов  |

***

Как победить staleness?
• Поиск элемента перед использованием
• Выбор подходящего момента для действия
• Повторные попытки после исключения
• А может быть не только staleness?

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)



