# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 08. Ожидания

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

## 1. Загрузка страницы

### 1.1. Поэтапный процесс загрузки веб страниц сайтов в браузере

Этапы загрузки веб страниц:

0). Пользователь открывает нужную страницу сайта в браузере (URL).

1). Обработка запросов к DNS-серверу. 

Запрос к хосту, на котором размешен ваш сайт со всеми его потрохами файлами и папками.

***DNS (Domain Name System)*** — система доменных имён, компьютерная распределённая система для получения информации о доменах. 
Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), 
получения информации о маршрутизации почты, обслуживающих узлах для протоколов в домене (SRV-запись).

***DNS-сервер (name server)*** — приложение, предназначенное для ответов на DNS-запросы по соответствующему протоколу. 
Также DNS-сервером могут называть хост, на котором запущено приложение.»

2). Обработка редиректов.

Время, которое будет потрачено на отработку HTTP-переадресации при загрузке страницы.

3). Подключение к серверу. 

Время, в течение которого браузер ожидает подключения к HTTP-серверу при получении содержимого страницы.

4). Ответ сервера.

Время, в течение которого передается ответ с содержимым страницы от HTTP-сервера к браузеру.

5). Обработка HTML.

Время, в течение которого браузер обрабатывает содержимое страницы после ее загрузки с сервера и до начала отрисовки.

6). Отрисовка браузером страницы

Время, которое пройдет от начала перехода на страницу до момента, когда страница начинает отрисовываться.

7). Полная загрузка

Время, которое пройдет от начала перехода на страницу до полной загрузки страницы со всеми ее компонентами (изображения, CSS, скрипты и т. п.). 
Это значение субъективно воспринимается посетителем как «качество» страницы.

![Этапы загрузки веб страниц](_Files/1.%20PageLoadStrategy/01.png)

### 1.2. Три важных события ЖЦ HTML страницы

У жизненного цикла HTML-страницы есть три важных события:

* *DOMContentLoaded* – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, 
  такие как картинки <img> и стили, могут быть ещё не загружены
  
Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс. 

* *load* – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.)

Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.

* *beforeunload* – пользователь покидает страницу

Событие beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить,
на самом ли деле он хочет уйти.

* *unload* - пользователь почти ушёл

Событие unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.

#### DOMContentLoaded

Событие DOMContentLoaded срабатывает на объекте document.

**DOMContentLoaded и скрипты**

Когда браузер обрабатывает HTML-документ и встречает тег <script>, 
он должен выполнить его перед тем, как продолжить строить DOM. 
Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (document.write), 
так что DOMContentLoaded должен подождать.

Есть два исключения из этого правила:

* скрипты с атрибутом async, который мы рассмотрим немного позже, не блокируют **DOMContentLoaded**
* скрипты, сгенерированные динамически при помощи document.createElement('script') и затем добавленные на страницу, 
также не блокируют это событие

**DOMContentLoaded и стили**

Внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт.
Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили
Причина в том, что скрипту может понадобиться получить координаты или другие свойства элементов, зависящих от стилей, как в примере выше. Естественно, он должен дождаться, пока стили загрузятся.
Так как DOMContentLoaded дожидается скриптов, то теперь он так же дожидается и стилей перед ними.

window.onload
Событие load на объекте window наступает, когда загрузилась вся страница, включая стили, картинки и другие ресурсы.

window.onunload
Когда посетитель покидает страницу, на объекте window генерируется событие unload. В этот момент стоит совершать простые действия, не требующие много времени, вроде закрытия связанных всплывающих окон.

Обычно здесь отсылают статистику.

window.onbeforeunload
Если посетитель собирается уйти со страницы или закрыть окно, обработчик beforeunload попросит дополнительное подтверждение.

Если мы отменим это событие, то браузер спросит посетителя, уверен ли он.
### document.readyState

Свойство **document.readyState** показывает нам текущее состояние загрузки.

Есть три возможных значения:

* *loading* – документ загружается
  
* *interactive* – документ был полностью прочитан

Свойство **document.readyState** станет **interactive** прямо перед **DOMContentLoaded**. 
Эти две вещи, на самом деле, обозначают одно и то же.

* *complete* – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены 

Свойство **document.readyState** станет **complete**, когда все ресурсы (iframe и img) загрузятся. 
Это произойдёт примерно в одно время с img.onload (img последний ресурс) и window.onload. 
Переключение на состояние complete означает то же самое, что и window.onload.
Разница заключается в том, что window.onload всегда срабатывает после всех load других обработчиков.

### 1.3. Перечисление PageLoadStrategy

***PageLoadStrategy*** - перечисление определяющее стратегии загрузки страницы.

Константы перечисления *PageLoadStrategy*

| Тип    | Описание                                                   | 
|--------|------------------------------------------------------------|
| NORMAL | Загрузка всей страницы (по умолчанию)                      |
| EAGER  | Загрузка только HTML части (без стилей, изображений и т д) |
| NONE   | Загрузки начальной страницы                                |

[selenium/docs/api : PageLoadStrategy](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/PageLoadStrategy.html)

**NORMAL**

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

**EAGER**

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

**NONE**

```java
ChromeOptions chromeOptions = new ChromeOptions();
chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE);
WebDriver driver = new ChromeDriver(chromeOptions);
driver.get("https://google.com");
```

***

## 2. Что такое ожидание?

***Ожидание*** - некий временной интервал между произведенными действиями 
(поиск элемента или любой другой вид операции с элементом).

Когда страница приложения загружена в браузере, элементы на этой странице могут подгружаться с различными временными интервалами.
Скрипт выполняется намного быстрее реакции приложения на команды.
Это затрудняет поиск элементов, если элемент не присутствует в **DOM**, возникает исключение **ElementNotVisibleException**.
Поэтому часто в скриптах необходимо дожидаться определенного состояния приложения для дальнейшего с ним взаимодействия.
Используя ожидания, мы можем решить эту проблему.
Таким образом ожидания нужны для синхронизации работы тестируемого приложения и тестового скрипта.

Selenium WebDriver предоставляет два типа ожиданий — **неявное (implicit)** и **явное (explicit)**. 

* *явное ожидание* заставляет WebDriver ожидать возникновение определенного условия до произведения действий
* *неявное ожидание* заставляет WebDriver опрашивать DOM определенное количество времени, когда пытается найти элемент

***

## 3. Неявные ожидания (Implicit Waits)

***Неявное ожидание (Implicit Waits)*** - ожидание, которое конфигурируют экземпляр WebDriver на совершение многократных попыток 
найти элемент (элементы) на странице в течении заданного периода времени, если элемент не найден сразу, и
только по истечении этого времени (по умолчанию 0) WebDriver бросит **ElementNotFoundException**. 

Неявные ожидания обычно настраиваются сразу после создания экземпляра WebDriver и действуют в течении всей жизни этого экземпляра, 
хотя переопределить их можно в любой момент. 

### 3.1. Интерфейс WebDriver.Options

Неявные ожидания настраиваются с помощью WebDriver.Options.

Методы интерфейса *WebDriver.Options*

| Тип      | Метод      | Описание                   | 
|----------|------------|----------------------------|
| Timeouts | timeouts() | Настройка неявных ожиданий |

[selenium/docs/api : WebDriver.Options](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Options.html)

### 3.2. Интерфейс Timeouts

***Timeouts*** - интерфейс представляющий методы для настройки неявных ожиданий.

Методы интерфейса *Timeouts*

| Тип                | Метод                               | Описание                                                                                    | 
|--------------------|-------------------------------------|---------------------------------------------------------------------------------------------|
| WebDriver.Timeouts | implicitlyWait(Duration duration)   | Настройка ожидания до появления элемента на странице (неявные ожидания) (document == ready) |
| WebDriver.Timeouts | pageLoadTimeout(Duration duration)  | Настройка ожидания до завершения загрузки страница перед появлением ошибки                  |
| WebDriver.Timeouts | setScriptTimeout(Duration duration) | Настройка ожидания до завершения выполнения асинхронного сценария перед появлением ошибки   |

[selenium/docs/api : Timeouts](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html)

**implicitlyWait(Duration duration)**

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
driver.get("http://some_url");
WebElement dynamicElement = driver.findElement(By.id("dynamicElement_id"));
```

**pageLoadTimeout(Duration duration)**

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().pageLoadTimeout(10, TimeUnit.SECONDS);
pageLoad();
```

**setScriptTimeout(Duration duration)**

```java
WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().setScriptTimeout(10, TimeUnit.SECONDS);
performScript();
```

***

## 4. Явные ожидания (Explicit Waits)

***Явные ожидания (Explicit Waits)*** - ожидание, которое определяет какое необходимое событие должно произойти для того, 
чтобы дальнейший код исполнился. 

Такое ожидание срабатывает один раз в указанном месте.

### 4.1. Интерфейс Wait<F>

Type Parameters:
F - the argument to pass to any function called
All Known Implementing Classes:
FluentWait, WebDriverWait
public interface Wait<F>
A generic interface for waiting until a condition is true or not null. The condition may take a single argument of type .

<T> T	until(java.util.function.Function<? super F,T> isTrue)	
Implementations should wait until the condition evaluates to a value that is neither null nor false.

Implementations should wait until the condition evaluates to a value that is neither null nor false. Because of this contract, the return type must not be Void.
If the condition does not become true within a certain time (as defined by the implementing class), this method will throw a non-specified Throwable. This is so that an implementor may throw whatever is idiomatic for a given test infrastructure (e.g. JUnit4 would throw AssertionError).

Type Parameters:
T - the return type of the method, which must not be Void
Parameters:
isTrue - the parameter to pass to the ExpectedCondition
Returns:
truthy value from the isTrue condition

[selenium/docs/api : WebDriverWait](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/WebDriverWait.html)

### 4.2. Класс WebDriverWait

Конструкторы класса:

* WebDriverWait(WebDriver driver, Duration timeout)
  
* WebDriverWait(WebDriver driver, Duration timeout, Duration sleep)
  
* WebDriverWait(WebDriver driver, Duration timeout, Duration sleep, Clock clock, Sleeper sleeper)


```java
WebDriverWait wait = new WebDriverWait(driver, 10L, 125L);
wait.until(driver -> driver.findElements(By.cssSelector("div.super")).size() > 10);
```

### 4.3. Ожидаемые условия (Expected Conditions)

Существуют некие условия, которые часто встречаются при автоматизации веб-сайтов. 
Ниже перечислены реализации каждого.

[selenium/docs/api : ExpectedConditions](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html)

ExpectedConditions:
alertIsPresent()
elementSelectionStateToBe()
elementToBeClickable()
elementToBeSelected()
frameToBeAvaliableAndSwitchToIt()
invisibilityOfTheElementLocated()
invisibilityOfElementWithText()
presenceOfAllElementsLocatedBy()
presenceOfElementLocated()
textToBePresentInElement()
textToBePresentInElementLocated()
textToBePresentInElementValue()
titleIs()
titleContains()
visibilityOf()
visibilityOfAllElements()
visibilityOfAllElementsLocatedBy()
visibilityOfElementLocated()

***

## 5. Fluent Waits


Wait wait = new FluentWait()

Fluent
driver = new ChromeDriver();
FluentWait<WebDriver> wait = new FluentWait<WebDriver>(driver)
.withTimeout(7, TimeUnit.SECONDS)
.pollingEvery(500, TimeUnit.MILLISECONDS)
.ignoring(NoSuchElementException.class);

***

## 6. Задержка (Thread.sleep)

Самым худшим вариантом является использование Thread.sleep(1000), в
случае с которым скрипт просто будет ждать определенное количество времени.
Это не гарантирует наступление нужного события либо будет слишком избыточным и увеличит время выполнения теста.

***

## 7. Сравнение явных и неявных ожиданий 

|            | Неявные                  | Явные                   |
|------------|--------------------------|-------------------------|
| Проверка   | На стороне браузера      | На стороне клиента      |
| Событие    | Ожидание появления в DOM | Ждать можно чего угодно |
| Исключение | NoSuchElementException   | TimeoutException        |
| Режим      | Работают автоматически   | Надо писать явно        |
| Запросы    | Один сетевой запрос      | Много сетевых запросов  |

***

Как победить staleness?
• Поиск элемента перед использованием
• Выбор подходящего момента для действия
• Повторные попытки после исключения
• А может быть не только staleness?

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)



