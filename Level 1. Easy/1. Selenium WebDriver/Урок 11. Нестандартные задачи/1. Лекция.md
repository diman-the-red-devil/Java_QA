Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 12. Нестандартные задачи

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Нестандартные задачи

## 1.1. Какие нестандартные задачи бывают?

Кроме обычного взаимодействия с UI (нажатие кнопок, переход по ссылкам и т д) 
в автоматизации тестирования встречаются много других интересных задач.

К ним можно отнести:

* отправка и сохранение файла
* авторизация BasicAuth
* отображение скрытых веб элементов страницы
* изменение параметров веб элементов страницы
* сравнение изображений страницы
* работа с разного типа файлами (.pdf, .xls)
* работа с веб хранилищем  
* эмуляция геолокации

и т д

## 1.2. Каким образом можно решить нестандартные задачи?

Нестандартные задачи можно решить несколькими способами:

* с помощью классов и интерфейсов **Selenium WebDriver**
* c помощью выполнения скрипта на **JavaScript**
* c помощью возможностей предоставляемых **DevTools**
* с помощью сторонних либ

***

# 2. Классы и интерфейсы Selenium WebDriver

В **Selenium WebDriver** существуют классы для

* представления цветов
* печати страницы в PDF
* работы с веб хранилищем
* представления геолокации

***

# 3. Стандартные команды Selenium

## 3.1. Класс WebDriver

## 3.1.1. Авторизация BasicAuth

***BasicAuth (Basic авторизация)*** - это самый простой способ ограничения доступа к веб-приложениям и документам,
предусмотренный стандартом протокола HTTP. При попытке обращения к таким ресурсам браузер формирует диалоговое окно,
в котором предлагается ввести свой логин и пароль,
после чего запрос выполняется повторно с предоставлением серверу данных для идентификации.

Cайты, использующие **BasicAuth**, встречаются нечасто, чаще это веб-приложения,
используемые для административных или корпоративных целей.

Основная проблема при тестировании таких приложений это нативные диалоговые окна, при появлении которых,
также как и алертов, дальнейшее управление браузером с помощью Selenium становится просто невозможным.

Одним из способов избежать появления диалогового окна может быть использование
специального URL формата **http://username:password@example.com/** для передачи учетных данных.
Эта конструкция все еще поддерживается некоторыми браузерами, однако такое решение является официально устаревшим и
иногда может отрицательно влиять на корректное выполнение дальнейших запросов на странице.

*Пример*

```java
driver.get("https://<username>:<password>@www.example.com/index.html");
```

## 3.2. Класс WebElement

## 3.2.1. Отправление файла

Отправление (upload) файла обычно является довольно простой задачей.
Она сводится к нахождению input элемента с атрибутом **type = "file"**.
Далее нужно ввести путь к файлу и нажать кнопку **submit**.

*Пример*

```java
WebElement element = driver.findElement(By.id("upload"));
element.sendKeys("/image.png");
```

***

# 4. Цвета

## 4.1. Класс Color

***Color*** - класс представляющий цвет.

Методы класса **Color**:

| Тип          | Метод                      | Описание                           | 
|--------------|----------------------------|------------------------------------|
| String       | asHex()                    | Представление цвета в HEX системе  |
| String       | asRgb()                    | Представление цвета в RGB системе  |
| String       | asRgba()                   | Представление цвета в RGBa системе |
| static Color | fromString(String value)   | Создание объекта из строки         |
| Color        | getColor()                 | Получение объекта                  |
| void         | setOpacity(double alpha)   | Установка прозрачности             |

[selenium/docs/api : Color](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/Color.html)

*Пример*

```java
private final Color HEX_COLOUR = Color.fromString("#2F7ED8");
private final Color RGB_COLOUR = Color.fromString("rgb(255, 255, 255)");
private final Color RGB_COLOUR = Color.fromString("rgb(40%, 20%, 40%)");
private final Color RGBA_COLOUR = Color.fromString("rgba(255, 255, 255, 0.5)");
private final Color RGBA_COLOUR = Color.fromString("rgba(40%, 20%, 40%, 0.5)");
private final Color HSL_COLOUR = Color.fromString("hsl(100, 0%, 50%)");
private final Color HSLA_COLOUR = Color.fromString("hsla(100, 0%, 50%, 0.5)");
private final Color TRANSPARENT = Color.fromString("transparent");
```

## 4.2. Перечисление Colors

***Colors*** - перечисление представляющее значения цветов.

Методы перечисления **Colors**:

| Тип             | Метод                | Описание                      | 
|-----------------|----------------------|-------------------------------|
| Color           | getColorValue()      | Получение значение цвета      | 
| static Colors   | valueOf(String name) | Получение константы из строки | 
| static Colors[] | values()             | Получение констант            | 

[selenium/docs/api : Colors](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/Colors.html)

### 4.2.1.

*Пример*

```java
private final Color BLACK = Color.fromString("black");
private final Color CHOCOLATE = Color.fromString("chocolate");
private final Color HOTPINK = Color.fromString("hotpink");

Color loginButtonColour = Color.fromString(driver.findElement(By.id("login")).getCssValue("color"));
Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id("login")).getCssValue("background-color"));

Assertions.assertTrue(loginButtonBackgroundColour.equals(HOTPINK));
Assertions.assertTrue(loginButtonBackgroundColour.asHex().equals("#ff69b4");
Assertions.assertTrue(loginButtonBackgroundColour.asRgba().equals("rgba(255, 105, 180, 1)");
Assertions.assertTrue(loginButtonBackgroundColour.asRgb().equals("rgb(255, 105, 180)");        
```

***

# 5. Печать страницы в PDF

## 5.1. Интерфейс PrintsPage

***PrintsPage*** - интерфейс для сохранения страницы в **PDF**.

Методы интерфейса **Platform**:

| Тип | Метод                            | Описание                  | 
|-----|----------------------------------|---------------------------|
| Pdf | print(PrintOptions printOptions) | Сохранение страницы в PDF |

[selenium/docs/api : PrintsPage](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/PrintsPage.html)

*Пример*

```java
driver.get("https://www.selenium.dev");
PrintsPage printer = (PrintsPage) driver;
PrintOptions printOptions = new PrintOptions();
printOptions.setPageRanges("1-2");
Pdf pdf = printer.print(printOptions);
String content = pdf.getContent();
```

## 5.2. Интерфейс Pdf

***Pdf*** - интерфейс для получения файла **PDF** в формате Base64.

Методы интерфейса **Pdf**:

| Тип    | Метод        | Описание                             | 
|--------|--------------|--------------------------------------|
| String | getContent() | Получение файла PDF в формате Base64 |

[selenium/docs/api : Pdf](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/Pdf.html)

## 5.3. Класс PrintOptions

***PrintOptions*** - класс представляющий опции **PDF** при сохранении файла.

Методы класса **Platform**:

| Тип                      | Метод                                                | Описание                      | 
|--------------------------|------------------------------------------------------|-------------------------------|
| boolean                  | getBackground()	                                  | Получение фона страницы       | 
| PrintOptions.Orientation | getOrientation()	                                  | Получение ориентации страницы | 
| PageMargin               | getPageMargin()	                                  | Получение отступов страницы   | 
| String[]                 | getPageRanges()	                                  | Получение                     | 
| PageSize                 | getPageSize()	                                      | Получение размеров страницы   | 
| double                   | getScale()	                                          | Получение масштаба страницы   | 
| boolean                  | getShrinkToFit()	                                  |                               | 
| void                     | setBackground(boolean background)	                  | Установка фона страницы       | 
| void                     | setOrientation(PrintOptions.Orientation orientation) | Установка ориентации страницы | 
| void                     | setPageMargin(PageMargin margin)	                  | Установка отступов страницы   | 
| void                     | setPageRanges(String firstRange, String... ranges)   |                               | 
| void                     | setPageSize(PageSize pageSize)	                      | Установка размеров страницы   | 
| void                     | setScale(double scale)	                              | Установка масштаба страницв   | 
| void                     | setShrinkToFit(boolean value)                        |                               | 

[selenium/docs/api : PrintOptions](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/print/PrintOptions.html)

## 5.4. Перечисление PrintOptions.Orientation

***PrintOptions.Orientation*** - перечисление представляющее ориентацию страницы.

Константы перечисления **PrintOptions.Orientation**:

| Тип           | Описание   | 
|---------------|------------|
| LANDSCAPE     | Альбомная  |
| PORTRAIT      | Портретная |

Методы перечисления **PrintOptions.Orientation**:

| Тип                               | Метод                | Описание                              | 
|-----------------------------------|----------------------|---------------------------------------|
| static PrintOptions.Orientation	| valueOf(String name) | Константа из строкового представления |
| static PrintOptions.Orientation[]	| values()             | Массив констант                       |

[selenium/docs/api : PrintOptions.Orientation](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/print/PrintOptions.Orientation.html)

## 5.5. Класс PageMargin

***PageMargin*** - класс представляющий отступы страницы.

Методы класса *PrintOptions.Orientation*

| Тип    | Метод       | Описание          | 
|--------|-------------|-------------------|
| double | getBottom() | От нижней границы |
| double | getLeft()   | От левой границы  |
| double | getRight()  | От правой границы |
| double | getTop()    | От верхней границы|

[selenium/docs/api : PageMargin](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/print/PageMargin.html)

## 5.6. Класс PageSize

***PageSize*** - класс представляющий размеры страницы.

Методы класса **PrintOptions.Orientation**

| Тип    | Метод       | Описание | 
|--------|-------------|----------|
| double | getHeight() | Высота   | 
| double | getWidth()  | Ширина   | 

[selenium/docs/api : PageSize](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/print/PageSize.html)

***

# 6. Веб хранилище

***Веб-хранилище (Web Storage, DOM-хранилище)*** - набор механизмов, которые используются для хранения данных локально
в веб-браузере пользователя в виде пары ключ/значение. Другими словами, это специально отведенное место в браузере
(похоже на небольшую базу данных), в котором мы можем работать с данными - записывать, читать и удалять их.

Существуют два основных типа веб-хранилища:

* *сессионное хранилище (sessionStorage)*
* *локальное хранилище (localStorage)*

Объекты веб-хранилища **localStorage** и **sessionStorage** позволяют хранить пары ключ/значение в браузере.

Что в них важно – данные, которые в них записаны, сохраняются

* после обновления страницы (в случае sessionStorage)
* после перезапуска браузера (при использовании localStorage).

Но ведь у нас уже есть куки. Зачем тогда эти объекты?

Проблемы куки:

* в каждом из них можно храниться максимум 4 Кбайт данных (этого может быть недостаточно для работы веб-приложения)

С появлением HTML5 мы получили доступ к более объемному веб-хранилищу (между 5 и 10 МБайт на каждый домен),
которое сохраняет информацию между загрузками страницы и посещениями сайта (даже после выключения и включения компьютера).

* cookie должны отправляться в обоих направлениях при каждой перезагрузке страницы, что может существенно замедлять работу веб-сайта;

В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе.
Поэтому мы можем хранить гораздо больше данных.

* куки также включаются в каждый HTTP-запрос при передаче данных через Интернет в незашифрованном виде.

* от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки.

Всё делается при помощи JavaScript.

Хранилище привязано к источнику (домен/протокол/порт).

Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

Объекты хранилища localStorage и sessionStorage предоставляют одинаковые методы и свойства:

setItem(key, value) – сохранить пару ключ/значение.
getItem(key) – получить данные по ключу key.
removeItem(key) – удалить данные с ключом key.
clear() – удалить всё.
key(index) – получить ключ на заданной позиции.
length – количество элементов в хранилище.

sessionStorage (сессионное хранилище, хранилище сессии)

Сессионное хранилище - это объект sessionStorage, который позволяет хранить данные для каждого домена, доступные на протяжении сессии, пока открыт браузер, и даже в том случае, если была осуществлена перезагрузка страницы. Однако закрытие вкладки браузера, самого браузера или перезагрузка компьютера приводит к удалению данных из sessionStorage.

Объект sessionStorage используется гораздо реже, чем localStorage.

localStorage (локальное хранилище)

Локальное хранилище - это объект localStorage, который позволяет хранить данные для каждого домена в течение неограниченного времени (после закрытия вкладки браузера, самого браузера, перезагрузки компьютера), а точнее пока пользователь самостоятельно не удалит данные.

Каждый домен имеет доступ к своему хранилищу данных localStorage. Например, localStorage, используемый для, https://osipenkov.ru является отдельным от localStorage, используемым для https://coobiq.com. Субдомены (поддомены) и различные протоколы HTTP (HTTP и HTTPS) имеют независимые друг от друга хранилища данных. Например, localStorage https://gtm.osipenkov.ru используется полностью отдельно от https://osipenkov.ru. Точно так же localStorage https://osipenkov.ru используется отдельно от http://osipenkov.ru.

Некоторые браузеры блокируют localStorage в режиме инкогнито. localStorage работает даже с отключенными cookie.

sessionStorage
Объект sessionStorage используется гораздо реже, чем localStorage.

Свойства и методы такие же, но есть существенные ограничения:

sessionStorage существует только в рамках текущей вкладки браузера.
Другая вкладка с той же страницей будет иметь другое хранилище.
Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.

https://learn.javascript.ru/localstorage

## 6.1. Интерфейс WebStorage

***WebStorage*** - интерфейс представляющее доступ к веб хранилищу.

Методы интерфейса **WebStorage**:

| Тип            | Метод               | Описание                       | 
|----------------|---------------------|--------------------------------|
| LocalStorage   | getLocalStorage()   | Доступ к локальному хранилищу  |
| SessionStorage | getSessionStorage() | Доступ к сессионному хранилищу |

## 6.2. Интерфейс LocalStorage

***LocalStorage*** - интерфейс представляющий локальное хранилище.

Методы интерфейса **LocalStorage**:

| Тип         | Метод                             | Описание                      | 
|-------------|-----------------------------------|-------------------------------|
| void        | clear()                           | Очистка локального хранилища  |
| String      | getItem(String key)               | Получение элемента по ключу   |
| Set<String> | keySet()                          | Получение набора ключей       |
| String      | removeItem(String key)            | Удаление элемента по ключу    |
| void        | setItem(String key, String value) | Добавление элемента           |
| int         | size()                            | Получение размера             |

[selenium/docs/api : LocalStorage](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/html5/LocalStorage.html)

## 6.3. Интерфейс SessionStorage

***SessionStorage*** - интерфейс представляющий сессионное хранилище.

Методы интерфейса **SessionStorage**:

| Тип         | Метод                             | Описание                      | 
|-------------|-----------------------------------|-------------------------------|
| void        | clear()                           | Очистка сессионного хранилища |
| String      | getItem(String key)               | Получение элемента по ключу   |
| Set<String> | keySet()                          | Получение набора ключей       |
| String      | removeItem(String key)            | Удаление элемента по ключу    |
| void        | setItem(String key, String value) | Добавление элемента           |
| int         | size()                            | Получение размера             |

[selenium/docs/api : SessionStorage](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/html5/SessionStorage.html)

***

# 7. Геолокация

## 7.1. Класс Location

***Location*** - класс представляющий локацию браузера.

Методы класса **Location**:

| Тип    | Метод          | Описание                          | 
|--------|----------------|-----------------------------------|
| double | getAltitude()  | Получение высоты над уровнем моря |
| double | getLatitude()  | Получение широты                  |
| double | getLongitude() | Получение долготы                 |

[selenium/docs/api : Location](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/html5/Location.html)

***

# 8. Выполнение JS скрипта

## 8.1. Интерфейс JavascriptExecutor

***JavascriptExecutor*** - интерфейс позволяющий **Selenium WebDriver** выполнять **JS** скрипт в браузере.

Методы интерфейса **JavascriptExecutor**:

| Тип                    | Метод                                             | Описание                            | 
|------------------------|---------------------------------------------------|-------------------------------------|
| Object                 | executeAsyncScript(String script, Object... args) | Выполнение асинхронного скрипта     | 
| Object                 | executeScript(String script, Object... args)      | Выполнение синхронного скрипта      | 
| default Object         | executeScript(ScriptKey key, Object... args)      | Выполнение сохраненного скрипта     | 
| default Set<ScriptKey> | getPinnedScripts()                                | Получение сохраненных скриптов      | 
| default ScriptKey      | pin(String script)                                | Сохранение скрипта в текущей сессии |
| default void           | unpin(ScriptKey key)                              | Удаление скрипта из текущий сессии  | 

[selenium/docs/api : JavascriptExecutor](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/JavascriptExecutor.html)

## 8.2. Решение задач с помощью выполнения JS

### 8.2.1. Клик на веб элемент

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor)driver;
WebElement button = driver.findElement(By.name("btnLogin"));
js.executeScript("arguments[0].click();", button);
```

### 8.2.2. Получение текста веб элемента

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor)driver;
WebElement button = driver.findElement(By.name("btnLogin"));
String text = (String) js.executeScript("return arguments[0].innerText", button);
```

### 8.2.3. Скроллинг страницы

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor)driver;		
js.executeScript("window.scrollBy(0,600)");
```

### 8.2.4. Отображение скрытых элементов

Изменение прозрачности элемнта.

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor) driver;	
WebElement element = driver.findElement("//input[@type='button']");
String script = "arguments[0].style.opacity=1;" +
        "arguments[0].style['transform']='translate(0px, 0px) scale(1)';" +
        "arguments[0].style['MozTransform']='translate(0px, 0px) scale(1)';" +
        "arguments[0].style['WebkitTransform']='translate(0px, 0px) scale(1)';" +
        "arguments[0].style['msTransform']='translate(0px, 0px) scale(1)';" +
        "arguments[0].style['OTransform']='translate(0px, 0px) scale(1)';" +
        "return true;";
js.executeScript(script, element);
```

Изменение видимости элемента.

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor) driver;
String script = "arguments[0].style.visibility='visible';";
js.executeScript(script, divVisibilityHidden);
```

Изменение отображения элемента.

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor) driver;
String script = "arguments[0].style.display='block';";
js.executeScript(script, divDisplayNone);
```

### 8.2.5. Создание цветов

*Пример*

```java
JavascriptExecutor js = (JavascriptExecutor) driver;
String script = "document.getElementById('button1').style.backgroundColor = 'HotPink';";
js.executeScript(script, divDisplayNone);
```

***

# 9. DevTools

***Инструменты разработчика (Development Tools или сокращённо DevTools)*** ─ программы, позволяющие создавать, 
тестировать и отлаживать (debug) программное обеспечение.

Современные браузеры, Safari, Firefox, Microsoft Edge, Chrome, Яндекс 
и другие, имеют встроенные инструменты разработчика, 
позволяющие просмотреть исходный код сайта. Отдельно устанавливать их не требуется. 
С их помощью можно просматривать и отлаживать HTML сайта, его CSS и Javascript. 
Также можно проверить сетевой трафик, потребляемый сайтом, его быстродействие и много других параметров.

***Chrome DevTools*** - набор инструментов веб-разработчика, встроенных непосредственно в браузер Google Chrome.

В **Selenium 4** добавили долгожданную встроенную поддержку протокола **Chrome DevTools** через интерфейс **DevTools**. 

https://www.selenium.dev/documentation/en/support_packages/chrome_devtools/
https://habr.com/ru/post/548898/

## 9.1. Класс DevTools

***DevTools*** - класс представляющий DevTools. 

Методы класса **DevTools**:

| Тип         | Метод                                            | Описание                      | 
|-------------|--------------------------------------------------|-------------------------------|
| <X> void    | addListener(Event<X> event, Consumer<X> handler) | Добавление слушателя события  |
| void        | clearListeners()                                 | Удаление слушателей событий   |
| void        | close()                                          | Закрытие DevTools             |
| void        | createSession()                                  |                               |
| void        |	createSessionIfThereIsNotOne()                   |                               |
| SessionID   | getCdpSession()                                  | Получение сессии              |
| Domains     | getDomains()                                     | установка геолокации          |
| <X> X       | send(Command<X> command)                         | Отправка                      |

[selenium/docs/api : DevTools](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/devtools/DevTools.html)

*Пример*

```java
ChromeDriver driver = new ChromeDriver();
DevTools devTools = driver.getDevTools();
devTools.createSession();
devTools.send(Performance.enable(Optional.empty()));
List<Metric> metricList = devTools.send(Performance.getMetrics());

driver.get("https://google.com");
driver.quit();

for(Metric m : metricList) {
    System.out.println(m.getName() + " = " + m.getValue());
}
```

***

# 10. Сторонние либы



***

# 11. Работа с файлом формата PDF

## 11.1. Библиотека Apache PdfBox

***Apache PDFBox*** - библиотека **Java** с открытым исходным кодом для работы с документами **PDF**.

Возможности:

* создание новых документов **PDF**
* создание документов **PDF** из текстового файла
* редактирование существующих документов **PDF**
* печатать **PDF**
* извлечение контента (текста) из документов **PDF**
* объединение документов **PDF**
* шифрование / дешифрование документов **PDF**
  и т д.

Apache PDFBox также включает в себя несколько утилит командной строки.

[Apache PDFBox](https://pdfbox.apache.org/)

[PDFBox API](https://pdfbox.apache.org/docs/2.0.13/javadocs/)

*Пример*

```java
// Открытие файла PDF
File file = new File("C:/new.pdf");
PDDocument document = PDDocument.load(file);
// Извлечение текста из документа PDF
PDFTextStripper pdfStripper = new PDFTextStripper();
String text = pdfStripper.getText(document);
System.out.println(text);
// Закрытие файла PDF
document.close();
````

## 11.2. Библиотека iText

***iText*** - библиотека на **Java**, предназначенная для работы с **pdf**.

Начиная с версии 5.0.0 свободно распространяется по лицензии **AGPL**
(обязывающая предоставлять пользователям возможность получения исходного кода), но также есть и коммерческая версия.

[iText PDF](https://itextpdf.com/en)

[iText API](https://itextpdf.com/en/resources/api-documentation)

*Пример*

```java
// Открытие файла PDF
PdfReader reader = new PdfReader("C:/new.pdf");
// Извлечение текста из документа PDF (нумерация страниц в PDF начинается с единицы)
for (int i = 1; i <= reader.getNumberOfPages(); ++i) {
    TextExtractionStrategy strategy = new SimpleTextExtractionStrategy();
    String text = PdfTextExtractor.getTextFromPage(reader, i, strategy);
    System.out.println(text);
}
// Закрытие файла PDF
reader.close();
````

***

# 12. Работа с файлами формата Excel

## 12.1.


## 12.2. 

***

# 13

Иногда в тестировании появляется необходимость сравнивать изображения. 
Например, для проверки загруженных иконок и изображений на сайте или для сравнения базового лэйаута на странице с текущим.

Webdriver обладает функционалом для снятия скриншотов, однако он не может сравнивать изображения. 
Для этого надо писать собственные расширения. В качестве примера рассмотрим следующий вспомогательный класс:

```java
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.PixelGrabber;

public class CompareUtil {
    public enum Result {
        Matched,
        SizeMismatch,
        PixelMismatch
    };
    static Result CompareImage(String baseFile, String actualFile) {
        Result compareResult = Result.PixelMismatch;
        Image baseImage = Toolkit.getDefaultToolkit().getImage(baseFile);
        Image actualImage = Toolkit.getDefaultToolkit().getImage(actualFile);
        
        try {
            PixelGrabber baseImageGrab = new PixelGrabber(baseImage, 0, 0, -1, -1, false);
            PixelGrabber actualImageGrab = new PixelGrabber(actualImage, 0, 0, -1, -1, false);
            int[] baseImageData = null;
            int[] actualImageData = null;
            
            if (baseImageGrab.grabPixels()) {
                int width = baseImageGrab.getWidth();
                int height = baseImageGrab.getHeight();
                baseImageData = new int[width * height];
                baseImageData = (int[]) baseImageGrab.getPixels();
            }
            
            if (actualImageGrab.grabPixels()) {
                int width = actualImageGrab.getWidth();
                int height = actualImageGrab.getHeight();
                actualImageData = new int[width * height];
                actualImageData = (int[]) actualImageGrab.getPixels();
            }
            System.out.println(baseImageGrab.getHeight() + "<>" + actualImageGrab.getHeight());
            System.out.println(baseImageGrab.getWidth() + "<>" + actualImageGrab.getWidth());
            
            if ((baseImageGrab.getHeight() != actualImageGrab.getHeight()) ||
                (baseImageGrab.getWidth() != actualImageGrab.getWidth())) {
                compareResult = Result.SizeMismatch;
            } else 
            if (java.util.Arrays.equals(baseImageData, actualImageData)) {
                compareResult = Result.Matched;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return compareResult;
    }
}
```

Пример теста с использованием этого класса:

```java
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.*;
import org.apache.commons.io.FileUtils;
import org.junit.*;
import static org.junit.Assert.*;
import java.io.File;

public class ScreenShotTest {
    public WebDriver driver;
    private StringBuffer verificationErrors = new StringBuffer();

    @Before
    public void setUp() throws Exception {
        // Create a new instance of the Firefox driver
        driver = new FirefoxDriver();
    }

    @Test
    public void imageCompareTest() throws Exception {
        String scrFile = "FILE_PATH";
        String baseScrFile = "BASE_FILE_PATH";
        // Заходим на страницу
        driver.get(URL);
        File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        FileUtils.copyFile(screenshotFile, new File(scrFile));
        try {
            //Сравниваем изображение с базовым
            assertEquals(CompareUtil.Result.Matched, CompareUtil.CompareImage(baseScrFile, scrFile));
        } catch (Error e) {
            // Сохраняем ошибки в переменную
            verificationErrors.append(e.toString());
        }
    }

    @After
    public void tearDown() throws Exception {
        //Закрываем браузер
        driver.quit();
        String verificationErrorString = verificationErrors.toString();
        if (!"".equals(verificationErrorString)) {
            fail(verificationErrorString);
        }
    }
}
```

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)
