Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 10. Протоколирование

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Для чего нужно протоколирование?

После выполнения автотеста с использованием **Selenium WevDriver** необходимо проанализировать результаты, 
а если тест оказался провален, то нужно еще и выяснить причину. 
Чтобы понять, почему возникла ошибка при выполнении теста можно воспользоваться записями в логе. 
Но иногда записей бывает недостаточно, нужны скриншоты ошибки.

***

# 2. Логи

***Логирование*** — запись в логи данных о работе программы (сервера, веб приложения и т д).

***Логи*** — файлы (обычно текстовые файлы), содержащие информацию о работе программы (сервера, веб приложения и т д), 
в которые вносятся определённые действия пользователя или программы.

Логи полезны для отладки различных частей программы, 
а также для сбора и анализа информации о работе системы с целью выявления ошибок. 
Всё это необходимо для контроля работы приложения, так как даже после релиза могут встретиться ошибки, 
а пользователи не всегда сообщают о багах в техподдержку. 

Чем больше процессов автоматизировано, тем быстрее будет идти разработка.
Хорошее логирование может сделать дебаггинг намного проще.

Логи состоят из записей, каждая из которых содержит 

* время (Log Timestamp)
  
* уровень (Log Level)

Предназначение уровней логгирования - предоставление пользователю способа фильтрации сообщений лога
в зависимости от уровня интереса пользователя.
Например, если цель логгирования - дебаггинг, то практически все сообщения будут нужны,
в то время как при общем мониторинге понадобится меньше информации.

* сообщение (Log Message)

Сообщение содержит основную информацию о работе приложения.

## 2.1. Интерфейс WebDriver.Options

Доступ к логам можно получить с помощью **WebDriver.Options**.

***WebDriver.manage()*** - реализация интерфейса **WebDriver.Options**.

Методы интерфейса **WebDriver.Options** для доступа к логам:

| Тип  | Метод  | Описание       | 
|------|--------|----------------|
| Logs | logs() | Доступ к логам |

[selenium/docs/api : WebDriver.Options](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.Options.html)

*Пример*

```java
Logs logs = driver.manage().logs();
```

## 2.2. Интерфейс Logs

***Logs*** - интерфейс предоставляющий методы получения логов.

Методы интерфейса **Logs**:

| Тип         | Метод                  | Описание                        | 
|-------------|------------------------|---------------------------------|
| Set<String> | getAvailableLogTypes() | Получение доступных типов логов |
| LogEntries  | get(String logType)    | Получение логов заданного типа  |

[selenium/docs/api : Logs](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/logging/Logs.html)

### 2.2.1. Получение доступных типов логов

**Selenium Webdriver** может быть использован в различных конфигурациях. 
К примеру, клиент, запускающий тест (Java), может напрямую взаимодействовать с драйвером (локальный запуск), 
который контролирует браузер, или опосредованно через сервер (удаленный запуск). 
В зависимости от конфигурации могут быть доступны различные типы логов. 
Поэтому **Selenium Webdriver** предоставляет возможность узнать типы поддерживаемых логов.

*Пример*

```java
Set<String> availableLogTypes = driver().manage().logs().getAvailableLogTypes();
```

### 2.2.2. Получение логов заданного типа



*Пример*

```java
Logs logs = driver.manage().logs();
LogEntries logsEntries = logs.get(LogType.BROWSER);
}
```

### 2.2.3. Получение логов заданного типа и уровня



*Пример*

```java
Logs logs = driver.manage().logs();
LogEntries logsEntries = logs.get(LogType.BROWSER);
List<LogEntry> logsEntriesList = logsEntries.getAll().stream()
    .filter(a -> a.getLevel() == Level.SEVERE)
    .collect(Collectors.toList());
```

## 2.3. Класс LogType

***LogType*** - класс представляющий типы логов **Selenium WebDriver**.

Константы класса **LogType**:

| Тип           | Константа   | Описание                                          | Пример                     | 
|---------------|-------------|---------------------------------------------------|----------------------------|
| static String	| CLIENT      | Логи от клиентской части Selenium Webdriver       | Логи Java Bindings         |
| static String	| SERVER      | Логи от серверной части Selenium Webdriver        | Логи Selenium Grid         |
| static String	| DRIVER      | Логи от драйвера                                  | Логи FirefoxDriver         |
| static String	| BROWSER     | Логи от браузера                                  | Логи JavaScript консоли    |
| static String	| PERFORMANCE | Логи относящиеся к производительности на странице | Тайминги загрузки ресурсов |
| static String	| PROFILER    | Логи относящиеся к таймингу производительности    |                            |

[selenium/docs/api : LogType](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/logging/LogType.html)

В целом, при дебагинге определенной конфигурации было бы полезно получить 
доступ к логам каждого отдельного компонента конфигурации:

* клиент (CLIENT)
* сервер (SERVER)
* драйвер (DRIVER)
* браузер (BROWSER)

Все же логи всех компонентов не могут быть доступны во всех конфигурациях. 
Пример с использованием сервера (или не использованием) - самый простой, 
но логи также могут не поддерживаться или их невозможно будет получить из-за браузера. 
В придачу к этому, иногда могут быть доступны и некоторые другие типы логов. 
Например, могут быть доступны логи, предназначенные для сбора данных о производительности на стороне клиента.

## 2.4. Класс Level

***Level*** - класс представляющий стандартные уровни логгирования.

Методы класса **Level**:

| Тип          | Метод              | Описание                                                                   | 
|--------------|--------------------|----------------------------------------------------------------------------|
| String       | getLocalizedName() | Получение локализованного наименования уровня логгирования                 |
| String       | getName()          | Получение нелокализованного наименования уровня логгирования               |
| int          | intValue()         | Получение численного значения уровня логгирования                          |
| static Level | parse(String name) | Преобразование строкового представления уровня логгирования в объект Level |

Константы класса **Level**: 
Для **Selenium Webdriver** существуют следующие уровни логгирования (в порядке возрастания детализированности):

| Тип           | Константа | Описание                             | Пример                                          |
|---------------|-----------|--------------------------------------|-------------------------------------------------|
| static Level	| OFF       | Отключение логгирования              | Отключение логгирования                         |
| static Level	| SEVERE    | Сообщения об ошибках                 | Неизвестные команды **Selenium Webdriver**      |
| static Level	| WARNING   | Сообщения предупреждающего характера | Перехваченное исключение **Selenium Webdriver** |
| static Level	| INFO      | Сообщения информативного характера   | Полученные команды **Selenium Webdriver**       |
| static Level	| DEBUG     | Сообщения для дебаггинга             | Информация о состоянии драйвера                 |
| static Level	| ALL       | Все сообщения                        | Все сообщения независимо от уровня              |

[javase/7/docs/api : Level](https://docs.oracle.com/javase/7/docs/api/java/util/logging/Level.html)

## 2.5. Класс LogEntries

***LogEntries*** - класс представляющий пул логов.

Методы класса **LogEntries**:

| Тип                | Метод      | Описание                                | 
|--------------------|------------|-----------------------------------------|
| List<LogEntry>     | getAll()   | Получение всех логов                    |
| Iterator<LogEntry> | iterator() | Получение итератора для доступа к логам |

[selenium/docs/api : LogEntries](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/logging/LogEntries.html)

*Пример*

```java
Logs logs = driver.manage().logs();
LogEntries logEntries = logs.get(LogType.BROWSER);
List<LogEntry> logEntriesList = logEntries.getAll()
```

## 2.6. Класс LogEntry

***LogEntry*** - класс представляющий запись лога.

Методы класса **LogEntry**:

| Тип    | Метод          | Описание                                 | 
|--------|----------------|------------------------------------------|
| Level  | getLevel()     | Получение уровня логгирования            |
| String | getMessage()   | Получение сообщения в логе               |
| long   | getTimestamp() | Получение временной метки (миллисекунды) |

[selenium/docs/api : LogEntry](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/logging/LogEntry.html)

*Пример*

```java
Logs logs = driver.manage().logs();
LogEntries logEntries = logs.get(LogType.DRIVER);
List<LogEntry> logEntriesList = logEntries.getAll()
for (LogEntry logEntry : logEntriesList) {
    System.out.println(logEntry.getLevel());
    System.out.println(logEntry.getMessage());
    System.out.println(logEntry.getTimestamp());
}
```

## 2.7. Класс LoggingPreferences

***LoggingPreferences*** - класс представляющий настройки логов.

Методы класса **LoggingPreferences**:

| Тип                | Метод                                    | Описание                                           | 
|--------------------|------------------------------------------|----------------------------------------------------|
| Level              | getLevel()                               | Получение уровня логгирования                      |
| LoggingPreferences | addPreferences(LoggingPreferences prefs) | Добавление настроек логгирования                   |
| void               | enable(String logType, Level level)      | Включение логгирования определенного типа и уровня |
| Set<String>        | getEnabledLogTypes()                     | Получение логгируемых типов логов                  |

[selenium/docs/api : LogEntry](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/logging/LogEntry.html)

### 2.7.1. Конфигурация логгирования

Бывают ситуации, когда логгирование необходимо полностью отключить, или сделать минимальным количество сообщений. 
Например, в случае, когда драйвер работает на устройстве с ограниченными ресурсами. 
Для поддержки таких ситуаций должна быть возможность конфигурировать логгирование как отдельная настройка в вебдрайвере. 
Реализовано это путем передачи драйверу списка пар тип лога - уровень логгирования. 
В большинстве реализаций клиентской части это сделано через **DesiredCapabilities** класс.

*Пример*

```java
DesiredCapabilities caps = DesiredCapabilities.firefox();
LoggingPreferences logs = new LoggingPreferences();
logs.enable(LogType.BROWSER, Level.OFF);
logs.enable(LogType.CLIENT, Level.SEVERE);
logs.enable(LogType.DRIVER, Level.WARNING);
logs.enable(LogType.PERFORMANCE, Level.INFO);
logs.enable(LogType.SERVER, Level.ALL);
WebDriver driver = new FirefoxDriver(caps);
```

***

# 2. Скриншоты

***Скриншот*** - изображение, полученное устройством и показывающее в точности то, 
что видит пользователь на экране монитора или другого визуального устройства вывода.

Одна из основных целей автоматизированного тестирования — сокращение ручного труда.
При работе с автоматизированными тестами в **Selenium** часто приходится делать скриншот веб-страницы или ее части. 
Это полезно, особенно при отладке ошибок или проверке согласованности поведения приложения в разных браузерах.
Не хотелось бы сидеть и следить за приложением каждый раз, когда выполняются тесты.
Поэтому снятие скриншотов приносит много пользы.

Скриншоты снимаются во время выполнения теста с помощью скрипта, который помогает

* проверить функциональность или состояние приложения после выполнения теста
* анализировать ошибки, просматривая состояние приложения, когда тест-кейс оканчивается неудачей

Скриншоты особенно полезны при выполнении headless-тестов, где не виден графический интерфейс приложения. 
Тем не менее **Selenium** захватит и сохранит скриншот, чтобы вы могли проверить его позже.
 
Есть несколько способов сделать скриншот:

* с помощью Selenium WebDriver (интерфейс TakesScreenshot) 
* с помощью сторонних библиотек

## 2.1. С помощью Selenium WebDriver

В **Selenium WebDriver** встроены возможности для снятия скриншотов без подключения сторонних библиотек.
Однако функционал снятия скриншотов несколько ограничен.

### 2.1.1. Интерфейс TakesScreenshot

***TakeScreenshot*** - интерфейс предоставляющий методы для снятия скриншотов.
                     
Методы интерфейса:

| Тип   | Метод                                 | Описание         |        
|-------|---------------------------------------|------------------|        
| <X> X | getScreenshotAs(OutputType<X> target) | Снятие скриншота |     

В качестве параметра он принимает значение, которое влияет на тип возвращаемого методом результата:

* *BASE64* — получить скриншот в формате данных base64
* *BYTES* — получить скриншот как набор байт
* *FILE* — получить скриншот, сохраненный во временный файл, 
  который будет удален после завершения работы JVM 
  
Разработчик должен самостоятельно сделать копию этого файла.

[selenium/docs/api : TakesScreenshot](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/TakesScreenshot.html)

### 2.1.1.1. Скриншот видимой области веб страницы

Чтобы снять скриншот видимой области веб страницы, необходимо вызвать метод **getScreenshotAs** на экземпляре драйвера.

*Пример*

```java
File file = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
BufferedImage image = ImageIO.read(file);
ImageIO.write(image, "png", new File("screenshot.png"));
```

### 2.1.1.2. Скриншот веб элемента

Чтобы снять скриншот веб элемента, необходимо вызвать метод **getScreenshotAs** на веб элементе.

*Пример*

```java
File file = driver.findElement(By.xpath("//div"))
        .getScreenshotAs(OutputType.FILE);
BufferedImage image = ImageIO.read(file);
ImageIO.write(image, "png", new File("screenshot.png"));
```

### 2.1.1.3. Скриншот веб элемента вырезанный из видимой области веб страницы

Чтобы снять скриншот веб элемента вырезанный из видимой области веб страницы, необходимо вызвать метод **getScreenshotAs** 
на экземпляре драйвера и вырезать область с интересующим веб элементом.

*Пример*

```java
WebElement element = driver.findElement(By.xpath("//div"));
Point l = element.getLocation();
Dimension s = element.getSize();
File file = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
BufferedImage image1 = ImageIO.read(file);
BufferedImage image2 = image1.getSubimage(l.getX() - 50, l.getY() - 50, s.getWidth() + 200, s.getHeight() + 100);
ImageIO.write(image2, "png", new File("screenshot.png"));
```

### 2.1.2. Интерфейс OutputType<T>

***OutputType<T>*** - интерфейс представляющий формат сохранения файла скриншота.

Методы интерфейса **OutputType<T>**:

| Тип | Метод                                  | Описание                                                 | 
|-----|----------------------------------------|----------------------------------------------------------|
| T	  | convertFromBase64Png(String base64Png) | Преобразование заданного base64 png в запрошенный формат |
| T   | convertFromPngBytes(byte[] png)        | Преобразование заданного png в запрошенный формат        |

Константы интерфейса **OutputType<T>**:

| Тип                       | Константа | Описание                                   | 
|---------------------------|-----------|--------------------------------------------|
| static OutputType<String> | BASE64    | Сохранение скриншота в формате Base64      |
| static OutputType<byte[]>	| BYTES     | Сохранение скриншота в виде массива байтов |
| static OutputType<File>   | FILE      | Сохранение скриншота в файле               |

[selenium/docs/api : OutputType](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/OutputType.html)

WebDriverException - on failure.
java.lang.UnsupportedOperationException - if the underlying implementation does not support screenshot capturing.

## 2.2. С помощью AShot

Интерфейс **TakesScreenshot** позволяет делать скриншоты целой страницы, текущего окна, 
видимой части страницы или всего дисплея, если это поддерживается браузером. 
Однако он не позволяет делать скриншоты отдельных элементов.

***AShot*** — сторонняя утилита Яндекса для захвата скриншотов в **Selenium WebDriver**. 

**AShot** обеспечивает следующие возможности:

* скриншоты отдельного веб-элемента
* скриншоты видимой части страницы
* скриншоты всей страницы
* сравнение скриншотов
* украшение скриншотов
  
[aShot](https://github.com/pazone/ashot)

### 2.2.1. Как скачать и настроить Ashot API?

Есть два способа настроить Ashot API

1. Использование Maven (https://mvnrepository.com/artifact/ru.yandex.qatools.ashot/ashot)
2. Вручную без использования какого-либо инструмента

### 2.2.2. Класс AShot

***AShot*** — класс для снятия скриншотов.

Методы класса **AShot**:

| Тип        | Метод                                                             | Описание                                                                                           | 
|------------|-------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| AShot      | addIgnoredArea(Coords area)                                       | Добавление игнорируемых координат                                                                  |
| AShot      | ignoredAreas(Set<Coords> ignoredAreas)                            | Установка набора игнорируемых координат                                                            |
| AShot      | addIgnoredElement(By selector)                                    | Добавление локатора игнорируемого элемента                                                         |
| AShot      | ignoredElements(Set<By> ignoredElements)                          | Установка набора локаторов игнорируемых элементов                                                  |
| AShot      | coordsProvider(CoordsProvider coordsProvider)                     | Установка координат                                                                                |
| AShot      | imageCropper(ImageCropper cropper)                                | Установка режима обрезки                                                                           |
| AShot      | shootingStrategy(ShootingStrategy strategy)                       | Установка режима создания снимков экрана                                                           |
| Screenshot | takeScreenshot(WebDriver driver, Collection<WebElement> elements) | Делает снимок экрана данных элементов. Если элементы не найдены, возвращается снимок всей страницы |
| Screenshot | takeScreenshot(WebDriver driver, WebElement element)              | Делает снимок экрана данного элемента                                                              |
| Screenshot | takeScreenshot(WebDriver driver)                                  | Делает снимок экрана всей страницы                                                                 |

#### 2.2.2.1. Скриншот видимой области страницы

*Пример*

```java
Screenshot screenshot = new AShot()
        .takeScreenshot(driver);
ImageIO.write(screenshot.getImage(), "png", new File("screenshot.png"));
```

#### 2.2.2.2. Скриншот всей страницы

*Пример*

```java
Screenshot screenshot = new AShot()
        .shootingStrategy(ShootingStrategies
            .viewportPasting(100))
        .takeScreenshot(driver);
ImageIO.write(screenshot.getImage(), "png", new File("screenshot.png"));
```

#### 2.2.2.3. Скриншот веб элемента

*Пример*

```java
WebElement element = driver.findElement(By.xpath("//div"));
Screenshot screenshot = new AShot()
        .coordsProvider(new WebDriverCoordsProvider())
        .takeScreenshot(driver, element);
ImageIO.write(screenshot.getImage(), "png", new File("screenshot.png"));
```

#### 2.2.2.4. Сравнение изображений

*Пример*

```java
BufferedImage actualImage = new AShot().takeScreenshot(driver).getImage();
BufferedImage expectedImage = ImageIO.read(new File("expectedImage.png"));
ImageDiffer imageDiffer = new ImageDiffer();
ImageDiff diff = imageDiffer.makeDiff(actualImage, expectedImage);
if (diff.hasDiff()) {
    logger.info("Изображения одинаковые");
} else {
    logger.info("Изображения разные");
}
```

#### 2.2.2.5. Скриншот с эффектом

*Пример*

```java
WebElement element = driver.findElement(By.xpath("//div"));
Screenshot screenshot = new AShot()
    .imageCropper(new IndentCropper()
        .addIndentFilter(new BlurFilter()))
    .takeScreenshot(driver, element);
ImageIO.write(screenshot.getImage(), "png", new File("screenshot.png"));
```

***

# 3. Запись видео

Иногда бывает полезным записать видео экрана. 

Для записи видео можно воспользоваться 2 способами:

1. Запись видео с помощью склеивания набора скриншотов
2. Запись видео с экрана с помощью сторонних библиотек

* Monte Screen Recorder
* FFmpeg (Video Recorder)

3. Запись видео с помощью Selenoid (запись видео из коробки в контейнерах).

## 3.1. Monte Screen Recorder

**Monte Media** - это библиотека Java для обработки мультимедийных данных. 
Поддерживаемые форматы мультимедиа включают картинки, видео, аудио и метаданные.

Недостаток данного рекордера в том, что для просмотра видео вам 
понадобится установленный на компьютере кодек [TSC](https://www.techsmith.com/products.html).

*Пример*

```java
public class VideoRecorder {
    private ScreenRecorder screenRecorder;
 
    public void startRecording() {
        try {
            GraphicsConfiguration gc = GraphicsEnvironment
                .getLocalGraphicsEnvironment().getDefaultScreenDevice()
                .getDefaultConfiguration();
 
            this.screenRecorder = new ScreenRecorder(gc, 
                    new Format(
                            MediaTypeKey, MediaType.FILE, 
                            MimeTypeKey, MIME_AVI), 
                    new Format(
                            MediaTypeKey, MediaType.VIDEO, 
                            EncodingKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE, 
                            CompressorNameKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE, 
                            DepthKey, 24, 
                            FrameRateKey, Rational.valueOf(15), 
                            QualityKey, 1.0f, 
                            KeyFrameIntervalKey, 15 * 60), 
                    new Format(
                            MediaTypeKey, MediaType.VIDEO, 
                            EncodingKey, "black", 
                            FrameRateKey, Rational.valueOf(30)), 
                    null);
 
            this.screenRecorder.start();
 
        } catch (Exception e) {
            System.out.println(e);
        }
    }
 
    public void stopRecording() {
        try {
            this.screenRecorder.stop();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
```

[Monte Screen Recorder - MonteMedia 0.7.7](http://www.randelshofer.ch/monte/javadoc/index.html)

## 3.2. FFmpeg

***FFmpeg*** — набор свободных библиотек с открытым исходным кодом, которые позволяют записывать, конвертировать и передавать 
цифровые аудио- и видеозаписи в различных форматах. 

Он включает:
* *libavcodec* — библиотеку кодирования и декодирования аудио и видео 
* *libavformat* — библиотеку мультиплексирования и демультиплексирования в медиаконтейнер.

[FFmpeg](https://ffmpeg.org/)

### 3.2.1. Video Recorder

***Video Recorder*** - обертка поверх **FFmpeg**.

Главное нужно не забыть, что по умолчанию обертка использует кодек **Monte**, а не **ffmpeg**.

[Video Recorder](https://github.com/SergeyPirogov/video-recorder-java)

Selenoid и его запись видео из коробки в контейнерах.

***

# 4. Запись трафика



***

# 5. Слушатель

EventFiringWebDriver

WebDriverEventListner

https://automation-remarks.com/selenium-logs/

Заметка о том, как залогировать действия Selenium Webdriver.
Вероятнее всего, вы всегда хотели получать больше информации от WebDriver так,
чтобы было легко дебажить скрипты или просто получать больше информации о тестах.
Теперь это стало возможным благодаря EventFiringWebDriver и WebDriverEventListner.
EventFiringWebDriver это класс, который используется как обертка над webDriver.
WebDriverEventListner - интерфейс, который нужно реализовать, чтобы получить доступ к действиям webdriver.

Поговорим чуть больше o классе EventFiringWebDriver. Этот класс реализует интерфейс WebDriver. Это означает, что в дополнение ко всем стандартным методам, появляется еще два метода:

register(WebDriverEventListener eventListener)

unregister(WebDriverEventListener eventListener)

Метод register позволяет зарегистрировать вашу реализацию WebDriverEventListner для того, чтобы слушать все действия webdriver и метод unregister позволяет прервать работу метода register.

Шаг 1: Реализуем интерфейс WebDriverEventListener

Создаем класс EventHandler и реализуем WebDriverEventListener:

package com.custom.listeners;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.events.WebDriverEventListener;

public class EventHandler implements WebDriverEventListener {

    private static final Logger LOG = LogManager.getLogger(EventHandler.class);

    @Override
    public void beforeNavigateTo(String url, WebDriver driver) {

    }

    @Override
    public void afterNavigateTo(String url, WebDriver driver) {

    }

    @Override
    public void beforeNavigateBack(WebDriver driver) {

    }

    @Override
    public void afterNavigateBack(WebDriver driver) {

    }

    @Override
    public void beforeNavigateForward(WebDriver driver) {

    }

    @Override
    public void afterNavigateForward(WebDriver driver) {

    }

    @Override
    public void beforeFindBy(By by, WebElement element, WebDriver driver) {
        LOG.debug("Should be " + by);
    }

    @Override
    public void afterFindBy(By by, WebElement element, WebDriver driver) {
        LOG.debug("Element found");
    }

    @Override
    public void beforeClickOn(WebElement element, WebDriver driver) {
        LOG.debug("Should click " + element.getTagName());
    }

    @Override
    public void afterClickOn(WebElement element, WebDriver driver) {
        LOG.debug("Clicked successfull");
    }

    @Override
    public void beforeChangeValueOf(WebElement element, WebDriver driver) {

    }

    @Override
    public void afterChangeValueOf(WebElement element, WebDriver driver) {

    }

    @Override
    public void beforeScript(String script, WebDriver driver) {

    }

    @Override
    public void afterScript(String script, WebDriver driver) {

    }

    @Override
    public void onException(Throwable throwable, WebDriver driver) {

    }
}


Шаг 2: Регистрируем слушателя

Создаем простой объект webdriver:

WebDriver driver = new FirefoxDriver();
Создаем объект EventFiringWebDriver и передаем ему созданный объект driver:

EventFiringWebDriver eventDriver = new EventFiringWebDriver(driver);
Регистрируем EventHandler:

eventDriver.register(new EventHandler());
Все, теперь мы можем спокойно писать тесты, как мы это делали раньше и при этом логировать действия драйвера.

import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.support.events.EventFiringWebDriver;

public class Demo {
public static void main(String[] args) {
EventFiringWebDriver eventDriver = new EventFiringWebDriver(new FirefoxDriver());
EventHandler handler = new EventHandler();
eventDriver.register(handler);
eventDriver.get("http://automation-remarks.com");
WebElement element = eventDriver.findElement(By.id("target"));
element.click();
}
}

В результате запуска у нас получится такой вот лог:

DEBUG com.home.custom.listeners.WDriverEventListener beforeFindBy - Should be By.name: banner
DEBUG com.home.custom.listeners.WDriverEventListener beforeFindBy - Should be By.name: banner
DEBUG com.home.custom.listeners.WDriverEventListener afterFindBy - Element found
DEBUG com.home.custom.listeners.WDriverEventListener beforeFindBy - Should be By.id: ibm-banner-welcome
DEBUG com.home.custom.listeners.WDriverEventListener beforeFindBy - Should be By.id: ibm-banner-welcome
DEBUG com.home.custom.listeners.WDriverEventListener afterFindBy - Element found
Вот так просто можно улучшить логирование в вашем тестовом фреймворке. Читабельных вам логов и удачи. Подписывайтесь на нашу рассылку;)


***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)



