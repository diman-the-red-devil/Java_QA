# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

## 1. XML, HTML, DOM

### 1.1. Что такое XML?

***XML (eXtensible Markup Language)*** — расширяемый язык разметки.

Спецификация *XML* описывает XML-документы и частично описывает поведение XML-процессоров (программ, читающих XML-документы и обеспечивающих доступ к их содержимому).
XML разрабатывался как язык с простым формальным синтаксисом, удобный для создания и обработки документов как программами так и человеком, с акцентом на использование в Интернете.
Язык называется расширяемым, поскольку он не фиксирует разметку, используемую в документах: разработчик волен создать разметку в соответствии с потребностями к конкретной области,
будучи ограниченным лишь синтаксическими правилами языка.

***Расширение XML*** — конкретная грамматика, созданная на базе *XML* и представленная словарём тегов и их атрибутов, а также набором правил, определяющих,
какие атрибуты и элементы могут входить в состав других элементов.

Сочетание простого формального синтаксиса, удобства для человека, расширяемости, а также базирование на кодировках
Юникод для представления содержания документов привело к широкому использованию как собственно *XML*,
так и множества производных специализированных языков на базе *XML* в самых разнообразных программных средствах.

*XML* рекомендован Консорциумом Всемирной паутины (W3C).
*XML* является подмножеством *SGML*.

## 1.2. Что такое HTML?

***HTML (HyperText Markup Language)*** — стандартизированный язык разметки веб-страниц во Всемирной паутине.

Код *HTML* интерпретируется браузерами; полученная в результате интерпретации страница отображается
на экране монитора компьютера или мобильного устройства.

Язык *HTML* до 5-й версии определялся как приложение *SGML* (стандартного обобщённого языка разметки по стандарту ISO 8879).
Спецификации *HTML5* формулируются в терминах *DOM* (объектной модели документа).
Строгим вариантом *HTML* является *XHTML*, он наследует синтаксис *XML* и является приложением языка *XML*в области разметки гипертекста.

*HTML*, как и *XML* имеет древовидную структуру.
В документе всегда имеется один корневой элемент, содержащий ряд вложенных элементов,
некоторые из которых тоже могут содержать вложенные элементы.
Так же могут встречаться текстовые узлы, комментарии и инструкции.
Можно считать, что XML-элемент содержит массив вложенных в него элементов и массив атрибутов.

У элементов дерева бывают **элементы-предки** и **элементы-потомки**.
У корневого элемента предков нет, а у тупиковых элементов (листьев дерева) нет потомков.
Каждый элемент дерева находится на определённом уровне вложенности (далее — **уровень**).
Элементы упорядочены в порядке расположения в тексте *XML*, и поэтому можно говорить об их предыдущих и следующих элементах.
Это очень похоже на организацию каталогов в файловой системе.

## 1.3. Что такое DOM?

***DOM (Document Object Model)*** - объектная модель документа, независящий от платформы и языка программный интерфейс,
позволяющий программам и скриптам получить доступ к содержимому *HTML*-, *XHTML*- и *XML*-документов,
а также изменять содержимое, структуру и оформление таких документов.

Согласно DOM-модели, документ является иерархией, состоящей из равноправных узлов дерева DOM.
Основные типы узлов:

* теги - **узлы-элементы (element node)**
* текст - **текстовые узлы (text node)**

Корневым элементом иерархии является **html**. У него есть два потомка.
Первый - **head**, второй - **body**. И так далее, каждый вложенный тег является потомком тега выше.

Модель DOM не накладывает ограничений на структуру документа. 
Любой документ известной структуры с помощью DOM может быть представлен в виде дерева узлов,
каждый узел которого представляет собой элемент, атрибут, текстовый, графический или любой другой объект. 
Узлы связаны между собой отношениями *Родитель - Потомок*.

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/01.jpg "Document Object Model (DOM)")

Проще говоря, DOM - это представление документа в виде дерева тегов.
Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел.

Основные характеристики DOM:

* основана на валидном HTML-коде
* может быть модифицирована из JavaScript
* не включает псевдоэлементы, созданные из CSS
* включает скрытые элементы (display: none)

Возможности DOM:

* поиск узлов (элементов)
* доступ к узлам вверх и вниз по иерархии (родителям и потомкам)
* получение и изменение содержимого узлов (текст, имя тега и т д)

Например для следующего фрагмента HTML

```html
<html>
  <head>
    <title>Заголовок</title>
  </head>
  <body>
     Прекрасный документ
   </body>
</html>
```

будет построено следующее дерево

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/02.jpg "Document Object Model (DOM)")

>Изначально различные браузеры имели собственные модели документов (DOM), несовместимые с остальными.
Для обеспечения взаимной и обратной совместимости специалисты международного консорциума W3C классифицировали эту модель по уровням,
для каждого из которых была создана своя спецификация. Все эти спецификации объединены в общую группу, носящую название **W3C DOM**.

## 1.4. Что такое веб элементы?

***Веб элементы*** – DOM объекты, находящиеся на веб странице, то, что пользователь видит (а иногда и не видит) на странице – 
заголовки, кнопка **ОК**, поля ввода, текстовые блоки и т д.

Языки программирования обычно получают доступ к веб-элементам как к нодам в **объектной модели документа (DOM)**.

Selenium WebDriver также работает с **объектной моделью документа (DOM)**.

***

## 2. Команды поиска веб элементов

Для поиска вэб-элементов на странице в Selenium WebDriver есть следующие методы

| Тип              | Метод               | Описание                                                     | 
|------------------|---------------------|--------------------------------------------------------------|
| WebElement       | findElement(By by)  | поиск элемента (возвращает первый найденный элемент)         |
| List<WebElement> | findElements(By by) | поиск всех элементов (возвращает список найденных элементов) |

[selenium/docs/api : WebDriver](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.html)

### 2.1. Поиск одного веб элемента - findElement

Для поиска одного веб элемента используется команда **findElement**.

```java
WebElement element = driver.findElement(By.tagName("p"));
System.out.println("Paragraph text:" + element.getText());
```

### 2.2. Поиск набора веб элементов - findElements

Для поиска набора веб элементов используется команда **findElements**.

```java
List<WebElement> elements = driver.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println("Paragraph text:" + element.getText());
}
```

### 2.3. Поиск веб элемента в веб элементе

В найденном веб элементе можно найти другой веб элемент.

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
WebElement element = rootElement.findElement(By.tagName("p"));
System.out.println(element.getText());
```

### 2.4. Поиск набора веб элементов в веб элементе

В найденном веб элементе можно найти другие веб элементы.

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
List<WebElement> elements = rootElement.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println(element.getText());
}
```

### 2.5. Цепочка из findElement

```java
WebElement element1 = driver
        .findElement(By.id("div1")
        .findElement(By.name("same");
WebElement element2 = driver
        .findElement(By.id("div2")
        .findElement(By.name("same");
```

***

## 3. Локаторы

Поскольку Webdriver - инструмент для автоматизации веб приложений, то большая часть работы с ним -- это работа с элементами.
А для того, чтобы осуществлять какие-то действия над элементами (DOM объектами) необходимо их точным образом определить(найти).
Для поиска элементов в Selenium используются локаторы.

***Локатор*** – объект, который находит и возвращает веб элементы на странице по заданному запросу.

### 3.1. Класс By

Selenium WebDriver предоставляет следующие типы локаторов элементов на странице:

| Тип | Метод                                      | Описание                                   | 
|-----|--------------------------------------------|--------------------------------------------|
| By  | By.id(String id)                           | поиск элемента по атрибуту id              |
| By  | By.name(String name)                       | поиск элемента по атрибуту name            |
| By  | By.className(String className)             | поиск элемента по атрибуту class           |
| By  | By.tagName(String tagName)                 | поиск элемента по тегу                     |
| By  | By.linkText(String linkText)               | поиск элемента по тексту ссылки            |   
| By  | By.partialLinkText(String partialLinkText) | поиск элемента по частичному тексту ссылки |
| By  | By.cssSelector(String cssSelector)         | поиск элемента по CSS селектору            |
| By  | By.xPath(String xpath)                     | поиск элемента по XPATH запросу            |

[selenium/docs/api : By](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/By.html)

Далее рассмотрим каждый из них подробнее.

### 3.2. Поиск элемента по атрибуту id (By.id)

Для поиска элемента по атрибуту *id* используется локатор **By.id**.

```HTML
<div id="menu_go">
    <a href="http://go.go" id="link_go">Go!</a>
    <input type="button" id="button_go">Go!</input>
</div>
```

```java
WebElement menuGo = driver.findElement(By.id("menu_go"));
WebElement linkGo = driver.findElement(By.id("link_go"));
WebElement buttonGo = driver.findElement(By.id("button_go"));
```

### 3.3. Поиск элемента по атрибуту name (By.name)

Для поиска элемента по атрибуту *name* используется локатор **By.name**.

```HTML
<input type="submit" name="button_submit">Submit</input>
<input type="submit" name="button_cancel">Cancel</input>
```

```java
WebElement buttonSubmit = driver.findElement(By.name("button_submit");
WebElement buttonCancel = driver.findElement(By.name("button_cancel");
```

### 3.4. Поиск элемента по атрибуту class (By.className)

Для поиска элемента по атрибуту *class* используется локатор **By.className**.

```HTML
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-default btn-primary">Submit</input>
```

```java
WebElement element1 = driver.findElement(By.className("btn");
WebElement element2 = driver.findElement(By.className("btn-primary");
WebElement element3 = driver.findElement(By.className("btn btn-default");
WebElement element4 = driver.findElement(By.className("btn btn-primary");
WebElement element5 = driver.findElement(By.className("btn btn-default btn-primary");
```

Метод **className** удобен для тестирования библиотек JavaScript / CSS, которые обычно используют набор определенных имен классов.

```java
WebElement element1 = driver.findElement(By.className("editable-textarea");
WebElement element2 = driver.findElement(By.className("editable-submit");
```

### 3.5. Поиск элемента по имени тега (By.tagName)

Для поиска элемента по имени тега используется локатор **By.tagName**.

```HTML
<body>
<p>Paragraph<p>
</body>
```

```java
WebElement body = driver.findElement(By.tag_name("body"));
WebElement paragraph = body.findElement(By.tag_name("p"));
```

### 3.6. Поиск элемента по тексту ссылки (By.linkText)

Для поиска элемента по тексту ссылки используется локатор **By.linkText**.

```HTML
<a href="/submit">Submit</a>
<a href="/cancel">Cancel</a>
```

```java
WebElement link1 = driver.findElement(By.link_text("Submit"));
WebElement link2 = driver.findElement(By.link_text("Cancel"));
```

### 3.7. Поиск элемента по частичному тексту ссылки (By.partialLinkText)

Для поиска элемента по частичному тексту ссылки используется локатор **By.partialLinkText**.

```HTML
<a href="/submit">Submit Me</a>
<a href="/cancel">Cancel Me</a>
```

```java
WebElement link1 = driver.findElement(By.partial_link_text("ubmi"));
WebElement link1 = driver.findElement(By.partial_link_text("ance"));
``` 

### 3.8. Поиск элемента с помощью CSS селектора (By.cssSelector)

Для поиска элемента с помощью CSS селектора используется локатор **By.cssSelector**.

***CSS селектор*** — формальное описание относительного пути до элемента/элементов HTML.

Классически, селекторы используются для задания правил стиля.
В случае с WebDriver, существование самих правил не обязательно, веб-драйвер использует синтаксис CSS только для поиска.
Поиск вернет первый элемент удовлетворяющий CSS-селектору.

```HTML
<input type="text" id="fistname" name="first_name" class="myForm">
```

```java
WebElement firstName = driver.findElement(By.cssSelector("input[name='first_name']"));
```

Подробнее про [CSS Селекторы](_CSS%20Selectors.md)

### 3.9. Поиск элемента с помощью XPATH запроса (By.xPath)

Для поиска элемента с помощью XPATH запроса  используется локатор **By.xPath**.

***XPath (XML Path Language)*** - язык запросов для выбора узлов из XML документа.

Когда браузер отображает веб-страницу, он анализирует его в дереве DOM.
XPath может использоваться для ссылки на определенный узел в дереве DOM.
XPath — самый мощный и гибкий способ найти определенный веб-элемент.

```HTML
<input class="search-form-input" type="search" itemprop="query-input" name="s" id="search for-2" placeholder="Search this website">
```

```java
WebElement firstName = driver.findElement(By.xpath("//input[@id=searchform-2]"));
WebElement firstName = driver.findElement(By.xpath("//input[@name=’s’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@type=’search’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@class=’search-form-input’]"));
```

Подробнее про [XPATH запросы](_XPATH%20Queries.md)

***

## Относительные локаторы

https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/locators/package-summary.html

***

## 4. Исключения

Если элемент не найден, то

* *findElement* выбрасывает исключение **NoSuchElementException**
* *findElements* возвращает пустой список

Если элемент не найден, то значит 
* не та страница открыта
* неправильный локатор
* элемент находится внутри фрейма
* нужно немного подождать

### 4.1. NoSuchElementException

***NoSuchElementException*** — исключение, которое вызывается методом findElement(By by), если элемент с заданным селектором не найден на странице.

[selenium/docs/api : NoSuchElementException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/NoSuchElementException.html)

### 4.2. StaleElementReferenceException

***StaleElementReferenceException*** — исключение, которое возникает, когда ссылка на элемент больше не действительна.

Вы получите StaleElementReferenceException в одном из следующих случаев, первый из которых наиболее распространенный:

* элемент был полностью удален со страницы

Наиболее частой причиной этого является то, что страница с искомым элементом, была обновлена, или пользователь перешел на другую страницу. 
Реже, но все также достаточно распространен случай, когда библиотека JavaScript удалила элемент и заменила его элементом с таким же ID или атрибутами. 
В этом случае, несмотря на то, что замененные элементы могут выглядеть похожими на оригиналы, они отличаются. Selenium Driver не имеет возможности определить, 
что замененный элемент на самом деле тот же, что и ожидался. Если вы уверены, что элемент заменен идентичным и присутствует на странице, 
то нужно выполнить поиск элемента снова и получить актуальную ссылку на него.

* элемент больше не подключен к DOM модели

Общей техникой, используемой для имитации вкладок интерфейса в веб-приложениях, является подготовка нескольких элементов div для каждой вкладки, 
но прикреплен к *DOM* в один момент времени только один из них, остальные же сохранены в переменные. 
В этом случае вполне возможно, что ваш код может иметь ссылку на элемент, который больше не прикреплен к *DOM* (то есть его предком является *document.documentElement*).
WedDriver вызывает исключение **StaleElementReferenceException** в этом случае, несмотря на то, что элемент существует, потому, что ссылка на элемент все равно потеряна. 
Вам придется заменять ее, выполняя поиск элемента каждый раз, после того как он будет прикреплен к DOM.

* элемент меняет свой тип, но сохраняет тот же локатор поиска (JQuery и др.)

Это крайне редкий случай, происходит он когда, например, поле input при нажатии или получении фокуса меняет значение type c text на password.

[selenium/docs/api : StaleElementReferenceException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/StaleElementReferenceException.html)

### 4.3. InvalidSelectorException 

***InvalidSelectorException*** — исключение генерируется методом findElement(By by) когда заданный селектор поиска не возвращает WebElement. 

Сейчас это исключение возникает только при использовании xpath — когда в xpath выражении есть синтаксические ошибки или выражение не указывает на WebElement (например, *count(.//span)»*).

### 4.4. IllegalLocatorException

***IllegalLocatorException*** — исключение, которое возникает, когда By не может обработать переданные ему аргументы. 

Наиболее распространенный случай возникновения — это использование составного имени класса в By.className().

***

## 5. Правила написания локаторов

### 5.1. Как писать хорошие локаторы?

Поиск элемента – это полдела. Создание уникального запроса для локатора – вот вторая половина. 
Если локатор чересчур широк, он будет возвращать ложноположительные значения. 
При слишком узком подходе он начнет ломаться при любом изменении DOM, и его будет сложно читать другим людям. 
Лучший подход здесь такой – пишите наиболее простой запрос, который уникально идентифицирует целевой элемент или элементы.

Приоритет использования локаторов (от высшего к низшему):

* поиск элемента по атрибуту **id**, если уникален (By.id)

Использование идентификаторов — самый простой и безопасный способ поиска элемента в HTML.
Если страница соответствует W3C HTML, идентификаторы должны быть уникальными и идентифицироваться в веб-элементах управления.
По сравнению с текстами тестовые сценарии, использующие идентификаторы, менее склонны к изменениям приложений
(например, разработчики могут принять решение об изменении метки, но с меньшей вероятностью изменить идентификатор).

* поиск элемента по атрибуту **name**, если уникален (By.name)

Атрибут *name* используются в элементах управления формой.
Значения имени передаются на сервер при отправке формы.
С точки зрения вероятности будущих изменений, атрибут *name*, второй по отношению к *id*.

* поиск элемента по атрибуту **class** (By.className)

Атрибут *class* элемента HTML используется для стилизации.
Он также может использоваться для идентификации элементов.
Как правило, атрибут класса элемента HTML имеет несколько значений.

* поиск элемента по **CSS селектору** (By.cssSelector)

* поиск элемента по **XPATH запросу** (By.xPath)

Одна из основных причин использования *CSS селекторов* и *XPath запросов* - отсутствие подходящего атрибута *id* или *name* для элемента, который вы хотите найти. 
Локаторы XPath также можно использовать для указания элементов через атрибуты, отличные от *id* и *name*.
Синтаксис *CSS селекторов*, более прост, однако использование *CSS селекторов*, как правило, более подвержено структурным изменениям веб-страницы.

* поиск элемента по **тексту ссылки**, только для гиперссылок (By.linkText)
  
Использование текста ссылки пожалуй, самый прямой способ щелкнуть ссылку, так как это то, что мы видим на странице.

* поиск элемента по **частичному тексту ссылки**, только для гиперссылок (By.partialLinkText)

Это может быть полезно, если текст генерируется динамически. 
Другими словами, текст на одной веб-странице может отличаться при следующем посещении. 
Мы могли бы использовать общий текст, общий для этих динамически создаваемых текстов ссылок, для их идентификации.

* поиск элемента по **тегу** (By.tagName)

В HTML есть ограниченный набор имен тегов. Обычно локатор *tagName* не используется для поиска элемента. 
Но часто используется с другими элементами в цепочке локаторов.

Уникальные ID, имена и имена классов крайне упрощают создание локаторов: запросы будут краткими и не требуют дополнительных якорей. 
Всегда ратуйте, чтобы разработчики использовали уникальные идентификаторы (например, имена классов) для всех элементов. 
Однако у многих элементов таких идентификаторов нет, и локаторам приходится полагаться на более сложные *CSS-селекторы* и *XPath*. 
Если это случилось с вами, вот мои рекомендации:

* используйте родительские элементы как якоря, если у них есть уникальный идентификатор

```css
#some-list > li
```

```xpath
//ul[@id=’some-list’]/li
```

* избегайте XPath с текстом/индексированием при любой возможности

```xpath
//div[3]//span[text()=’hello’]
```

Это наиболее хрупкие тесты.

* используйте функцию **contains**, проверяя классы в XPath

```xpath
//div[contains(@class, ‘some-class’)]
```

У элементов зачастую больше одного класса. 
Функция *contains* проверит подстроку вместо полной строки класса.
Но будьте осторожны, потому что под выдачу попадут также *some-class2*!

* всегда тестируйте локаторы, в них часто встречаются ошибки синтаксиса и ложноположительные значения

**Chrome DevTools** упрощает их тестирование – нажмите Ctrl+F на вкладке элементов и вставьте запрос локатора в поле поиска. 
DevTools подсветит все соответствующие элементы по порядку. Шик-блеск-красота!

Устойчивость к изменениям вёрстки могут обеспечить:

* максимально точные критерии выбора
* как можно меньше порядковых номеров
* привязка к ближайшему уникальному элементу
* минимум прыжков по DOM

### 5.2. Что делать, если тесты нестабильны?

Тестирование через Web UI часто критикуют за нестабильность, потому что тесты часто падают из-за непредвиденных причин. 
Однако большая часть ненадежности, с которой сталкиваются тестировщики Web UI (и, зачастую, пользователи Selenium WebDriver как такового) связана с тем, 
что все Web-взаимодействия изначально создают гоночные условия. 

Автоматизация и браузер работают независимо друг от друга, и взаимодействие должно синхронизироваться с состоянием страницы. 
В противном случае WebDriver будет выдавать исключения из-за таймаутов, устаревших и не найденных элементов. 
В ряде случаев эти проблемы возникают не каждый раз, поэтому их тяжело отследить и исправить.

#### Ожидание существования элемента перед взаимодействием с ним

Лучший способ избежать гоночных условий таков – **всегда ожидайте существования элемента, прежде чем взаимодействовать с ним**. 
Это кажется элементарным, но про это легко забыть. Пакеты Selenium WebDriver всегда предлагают какую-то разновидность объекта WebDriverWait, 
заставляющего драйвер ожидать истинности определенного условия перед дальнейшими действиями. 
Простейший способ проверить, существует ли элемент – это проверить список элементов, возвращаемый вызовом FindElements (для списка элементов) и убедиться, что он непустой. 
Добавление дополнительного вызова для каждого взаимодействия может показаться затратным, 
однако дизайн-шаблоны хорошо спроектированных фреймворков (например, Screenplay) могут автоматически осуществлять подобные проверки.

#### Получение свежих элементов

Еще одна хорошая практика – **всегда получать свежие элементы**. 
Иногда автоматизация вначале получит ряд элементов, а затем через второй запрос получит следующую часть. 
Или же, в случае с Page Object Factory, элементы получаются один раз при конструировании Page Object, а затем на них ссылаются. 

Вне зависимости от способа – чем дольше существует объект на веб-странице, тем более он подвержен тому, чтобы устареть и вызвать исключения. 
Всегда запрашивайте элемент тогда, когда он нужен – в этом случае он не успеет устареть!

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)