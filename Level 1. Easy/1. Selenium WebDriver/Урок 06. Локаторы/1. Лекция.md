Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

# 1. Локаторы, XML, HTML, DOM

## 1.1. Что такое XML?

***XML (eXtensible Markup Language)*** — расширяемый язык разметки.

Спецификация **XML** описывает **XML**-документы и частично описывает поведение **XML**-процессоров 
(программ, читающих **XML**-документы и обеспечивающих доступ к их содержимому).
XML разрабатывался как язык с простым формальным синтаксисом, удобный для создания и 
обработки документов как программами так и человеком, с акцентом на использование в Интернете.
Язык называется расширяемым, поскольку он не фиксирует разметку, используемую в документах: 
разработчик волен создать разметку в соответствии с потребностями к конкретной области,
будучи ограниченным лишь синтаксическими правилами языка.

***Расширение XML*** — конкретная грамматика, созданная на базе **XML** и представленная словарём тегов и их атрибутов, 
а также набором правил, определяющих, какие атрибуты и элементы могут входить в состав других элементов.

Сочетание простого формального синтаксиса, удобства для человека, расширяемости, а также базирование на кодировках
Юникод для представления содержания документов привело к широкому использованию как собственно **XML**,
так и множества производных специализированных языков на базе **XML** в самых разнообразных программных средствах.

**XML** рекомендован Консорциумом Всемирной паутины (W3C).
**XML** является подмножеством **SGML**.

## 1.2. Что такое HTML?

***HTML (HyperText Markup Language)*** — стандартизированный язык разметки веб-страниц во Всемирной паутине.

Код **HTML** интерпретируется браузерами; полученная в результате интерпретации страница отображается
на экране монитора компьютера или мобильного устройства.

Язык **HTML** до 5-й версии определялся как приложение **SGML** (стандартного обобщённого языка разметки по стандарту ISO 8879).
Спецификации **HTML5** формулируются в терминах **DOM** (объектной модели документа).
Строгим вариантом **HTML** является **XHTML**, он наследует синтаксис **XML** и является приложением языка **XML** 
в области разметки гипертекста.

**HTML**, как и **XML** имеет древовидную структуру.
В документе всегда имеется один корневой элемент, содержащий ряд вложенных элементов,
некоторые из которых тоже могут содержать вложенные элементы.
Так же могут встречаться текстовые узлы, комментарии и инструкции.
Можно считать, что **XML**-элемент содержит массив вложенных в него элементов и массив атрибутов.

У элементов дерева бывают **элементы-предки** и **элементы-потомки**.
У корневого элемента предков нет, а у тупиковых элементов (листьев дерева) нет потомков.
Каждый элемент дерева находится на определённом уровне вложенности (далее — **уровень**).
Элементы упорядочены в порядке расположения в тексте, и поэтому можно говорить об их предыдущих и следующих элементах.
Это очень похоже на организацию каталогов в файловой системе.

## 1.3. Что такое DOM?

***DOM (Document Object Model)*** - объектная модель документа, независящий от платформы и языка программный интерфейс,
позволяющий программам и скриптам получить доступ к содержимому **HTML**-, **XHTML**- и **XML**-документов,
а также изменять содержимое, структуру и оформление таких документов.

Согласно **DOM**-модели, документ является иерархией, состоящей из равноправных узлов дерева **DOM**.
Основные типы узлов:

* теги - **узлы-элементы (element node)**
* текст - **текстовые узлы (text node)**

Корневым элементом иерархии является **html**. У него есть два потомка.
Первый - **head**, второй - **body**. И так далее, каждый вложенный тег является потомком тега выше.

Модель **DOM** не накладывает ограничений на структуру документа. 
Любой документ известной структуры с помощью **DOM** может быть представлен в виде дерева узлов,
каждый узел которого представляет собой элемент, атрибут, текстовый, графический или любой другой объект. 
Узлы связаны между собой отношениями **Родитель - Потомок**.

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/01.jpg "Document Object Model (DOM)")

Проще говоря, **DOM** - это представление документа в виде дерева тегов.
Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел.

Основные характеристики **DOM**:

* основана на валидном **HTML**-коде
* может быть модифицирована из **JavaScript**
* не включает псевдоэлементы, созданные из **CSS**
* включает скрытые элементы (**display: none**)

Возможности **DOM**:

* поиск узлов (элементов)
* доступ к узлам вверх и вниз по иерархии (родителям и потомкам)
* получение и изменение содержимого узлов (текст, имя тега и т д)

*Пример*

Для следующего фрагмента **HTML**

```html
<html>
  <head>
    <title>Заголовок</title>
  </head>
  <body>
     Прекрасный документ
   </body>
</html>
```

будет построено следующее дерево

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/02.jpg "Document Object Model (DOM)")

>Изначально различные браузеры имели собственные модели документов (DOM), несовместимые с остальными.
Для обеспечения взаимной и обратной совместимости специалисты международного консорциума W3C классифицировали эту модель по уровням,
для каждого из которых была создана своя спецификация. Все эти спецификации объединены в общую группу, носящую название **W3C DOM**.

## 1.4. Что такое веб элементы?

***Веб элементы*** – **DOM** объекты, находящиеся на веб странице, то, что пользователь видит (а иногда и не видит) на странице – 
заголовки, кнопка **ОК**, поля ввода, текстовые блоки и т д.

Языки программирования обычно получают доступ к веб-элементам как к нодам в **объектной модели документа (DOM)**.

**Selenium WebDriver** также работает с **объектной моделью документа (DOM)**.

## 1.5. Что такое локаторы?

Поскольку **Selenium WebDriver** - инструмент для автоматизации веб приложений, то большая часть работы с ним - это работа с элементами.
А для того, чтобы осуществлять какие-то действия над элементами (**DOM** объектами) необходимо их точным образом определить (найти).
Для поиска элементов в **Selenium WebDriver** используются локаторы.

***Локатор*** – объект, который находит и возвращает веб элементы на странице по заданному запросу.

Как пользователи, люди взаимодействуют с веб-страницами визуально - 
смотрят, скроллят, кликают и печатают посредством браузера.
Тест-автоматизация, однако, взаимодействует со страницами программно - 
нужен закодированный способ поиска и манипулирования теми же самыми элементами.
Традиционная автоматизация не будет **смотреть** на страницу, как человек – вместо этого она будет искать через **DOM**.

То есть если обычно пользователь видит кнопку **Login** и знает, что надо нажать именно на нее,
то в случае с автоматизацией браузеру надо дать команду **нажать**, а еще обозначить,
что именно жать. Собственно, чтобы взаимодействие браузера происходило с нужным вам элементом,
а не соседним или вообще скрытым, и нужно умение писать уникальные локаторы.

***

# 2. Поиск веб элементов

## 2.1. Интерфейс WebDriver

***WebDriver*** - интерфейс для управления браузером.

Методы интерфейса **WebDriver** для поиска вэб-элементов на странице:

| Тип              | Метод               | Описание                                                     | 
|------------------|---------------------|--------------------------------------------------------------|
| WebElement       | findElement(By by)  | Поиск элемента (возвращает первый найденный элемент)         |
| List<WebElement> | findElements(By by) | Поиск всех элементов (возвращает список найденных элементов) |

[selenium/docs/api : WebDriver](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.html)

### 2.1.1. Поиск одного веб элемента

Для поиска одного веб элемента используется команда **findElement**.

*Пример*

```java
WebElement element = driver.findElement(By.tagName("p"));
System.out.println("Paragraph text:" + element.getText());
```

### 2.1.2. Поиск набора веб элементов

Для поиска набора веб элементов используется команда **findElements**.

*Пример*

```java
List<WebElement> elements = driver.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println("Paragraph text:" + element.getText());
}
```

### 2.1.3. Поиск одного веб элемента в веб элементе

В найденном веб элементе можно найти другой веб элемент.

*Пример*

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
WebElement element = rootElement.findElement(By.tagName("p"));
System.out.println(element.getText());
```

### 2.1.4. Поиск набора веб элементов в веб элементе

В найденном веб элементе можно найти другие веб элементы.

*Пример*

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
List<WebElement> elements = rootElement.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println(element.getText());
}
```

### 2.1.5. Цепочка из findElement

*Пример*

```java
WebElement element1 = driver
        .findElement(By.id("div1")
        .findElement(By.name("same");
WebElement element2 = driver
        .findElement(By.id("div2")
        .findElement(By.name("same");
```

## 2.2. Исключения

Если элемент не найден то:

* **findElement** вызовет исключение **NoSuchElementException**
* **findElements** вернет пустой ответ []

### 2.2.1. NoSuchElementException

***NoSuchElementException*** — исключение, которое вызывается методом **findElement**, если элемент с заданным селектором не найден на странице.

[selenium/docs/api : NoSuchElementException](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/NoSuchElementException.html)

Исключение **NoSuchElementException** возникает в одном из следующих случаев

* открыта не та страница

В ходе выполнения автотеста может выполниться переход на другую страницу, а элемент находится на предыдующей странице.
В этом случае нужно проверить, что элемент есть на странице (**DevTools** в помощь).

* задан неправильный локатор

Скорее всего в локаторе есть ошибка или локатор в принципе не находит нужный элемент.
В этом случае нужно проверить, что локатор находит элемент на странице (**DevTools** в помощь).

* элемент находится внутри фрейма

Если элемент находится внутри, то драйвер его не найдет, так как фрейм считается отдельным объектом со своим **DOM**.
В этом случае нужно убедиться, что элемент не внутри фрейма (**DevTools** в помощь), 
а если все таки внутри фрейма, то вначале нужно переключиться на фрейм.

* элемент появляется не сразу

В этом случае нужно добавить ожидание элемента.

***

# 3. Простые локаторы

## 3.1. Класс By

**By** - класс реализующий методы поиска элементов с помощью простых локаторов.

Методы класса **By** (локаторы):

| Тип | Метод                                      | Описание                                   | 
|-----|--------------------------------------------|--------------------------------------------|
| By  | By.id(String id)                           | Поиск элемента по атрибуту id              |
| By  | By.name(String name)                       | Поиск элемента по атрибуту name            |
| By  | By.className(String className)             | Поиск элемента по атрибуту class           |
| By  | By.tagName(String tagName)                 | Поиск элемента по тегу                     |
| By  | By.linkText(String linkText)               | Поиск элемента по тексту ссылки            |   
| By  | By.partialLinkText(String partialLinkText) | Поиск элемента по частичному тексту ссылки |
| By  | By.cssSelector(String cssSelector)         | Поиск элемента по CSS селектору            |
| By  | By.xPath(String xpath)                     | Поиск элемента по XPATH запросу            |

[selenium/docs/api : By](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/By.html)

При этом **ID**, **Name**, **Tag name** и **Class name**— частные случаи CSS-селекторов. 
Таким образом, основные виды локаторов, с которыми придется сталкиваться — CSS-селекторы и XPath-запросы.
Далее рассмотрим каждый из них подробнее.

### 3.1.1. Поиск элемента по атрибуту id (By.id)

Для поиска элемента по атрибуту **id** используется локатор **By.id**.

*Пример*

```HTML
<div id="menu_go">
    <a href="http://go.go" id="link_go">Go!</a>
    <input type="button" id="button_go">Go!</input>
</div>
```

```java
WebElement menuGo = driver.findElement(By.id("menu_go"));
WebElement linkGo = driver.findElement(By.id("link_go"));
WebElement buttonGo = driver.findElement(By.id("button_go"));
```

### 3.1.2. Поиск элемента по атрибуту name (By.name)

Для поиска элемента по атрибуту **name** используется локатор **By.name**.

*Пример*

```HTML
<input type="submit" name="button_submit">Submit</input>
<input type="submit" name="button_cancel">Cancel</input>
```

```java
WebElement buttonSubmit = driver.findElement(By.name("button_submit");
WebElement buttonCancel = driver.findElement(By.name("button_cancel");
```

### 3.1.3. Поиск элемента по атрибуту class (By.className)

Для поиска элемента по атрибуту **class** используется локатор **By.className**.

*Пример*

```HTML
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-default btn-primary">Submit</input>
```

```java
WebElement element1 = driver.findElement(By.className("btn");
WebElement element2 = driver.findElement(By.className("btn-primary");
WebElement element3 = driver.findElement(By.className("btn btn-default");
WebElement element4 = driver.findElement(By.className("btn btn-primary");
WebElement element5 = driver.findElement(By.className("btn btn-default btn-primary");
```

Метод **className** удобен для тестирования библиотек JavaScript / CSS, которые обычно используют набор определенных имен классов.

*Пример*

```java
WebElement element1 = driver.findElement(By.className("editable-textarea");
WebElement element2 = driver.findElement(By.className("editable-submit");
```

### 3.1.4. Поиск элемента по имени тега (By.tagName)

Для поиска элемента по имени тега используется локатор **By.tagName**.

*Пример*

```HTML
<body>
<p>Paragraph<p>
</body>
```

```java
WebElement body = driver.findElement(By.tag_name("body"));
WebElement paragraph = body.findElement(By.tag_name("p"));
```

### 3.1.5. Поиск элемента по тексту ссылки (By.linkText)

Для поиска элемента по тексту ссылки используется локатор **By.linkText**.

*Пример*

```HTML
<a href="/submit">Submit</a>
<a href="/cancel">Cancel</a>
```

```java
WebElement link1 = driver.findElement(By.link_text("Submit"));
WebElement link2 = driver.findElement(By.link_text("Cancel"));
```

### 3.1.6. Поиск элемента по частичному тексту ссылки (By.partialLinkText)

Для поиска элемента по частичному тексту ссылки используется локатор **By.partialLinkText**.

*Пример*

```HTML
<a href="/submit">Submit Me</a>
<a href="/cancel">Cancel Me</a>
```

```java
WebElement link1 = driver.findElement(By.partial_link_text("ubmi"));
WebElement link1 = driver.findElement(By.partial_link_text("ance"));
``` 

### 3.1.7. Поиск элемента с помощью CSS селектора (By.cssSelector)

Для поиска элемента с помощью CSS селектора используется локатор **By.cssSelector**.

***CSS селектор*** — формальное описание относительного пути до элемента/элементов HTML.

Классически, селекторы используются для задания правил стиля.
В случае с **WebDriver**, существование самих правил не обязательно, веб-драйвер использует синтаксис CSS только для поиска.
Поиск вернет первый элемент удовлетворяющий CSS-селектору.

*Пример*

```HTML
<input type="text" id="fistname" name="first_name" class="myForm">
```

```java
WebElement firstName = driver.findElement(By.cssSelector("input[name='first_name']"));
```

Подробнее про [CSS Селекторы](_CSS%20Selectors.md)

### 3.1.8. Поиск элемента с помощью XPATH запроса (By.xPath)

Для поиска элемента с помощью XPATH запроса используется локатор **By.xPath**.

***XPath (XML Path Language)*** - язык запросов для выбора узлов из XML документа.

Когда браузер отображает веб-страницу, он анализирует его в дереве **DOM**.
**XPath** может использоваться для ссылки на определенный узел в дереве **DOM**.
**XPath** — самый мощный и гибкий способ найти определенный веб-элемент.

*Пример*

```HTML
<input class="search-form-input" type="search" itemprop="query-input" name="s" id="search for-2" placeholder="Search this website">
```

```java
WebElement firstName = driver.findElement(By.xpath("//input[@id=searchform-2]"));
WebElement firstName = driver.findElement(By.xpath("//input[@name=’s’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@type=’search’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@class=’search-form-input’]"));
```

Подробнее про [XPATH запросы](_XPATH%20Queries.md)

## 3.2. Исключения

### 3.2.1. InvalidSelectorException

***InvalidSelectorException*** — исключение генерируется, когда заданный селектор поиска не возвращает **WebElement**.

Сейчас это исключение возникает только при использовании **xpath** — когда в **xpath** выражении есть синтаксические ошибки 
или выражение не указывает на **WebElement** (например, *count(.//span)»*).

### 3.2.2. IllegalLocatorException

***IllegalLocatorException*** — исключение, которое возникает, когда **By** не может обработать переданные ему аргументы.

Наиболее распространенный случай возникновения — это использование составного имени класса в **By.className**.

***

# 4. Относительные локаторы

***Относительные локаторы (Relative Locators)*** - локаторы, помогающие найти элементы, 
которые находятся рядом с другими элементами, выше, ниже, слева и справа от него 
(позиционный способ поиска элементов).

Этот функционал был добавлен в **Selenium 4**.

Используется для поиска элементов по их расположению на странице, а не по их положению в **DOM**.
Элементы возвращаются в порядке их близости к последнему элементу привязки, который использовался для их поиска.

Все относительные локаторы используют **прямоугольник ограничивающий элементы**,
чтобы определить, является ли что-то **левым**, **правым**, **выше** или **ниже** другого.

*Пример*

+-----+
|  a  |---+
+-----+ b |
    +-----+

Если элемент **a** частично перекрывает элемент **b**, то элемент **b** не является
ни **выше**, ни **ниже**, ни **слева** или **справа** относительно элемента **a**.
Это связано с тем, как положение элементов рассчитываются с использованием блочной модели.
У ограничивающего прямоугольника **b** крайний левый край находится справа от
крайнего правого края ограничивающего прямоугольника **a**,
так что это не считается коррректным **справа** для **a**.
Аналогичная логика применима и к другим направлениям.

## 4.1. Класс RelativeLocator

***RelativeLocator*** - класс реализующий относительные локаторы.

Методы класс **RelativeLocator**:

| Тип                               | Метод                | Описание                                               | 
|-----------------------------------|----------------------|--------------------------------------------------------|
| static RelativeLocator.RelativeBy | with(String tagName) | Старт поиск элемента с помощью относительного локаторп |

[selenium/docs/api : RelativeLocator](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/locators/RelativeLocator.html)

Метод **findElement** может принимать метод **with**, 
который возвращает объект **RelativeLocator.RelativeBy** (потомок **By**).

*Пример*

```java
List<WebElements> elements = driver
        .findElements(withTagName("p").above(By.id("id")));
```

Вернет все элементы **p** выше самого низкого **WebElement**, отсортированные по близости к минимальному.
Близость определяется простым сравнением расстояния до центральной точки каждого из элементов по очереди.
Для некоторых непрямоугольных форм (например, абзацев текста, занимающих более одной строки),
это может привести к неожиданным результатам.

## 4.2. Класс RelativeLocator.RelativeBy

***RelativeLocator.RelativeBy*** - класс реализующий методы поиска элементов с помощью относительных локаторов.

Методы класса **RelativeLocator.RelativeBy** (относительные локаторы):

| Тип                        | Метод                                                | Описание                                                       | 
|----------------------------|------------------------------------------------------|----------------------------------------------------------------|
| RelativeLocator.RelativeBy | above(By locator)	                                | Искомый элемент находится над указанным элементом              |
| RelativeLocator.RelativeBy | above(WebElement element)	                        | Искомый элемент находится над указанным элементом              |
| RelativeLocator.RelativeBy | below(By locator)	                                | Искомый элемент находится ниже указанного элемента             |
| RelativeLocator.RelativeBy | below(WebElement element)	                        | Искомый элемент находится ниже указанного элемента             |
| List<WebElement>           | findElements(SearchContext context)                  | Поиск набора элементов                                         |
| By.Remotable.Parameters    | getRemoteParameters()	                            | Получение параметров                                           |
| RelativeLocator.RelativeBy | near(By locator)	                                    | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | near(By locator, int atMostDistanceInPixels)	        | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | near(WebElement element)	                            | Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | near(WebElement element, int atMostDistanceInPixels)	| Искомый элемент находится на расстоянии от указанного элемента |
| RelativeLocator.RelativeBy | toLeftOf(By locator)	                                | Искомый элемент находится слева от указанного элемента         |
| RelativeLocator.RelativeBy | toLeftOf(WebElement element)	                        | Искомый элемент находится слева от указанного элемента         |
| RelativeLocator.RelativeBy | toRightOf(By locator)	                            | Искомый элемент находится справа от указанного элемента        |
| RelativeLocator.RelativeBy | toRightOf(WebElement element)                        | Искомый элемент находится справа от указанного элемента        |

[selenium/docs/api : RelativeLocator.RelativeBy](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/locators/RelativeLocator.RelativeBy.html)

### 4.2.1. Поиск элемента выше заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//h1"))
        .above(By.xpath("//h2")));
```

### 4.2.2. Поиск элемента ниже заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//h2"))
        .below(By.xpath("//h1")));
```

### 4.2.3. Поиск элемента слева от заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//button[text()=\"Button1\"]"))
        .toLeftOf(By.xpath("//button[text()=\"Button3\"]")));
```

### 4.2.4. Поиск элемента справа от заданного элемента

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//button[text()=\"Button3\"]"))
        .toRightOf(By.xpath("//button[text()=\"Button1\"]")));
```

### 4.2.5. Поиск элемента рядом с заданным элементом

*Пример*

```java
WebElement element = driver
        .findElement(RelativeLocator
        .with(By.xpath("//button[text()=\"Button1\"]"))
        .near(By.xpath("//button[text()=\"Button2\"]")));
```

## 4.3. Исключения

Класс **RelativeLocator.RelativeBy** генерирует те же исключения, что и **By** то есть:

* **IllegalLocatorException**
* **InvalidSelectorException**

***

# 5. Правила написания локаторов

## 5.1. Как писать хорошие локаторы?

Поиск элемента – это полдела. Создание уникального запроса для локатора – вот вторая половина. 
Если локатор чересчур широк, он будет возвращать ложноположительные значения. 
При слишком узком подходе он начнет ломаться при любом изменении **DOM**, и его будет сложно читать другим людям. 
Лучший подход здесь такой – пишите наиболее простой запрос, который уникально идентифицирует целевой элемент или элементы.

### 5.1.1. Какой локатор будем считать оптимальным?

Оптимальный локатор:

* должен однозначно определять элемент, т.е. должен быть уникальным в пределах страницы (экрана)
  
Конечно, иногда нужно найти группу однотипных элементов (например, разные элементы списка), 
но даже в этом случае мы ищем локатор, позволяющий найти только эти элементы и никакие больше.  

* должен содержать как можно меньше соседних элементов

Таким образом, обеспечивается стабильность: соседние элементы могут часто меняться, а значит, 
чем их меньше в локаторе, тем реже нам придется что-то в локаторе менять.

* должен помогать ориентироваться в автотесте, т.е. нужно использовать такие атрибуты, которые что-то говорят об элементе
  
Чтобы только взглянув на локатор сразу было понятно, что это за элемент. 
Конечно, это условие выполняется реже всего, но нужно к этому стремиться.

И тут нужно сразу предостеречь желающих использовать в локаторе видимый текст элемента. 
Вроде бы, что может лучше говорить о назначении элемента, чем его текст? 
Это конечно да, только вот все то, что видит конечный пользователь, меняется гораздо чаще,
например, потому что так красивее, понятнее и сильнее привлекает внимание. 
Конечно, если совсем не за что зацепиться при составлении локатора, можно использовать текст.

### 5.1.2. Какой приоритет при использовании локаторов?

Приоритет использования локаторов (от высшего к низшему):

* поиск элемента по атрибуту **id**, если уникален (By.id)

Использование идентификаторов — самый простой и безопасный способ поиска элемента в HTML.
Если страница соответствует W3C HTML, идентификаторы должны быть уникальными и идентифицироваться в веб-элементах управления.
По сравнению с текстами тестовые сценарии, использующие идентификаторы, менее склонны к изменениям приложений
(например, разработчики могут принять решение об изменении метки, но с меньшей вероятностью изменить идентификатор).

* поиск элемента по атрибуту **name**, если уникален (By.name)

Атрибут **name** используются в элементах управления формой.
Значения имени передаются на сервер при отправке формы.
С точки зрения вероятности будущих изменений, атрибут **name**, второй по отношению к **id**.

* поиск элемента по атрибуту **class** (By.className)

Атрибут **class** элемента HTML используется для стилизации.
Он также может использоваться для идентификации элементов.
Как правило, атрибут класса элемента HTML имеет несколько значений.

* поиск элемента по **CSS селектору** (By.cssSelector)

* поиск элемента по **XPATH запросу** (By.xPath)

Одна из основных причин использования **CSS селекторов** и **XPath запросов** - 
отсутствие подходящего атрибута **id** или **name** для элемента, который вы хотите найти. 
Локаторы XPath также можно использовать для указания элементов через атрибуты, отличные от **id** и **name**.
Синтаксис **CSS селекторов**, более прост, однако использование **CSS селекторов**, 
как правило, более подвержено структурным изменениям веб-страницы.

* поиск элемента по **тексту ссылки**, только для гиперссылок (By.linkText)
  
Использование текста ссылки пожалуй, самый прямой способ щелкнуть ссылку, так как это то, что мы видим на странице.

* поиск элемента по **частичному тексту ссылки**, только для гиперссылок (By.partialLinkText)

Это может быть полезно, если текст генерируется динамически. 
Другими словами, текст на одной веб-странице может отличаться при следующем посещении. 
Мы могли бы использовать общий текст, общий для этих динамически создаваемых текстов ссылок, для их идентификации.

* поиск элемента по **тегу** (By.tagName)

В **HTML** есть ограниченный набор имен тегов. Обычно локатор **tagName** не используется для поиска элемента. 
Но часто используется с другими элементами в цепочке локаторов.

### 5.1.3. Как правильно писать CSS селекторы и XPath запросы?

Уникальные ID, имена и имена классов крайне упрощают создание локаторов: запросы будут краткими и не требуют дополнительных якорей. 
Всегда ратуйте, чтобы разработчики использовали уникальные идентификаторы (например, имена классов) для всех элементов. 
Однако у многих элементов таких идентификаторов нет, 
и локаторам приходится полагаться на более сложные **CSS селекторы** и **XPath запросы**. 

Если это случилось, вот рекомендации:

* используйте родительские элементы как якоря, если у них есть уникальный идентификатор

*Пример*

```css
#some-list > li
```

```xpath
//ul[@id=’some-list’]/li
```

* избегайте **XPath запросы** с текстом/индексированием при любой возможности

*Пример*

```xpath
//div[3]//span[text()=’hello’]
```

Это наиболее хрупкие тесты.

* используйте функцию **contains**, проверяя классы в XPath

*Пример*

```xpath
//div[contains(@class, ‘some-class’)]
```

У элементов зачастую больше одного класса. 
Функция *contains* проверит подстроку вместо полной строки класса.
Но будьте осторожны, потому что под выдачу попадут также *some-class2*!

* всегда тестируйте локаторы, в них часто встречаются ошибки синтаксиса и ложноположительные значения

**Chrome DevTools** упрощает их тестирование – нажмите Ctrl+F на вкладке элементов и вставьте запрос локатора в поле поиска. 
DevTools подсветит все соответствующие элементы по порядку. Шик-блеск-красота!

Устойчивость к изменениям вёрстки могут обеспечить:

* максимально точные критерии выбора
* как можно меньше порядковых номеров
* привязка к ближайшему уникальному элементу
* минимум прыжков по DOM

## 5.2. Что делать, если тесты нестабильны?

Тестирование через Web UI часто критикуют за нестабильность, потому что тесты часто падают из-за непредвиденных причин. 
Однако большая часть ненадежности, с которой сталкиваются тестировщики Web UI 
(и, зачастую, пользователи **Selenium WebDriver** как такового) связана с тем, 
что все Web-взаимодействия изначально создают гоночные условия. 

Автоматизация и браузер работают независимо друг от друга, и взаимодействие должно синхронизироваться с состоянием страницы. 
В противном случае WebDriver будет выдавать исключения из-за таймаутов, устаревших и не найденных элементов. 
В ряде случаев эти проблемы возникают не каждый раз, поэтому их тяжело отследить и исправить.

### 5.2.1. Ожидание существования элемента перед взаимодействием с ним

Лучший способ избежать гоночных условий таков – **всегда ожидайте существования элемента, прежде чем взаимодействовать с ним**. 
Это кажется элементарным, но про это легко забыть. 
Пакеты **Selenium WebDriver** всегда предлагают какую-то разновидность объекта **WebDriverWait**, 
заставляющего драйвер ожидать истинности определенного условия перед дальнейшими действиями. 
Простейший способ проверить, существует ли элемент – это проверить список элементов, 
возвращаемый вызовом **findElements** (для списка элементов) и убедиться, что он непустой. 
Добавление дополнительного вызова для каждого взаимодействия может показаться затратным, 
однако дизайн-шаблоны хорошо спроектированных фреймворков (например, **Screenplay**) могут автоматически осуществлять подобные проверки.

### 5.2.2. Получение свежих элементов

Еще одна хорошая практика – **всегда получать свежие элементы**. 
Иногда автоматизация вначале получит ряд элементов, а затем через второй запрос получит следующую часть. 
Или же, в случае с **Page Object Factory**, элементы получаются один раз при конструировании **Page Object**, а затем на них ссылаются. 

Вне зависимости от способа – чем дольше существует объект на веб-странице, тем более он подвержен тому, чтобы устареть и вызвать исключения. 
Всегда запрашивайте элемент тогда, когда он нужен – в этом случае он не успеет устареть!

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)