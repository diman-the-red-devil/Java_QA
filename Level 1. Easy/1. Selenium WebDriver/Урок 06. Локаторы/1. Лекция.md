# Java_QA / Level 1. Easy - Основы / 1.1. Selenium WebDriver / Урок 06. Локаторы 1. CSS

[![Содержание](https://img.shields.io/badge/-%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5-purple)](README.md)
[![Вперед](https://img.shields.io/badge/-%D0%92%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-brightgreen)](2.%20Практика.md)

***

## 1. Document Object Model (DOM)

***Document Object Model (DOM)*** - объектная модель документа, независящий от платформы и языка программный интерфейс,
позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов,
а также изменять содержимое, структуру и оформление таких документов.

Согласно DOM-модели, документ является иерархией, состоящей из равноправных узлов дерева DOM.
Основные типы узлов:

* теги - **узлы-элементы (element node)**
* текст - **текстовые узлы (text node)**

Корневым элементом иерархии является **html**. У него есть два потомка.
Первый - **head**, второй - **body**. И так далее, каждый вложенный тег является потомком тега выше.

Модель DOM не накладывает ограничений на структуру документа. 
Любой документ известной структуры с помощью DOM может быть представлен в виде дерева узлов,
каждый узел которого представляет собой элемент, атрибут, текстовый, графический или любой другой объект. 
Узлы связаны между собой отношениями *Родитель - Потомок*.

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/01.jpg "Document Object Model (DOM)")

Проще говоря, DOM - это представление документа в виде дерева тегов.
Это дерево образуется за счет вложенной структуры тегов плюс текстовые фрагменты страницы, каждый из которых образует отдельный узел.

Основные характеристики DOM:

* основана на валидном HTML-коде
* может быть модифицирована из JavaScript
* не включает псевдоэлементы, созданные из CSS
* включает скрытые элементы (display: none)

Возможности DOM:

* поиск узлов (элементов)
* доступ к узлам вверх и вниз по иерархии (родителям и потомкам)
* получение и изменение содержимого узлов (текст, имя тега и т д)

Например для следующего фрагмента HTML

```html
<html>
  <head>
    <title>Заголовок</title>
  </head>
  <body>
     Прекрасный документ
   </body>
</html>
```

будет построено следующее дерево

![Document Object Model (DOM)](_Files/1.%20Web%20Elements/02.jpg "Document Object Model (DOM)")

> Изначально различные браузеры имели собственные модели документов (DOM), несовместимые с остальными.
Для обеспечения взаимной и обратной совместимости специалисты международного консорциума W3C классифицировали эту модель по уровням,
для каждого из которых была создана своя спецификация. Все эти спецификации объединены в общую группу, носящую название **W3C DOM**.

***Веб-элементы*** – DOM объекты, находящиеся на веб странице, то, что пользователь видит (а иногда и не видит) на странице – 
заголовки, кнопки "ОК", поля ввода, текстовые блоки и т д.

Языки программирования обычно получают доступ к веб-элементам как к нодам в **объектной модели документа (DOM)**.

Selenium WebDriver также работает с **объектной моделью документа (DOM)**.

***

## 2. Команды поиска веб элементов

Для поиска вэб-элементов на странице в Selenium WebDriver есть следующие методы

| Тип              | Метод               | Описание                                                     | 
|------------------|---------------------|--------------------------------------------------------------|
| WebElement       | findElement(By by)  | поиск элемента (возвращает первый найденный элемент)         |
| List<WebElement> | findElements(By by) | поиск всех элементов (возвращает список найденных элементов) |

[selenium/docs/api : WebDriver](https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebDriver.html)

### Поиск одного веб элемента - findElement

Для поиска одного элемента используется команда **findElement**

```java
WebElement element = driver.findElement(By.tagName("p"));
System.out.println("Paragraph text:" + element.getText());
```

### Поиск набора веб элементов - findElements

Для поиска одного элемента используется команда **findElements**

```java
List<WebElement> elements = driver.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println("Paragraph text:" + element.getText());
}
```

### Поиск веб элемента в веб элементе

В найденном вэб-элементе можно найти другой вэб-элемент.

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
WebElement element = rootElement.findElement(By.tagName("p"));
System.out.println(element.getText());
```

### Поиск набора веб элементов в веб элементе

В найденном вэб-элементе можно найти другие вэб-элементы.

```java
WebElement rootElement = driver.findElement(By.tagName("div"));
List<WebElement> elements = rootElement.findElements(By.tagName("p"));
for (WebElement element : elements) {
    System.out.println(element.getText());
}
```

### Цепочка из findElement

```java
WebElement element1 = driver
        .findElement(By.id("div1")
        .findElement(By.name("same");
WebElement element2 = driver.
        findElement(By.id("div2")
        .findElement(By.name("same");
```

***

## 3. Локаторы

Поскольку Webdriver - это инструмент для автоматизации веб приложений, то большая часть работы с ним это работа с веб-элементами.
А для того, чтобы осуществлять какие-то действия над веб-элементами (DOM объектами) необходимо их точным образом определить(найти).
Для поиска элементов в Selenium используются локаторы.

***Локатор*** – объект, который находит и возвращает веб-элементы на странице по заданному запросу.

### Класс By

Selenium WebDriver предоставляет следующие типы локаторов элементов на странице:

| Тип | Метод                                      | Описание                                   | 
|-----|--------------------------------------------|--------------------------------------------|
| By  | By.id(String id)                           | поиск элемента по атрибуту id              |
| By  | By.name(String name)                       | поиск элемента по атрибуту name            |
| By  | By.className(String className)             | поиск элемента по атрибуту class           |
| By  | By.tagName(String tagName)                 | поиск элемента по тегу                     |
| By  | By.linkText(String linkText)               | поиск элемента по тексту ссылки            |   
| By  | By.partialLinkText(String partialLinkText) | поиск элемента по частичному тексту ссылки |
| By  | By.cssSelector(String cssSelector)         | поиск элемента по CSS селектору            |
| By  | By.xPath(String xpath)                     | поиск элемента по XPATH запросу            |

Далее рассмотрим каждый из них подробнее.

### Поиск элемента по атрибуту id (By.id)

```HTML
<div id="menu_go">
    <a href="http://go.go" id="link_go">Go!</a>
    <input type="button" id="button_go">Go!</input>
</div>
```

```java
WebElement menuGo = driver.findElement(By.id("menu_go"));
WebElement linkGo = driver.findElement(By.id("link_go"));
WebElement buttonGo = driver.findElement(By.id("button_go"));
```

### Поиск элемента по атрибуту name (By.name)

```HTML
<input type="submit" name="button_submit">Submit</input>
<input type="submit" name="button_cancel">Cancel</input>
```

```java
WebElement buttonSubmit = driver.findElement(By.name("button_submit");
WebElement buttonCancel = driver.findElement(By.name("button_cancel");
```

### Поиск элемента по атрибуту class (By.className)

```HTML
<a href="back.html" class="btn btn-default">Cancel</a>
<input type="submit" class="btn btn-default btn-primary">Submit</input>
```

```java
WebElement element1 = driver.findElement(By.className("btn");
WebElement element2 = driver.findElement(By.className("btn-primary");
WebElement element3 = driver.findElement(By.className("btn btn-default");
WebElement element4 = driver.findElement(By.className("btn btn-primary");
WebElement element5 = driver.findElement(By.className("btn btn-default btn-primary");
```

Метод **className** удобен для тестирования библиотек JavaScript / CSS, которые обычно используют набор определенных имен классов.

```java
WebElement element1 = driver.findElement(By.className("editable-textarea");
WebElement element2 = driver.findElement(By.className("editable-submit");
```

### Поиск элемента по имени тега (By.tagName)

```HTML
<body>
<p>Paragraph<p>
</body>
```

```java
WebElement body = driver.findElement(By.tag_name("body"));
WebElement paragraph = body.findElement(By.tag_name("p"));
```

### Поиск элемента по тексту ссылки (By.linkText)

```HTML
<a href="/submit">Submit</a>
<a href="/cancel">Cancel</a>
```

```java
WebElement link1 = driver.findElement(By.link_text("Submit"));
WebElement link2 = driver.findElement(By.link_text("Cancel"));
```

### Поиск элемента по частичному тексту ссылки (By.partialLinkText)

```HTML
<a href="/submit">Submit Me</a>
<a href="/cancel">Cancel Me</a>
```

```java
WebElement link1 = driver.findElement(By.partial_link_text("ubmi"));
WebElement link1 = driver.findElement(By.partial_link_text("ance"));
``` 

### Поиск элемента с помощью CSS селектора (By.cssSelector)

***CSS селектор*** — формальное описание относительного пути до элемента/элементов HTML.
Классически, селекторы используются для задания правил стиля.
В случае с WebDriver, существование самих правил не обязательно, веб-драйвер использует синтаксис CSS только для поиска.
Поиск вернет первый элемент удовлетворяющий CSS-селектору.

```HTML
<input type="text" id="fistname" name="first_name" class="myForm">
```

```java
WebElement firstName = driver.findElement(By.cssSelector("input[name='first_name']"));
```

### Поиск элемента с помощью XPATH запросов (By.xPath)

***XPath (XML Path Language)*** - язык запросов для выбора узлов из XML документа.
Когда браузер отображает веб-страницу, он анализирует его в дереве DOM.
XPath может использоваться для ссылки на определенный узел в дереве DOM.
XPath — самый мощный и гибкий способ найти определенный веб-элемент.

```HTML
<input class="search-form-input" type="search" itemprop="query-input" name="s" id="search for-2" placeholder="Search this website">
```

```java
WebElement firstName = driver.findElement(By.xpath("//input[@id=searchform-2]"));
WebElement firstName = driver.findElement(By.xpath("//input[@name=’s’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@type=’search’]"));
WebElement firstName = driver.findElement(By.xpath("//input[@class=’search-form-input’]"));
```

***

## 4. Исключения

Вэб элемент не найден

Вэб элемент не существует

***

## 5. Правила написания локаторов

Как писать хорошие локаторы?

Поиск элемента – это полдела. Создание уникального запроса для локатора – вот вторая половина. 
Если локатор чересчур широк, он будет возвращать ложноположительные значения. 
При слишком узком подходе он начнет ломаться при любом изменении DOM, и его будет сложно читать другим людям. 
Лучший подход здесь такой – пишите наиболее простой запрос, который уникально идентифицирует целевой элемент или элементы.

Приоритет использования локаторов (от высшего к низшему):

* поиск элемента по атрибуту id (By.id)

ID (если уникален)

Использование идентификаторов — самый простой и безопасный способ поиска элемента в HTML.
Если страница соответствует W3C HTML, идентификаторы должны быть уникальными и идентифицироваться в веб-элементах управления.
По сравнению с текстами тестовые сценарии, использующие идентификаторы, менее склонны к изменениям приложений
(например, разработчики могут принять решение об изменении метки, но с меньшей вероятностью изменить идентификатор).

* поиск элемента по атрибуту name (By.name)

Имя (если уникально)

Атрибут name используются в элементах управления формой.
Значения имени передаются на сервер при отправке формы.
С точки зрения вероятности будущих изменений, атрибут name, второй по отношению к ID.

* поиск элемента по атрибуту class (By.className)

Имя класса

Атрибут class элемента HTML используется для стилизации.
Он также может использоваться для идентификации элементов.
Как правило, атрибут класса элемента HTML имеет несколько значений, как показано ниже.

* поиск элемента по CSS селектору (By.cssSelector)

Однако использование селектора CSS, как правило, более подвержено структурным изменениям веб-страницы.

* поиск элемента по XPATH запросу (By.xPath)



* поиск элемента по тексту ссылки (By.linkText)



* поиск элемента по частичному тексту ссылки (By.partialLinkText)
  
Только для гиперссылок. 
Использование текста ссылки — это, пожалуй, самый прямой способ щелкнуть ссылку, так как это то, что мы видим на странице.

Selenium позволяет идентифицировать элемент управления гиперссылкой с частичным текстом. 
Это может быть полезно, если текст генерируется динамически. 
Другими словами, текст на одной веб-странице может отличаться при следующем посещении. 
Мы могли бы использовать общий текст, общий для этих динамически создаваемых текстов ссылок, для их идентификации.

* поиск элемента по тегу (By.tagName)

В HTML есть ограниченный набор имен тегов. Другими словами, многие элементы используют одни и те же имена тегов на веб-странице.
Обычно локатор tagName не используется для поиска элемента. Но часто используется с другими элементами в цепочке локаторов.


Уникальные ID, имена и имена классов крайне упрощают создание локаторов: запросы будут краткими и не требуют дополнительных якорей. 
Всегда ратуйте, чтобы ваши разработчики использовали уникальные идентификаторы (например, имена классов) для всех элементов. 
Однако у многих элементов таких идентификаторов нет, и локаторам приходится полагаться на более сложные CSS-селекторы и (содрогнувшись) XPath. 

Если это случилось с вами, вот мои рекомендации:

Используйте родительские элементы как якоря, если у них есть уникальный идентификатор:
Пример CSS-селектора: “#some-list > li”
XPath-пример: “//ul[@id=’some-list’]/li”

Избегайте XPath с текстом/индексированием при любой возможности.
Плохой пример: “//div[3]//span[text()=’hello’]”
Это наиболее хрупкие тесты.

Используйте функцию "contains", проверяя классы в XPath.
Пример: “//div[contains(@class, ‘some-class’)]”
У элементов зачастую больше одного класса.
“contains” проверит подстроку вместо полной строки класса.
Но будьте осторожны, потому что под выдачу попадут также “some-class2”!

Всегда тестируйте локаторы, в них часто встречаются ошибки синтаксиса и ложноположительные значения. 
Chrome DevTools упрощает их тестирование – нажмите Ctrl+F на вкладке элементов и вставьте запрос локатора в поле поиска. 
DevTools подсветит все соответствующие элементы по порядку. Шик-блеск-красота!

Что делать, если тесты нестабильны?

Тестирование через Web UI часто критикуют за нестабильность, потому что тесты часто падают из-за непредвиденных причин. 
Однако большая часть ненадежности, с которой сталкиваются тестировщики Web UI (и, зачастую, пользователи Selenium WebDriver как такового) связана с тем, 
что все Web-взаимодействия изначально создают гоночные условия. 
Автоматизация и браузер работают независимо друг от друга, и взаимодействие должно синхронизироваться с состоянием страницы. 
В противном случае WebDriver будет выдавать исключения из-за таймаутов, устаревших и не найденных элементов. 
В ряде случаев эти проблемы возникают не каждый раз, поэтому их тяжело отследить и исправить.

Лучший способ избежать гоночных условий таков – всегда ожидайте существования элемента, прежде чем взаимодействовать с ним. 
Это кажется элементарным, но про это легко забыть. Пакеты Selenium WebDriver всегда предлагают какую-то разновидность объекта WebDriverWait, 
заставляющего драйвер ожидать истинности определенного условия перед дальнейшими действиями. 
Простейший способ проверить, существует ли элемент – это проверить список элементов, возвращаемый вызовом FindElements (для списка элементов) и убедиться, что он непустой. 
Добавление дополнительного вызова для каждого взаимодействия может показаться затратным, 
однако дизайн-шаблоны хорошо спроектированных фреймворков (например, Screenplay) могут автоматически осуществлять подобные проверки.

Еще одна хорошая практика – всегда получать "свежие" элементы. 
Иногда автоматизация вначале получит ряд элементов, а затем через второй запрос получит следующую часть. 
Или же, в случае с Page Object Factory (никогда ей не пользуйтесь – если в трех словах, она отвратительна), 
элементы получаются один раз при конструировании Page Object, а затем на них ссылаются. 
Вне зависимости от способа – чем дольше существует объект на веб-странице, тем более он подвержен тому, чтобы устареть и вызвать исключения. 
Я видел элементы, необъяснимо устаревающие, даже если они еще присутствовали на странице. 
Всегда запрашивайте элемент тогда, когда он нужен – в этом случае он не успеет устареть!

***

Практика [![Перейти](https://img.shields.io/badge/-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D1%82%D0%B8-blue)](2.%20Практика.md)