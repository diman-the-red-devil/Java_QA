Java_QA / 10. Паттерны

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)

***

# Содержание

* [1. Что такое паттерны?](#1-что-такое-паттерны)
  * [1.1. Краткая история](#11-краткая-история)
  * [1.2. 23 паттерна проектирования GOF](#12-23-паттерна-проектирования-gof)
* [2. Зачем нужны паттерны?](#2-зачем-нужны-паттерны)
* [3. Паттерны в автотестировании](#3-паттерны-в-автотестировании)
* [4. Паттерн Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))](#4-паттерн-объект-страницы--объектная-модель-страницы-page-object--page-object-model-pom)
  * [4.1. Структура паттерна](#41-структура-паттерна)
  * [4.2. Шаги реализации паттерна](#42-шаги-реализации-паттерна)
  * [4.3. Применимость паттерна](#43-применимость-паттерна)
  * [4.4. Плюсы и минусы применения паттерна](#44-плюсы-и-минусы-применения-паттерна)
    * [4.4.1. Плюсы применения паттерна](#441-плюсы-применения-паттерна)
    * [4.4.2. Минусы применения паттерна](#442-минусы-применения-паттерна)
  * [4.5. Применение паттерна в автотестах](#45-применение-паттерна-в-автотестах)
    * [4.5.1. UI автотесты с POM](#451-ui-автотесты-с-pom)
      * [4.5.1.1. До применения паттерна](#4511-до-применения-паттерна)
      * [4.5.1.2. После применения паттерна](#4512-после-применения-паттерна)
* [5. Паттерн Подготовка, Действие, Проверка (Arrange Act Assert (AAA))](#5-паттерн-подготовка-действие-проверка-arrange-act-assert-aaa)
  * [5.1. Структура паттерна](#51-структура-паттерна)
  * [5.2. Шаги реализации паттерна](#52-шаги-реализации-паттерна)
  * [5.3. Применимость паттерна](#53-применимость-паттерна)
  * [5.4. Плюсы и минусы применения паттерна](#54-плюсы-и-минусы-применения-паттерна)
      * [5.4.1. Плюсы применения паттерна](#541-плюсы-применения-паттерна)
      * [5.4.2. Минусы применения паттерна](#542-минусы-применения-паттерна)
  * [5.5. Применение паттерна в автотестах](#55-применение-паттерна-в-автотестах)
    * [5.5.1. UI автотесты с POM + AAA](#551-ui-автотесты-с-pom--aaa)
      * [5.5.1.1. До применения паттерна](#5511-до-применения-паттерна)
      * [5.5.5.2. После применения паттерна](#5552-после-применения-паттерна)
* [6. Паттерн Сопоставитель / матчер (Assert Object / Matchers)](#6-паттерн-сопоставитель--матчер-assert-object--matchers)
    * [6.1. Структура паттерна](#61-структура-паттерна)
    * [6.2. Шаги реализации паттерна](#62-шаги-реализации-паттерна)
    * [6.3. Применимость паттерна](#63-применимость-паттерна)
    * [6.4. Плюсы и минусы применения паттерна](#64-плюсы-и-минусы-применения-паттерна)
      * [6.4.1. Плюсы применения паттерна](#641-плюсы-применения-паттерна)
      * [6.4.2. Минусы применения паттерна](#642-минусы-применения-паттерна)
    * [6.5. Применение паттерна в автотестах](#65-применение-паттерна-в-автотестах)
      * [6.5.1. UI автотестах с POM + AAA + Matchers](#651-ui-автотестах-с-pom--aaa--matchers)
        * [6.5.1.1. До применения паттерна](#6511-до-применения-паттерна)
        * [6.5.1.2. После применения паттерна](#6512-после-применения-паттерна)
* [7. Паттерн Элементы страницы (Page Elements)](#7-паттерн-элементы-страницы-page-elements)
    * [7.1. Структура паттерна](#71-структура-паттерна)
    * [7.2. Шаги реализации паттерна](#72-шаги-реализации-паттерна)
    * [7.3. Применимость паттерна](#73-применимость-паттерна)
    * [7.4. Плюсы и минусы применения паттерна](#74-плюсы-и-минусы-применения-паттерна)
      * [7.4.1. Плюсы применения паттерна](#741-плюсы-применения-паттерна)
      * [7.4.2. Минусы применения паттерна](#742-минусы-применения-паттерна)
    * [7.5. Применение паттерна в автотестах](#75-применение-паттерна-в-автотестах)
      * [7.5.1. UI автотесты с POM + PE + AAA + Matchers](#751-ui-автотесты-с-pom--pe--aaa--matchers)
        * [7.5.1.1. До применения паттерна](#7511-до-применения-паттерна)
        * [7.5.1.2. После применения паттерна](#7512-после-применения-паттерна)

***

# 1. Что такое паттерны?

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Паттерн проектирования или шаблон*** в разработке программного обеспечения — повторяемая архитектурная конструкция, 
представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

В отличие от готовых функций или библиотек, **паттерн** нельзя просто взять и скопировать в программу. 
**Паттерн** представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, 
которую нужно будет ещё подстроить под нужды вашей программы.

**Паттерны** часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. 
Но если алгоритм — это чёткий набор действий, то **паттерн** — это высокоуровневое описание решения, 
реализация которого может отличаться в двух разных программах.

Объектно-ориентированные **паттерны** показывают отношения и взаимодействия между классами или объектами,
без определения того, какие конечные классы или объекты приложения будут использоваться.

Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, 
а **паттерн** — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

## 1.1. Краткая история

В **1970-е** годы архитектор **Кристофер Александр** составил набор паттернов проектирования.
В области архитектуры эта идея не получила такого развития, как позже в области программной разработки.

В **1987** году **Кент Бэк (Kent Beck)** и **Вард Каннингем (Ward Cunningham)** взяли идеи Александра и
разработали паттерны применительно к разработке программного обеспечения для разработки графических оболочек на языке **Smalltalk**.

В **1988** году **Эрих Гамма (Erich Gamma)** начал писать докторскую диссертацию при цюрихском университете
об общей переносимости этой методики на разработку программ.

В **1989—1991** годах **Джеймс Коплин (James Coplien)** трудился над разработкой идиом для программирования
на **C++** и опубликовал в **1991** году книгу **Advanced C++ Idioms**.

В этом же году **Эрих Гамма** заканчивает свою докторскую диссертацию и переезжает в США,
где в сотрудничестве с **Ричардом Хелмом (Richard Helm)**, **Ральфом Джонсоном (Ralph Johnson)** и **Джоном Влиссидесом (John Vlissides)**
публикует книгу **Design Patterns — Elements of Reusable Object-Oriented Software**.
В книге сформулированы все паттерны, с которыми они сталкивались в то время в объектно-ориентированном мире.
Книга состоит из двух частей, в первых двух главах рассказывается о возможностях и недостатках объектно-ориентированного программирования,
а во второй части описаны **23 классических паттерна проектирования**.

Также команда авторов этой книги известна общественности под названием **Банда четырёх (Gang of Four, часто сокращается до GoF)**.
Именно эта книга стала причиной роста популярности паттернов проектирования.

## 1.2. 23 паттерна проектирования GOF

**23 паттерна проектирования**:

* *порождающие*

***Порождающие паттерны*** - паттерны, которые беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

1. *Одиночка (Singleton)*
2. *Фабричный метод (Factory Method)*
3. *Абстрактная фабрика (Abstract Factory)*
4. *Строитель (Builder)*
5. *Прототип (Prototype)*

* *структурные*

***Структурные паттерны*** - паттерны, которые показывают различные способы построения связей между объектами.

1. *Декоратор (Decorator)*
2. *Заместитель (Proxy)*
3. *Фасад (Facade)*
4. *Приспособленец (Flyweight)*
5. *Адаптер (Adapter)*
6. *Мост (Bridge)*
7. *Компоновщик (Composite)*

* *поведенческие*

***Поведенческие паттерны*** - паттерны, которые заботятся об эффективной коммуникации между объектами.

1. *Цепочка обязанностей (Chain of responsibility)*
2. *Команда (Command)*
3. *Интерпретатор (Interpreter)*
4. *Итератор (Iterator)*
5. *Посредник (Mediator)*
6. *Хранитель (Memento)*
7. *Наблюдатель (Observer)*
8. *Состояние (State)*
9. *Стратегия (Strategy)*
10. *Шаблонный метод (Template method)*
11. *Посетитель (Visitor)*

![23 паттерна проектирования GOF](./_Files/1.%20Lection/1.%20Patterns/01.png "23 паттерна проектирования GOF")

К настоящему времени в других областях также накопилось множество паттернов, 
и потому существуют и другие группы паттернов:

* *паттерны параллельного программирования*
* *паттерны архитектуры системы*
* *паттерны ентерпрайз разработки*

и т д.

***

# 2. Зачем нужны паттерны?

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Вы можете вполне успешно работать, не зная ни одного **паттерна**. 
Более того, вы могли уже не раз реализовать какой-то из **паттернов**, даже не подозревая об этом.

Но осознанное владение инструментом как раз и отличает профессионала от любителя. 
Вы можете забить гвоздь молотком, а можете и дрелью, если сильно постараетесь. 
Но профессионал знает, что главная фишка дрели совсем не в этом. 

Итак, зачем же знать **паттерны**?

* *проверенные решения* 

Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. 
До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.

* *стандартизация кода*

Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, 
так как все скрытые проблемы в них уже давно найдены.

* *общий программистский словарь*

Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, 
какой крутой дизайн вы придумали и какие классы для этого нужны.

**Паттерны** не классы, пакеты или библиотеки, 
которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда.
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.
Не существует такого понятия как **хороший паттерн** или **плохой паттерн**. 
Сам термин **паттерн** был придуман в качестве формулировки проблемы и предложенного решения. 
Если задача не разделяет проблему, для которой **паттерн** был придуман – это не значит, 
что он плохой или вышел из моды, просто он не подходит для решения этой задачи. 
Если проблема каким-то образом совпадает и накладывается на этот **паттерн**, значит, стоит его рассмотреть.
Таким образом важно не просто приносить дизайн-паттерны в проект, 
важно понимать их назначение, проблематику, как и чем они могут помочь.

***

# 3. Паттерны в автотестировании 

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

Изначально классические **паттерны** были сформулированы давным-давно четверкой, 
которая выпустила книгу **Design Patterns**. В книге сформулированы все **паттерны**, 
с которыми они сталкивались в то время в объектно-ориентированном мире.
Есть проблема – есть ее решение, и долгое время эта концепция дизайн-паттернов росла и развивалась, 
пополняясь новыми паттернами.

Сегодня просматривается тенденция появления подобных **паттернов** в других областях, 
в которых накопилась проблематика. Автоматизация тестирования имеет собственный набор задач, 
так что существует и набор полезных паттернов проектирования для этой области.

Основными драйверами практически всех **паттернов** в автоматизации тестирования являются **факторы**:

* *надежность*
* *понятность*
* *гибкость*
* *поддерживаемость*
* *стабильность*

![Факторы](./_Files/1.%20Lection/1.%20Patterns/02.jpeg "Факторы")

Большая часть этих факторов находится под влиянием разделения компонентов.
В любом тесте – функциональном, интеграционном, unit-тесте — всегда присутствует три **компонента**:

* *тестовая логика* (описание шагов тест кейсов)
* *тестовые данные* (описание данных для тест кейсов)
* *техническая часть* (отвечающая за непосредственное взаимодействие с приложением - вызов функций, клики на экран и т. п.)

Если эти **компоненты** хорошо разделены, тесты начинают хорошо попадать в выше упомянутые **факторы**,
потому что в этом случае ими гораздо проще манипулировать, гораздо проще их понимать и поддерживать.

***Паттерны в автотестировании*** - паттерны, основная задача которых сводится к структурированию кода тестов,
чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью.

***

# 4. Паттерн Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))*** - паттерн, 
который моделирует страницы в качестве объектов в коде и позволяет **разделять логику выполнения тестов от их реализации**.

![Паттерн Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))](./_Files/1.%20Lection/2.%20Page%20Object%20Model/01.jpg "Паттерн Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))")

Существует большая разница между **логикой тестирования (что проверить)** и его **реализацией (как проверить)**. 

*Пример*

```text
Сценарий "Ввод неверного логина и пароля"

Шаги:
1. Пользователь вводит неверный логин или пароль
2. Нажимает кнопку входа

Ожидаемый результат:
Получает сообщение об ошибке 
```

Этот сценарий описывает логику теста, в то время как реализация содержит в себе такие действия как:

* поиск полей ввода на странице
* заполнение полей ввода
* проверку полученной ошибки

и т.д.

И если, например, измениться способ вывода сообщения об ошибке, то это никак не повлияет на сценарий теста, 
все также нужно будет ввести неверные данные, нажать кнопку входа и проверить ошибку. 
Но это напрямую затронет реализацию теста — необходимо будет изменить метод получающий и обрабатывающий сообщение об ошибке. 
При **разделении логики теста от его реализации** автотесты становятся более гибкими и их, как правило, легче поддерживать.

Паттерн **Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))** предлагает 
каждую веб-страницу проекта описывать в виде объекта класса, который содержит веб элементы размещенные на странице и 
методы взаимодействие пользователя со страницей. А в тесты выносится вся бизнес-логика.
такой подход помогает избежать проблем с тестами при изменении верстки веб-приложения.

## 4.1. Структура паттерна

![Структура паттерна Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))](./_Files/1.%20Lection/2.%20Page%20Object%20Model/02.jpg "Структура паттерна Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))")

Структура паттерна:

1. *Базовый объект страниц (Base Page)*
  
***Базовый объект страниц (Base Page)*** - базовый класс для всех классов моделирующих веб страницы, 
в котором определяются базовые методы для работы с **WebDriver**.

Все классы конкретных веб страниц будут расширять **Базовый объект страниц (Base Page)**, 
унаследовав, таким образом, все базовые методы.

В классе **Базовый объект страниц (Base Page)** не должно быть инициализации **WebDriver**, 
инициализация выполняется в классе с тестами.

2. *Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))*

***Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))*** - конкретный класс, 
который расширяет **Базовый объект страниц (Base Page)** и реализует методы для работы с конкретными веб страницами.

При использовании паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))** 
элементы страниц, а также методы непосредственного взаимодействия пользователя с ними, 
выносятся в отдельный классы, отвечающие за работу с **HTML** каждой конкретной веб страницы.
К примеру, можно создать отдельные классы для Главной страницы, страницы Авторизации и Регистрации.

**Объект страницы** должен представлять значимые элементы страницы, 
то есть класс необязательно должен представлять собой всю страницу.
Он может быть частью страницы, которая часто используется на сайте (или даже на одной странице).
Например, пагинация или блок ссылок. Нет никакой необходимости моделировать все элементы представленные на странице,
если в тестах с ними нет никакого взаимодействия. Лишний код только ухудшит восприятие и понимание.

3. *Тесты (Tests)*

***Тесты (Tests)*** - классы, которые реализует логику тестов.

**Объекты страницы** никогда не должны делать проверки или утверждения.
Это часть теста и всегда должна быть в коде теста, а не в **объекте страницы**.
**Объект страницы** должен содержать элементы страницы и методы, с помощью которых можно с ними взаимодействовать.
Но никакой код, связанный с тем, что тестируется, не должен находиться в **объекте страницы**.

Существует одна, единственная проверка, которая может и должна быть внутри **объекта страницы**,
а именно проверка того, что страница и, возможно, критические элементы на странице были загружены правильно.
Эта проверка должна выполняться при создании экземпляра **объекта страницы**.

## 4.2. Шаги реализации паттерна

1. *Создание Базового объекта страниц*

Вынесение общих шагов в базовый конструктор - инициализация ожиданий и т д.

2. *Создание объектов страниц*

Моделирование только значимых элементов страницы.

3. *Применение объектов страниц в UI тестах*

Вызов методов взаимодействия с элементами страницы.

## 4.3. Применимость паттерна

1. *Когда необходимо улучшение поддержки кода UI автотестов с Selenium WebDriver*

Увеличение количества UI автотестов с **Selenium WebDriver** непременно приведет к дублированию кода локаторов и
методов взаимодействия с элементами веб страницы, что в свою очередь усложнит поддержку кода автотестов.

Например, на домашней странице веб-приложения есть строка меню, которая ведет к различным модулям с разными функциями.
Многие автотесты будут щелкать по этим кнопкам меню для выполнения определенных тестов. 
Представьте, что пользовательский интерфейс изменен / обновлен, а кнопки меню перемещены в другое место на домашней странице, 
это приведет к сбою тестов автоматизации. Автоматизированные тестовые примеры не пройдут, 
поскольку сценарии не смогут найти определенные локаторы элементов для выполнения действия.
Теперь автотестировщику для обновления локаторов и методов придется просмотреть весь код. 
Это потребует много времени, которое можно было бы использовать для увеличения тестового покрытия автотестами. 

Применение паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))**
улучшает поддержку кода автотестов, делает код более понятным и структурированным и самое главное экономит время.

## 4.4. Плюсы и минусы применения паттерна

### 4.4.1. Плюсы применения паттерна

1. *Четкое разделение между кодом тестов и кодом специфичным для страницы (таким как локаторы)*

Код функциональных тестов написанных с использованием **Selenium WebDriver** в основном будет 
состоять из взаимодействий с веб-интерфейсом, который проверяется.
То есть любой код теста будет состоять из последовательностей:

* поиск элемента на странице
* получение свойства элемента или выполнения действия с элементом
* проверка некоторого состояние элемента или системы с помощью различных утверждений

Даже в самом простом тесте читаемость очень плохая, так присутствует много кода **Selenium WebDriver**,
который скрывает цель теста, делая его трудным для восприятия.

Применение паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))** 
обеспечивает четкое разделение технических деталей (взаимодействие с элементами веб интерфейса) и фактической логикой тестов.
Также паттерн объединяет все действий по работе с конкретной веб-страницей в одном месте (соответствующем классе).

![Разделение между кодом тестов и кодом специфичным для страницы](./_Files/1.%20Lection/2.%20Page%20Object%20Model/03.jpg "Разделение между кодом тестов и кодом специфичным для страницы")

2. *Обеспечение единого места для определения операций, выполняемых на странице вместе разброса этих методов по тестам*

При написании UI тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами в разных кейсах. 
Что в свою очередь приводит к написанию одинакового кода в разных местах.

Применение паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))** 
значительно уменьшает количество повторяющегося кода путем создания единого места (**объект страницы**) 
для определения операций, выполняемых на странице вместе разброса этих методов по тестам.

![Обеспечение единого места для определения операций, выполняемых на странице](./_Files/1.%20Lection/2.%20Page%20Object%20Model/04.png "Обеспечение единого места для определения операций, выполняемых на странице")

3. *Изменение кода страницы только в одном месте при изменениях в дизайне страницы*

В любом в пользовательском интерфейсе, часто вносятся как незначительные, так и серьезные изменения.
Это может быть новый дизайн, реструктуризация полей и кнопок и т д.
Изменения в пользовательском интерфейсе часто нарушают работу нескольких тестов в нескольких местах.
Без применения паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))** 
локаторы веб элементов на странице и методы работы с ними будут разнесены по нескольким классам, 
что сильно усложнить поддержку кода.

Применение паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))** 
позволяет легко обновить код, после любого изменения пользовательского интерфейса, 
путем добавления новых элементов, обновления или удаления существующих в одном месте (**объекте страницы**), 
а не исправлять каждый тест, в котором этот интерфейс используется.

4. *Повторное использование кода работы с элементами страниц*
   
Как уже упоминалось выше при написании тестов приходится взаимодействовать с одними и теми же веб страницами и веб элементами.

Применение паттерна **Объект страницы / объектная модель страницы (Page Object / Page Object Model (POM))** 
обеспечивает сохранение отдельных репозиториев объектов страницы независимо от тестов автоматизации. 
Что в свою очередь позволяет повторно использовать этот репозиторий для разных целей с разными инструментами.
Например, можно интегрировать объектную модель страницы в **Selenium** с **TestNG** / **JUnit** для функционального тестирования
и одновременно с **JBehave** / **Cucumber** для приемочного тестирования.

### 4.4.2. Минусы применения паттерна

1. *Дублирование однотипных веб элементов*

Каждая страница может иметь ссылки, кнопки, хедеры и т д. 

2. *Дублирование однотипных операций*

Следствие первого пункта.
С каждым типом веб элементов можно выполнить только определенные действия.  
Например, кликнуть на кнопку, показать список в выпадашке и т д.

При описании страниц и методов взаимодействия с веб элементами неизбежно 
будет дублироваться часть логики по работе с каждым конкретным типом элементов страницы. 
Например, везде где есть чекбоксы придется делать проверку что он не выбран и т д.

## 4.5. Применение паттерна в автотестах

### 4.5.1. UI автотесты с POM

#### 4.5.1.1. До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    @Test
    public void loginTest() {
        // Страница "Вход"
        // Ввести логин и пароль 
        driver.findElement(By.name("login")).sendKeys("login");
        driver.findElement(By.name("password")).sendKeys("password");
        driver.findElement(By.name("sign-in")).click();
        
        // Стартовая страница
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(driver.findElement(By.tagName("h1")).isDisplayed());
        Assertions.assertEquals(driver.findElement(By.tagName("h1")).getText(), "Стартовая страница", 
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

Очевидно, что во многих тестах потребуется вход с логином и паролем. 
Следовательно, в каждый тест придется копипастить фрагмент кода с входом по логину и паролю.
Если вдруг на странице входа по логину и паролю изменятся локаторы, то придется делать правки во многих местах.
Также по коду невозможно понять что и на какой странице происходит.
И это только небольшой фрагмент кода.

#### 4.5.1.2. После применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*
   
*Пример*

```java
// Страница "Home"
public class HomePage { 
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
    
    // Конструктор
    public HomePage(WebDriver driver){
        this.driver = driver;
    }
    
    // Отображается элемент?
    public boolean isTextDisplyed() {
        return driver.findElement(tеxtBy).isDisplayed();
    }
    
    // Получение текста 
    public String getText() {
        return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isTextDisplyed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

После применения паттерна в случае изменения верстки на страницах, нужно будет лишь поправить локаторы в одном классе, 
независимо от того, в скольких классах с тестами используются страницы.
Глядя на код теперь сразу понятно какие действия и на какой странице выполняется.

### 4.5.2. UI автотесты с POM. Selenium Page Factory

***Page Factory*** – это встроенная концепция паттерна **Page Object Model** в **Selenium Web Driver**. 
Она хорошо оптимизирована и используется для инициализации объектов страницы или для создания объекта страницы в целом. 
**Page Factory** инициализирует элементы класса страницы, не используя **findElement(s)**.
Вместо этого применяется аннотация **@FindBy**, служащая для поиска веб элементов. 
Аннотация может найти элементы по:

* тегу (**tagName**)
* частичному тексту ссылки (**partialLinkText**)
* тексту ссылки (**linkText**)
* атрибуту name (**name**) 
* атрибуту id (**if**)
* селектору CSS (**css**)
* запросу XPath (**xpath**)
* названию класса (**className**) 

**Page Factory** также использует метод **initElements** для инициализации веб-элементов.

#### 4.5.2.1. До применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage { 
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
    
    // Конструктор
    public HomePage(WebDriver driver){
        this.driver = driver;
    }
    
    // Отображается элемент?
    public boolean isTextDisplyed() {
        return driver.findElement(tеxtBy).isDisplayed();
    }
    
    // Получение текста 
    public String getText() {
        return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isTextDisplyed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

#### 4.5.2.2. После применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Поле ввода "Логин"
    @FindBy(name = "login")
    private WebElement textFieldLogin;
    // Поле ввода "Пароль"
    @FindBy(name = "password");
    private WebElement textFieldPassword;
    // Кнопка "Отправить"
    @FindBy(name = "sign_in")
    private WebElement buttonSignIn;
    
    // Конструктор
    public SignInPage(WebDriver driver){
        // Инициализация веб элементов
        PageFactory.initElements(driver, this);
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        textFieldLogin.sendKeys(login);
        textFieldPassword.sendKeys(password);
        buttonSignIn.click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage {
    // Текст 
    @FindBy(tagName = "h1")
    private tеxtH1;
    
    // Конструктор
    public HomePage(WebDriver driver){
        // Инициализация веб элементов
        PageFactory.initElements(driver, this);
    }
    
    // Отображается элемент?
    public boolean isTextDisplyed() {
        return tеxtH1.isDisplayed();
    }
    
    // Получение текста 
    public String getText() {
        return tеxtH1.getText();
    }
}
```

3. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isTextDisplyed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

***

# 5. Паттерн Подготовка, Действие, Проверка (Arrange Act Assert (AAA))

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Подготовка, Действие, Проверка (Arrange Act Assert (AAA))*** – паттерн, 
который организует структуру тест-кейсов и задает порядок операций.

![Паттерн Подготовка, Действие, Проверка (Arrange Act Assert (AAA))](./_Files/1.%20Lection/3.%20Arrange%20Act%20Assert/01.jpg "Паттерн Подготовка, Действие, Проверка (Arrange Act Assert (AAA))")

В **BDD** паттерн **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** 
называется иначе **Если, Когда, Тогда (Given When Then)** (вспомним про это в следующих главах).
Язык **Gherkin** использует шаги **Если, Когда, Тогда** для описания поведенческих сценариев.
По сути это та же самая формула, что и в **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))**

**Тест** – это процедура, которая проверяет поведение с целью определить, правильно ли оно функционирует. 
Тестов существует много разных видов (**unit**, **интеграционные**, **end-to-end**), 
но все функциональные тесты по сути делают одно и то же: пробуют что-то и сообщают **PASS** или **FAIL**.

Паттерн **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** пришел из юнит тестов, 
однако его можно применять и в любых других тестах, в том числе и в UI тестах.
Так как по сути тесты выполняют везде одно и тоже:
 
* подготовку тестовых данных и перевод тестовой системы в определенное состояние
* выполнение каких то действий по изменению состояния тестовой системы
* проверку полученного результата

Паттерн **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** 
предоставляет простую единообразную структуру для всех тестов в проекте.
Это единообразие дает большое преимущество: привыкнув к нему, 
вы сможете легко прочитать и понять любой тест.

## 5.1. Структура паттерна

![Структура паттерна Подготовка, Действие, Проверка (Arrange Act Assert (AAA))](./_Files/1.%20Lection/3.%20Arrange%20Act%20Assert/02.jpg "Структура паттерна Подготовка, Действие, Проверка (Arrange Act Assert (AAA))")

Структура кода теста (метода) при использовании паттерна **AAA**:

1. *Секция подготовки (Arrange)* 

***Секция подготовки (Arrange)*** - секция, в которой выполняются шаги по подготовке 
тестируемой системы и ее зависимостей в нужное состояние.

Эти шаги должны подготовить тест-кейс:

* создание объектов
* выполнение особых настроек
* подготовка данных 
* передача подготовленных зависимостей
* сохранение выходного значения (если оно есть)
  
и т. д

**Секция подготовки (Arrange)** обычно является самой большой из трех.
Если она становится слишком большой, лучше выделить отдельные операции подготовки либо
в приватные методы того же класса теста, либо в отдельный класс-фабрику.

2. *Секция действия (Act)* 

***Секция действия (Act)*** - секция, в которой выполняются шаги по выполнению основной задачи теста.

Эти шаги должны выполнить тест кейс:

* вызов функции/метода
* вызов api 
* взаимодействие с веб-страницей

и т. д.

**Секция действия (Act)** обычно состоит всего из одной строки кода.

3. *Секция проверки (Assert)* 

***Секция проверки (Assert)*** - секция, в которой выполняются шаги по проверке результата 
(возвращаемое значение или итоговое состояние тестируемой системы).
  
Эти шаги должны получить ответ на вопрос упал тест или прошел:

* проверка числовых или строковых значений
* проверка множества аспектов системы

и т. д.

**Секция проверки (Assert)** должна содержать одну проверку.
Если секция проверки становится большой, то это может быть признаком того, что в коде недостает какой-то абстракции.
Например, вместо того чтобы по отдельности проверять все свойства объекта, возвращенного тестируемой системой,
возможно, будет лучше добавить методы проверки равенства (equality members) в класс такого объекта.
После этого объект можно будет сравнивать с ожидаемым значением всего одной командой.

**В тесте не должно быть множественных секций Arrange, Act, Assert**.

Время от времени встречаются тесты с несколькими секциями **Arrange (Подготовка)**, **Act (Действие)** или **Assert (Проверка)**.

Обычно они работают так:

![Несколько секциЙ Arrange Act Assert](./_Files/1.%20Lection/3.%20Arrange%20Act%20Assert/03.jpg "Несколько секциЙ Arrange Act Asser")

Когда присутствует несколько секций действий, разделенных секциями проверки и, возможно, секциями подготовки, это означает, 
что тест проверяет несколько единиц поведения. Такой структуры тестов лучше избегать.
Если есть тест, содержащий серию действий и проверок, то лучше отрефакторить его: выделить каждое действие в отдельный тест.
Иногда допустимо иметь несколько секций действий в тестах. 

**В тесте не должно быть ветвлений**.

Наличие в тестах ветвления является **антипаттерном**. Тест должен представлять собой простую последовательность шагов без ветвлений.
Присутствие ветвления означает, что тест проверяет слишком много всего. Следовательно, такой тест должен быть разбит на несколько тестов.
Ветвление в тестах не дает ничего, кроме дополнительных затрат на сопровождение: команды if затрудняют чтение и понимание тестов.

## 5.2. Шаги реализации паттерна

1. *Выделить шаги по подготовке тестовых данных и тестовой системы в секцию Arrange*

В секцию **Arrange** можно выделить шаги генерации и получения данных, подключения к БД, чтение файлов, настройки тестовой системы.

2. *Выделить шаги по воздействию на состояние тестовой системы в секцию Act*

Желательно, чтобы секции **Act** действие состояло из одной строки кода, то есть многошаговые действия лучше выделить в отдельный метод.

3. *Выделить шаги по проверке результата выполненных действий в секцию Assert*

В секции **Assert** не должно быть несколько проверок.

## 5.3. Применимость паттерна

1. *Когда нужна унификация кода тестов*

Код тестов представляет собой длинную неструктурированную простыню, в которой сложно разобраться и ориентироваться.
Такой код трудно понимать (особенно без наличия комментариев), сложно поддерживать и рефакторить.

## 5.4. Плюсы и минусы применения паттерна

### 5.4.1. Плюсы применения паттерна

1. *Разделение действий по настройке от основных действий и действий проверки*

Применение паттерна **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** 
позволяет четко разделить действия по настройке от основных действий и действий проверки.
Использование паттерна **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** 
при написании тестов, намного повышает шансы других разработчиков понять код.

![Разделение кода теста в AAA](./_Files/1.%20Lection/3.%20Arrange%20Act%20Assert/04.jpg "Разделение кода теста в AAA")

2. *Обеспечение определенного порядка при написании тестов*

Применение паттерна **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** 
требует разбиения теста на три секции и обязательного выполнения единственной проверки в тесте, 
а не просто хождение по шагам. То есть внедрение данного паттерна вносит как бы стандарт в написании тестов, 
тем самым делая их понятными для всех.

3. *Упрощение рефакторинга и ревью кода* 

Применение паттерна **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))**  упрощает рефакторинг и ревью кода:

* выявление наличия тестов, пытающихся одновременно протестировать слишком много разных вещей 
(*настрой действуй проверь, настрой действуй проверь*)
* обнаружение общих блоков кода в секции **Arrange**, которые можно вынести в **SetUp** метод

### 5.4.2. Минусы применения паттерна

1. *Применение данного паттерна огромный оверхед, если в тесте всего одна две проверки*

Конечно, паттерн **Подготовка, Действие, Проверка (Arrange Act Assert (AAA))** 
не должен быть способом написания проверок по умолчанию.
Если вы можете завершить тест одним или двумя проверками, то, вероятно, 
лучше не оборачивать их какими-либо дополнительными объектами.
Наличие слишком большого количества проверок также может означать, 
что тестируемые объекты плохо спроектированы (проверяют слишком много всего).

## 5.5. Применение паттерна в автотестах

### 5.5.1. UI автотесты с POM + AAA

#### 5.5.1.1. До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        HomePage homePage = signInPage.loginValidUser("login", "password");
        
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
    ...
}
```

Нет четкого разделения шагов по этапам и понимания, где шаги по настройке/подготовке, 
а где шаги по выполнению действий и проверке. 

##### 5.5.5.2. После применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin(login, password);

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isTextDisplyed());
        Assertions.assertEquals(expected, homePage.getText(),
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }

    public HomePage getPageAfterLogin(String login, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser(login, password);
    }
    ...
}
```

После применения паттерна и вынесения шагов действий тест стал более чистым и прозрачным. 

# 6. Паттерн Сопоставитель / матчер (Assert Object / Matchers)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Сопоставитель / матчер (Assert Object / Matchers)*** - паттерн, который создает проверки специфичные для предметной области,
скрывая технические детали реализации.

![Паттерн Сопоставитель / матчер (Assert Object / Matchers)](./_Files/1.%20Lection/4.%20Assert%20Object/01.jpg "Паттерн Сопоставитель / матчер (Assert Object / Matchers)")

Одна из наиболее значительных проблем с написанными тестами, заключается в том, 
что тесты проверяют не бизнес-инварианты, а основные технические детали.

Существует несколько популярных способов описывать проверки. Кроме вызова обычных функций, 
популярностью пользуются **сопоставители / матчеры**, которые внешне выглядят как мини-язык для описания проверок.
**Сопоставители / матчеры** стали популярны в тестовых фреймворках после появления подхода **BDD**.

Паттерн **Сопоставитель / матчер (Assert Object / Matchers)** предлагает воплощать проверки в виде повторяющихся конструкций, 
которые позволят не писать такие проверки в будущем, если он понадобится снова – возможно, уже в другом тесте.

Существует несколько библиотек, которые уже содержат множество готовых к использованию **сопоставителей / матчеров** 
и предоставляют простой в использовании API для создания кастомных **сопоставителей / матчеров**.
Самые популярные из них - **Hamcrest** и **AssertJ**.

*Пример*

```java
// AssertJ 
char[] data = {'a', 'b', 'c'};
assertThat(data).hasSameSizeAs(new int[] {1, 2, 3});
assertThat(data).isNotNull();
assertThat(true).isTrue();
assertThat(1).isIn(1, 2, 3, 4);
assertThat(9).isBetween(9, 11);
assertThat(10).isStrictlyBetween(9, 11);
```

[AssertJ](https://assertj.github.io/doc/)

*Пример*

```java
// Hamcrest
Map<Integer, String> map = new HashMap<Integer, String>();
map.put(1, "a");
map.put(2, "b");
map.put(3, "c");
assertThat(map, hasKey(1));
assertThat(map, hasValue("a"));
assertThat(map, hasEntry(3, "c"));
```

[Hamcrest](http://hamcrest.org/)

## 6.1. Структура паттерна

![Структура паттерна Сопоставитель / матчер (Assert Object / Matchers)](./_Files/1.%20Lection/4.%20Assert%20Object/02.jpg "Структура паттерна Сопоставитель / матчер (Assert Object / Matchers)")

Структура патерна:

1. *Сопоставитель / матчер (Assert Object / Matcher)*

***Сопоставитель / матчер (Assert Object / Matcher)*** - класс обертка вокруг тестируемого объекта, 
скрывающий технические детали проверок и предоставляющий предметно ориентированные названия методов для проверки.

Для базовых проверок написано уже огромное количество **сопоставителей / матчеров** писать их с нуля не нужно. 
Здесь же идет речь о бизнес-проверках – о тех группировках таких простейших функциональных **сопоставителей / матчеров** 
базовых типов, которые формулируют бизнес-задачу, то что именно необходимо проверить с точки зрения бизнеса.

2. *Тесты (Tests)*

***Тесты (Tests)*** - класс, который реализует логику тестов.

## 6.2. Шаги реализации паттерна

1. *Выделить бизнес сущность*

Это должен быть какой то объект, характеиристики которого мы проверяем. Например, пользователь, 
у которого могут быть такие характеристики как: 

* личные данные / профиль
* права на просмотр каких то разделов
* права на выполнение каких либо действий

2. *Создать для бизнес сущности класс с матчерами*

Класс должен содержать набор методов-проверок.
Названия методов должны говорить о том что мы хотим проверить.
В классе можно использовать библиотеки простых матчеров (**AssertJ** / **Hamcrest**).

## 6.3. Применимость паттерна

1. *Когда нужны улучшение читаемости и понимания проверок в тестах*

Наличие в тесте множества различных проверок относящихся к какой-то одной доменной сущности.
За этими проверками нет логического названия проверки, то есть не понятно что же конкретно проверяется.

## 6.4. Плюсы и минусы применения паттерна

### 6.4.1. Плюсы применения паттерна

1. *Создание логики предметной области в тестах*

Применение паттерна **Сопоставитель / матчер (Assert Object / Matchers)** создает логику предметной области в тестах,
объединяя группу проверок нацеленных на конкретный объект в отдельный класс.

2. *Устранение дублирования при написании прокерок*

Применение паттерна **Сопоставитель / матчер (Assert Object / Matchers)** обеспечивает создание отдельного класса с проверками,
которые могут использоваться повторно, что сокращает общее дублирование кода.

### 6.4.2. Минусы применения паттерна

1. *Применение данного паттерна оверхед, если в тесте используются примитивные проверки*

Если в тестах нет сложных бизнес данных, то не следует применять данный паттерн, 
вполне хватит стандартных **сопоставителей / матчеров** из библиотек **AssertJ** или **Hamcrest**. 

## 6.5. Применение паттерна в автотестах

### 6.5.1. UI автотестах с POM + AAA + Matchers

#### 6.5.1.1. До применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        Assertions.assertTrue(homePage.isDisplayed());
        Assertions.assertEquals(homePage.getText(), "Стартовая страница",
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

В исходном примере не видно очевидной логики проверок в тесте.
Пользователю может быть непонятно что именно будет проверяться.

#### 6.5.1.2. После применения паттерна

1. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```   

2. *Класс с матчерами - HomePageAssert*

```java
// Матчеры
public class HomePageAssert {
    private HomePage homePage;
    
    public HomePageAssert(HomePage homePage) {
        this.homePage = homePage;
    }
    
    // Проверка отображения текста после входа с логином и паролем
    public void displayedTextAfterLogin() {
        Assertions.assertTrue(homePage.isTextDisplyed());
    }
    
    // Проверка текста после входа с логином и паролем
    public void textAfterLoginIs(String expected) {
        Assertions.assertEquals(expected, homePage.getText(),
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

Теперь тест выглядит великолепно и его можно читать намного проще, 
чем раньше, а код утверждения внизу остается прежним.

***

# 7. Паттерн Элементы страницы (Page Elements)

[![Содержание](https://img.shields.io/badge/-Содержание-66eeff)](#содержание)

***Элементы страницы (Page Elements)*** - паттерн, моделирующий элементы интерфейса страницы (виджеты) 
в виде объектов в коде и описывающий действия, которые можно выполнить с конкретным типом элементов интерфейса. 
Данный паттерн дополняет и улучшает паттерн **Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))**.

![Паттерн Элементы страницы (Page Elements)](./_Files/1.%20Lection/5.%20Page%20Elements/01.jpg "Паттерн Элементы страницы (Page Elements)")

В классическом варианте, паттерн **Объект страницы / Объектная модель страницы (Page Object / Page Object Model (POM))** 
предполагает создание одного класса на одну страницу, который содержит набор элементов **WebElement**.
Интерфейс **WebElement** не делает различия между кнопкой, текстом (тег \<p\>) или таблицей.

У этого есть ряд минусов:

* для всех элементов интерфейса доступны одинаковые методы, которые иногда не применимы 

На текст и таблицу нельзя кликнуть, нельзя им передать текст как в текстовое поле.

* использование кастомных элементов интерфейса при создании веб-приложений (выпадашки, календари и т д)

Выбор варианта из выпадашки нельзя сделать одним кликом, для обработки данных таблицы нужно писать отдельные методы. 

* присутствие кастомных элементов интерфейса на многих страницах

Копирование кода специфичного для конкретных типов элементов интерфейса по всему проекту.

Паттерн **Элементы страницы (Page Elements)**: 

* предлагает создавать обертки для элемента **WebElement** или набора элементов **WebElement** на странице, 
которые описывают более привычный для пользователя вид элементов интерфейса страницы, 
такой как кнопки, ссылки, таблицы, меню и так далее
* позволяет дробить страницу на более мелкие составляющие – блоки, виджеты и т.д., п
после чего эти блоки можно переиспользовать в нескольких страницах.

## 7.1. Структура паттерна

![Структура паттерна Элементы страницы (Page Elements)](./_Files/1.%20Lection/5.%20Page%20Elements/02.jpg "Структура паттерна Элементы страницы (Page Elements)")

Структура патерна:

1. *Базовый элемент (Base Element)*

***Базовый элемент (Base Element)*** - базовый класс для всех классов моделирующих элементы интерфейса страницы,
в котором определяются базовые методы для работы.

Все классы конкретных элементов интерфейса будут расширять **Базовый элемент (Base Element)**,
унаследовав, таким образом, все базовые методы.

2. *Элементы страницы (Page Element)*

***Элементы страницы (Page Element)*** - конкретный класс, который расширяет **Базовый элемент (Base Element)** 
и реализует методы для работы с конкретными элементами интерфейса страницы.

**Элемент страницы (Page Element)** должен представлять конкретный тип элемента интерфейса страницы 
(кнопку, ссылку, чекбокс и т д).

3. *Объект страницы (Page Object)*

***Объект страницы (Page Object)*** - класс, который реализует модель страницы и содержит конкретные элементы интерфейса страницы.

## 7.2. Шаги реализации паттерна

1. *Создание Базового элемента страницы*

Вынесение общей логики для всех элементов интерфейса.

2. *Создание элементов страницы*

Добавление в каждый класс, представляющий конкретный тип элемента интерфейса, специфичных для него методов.

3. *Создание блоков из элементов страницы*

Для таких элементов как фильтры, представляющих собой блоки из более простых элементов, можно создать свои объекты в коде.

4. *Использование элементов в классах объектах страниц* 

## 7.3. Применимость паттерна

1. *Когда есть множество кастомных элементов на страницах*

Выпадающие списки, ползунки, таблицы и т д представляют собой комплексные веб элементы, 
для работы с которыми уже не обойтись одной командой (*click* или *sendKeys*).
Наличие же подобных элементов на нескольких страницах заставляет дублировать код.

2. *Когда нужно скрыть мелкие детали и сделать работу с элементами страницы более ясной и прозрачной* 

Повторяемые стандартные шаги при выполнении какого либо действия.
Например, перед каждым действием нужно дожидаться наличия элемента на странице либо его вилимости,
либо выполнять какие то проверки (выбран ли уже флажок или переключатель).  

## 7.4. Плюсы и минусы применения паттерна

### 7.4.1. Плюсы применения паттерна

1. *Уменьшение дублирования кода*

Все многократно повторяющиеся действия с каким либо типом элемента интерфейса страницы будут вынесены в специальные классы.

2. *Улучшение поддержки кода*

Следствие первого пункта. В случае необходимости добавления новых методов определенным типам элементов интерфейса страницы,
можно будет это сделать в одном класса, а не по всему проекту.

### 7.4.2. Минусы применения паттерна

1. *Дополнительные абстракции*

В случае, если комплексных элементов интерфейса страницы немного, 
то выделение отдельного класса может быть неоправданной тратой времени.

## 7.5. Применение паттерна в автотестах

### 7.5.1. UI автотесты с POM + PE + AAA + Matchers

#### 7.5.1.1. До применения паттерна

1. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера  
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("sign_in");
    
    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }
    
    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        driver.findElement(loginBy).sendKeys(login);
        driver.findElement(passwordBy).sendKeys(password);
        driver.findElement(signInBy).click();
        return new HomePage(driver);
    }
}
```

2. *Класс страницы (Page Object) - HomePage*

*Пример*

```java
// Страница "Home"
public class HomePage { 
    // Драйвер браузера 
    protected WebDriver driver;
    // Текст 
    private By tеxtBy = By.tagName("h1");
    
    // Конструктор
    public HomePage(WebDriver driver){
        this.driver = driver;
    }
    
    // Отображается элемент?
    public boolean isTextDisplyed() {
        return driver.findElement(tеxtBy).isDisplayed();
    }
    
    // Получение текста 
    public String getText() {
        return driver.findElement(tеxtBy).getText();
    }
}
```

3. *Класс с матчерами - HomePageAssert*

```java
// Матчеры
public class HomePageAssert {
    private HomePage homePage;
    
    public HomePageAssert(HomePage homePage) {
        this.homePage = homePage;
    }
    
    // Проверка отображения текста после входа с логином и паролем
    public void displayedTextAfterLogin() {
        Assertions.assertTrue(homePage.isTextDisplyed());
    }
    
    // Проверка текста после входа с логином и паролем
    public void textAfterLoginIs(String expected) {
        Assertions.assertEquals(expected, homePage.getText(),
                "Ошибка! Текст на странице не соответствует ожидаемому");
    }
}
```

4. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

#### 7.5.1.2. После применения паттерна

1. *Базовый класс - Base Element*

```java
// Базовый класс для всех элементов
public class Element {
    // Элемент страницы
    protected WebElement webElement;

    // Базовый конструктор
    public Element(WebDriver driver, By by) {
        // Ожидание перед поиском элемента
        WaitFor.initWait(driver, Duration.ofMillis(3000), Duration.ofMillis(300));
        WaitFor.presenceOfElementLocated(by);
        // Поиск элемента
        webElement = driver.findElement(by);
    }

    // Получение оборачиваемого элемента
    public WebElement getWebElement() {
        return webElement;
    }
}
```

2. *Класс кнопки - Button*

```java
// Кнопка
public class Button extends Element {
    // Конструктор
    public Button(WebDriver driver, By by) {
        super(driver, by);
    }

    // Нажатие на кнопку
    public void click() {
        webElement.click();
    }
}
```

3. *Класс текстового поля - TextBox*

```java
// Текстовое поле
public class TextBox extends Element {
    // Конструктор
    public TextBox(WebDriver driver, By by) {
        super(driver, by);
    }

    // Нажатие на текстовое поле
    public void click() {
        webElement.click();
    }

    // Ввод значения в текстовое поле
    public void setValue(String text) {
        webElement.sendKeys(text);
    }
}
```

4. *Класс флажка- CheckBox*

```java
// Флажок
public class CheckBox extends Element{
    // Конструктор
    public CheckBox(WebDriver driver, By by) {
        super(driver, by);
    }

    // Установка флажка
    public void setChecked(boolean value) {
        if (value != isChecked()) {
            webElement.click();
        }
    }

    // Проверка, что флажок установлен
    public boolean isChecked() {
        return webElement.isSelected();
    }
}
```

5. *Класс страницы (Page Object) - SignInPage*

*Пример*

```java
// Страница "Sign In"
public class SignInPage {
    // Драйвер браузера
    protected WebDriver driver;
    // Поле ввода "Логин"
    private By loginBy = By.name("login");
    // Поле ввода "Пароль"
    private By passwordBy = By.name("password");
    // Кнопка "Отправить"
    private By signInBy = By.name("commit");

    // Конструктор
    public SignInPage(WebDriver driver){
        this.driver = driver;
    }

    // Вход с логином и паролем
    public HomePage loginValidUser(String login, String password) {
        TextBox tbxLogin = new TextBox(driver, loginBy);
        tbxLogin.setValue(login);
        TextBox tbxPassword = new TextBox(driver, passwordBy);
        tbxPassword.setValue(password);
        Button btnSignIn = new Button(driver, signInBy);
        btnSignIn.click();
        return new HomePage(driver);
    }
}
```

6. *Класс с тестами - LoginTest*

*Пример*

```java
// Тест
public class LoginTest {
    ...
    @Test
    public void loginTest() {
        // Arrange
        String login = "login";
        String password = "password";
        String expected = "Стартовая страница";

        // Act
        HomePage homePage = getPageAfterLogin("login", "password")

        // Assert
        // Проверить что отображается текст "Стартовая страница"
        HomePageAssert homePageAssert = new HomePageAssert(homePage);
        homePageAssert.displayedTextAfterLogin();
        homePageAssert.textAfterLoginIs(expected);
    }

    public HomePage getPageAfterLogin(String email, String password) {
        // Страница "Sign In"
        SignInPage signInPage = new SignInPage(driver);
        // Вход с логином и паролем
        // Страница "Home"
        return signInPage.loginValidUser("login", "password");
    }
    ...
}
```

***

[![Главная](https://img.shields.io/badge/-Главная-aaccee)](README.md)
[![Практика](https://img.shields.io/badge/-Практика-aaffaa)](2.%20Практика.md)